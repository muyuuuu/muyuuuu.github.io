<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算是一个陈述句流水帐的年终总结吧</title>
    <url>/2022/02/04/2021/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时间有些晚了，选一个词来描述今年的话，现实魔幻主义，孤魂野鬼又一年。现实比魔幻还要魔幻，魔幻比现实还要现实。</p>
<a id="more"></a>
<p>还是那句话，悲观是我的状态，努力是我的态度，不冲突。</p>
<ul>
<li><p>1 月，那会儿在期末考试吧，并趁考试的时候忙里偷闲学完了操作系统和 C++。至于为什么研究生在考试的时候才是一年中最清闲的时光，懂得都懂。大概又说错了一些话，又错过了，以后只在适当的时候和懂得人去说。也是在这时候完成的心态的转变，放弃科研。这个月看完了火影，仿佛自己是宇智波，被生活的重压的反噬了。</p>
</li>
<li><p>2 月，忘记了，大概是返校，选课。有一门老师的课极度恶心，又是说论文多么多么重要，不注重实践的东西反手退课，我至今羡慕学完计算机原理能写 RISC 五级流水的人。这个月印象最深的是初次尝试去淘宝开代码店了，这也是今年值得记录的大事之一。实在穷的揭不开锅，接近没钱吃饭的程度，实在没办法。接的前两个业务是 LaTeX 排版的，第一笔业务挣了 20 块钱，我当时在想我能免费用 5 次学校的洗衣机。我成为了我曾经讨厌的人，也许并不是。</p>
</li>
<li><p>3 月，连夜参加了同学的婚礼。同学在大学所在地结婚，正好我大学毕业很匆忙，没和同学告别，趁此机会好多同学都回来了，大家一起吃个饭，一起聊聊天，弥补当面没有告别的遗憾。不像上次，这次分别没有哭的稀里哗啦。</p>
</li>
<li><p>4 月，同学来了西安，和他一起在西安、咸阳转了转，是我第一次正经在西安旅游吧。之后爬了华山，和她矛盾愈演愈烈，不喜欢阴阳的聊天，索性不聊了。这个月应该是接业务的顶峰，啥都接，凌晨一点写代码头很晕的那种，不上课不科研一直在陪客户，很累，像个孤魂野鬼。在某一天，听了很久的音乐，推了所有的业务，退款道歉，准备收手。</p>
</li>
<li><p>5 月，学了下 mmdetection，shell 和设计模式，之后就是研三毕业的节奏占据实验室的主流，真好，解脱了。业务并没有彻底放弃，一个月一两笔，多了就不接了，第一点没啥营养，第二点我没钱吃饭。</p>
</li>
<li><p>6 月，准备期末？和几个客户确定了长期关系。</p>
</li>
<li><p>7 月，暑假放 10 天，但接了个华为的项目，旅行计划泡汤。想临时冲一下项目，加上暑假回去也没想见的人，索性留校了。后续又自己学了一些无监督、高维索引和线程池的东西，自己把项目解决了。</p>
</li>
<li><p>8 月，被折腾去投论文，很累，累的原因倒不是多难，而是这个字体加粗，这里行间距，这里符号替换，和换成及，去掉空格，加粗，换成楷体，真的很没意思。开始打游戏缓解压力，一天一天又一天。</p>
</li>
<li><p>9 月，在华为项目基础上又做了上游的开发，算是体验了一下一整套系统吧，然后打游戏，打游戏，打游戏…… 置身现实魔幻主义，被折腾的很累。</p>
</li>
<li><p>10 月，又被抓去投论文，真的很没意思。不是落地的项目，只在玩具数据集上追求比 A 高 2 个点，比 B 高 3 个点，比 C 高 10 个点，仿佛前人的工作都是垃圾，自己论文无与伦比的新颖，晚诞生一年就是这个世界的损失，用各种词汇体现论文的创新，但本来就是很简单的东西。因此对这种东西深恶痛绝。一个同学考上了清华，给我介绍了一笔大业务，会持续到明年 4 月吧，能写到简历里。所以除了老客户的业务，新业务都不接了。</p>
</li>
<li><p>11 月，接到了第二个华为的项目，补了一下 C++ 的高级特性，然后就去开发了。体验了面向生产环境该如何编程，如何设计数据结构，代码如何检验，开发之余还是打游戏，接业务。仿佛脱离了现实进入了魔幻。</p>
</li>
<li><p>12 月，大四的师弟来了，帮着我搞项目，也请了几顿饭，我又又又被抓去投论文了，真的恶心，持续性头晕。其中一点是，做深度学习但没有显卡，实验得不到保障。时隔 8 个月，和他关系有所缓和，他也理解了我所处环境的苦衷，终于能好好说话了，不容易。我也尝试不再去抱怨，可总是没话题去说，也许随缘吧。开始不带手机回宿舍，好好睡一觉。买了把静电容键盘。</p>
</li>
</ul>
<p>生活总是这样，不给半点希望的星光，把人压的苟延残喘却无可奈何，难过的时候都要去 b 站算卦占卜来看一下接下来的日子走势，企图获得一星半点的慰籍。可能是自己想太多，进入了精神内耗，经历过很多难熬的日子，似乎也不差这几百天。可能有什么办法呢？今年就要秋招了，努力一下，等找完工作稳定下来，好好休息吧，不再去想乱七八糟的东西。</p>
<p>我觉得师兄有句话很好，毕业了绝对不能立刻买房，先玩几年。学校里跟个孙子似的，没必要一毕业立刻成为孙子，每天一挣钱欠银行几百块钱的日子也不好受。虽然早晚是孙子，但先玩几年，快乐几年再说。</p>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>AVL树的Python实现</title>
    <url>/2018/11/03/AVL-RB-tree/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>AVL是平衡树，平衡因子概念什么的就不阐述了，主要是在不平衡时候如何旋转。（1）右子树右节点插入：左旋转。（2）左子树左节点插入：右旋转。（3）右子树左节点插入：右旋转后左旋转。（4）左子树右节点插入：左旋转后右旋转。</p>
<ul>
<li><strong>所谓的左旋和右旋</strong>都是以子树为原点的：如b是a的子树，那么旋转就围绕b来进行。</li>
<li>如果b是a的左子树，那么就围绕b将a向右旋转，看着就像是a直接掉下来了，掉成了b的右子树。</li>
<li>如果b是a的右子树，那么就围绕b将a向左旋转，看着就像是a直接掉下来了，掉成了b的左子树。</li>
</ul>
<a id="more"></a>
<p>如果对本文有疑问或者想找男朋友，可以联系我，<a href="https://muyuuuu.github.io/about/">点击此处有我联系方式。</a></p>
<p>有关AVL树的具体旋转操作请看<a href="https://blog.csdn.net/qq_25806863/article/details/74755131" target="_blank" rel="noopener">这里，讲的贼详细</a>。</p>
<p>AVL树有左右孩子的概念，所以，在实现AVL树之前，有必要先引入Python中类的概念，先来个MWE。</p>
<h3 id="Python的类"><a href="#Python的类" class="headerlink" title="Python的类"></a>Python的类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, brand, gas)</span>:</span></span><br><span class="line">        self.brand = brand</span><br><span class="line">        self.gas = gas</span><br><span class="line">        print(<span class="string">'一辆新的'</span>, self.brand, <span class="string">'被生产出来了！'</span>)</span><br><span class="line">    <span class="comment"># 定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_gas</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        self.gas += amount</span><br><span class="line">    <span class="comment"># 定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_gas</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'剩余汽油：'</span>, self.gas)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">benz = Car(<span class="string">'Benz'</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment"># 调用方法</span></span><br><span class="line">benz.add_gas(<span class="number">200</span>)</span><br><span class="line">benz.show_gas()</span><br></pre></td></tr></table></figure>
<h3 id="AVL树的实现"><a href="#AVL树的实现" class="headerlink" title="AVL树的实现"></a>AVL树的实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 定义每个节点的数据，左孩子右孩子，平衡因子</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data = <span class="number">0</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.height = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTree</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__Max</span><span class="params">(self, h1, h2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> h1 &gt; h2:</span><br><span class="line">            <span class="keyword">return</span> h1</span><br><span class="line">        <span class="keyword">elif</span> h1 &lt;= h2:</span><br><span class="line">            <span class="keyword">return</span> h2</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 左左情况，向右旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__LL</span><span class="params">(self, r)</span>:</span></span><br><span class="line">        node = r.left</span><br><span class="line">        r.left = node.right</span><br><span class="line">        node.right = r</span><br><span class="line">        r.height = self.__Max(self.getHeight(r.right), self.getHeight(r.left)) + <span class="number">1</span></span><br><span class="line">        node.height = self.__Max(self.getHeight(node.right), self.getHeight(node.left)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 右右，左旋</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__RR</span><span class="params">(self, r)</span>:</span></span><br><span class="line">        node = r.right</span><br><span class="line">        r.right = node.left</span><br><span class="line">        node.left = r</span><br><span class="line">        r.height = self.__Max(self.getHeight(r.right), self.getHeight(r.left)) + <span class="number">1</span></span><br><span class="line">        node.height = self.__Max(self.getHeight(node.right), self.getHeight(node.left)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 左右，先左旋再右旋</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__LR</span><span class="params">(self, r)</span>:</span></span><br><span class="line">        r.left = self.__RR(r.left)</span><br><span class="line">        <span class="keyword">return</span> self.__LL(r)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 右左，先右旋再左旋</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__RL</span><span class="params">(self, r)</span>:</span></span><br><span class="line">        r.right = self.__LL(r.right)</span><br><span class="line">        <span class="keyword">return</span> self.__RR(r)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># r是self.root</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__insert</span><span class="params">(self, data, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> r == <span class="literal">None</span>:</span><br><span class="line">            node = TreeNode()</span><br><span class="line">            node.data = data</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">elif</span> data == r.data:</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">elif</span> data &lt; r.data:</span><br><span class="line">            r.left = self.__insert(data, r.left)</span><br><span class="line">            <span class="comment"># 左高右低</span></span><br><span class="line">            <span class="keyword">if</span> self.getHeight(r.left) - self.getHeight(r.right) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> data &lt; r.left.data:</span><br><span class="line">                    r = self.__LL(r)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = self.__LR(r)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r.right = self.__insert(data, r.right)</span><br><span class="line">            <span class="keyword">if</span> self.getHeight(r.right) - self.getHeight(r.left) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> data &gt; r.right.data:</span><br><span class="line">                    r = self.__RR(r)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = self.__RL(r)</span><br><span class="line"></span><br><span class="line">        r.height = self.__Max(self.getHeight(r.left), self.getHeight(r.right)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除data节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete</span><span class="params">(self, data, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> r == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> r.data == data:</span><br><span class="line">            <span class="comment"># 如果只有右子树，直接将右子树赋值到此节点</span></span><br><span class="line">            <span class="keyword">if</span> r.left == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> r.right</span><br><span class="line">            <span class="comment"># 如果只有左子树，直接将左子树赋值到此节点</span></span><br><span class="line">            <span class="keyword">elif</span> r.right == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> r.left</span><br><span class="line">            <span class="comment"># 如果同时有左右子树</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 左子树高度大于右子树</span></span><br><span class="line">                <span class="keyword">if</span> self.getHeight(r.left) &gt; self.getHeight(r.right):</span><br><span class="line">                    <span class="comment"># 找到最右节点 返回节点值 并删除该节点</span></span><br><span class="line">                    node = r.left</span><br><span class="line">                    <span class="keyword">while</span>(node.right != <span class="literal">None</span>):</span><br><span class="line">                        node = node.right</span><br><span class="line">                    r = self.__delete(node.data, r)</span><br><span class="line">                    r.data = node.data</span><br><span class="line">                    <span class="keyword">return</span> r</span><br><span class="line">                <span class="comment"># 右子树高度大于左子树</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = r.right</span><br><span class="line">                    <span class="keyword">while</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                        node = node.left</span><br><span class="line">                    r = self.__delete(node.data, r)</span><br><span class="line">                    r.data = node.data</span><br><span class="line">                    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> data &lt; r.data:</span><br><span class="line">            <span class="comment"># 在左子树中删除</span></span><br><span class="line">            r.left = self.__delete(data, r.left)</span><br><span class="line">            <span class="comment"># 右子树高度与左子树高度相差超过1</span></span><br><span class="line">            <span class="keyword">if</span> self.getHeight(r.right) - self.getHeight(r.left) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> self.getHeight(r.right.left) &gt; self.getHeight(r.right.right):</span><br><span class="line">                    r = self.__RL(r)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = self.__RR(r)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> data &gt; r.data:</span><br><span class="line">            <span class="comment"># 右子树中删除</span></span><br><span class="line">            r.right = self.__delete(data, r.right)</span><br><span class="line">            <span class="comment"># 左子树与右子树高度相差超过1</span></span><br><span class="line">            <span class="keyword">if</span> self.getHeight(r.left)-self.getHeight(r.right) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> self.getHeight(r.left.right)&gt;self.getHeight(r.left.left):</span><br><span class="line">                    r = self.__LR(r)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = self.__LL(r)</span><br><span class="line">        <span class="comment"># 更新高度</span></span><br><span class="line">        r.height = self.__Max(self.getHeight(r.left), self.getHeight(r.right))+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__show</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># print (root.data)</span></span><br><span class="line">            self.__show(root.left)</span><br><span class="line">            self.__show(root.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.root = self.__insert(data, self.root)</span><br><span class="line">        <span class="keyword">return</span> self.root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.root = self.__delete(data, self.root)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 求结点的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHeight</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># print node</span></span><br><span class="line">        <span class="keyword">return</span> node.height</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__show(self.root)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bi = BTree()</span><br><span class="line">    insert_time = []</span><br><span class="line">    delete_time = []</span><br><span class="line">    <span class="keyword">for</span> right_interval <span class="keyword">in</span> range(<span class="number">1000</span>, <span class="number">500000</span>, <span class="number">50000</span>):</span><br><span class="line">        array = np.random.randint(<span class="number">1</span>, <span class="number">100</span>, right_interval)</span><br><span class="line">        since = time.time()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            bi.Insert(i)</span><br><span class="line">        end = time.time() - since</span><br><span class="line">        insert_time.append(end)</span><br><span class="line">        print(<span class="string">'AVL insert : '</span> + str(right_interval) + <span class="string">' Data: '</span> + str(end) + <span class="string">'s'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right_interval <span class="keyword">in</span> range(<span class="number">1000</span>, <span class="number">500000</span>, <span class="number">50000</span>):</span><br><span class="line">        array = np.random.randint(<span class="number">1</span>, <span class="number">100</span>, right_interval)</span><br><span class="line">        since = time.time()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            bi.Delete(i)</span><br><span class="line">        end = time.time() - since</span><br><span class="line">        delete_time.append(end)</span><br><span class="line">        print(<span class="string">'AVL delete : '</span> + str(right_interval) + <span class="string">' Data: '</span> + str(end) + <span class="string">'s'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            bi.Insert(i)</span><br></pre></td></tr></table></figure>
<h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p>  Have a look about the result of insertion and delete operation to AVL。<br>  <strong>Insertion:</strong><br><img data-src="/2018/11/03/AVL-RB-tree/i.png" alt><br>  <strong>Delete:</strong><br><img data-src="/2018/11/03/AVL-RB-tree/d.png" alt><br>  <strong>Statistic:</strong><br><img data-src="/2018/11/03/AVL-RB-tree/1.png" alt></p>
<hr>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>一个好看通用的PyQt5界面</title>
    <url>/2019/11/16/A-Beautiful-PyQt5-Interface/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>经过多天的折腾和（准备期末），终于闲下来可以把已经写好的界面发布出来了。另外的修改是，我个人觉得不错的代码会直接放github的链接，一些无所谓的代码，比如 <code>实现快速排序</code> 这种内容就直接放源代码在博客里了。</p>
<a id="more"></a>
<h1 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h1><p><img data-src="/2019/11/16/A-Beautiful-PyQt5-Interface/1.gif" alt></p>
<h1 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h1><ul>
<li>布局类： QStackedLayout, QGridLayout, QVBoxLayout, QHBoxLayout, QSplitter</li>
<li>容器: QTreeWidget, QFrame, QTabWidget</li>
<li>常见控件: QLabel, QLineEdit, QRadioButton, QSpinBox, QComboBox, QCalendarWidget, QDateTimeEdit, QMessageBox</li>
<li>QSS: qdarkstyle </li>
</ul>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>写这份代码的目的是，在以后的软件开发用能够快速使用这个界面（或者借鉴修改），灵活使用。所以里面的代码并没有功能函数，只有界面函数，供大家参考借鉴。满足通用性和美观性。</p>
<p>在以后的开发中要灵活运用这些布局，才能写出好的界面，而不是使用QtDesigner这类可视化工具，毕竟太丑了。</p>
<h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p>里面包含了依赖库和运行方式:<br><a href="https://github.com/muyuuuu/A-Beautiful-PyQt5-Interface" target="_blank" rel="noopener">https://github.com/muyuuuu/A-Beautiful-PyQt5-Interface</a></p>
]]></content>
      <tags>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Arch 折腾全记录，彻底告别 Windows</title>
    <url>/2021/07/31/Arch-config/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>想来想去，以壮士断腕的决心决定抛弃垃圾 <code>windows</code> 了，实在是 <code>TMD</code> 卡的要死，但是以我电脑的配置，不可能卡的。加上 <code>C</code> 盘的无理由暴增，<code>TMD</code> 空间锐减，加上每次系统动不动更新，每次更新都 <code>TMD</code> 出 <code>bug</code> 直接卡死。我宁肯花一周的时间打造一款我的主力 <code>Arch Linux</code> ，再 <code>TMD</code> 也不向 <code>windows</code> 低头了。以本文记录 <code>Arch Linux</code> 的折腾全记录。</p>
<p>包括：代理、终端、字体、换源更新、软件、甚至是博客迁移等。最重要的是，关于向这个世界的妥协，如何使安装 QQ、微信和 word 等非必要但深入人心的软件。毕竟老板让你微信给他发文件还是很常见的，毕竟老板没手没脚，发一次不接收必须发第 $N$ 次，毕竟他用 LaTeX 也要手动编号。</p>
<a id="more"></a>
<h1 id="关于代理"><a href="#关于代理" class="headerlink" title="关于代理"></a>关于代理</h1><p>我用的是 <code>clash</code>，直接 <code>sudo pacman -s clash</code> 即可，而后将其设置为开机启动，后台自己执行。<a href="https://github.com/Sitoi/SystemdClash" target="_blank" rel="noopener">相关参考</a>。</p>
<p>不过刚到新系统，一般会面临先有鸡还是先有蛋的问题，即：代理服务在国外，没有代理买不了服务，没有服务就出不去。所以，提前找同学接好代理，注意：有些代理只能在 <code>windows</code> 使用，一定要看好 <code>linux</code> 是否可以用。</p>
<h1 id="关于输入法"><a href="#关于输入法" class="headerlink" title="关于输入法"></a>关于输入法</h1><p><a href="https://www.cnblogs.com/qscgy/p/13385905.html" target="_blank" rel="noopener">文章推荐</a>，关于安装和配置就这个写的比较好，网上其他教程太垃圾且过时。在配置输入法的时候记得选择里面的 <code>pinyin</code>，其他的中文输入不行，然后重启即可。</p>
<h1 id="关于更新与换源"><a href="#关于更新与换源" class="headerlink" title="关于更新与换源"></a>关于更新与换源</h1><p><code>sudo pacman -Syu</code>，同步仓库即同步本地软件和仓库中软件的最新状态，更新所有系统上被 <code>pacman</code> 管理的的软件。<code>Su</code> 升级系统；<code>Syy</code> 会只刷新数据库。</p>
<p><strong>Arch Linux 中文社区仓库</strong> 是由 Arch Linux 中文社区驱动的非官方软件仓库，包含许多官方仓库未提供的额外的软件包，以及已有软件的 git 版本等变种。一部分软件包的打包脚本来源于 AUR，但也有许多包与 AUR 不一样。以清华大学的源为例，在 <code>/etc/pacman.conf</code> 文件末尾添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure>
<p>因为所有软件包都是经过开发者私钥签名，验证签名需要导入对应的公钥，即：安装 <code>archlinuxcn-keyring</code> 包以导入 GPG key。</p>
<p>当然，有些软件不一定在 archlinuxcn 源中，所以其它软件的换源方式为：编辑 /etc/pacman.d/mirrorlist，文件顶端添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure>
<p>更新软件包缓存：<code>sudo pacman -Syy</code>。</p>
<h1 id="关于浏览器"><a href="#关于浏览器" class="headerlink" title="关于浏览器"></a>关于浏览器</h1><p>我使用的浏览器是 <code>google-chrome-stable</code>，因为 <code>chromium</code> 不支持登录谷歌帐号，插件、书签无法同步，且 <code>chromium wiki</code> 上提供的解决方案也是曲线救国，我不喜欢。</p>
<p><img data-src="https://z3.ax1x.com/2021/07/31/Wv01K0.png" alt></p>
<p>在 <code>pacman -S google-chrome-stable</code> 后，因为浏览器不能使用代理而无法为了科学上网。我查了一下可以使用 <code>proxychains</code>，但是配合 <code>google-chrome-stable</code> 使用时会直接 <code>core dumped</code>，查了一下据说是这俩软件水火不容。而后我又查到了其它用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">google-chrome-stable --proxy-server=&quot;socks5://127.0.0.1:7891&quot;</span><br></pre></td></tr></table></figure>
<p>这样开启的浏览器是有代理的，然后登录 <code>chrome</code>，登录谷歌，直接同步，一切都很舒服。</p>
<h1 id="关于字体"><a href="#关于字体" class="headerlink" title="关于字体"></a>关于字体</h1><p>掏出万能的 wiki 文档，发现安装字体的三种方式：</p>
<ul>
<li>如果有人打包，那么 <code>sudo pacman -S ttf-lxgw-wenkai</code>，这是一款我比较喜欢的字体，这样通过包管理器的方式安装；</li>
<li>如果没人打包，可以手动下载字体，将字体移动到 <code>/usr/share/fonts/</code> 目录，所有用户可用；如果是个人用户可用，那么就放到 <code>~/.local/share/fonts</code>，而后使用 <code>fc-cache -vf</code> 刷新字体缓存。字体权限是 <code>644</code>，-rw-r—r— 1。</li>
</ul>
<p>安装完毕后，可以在设置-&gt;字体中，配置自己喜欢的字体，如果没有立即生效，记得重启。关于 <code>latex</code> 如何调用系统的字体，时而文件名、时而字体名，时而镜像中克隆的名字，等改天单独写吧。</p>
<p>一般而言，<code>sans serif</code> 表示无衬线字体，<code>Serif</code> 表示衬线字体，<code>Noto</code> 表示谷歌命名的字体，<code>Mono</code> 是等宽字体。我一般使用的字体是：思源宋体黑体、<code>source code pro</code> 和 <code>IBM Plex Mono</code>，落霞孤鹜等。</p>
<p>此外，还会遇到终端、软件里面时而衬线字体时而非衬线字体等极度丑陋的情况，这个时候需要进行一些配置，可以参考<a href="https://szclsya.me/zh-cn/posts/fonts/linux-config-guide/" target="_blank" rel="noopener">这篇博客</a>。</p>
<h1 id="关于终端"><a href="#关于终端" class="headerlink" title="关于终端"></a>关于终端</h1><ul>
<li>更改系统默认终端：<code>sudo chsh -s /usr/bin/bash</code>，如果切换失败，可以尝试进入 <code>root</code> 切换或 <code>usermod -s /usr/bin/fish lanling</code> 命令，查看系统默认终端：<code>cat /etc/shells</code>；</li>
<li><code>shell</code> 用的是 <code>fish</code> 毕竟是真的舒服，<code>oh my zsh</code> 太乱了。系统自带的 <code>konsole</code> 配和 <code>oh my zsh</code> 时常乱码，但是，不可否认，<code>konsole</code> 分屏、配色、标签页等各个方面都极度强大。</li>
</ul>
<p><img data-src="https://z3.ax1x.com/2021/07/31/Wv07dS.jpg" alt></p>
<p>所以我决定抛弃 <code>zsh</code>。注意切换终端时需要注意：进入 <code>root</code> 切换，不能在当前用户切换，否则下次重启电脑无法进入系统（并不是密码错误，我确实遇到了这个问题）。然后我登录了 <code>root</code> 用户，发现切换到子用户时：<code>failed to execute /bin/zsh</code>，说明 <code>shell</code> 没切换成功，而后两种方案，一种是装回 <code>zsh</code> ，一种是在 <code>root</code> 端切换为 <code>bash</code>，这样用户端就能进入系统了。</p>
<ul>
<li>而后选择的新 <code>shell</code> 是 <code>fish</code>，<code>sudo pacman -S fish</code> 即可，在终端执行 <code>ish_config</code>，进入 <code>web</code> 端的颜色配置。</li>
<li><code>set -U fish_prompt_pwd_dir_length 0</code> 会在终端现实全部的路径，如 <code>code/github/Face/Detect</code>，否则是 <code>c/g/F/D</code> 很难看。</li>
</ul>
<h1 id="关于软件"><a href="#关于软件" class="headerlink" title="关于软件"></a>关于软件</h1><p>列出我使用的软件，对于如何安装 QQ，微信和 word，将在文末给出。</p>
<ul>
<li><code>telegram</code>，吹水与交流技术</li>
<li><code>peek</code>，录制 <code>gif</code></li>
<li><code>visual-studio-code-bin</code>，写代码</li>
<li><code>clash</code>，懂得都懂</li>
<li><code>google-chrome-stable</code>，浏览器</li>
<li><code>typora</code>，写 <code>markdown</code> 的东西</li>
<li><code>flameshot</code>，截图工具，比深度截图好用一百倍</li>
</ul>
<p>此外，还设置了一些软件开启自启动：<code>flameshot</code>，<code>clash</code> 等。</p>
<p>软件的快捷键自己设置吧，我只设置了终端、浏览器，截图的快捷键。位于设置、自定义快捷键、编辑、新建、全局快捷键、命令。</p>
<h1 id="关于美化"><a href="#关于美化" class="headerlink" title="关于美化"></a>关于美化</h1><p>众所周知，不美化还怎么写代码，但是我友情提示一下：以我多年美化的经验而言，美化的尽头绝对是系统默认。</p>
<ul>
<li>底部的 <code>dock</code> 栏可以使用 <code>plank</code> 这个软件，但是无法和状态栏配合双屏使用，于是卸载。</li>
<li>设置、外观里面设置主题。</li>
<li>如果设置无法打开，那么查看是否有 <code>systemsettings5</code> 进程没彻底杀死，如果有，杀死即可。</li>
<li>而后自己折腾吧，<code>i3wm</code> 有点无从下手的样子。我尝试折腾了一下，直接黑屏，除了鼠标啥都没有，然后不知道动了哪个配置文件，<code>KDE</code> 都回不去了，系统会自动退出到登陆界面，登陆后还是退出，一个死循环。无奈，删除账户，新建账户，第六次重装系统。</li>
</ul>
<h1 id="关于博客搬家"><a href="#关于博客搬家" class="headerlink" title="关于博客搬家"></a>关于博客搬家</h1><p>我的博客是基于 <code>hexo</code> 的，而之前的博客在 windows 上，所以要进行博客搬家。博客搬家倒是很容易，先安装必要依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S nodejs</span><br><span class="line">sudo pacman -S npm</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>而后在安装 <code>hexo</code> 的时候有坑，有坑的是传统方案：<code>npm install -g hexo-cli</code>，这样会发现没权限，而后 <code>sudo npm install -g hexo-cli</code>，但这是很烂的行为，因为 <code>Arch</code> 的包最好用 <code>pacman</code> 管理起来，而 <code>npm</code> 安装的并不会被管理。所以，掏出万能的 <code>AUR</code>，发现里面有 <code>hexo</code>，安装即可。</p>
<p>之后的东西就简单了，新建博客路径，拷贝原始博客的文件到新的路径下：</p>
<ol>
<li>博客配置文件./_config.yml</li>
<li>主题配置文件夹./theme/</li>
<li>文章及相关内容的文件夹./source/</li>
<li>模板文件夹./scaffolds/</li>
<li>记录博客所有的插件的文件./package.json</li>
</ol>
<p>最后进入博客目录，执行 <code>npm install</code>，而后就可以使用博客了，这也是我换系统后的第一篇博客。</p>
<h1 id="关于善后"><a href="#关于善后" class="headerlink" title="关于善后"></a>关于善后</h1><p><code>word, excel, ppt, qq, wechat</code> 等软件如何使用或者寻找替代品也是必须要妥协的，毕竟很多人都在用，毕竟大部分人都不知道 latex 和 telegram 的存在。</p>
<h2 id="wps"><a href="#wps" class="headerlink" title="wps"></a>wps</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/Software/AUR</span><br><span class="line">cd ~/Software/AUR</span><br><span class="line">git clone https://aur.archlinux.org/wps-office-cn.git</span><br><span class="line">cd wps-office-cn</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure>
<p>而后按下 <code>meta</code> 键，就可以搜到了。再把字体从自己的 <code>windows</code> 系统拷贝过来，这样 <code>wps</code> 就有字体了，我是把字体拷贝到了 <code>/usr/share/fonts</code>。注意，安装完毕之后，<code>Software/AUR</code> 是可以删除的。</p>
<h2 id="qq"><a href="#qq" class="headerlink" title="qq"></a>qq</h2><p>无论是安装 QQ 还是 Tim，我试了网上和 wiki 说的那些什么用 <code>yay</code> 安装 <code>qq, deepin, office, wine, light</code> 乱七八糟的无法装成功，不如直接用官方构建好的包。去 <a href="https://im.qq.com/pcqq" target="_blank" rel="noopener">官方</a> 下载对应的发行版的包，<code>arch</code> 就下载 <code>pacman</code> 的，而后 <code>sudo pacman -U linuxqq_2.0.0-b2-1089_x86_64.pkg.tar</code>。</p>
<h2 id="wechat"><a href="#wechat" class="headerlink" title="wechat"></a>wechat</h2><p>既然 QQ 都安装成功了，那么也就通过这种方式安装 wechat 吧。去 github 下载别人<a href="https://github.com/countstarlight/deepin-wine-wechat-arch" target="_blank" rel="noopener">打包好的</a>，安装方式同 QQ。因为 3.0+ 的不能发文件且我在 issue 里面也没看到啥特别好修复方法。建议下载 <code>2.9.5</code> 版本的，然后将 wine 替换为 deepin-wine5 修理一下，可以参考<a href="https://www.jianshu.com/p/11231b51ece0" target="_blank" rel="noopener">这里</a>。</p>
]]></content>
      <tags>
        <tag>Computer</tag>
      </tags>
  </entry>
  <entry>
    <title>我和我的操作系统们</title>
    <url>/2020/11/15/Arch/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学业繁忙，作业真多。好久没来写博客了，<del>来水一篇。</del>注：本文没有任何引战的意思，不要在评论区对别人强行安利<strong>『自己喜欢，自己认为好，但别人可能根本不需要』</strong>的东西，没意思。每个人的想法都不一样。</p>
<ul>
<li><code>windows</code>: 只保留word和excel这类我要向世界妥协的软件；</li>
<li><code>ubuntu</code>：入手的第一款linux系统，活在虚拟机里，装软件遇到依赖困难好感全无，之后不了了之；</li>
<li><code>manjaro</code>：入手的第二款linux系统，活在硬盘上。配合gnome桌面环境奔腾了一年。作为主力开发系统，包含了所有的开发工具。再一次滚动更新中坏掉，懒的修了，拿出了关键文件，将系统格掉；</li>
<li><code>Arch</code>：入手的第三款linux系统，活在硬盘上。正在作为主力系统的路上，最近课多，没折腾。</li>
</ul>
<a id="more"></a>
<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p>对这个系统的好感是最低的，集中在以下方面：</p>
<ul>
<li>我测试过（没记录具体数值）。同一份代码，<code>i5-7300U</code>的CPU在<code>manjaro</code>系统中的执行速度，远远快于<code>i7-9870H</code>的CPU在<code>windows</code>下的执行速度；</li>
<li><code>windows</code>的C盘不明觉厉，不知道里面是什么，但只知道它在飞速扩充；</li>
<li>界面丑陋；</li>
<li>其次，也是很重要的一点。永远不知道系统飞速运转是为什么，是在更新？是在窃取我的数据？如下图，我并没有兴趣去查下面这些东西是干什么的，但为什么不能在执行前尝试争取用户的同意呢？这样用户心里也有数。自己莫名其面的开始执行是真的吓人，毕竟科班出身的我，系统或软件的运行一定要在我的掌握之中（也不要求掌握太底层），不然没安全感。</li>
</ul>
<p><img data-src="https://static01.imgkr.com/temp/d35e61c98a174c5f902cc46ab8964b49.png" alt><br><img data-src="https://static01.imgkr.com/temp/762fab3571cb4878aa2082b83616b2df.png" alt><br><img data-src="https://static01.imgkr.com/temp/f19480a61101493a931a157dcfc67370.png" alt></p>
<p>但我也知道，如果没有windows这样方便纯小白的系统，计算机不可能像今天这样普及到各行各业。</p>
<h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><p>这个系统使用次数很少，断断续续两三年，还是看网上用的人很多我才用的，谈下我认为的缺点吧，毕竟用的时间少，没体会到啥优点。</p>
<ul>
<li>有较多的没用的内置软件；</li>
<li>安装某开发工具时遇到了依赖问题，太折腾了（可能我折腾的姿势不对）。</li>
</ul>
<p>给新手的初体验，除了终端外一切都很像windows，没啥特别吸引我的地方，所以就放弃了，连同虚拟机一起卸载。</p>
<h1 id="Manjaro"><a href="#Manjaro" class="headerlink" title="Manjaro"></a>Manjaro</h1><p>被我魔改成了Mac模样，顶部的状态栏，会随着打开不同的软件，而显示不同软件的顶部栏：</p>
<p><img data-src="https://static01.imgkr.com/temp/9e0b9aa2aa64490381068ae9bd8076b2.jpeg" alt><br><img data-src="https://static01.imgkr.com/temp/aae5968399eb4ed9b4b53bc015972a0a.png" alt></p>
<p>优点：</p>
<ul>
<li>基于<code>Arch</code>开发，软件很多；</li>
<li><code>pacman -Ss</code>可以查找想要的软件，<code>pacman -Rs</code>卸载软件及相关依赖，这一点很爽；</li>
<li>软件和系统可以滚动更新；</li>
<li>本人颜控，有丰富的桌面环境，可以配置很炫酷的主题和终端界面，开发效率++；</li>
<li>有着和ubuntu一样的易用性，对新手友好；</li>
<li>硬件驱动方面支持的可以，我甚至在这个系统下面开发过单片机的程序；</li>
<li>没有奇怪的依赖和预装软件。</li>
</ul>
<p>大部分直接在折腾各种软件，并没有专注了解这个系统，但还是能发现一些缺点的：</p>
<ul>
<li>某些软件配置困难，如python接口的的<code>graph-tool</code>，死活装不上，贼慢；</li>
<li>在某次滚动更新中滚挂了，放弃了这个系统，转而进入<code>Arch</code>教；</li>
<li><del>可惜没来得及给这个系统配一个二次元小姐姐的桌面，让它更好看一点。</del></li>
</ul>
<p><img data-src="https://static01.imgkr.com/temp/1e88d6a99a1b4411838d14f5d76c950d.png" alt></p>
<h1 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h1><p>By the way, I use Arch. 折腾了一天，终于装上了，<del>安装Arch需要很强的技术性和踩坑能力，新手不建议尝试，甚至按着别人装好的教程都不一定能装上，我也折腾了三四次踩了踩坑才装上。</del>看到Arch第一次跑起来的小黑窗带来的欣喜：</p>
<p><img data-src="https://static01.imgkr.com/temp/db3277db57b64afba000fd296155a677.jpg" alt></p>
<p>以及亲眼看到<code>Arch</code>的logo：</p>
<p><img data-src="https://static01.imgkr.com/temp/10ed89c79bce41c9988acb28daeb7b37.png" alt></p>
<p>在安装好桌面环境后，看到它再次成功跑起来的欣喜：</p>
<p><img data-src="https://static01.imgkr.com/temp/4cb4b8390ecc4e7c9206855cc1a316a9.jpg" alt></p>
<p>而<code>Arch</code>的优缺点则显而易见：</p>
<ul>
<li>软件库庞大，几乎可以使用<code>pacman</code>安装到任何软件，实在不行还有AUR(Archlinux User Repository)；</li>
<li><code>pacman -Ss</code>可以查找想要的软件，<code>pacman -Rs</code>卸载软件及相关依赖，这一点很爽；</li>
<li>archlinux的wiki覆盖范围之广，从安装到维护，从系统到软件，可以说是无敌的存在；</li>
<li>定制化程度很高，可以定制属于自己的系统。不会预装任何没用的东西，也就是所有安装的东西都是用户指定的，足够轻量和精简；</li>
<li><code>pacman -Syu</code>一键滚动升级，不需要繁琐的过程就直接升级到最新版，很geek，避免任何不必要的添加、修改和复杂增加，保持简单，且一目了然；</li>
<li>适合爱折腾的人，比如配置图形界面、配置输入法等过程并不适合新手；</li>
<li>社区驱动，对独立和自由的追求，不受商业集团的影响；</li>
<li>私人原因：arhclinuxcn社区是国内众多技术社区中少有的强。</li>
</ul>
<p>缺点：</p>
<ul>
<li>没办法像ubuntu和manjaro那样开箱即用，或者说，新手要开箱即用，老手就不一定了；</li>
<li>配置图形界面、输入法等过程令人头疼，配置好了后还是可以的；</li>
<li>可能会把系统滚坏了。</li>
</ul>
<p>如果有时间，我在加点炫酷的桌面风格吧，<del>企图用颜值来吸引更多的人入坑。</del></p>
]]></content>
      <tags>
        <tag>Computer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++数据结构篇『一』C++风格数组与字符串类</title>
    <url>/2019/03/31/C-string/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>起初是为了刷题而学习使用<code>C++</code>的，毕竟算法很重要。为什么不使用<code>python</code>作为刷题工具呢，第一性能很差劲，第二，上学期学算法我写<code>python</code>的第一句就是<code>import numpy as np</code>，这是个不太好的习惯。</p>
<p>刷题的过程中，因为对<code>C++</code>的一些形如<code>STL</code>的特性并不是很了解，与其说是<code>C++</code>倒不如说是<code>C</code>，所以不如学习一下<code>C++</code>的特性先。<del>没想到两年后我来填坑了。</del></p>
<a id="more"></a>
<h1 id="array"><a href="#array" class="headerlink" title="array"></a>array</h1><p>C语言风格的数组：</p>
<ul>
<li>可能退化为指针，<code>sizeof(a)/sizeof(a[0])</code>失效</li>
<li>不知道自己的大小</li>
<li>数组元素无法直接复制, <code>a = b</code></li>
<li>不能自动推导类型，<code>auto a[] = {1, 2, 3}</code></li>
</ul>
<p>C++风格数组：</p>
<ul>
<li>是一个容器类，有迭代器</li>
<li>是模板类，容纳任何类型的数据，但数组不能扩大也不能缩小，数据类型相同</li>
<li>对类模板的参数进行推导，推导出类型和数量</li>
<li>可以直接赋值</li>
<li>知道自己的大小 <code>size()</code></li>
<li>和另一个数组交换内容 <code>swap()</code></li>
<li>用指定内容填充自己 <code>fill()</code></li>
<li>取某个元素位置，做越界检查 <code>at()</code></li>
</ul>
<h2 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h2><p>使用C++风格数组时，先在头文件中引用，并使用<code>using</code>指令声明使用<code>std</code>空间中的对应对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">array</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// int 类型 10 个元素</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; x, x1;</span><br><span class="line"><span class="comment">// char 类型 5 个元素</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">char</span>, 5&gt; a&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动推导 C++17 支持</span></span><br><span class="line"><span class="built_in">array</span> a1 &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">array</span> a2 &#123;<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问指定元素 做越界检查</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.at(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 越界后，直接退出，不报错，后续语句无法执行</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; a.at(10) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问第一个元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问最后一个元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;a 表示取出a这个数组对象的地址</span></span><br><span class="line"><span class="comment">// &amp;a[0] 取出存储数组位置的首地址</span></span><br><span class="line"><span class="comment">// 返回指向数组第一个元素的指针</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(a.data()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容量</span></span><br><span class="line"><span class="comment">// 当前容量</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回容纳的最大元素数</span></span><br><span class="line"><span class="comment">// 因为 array 类必须指定数组的数量，且数量不可变</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以指定值填充容器</span></span><br><span class="line">x.<span class="built_in">fill</span>(<span class="number">12</span>);</span><br><span class="line">x1.<span class="built_in">fill</span>(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换内容</span></span><br><span class="line">x.swap(x1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组 4行3列</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;<span class="keyword">int</span> , 3&gt;, 4&gt; a1;</span><br></pre></td></tr></table></figure>
<h1 id="C语言中的字符串"><a href="#C语言中的字符串" class="headerlink" title="C语言中的字符串"></a>C语言中的字符串</h1><p>C语言中的字符串不能作为参数返回，因为子函数在执行完毕后所有变量的空间都会释放，（当然全局变量除外），处理起来比较麻烦。且C语言的字符串为字符数组，类型为<code>const char*</code>，以空字符结尾，遇到0会终止，无法记录自身长度，不能像对象那样用着方便，并不是严格意义的字符串。所以来用C++的String类吧，体验真正的字符串。</p>
<h1 id="到C-中String类的世界"><a href="#到C-中String类的世界" class="headerlink" title="到C++中String类的世界"></a>到C++中String类的世界</h1><h2 id="声明与初始化-1"><a href="#声明与初始化-1" class="headerlink" title="声明与初始化"></a>声明与初始化</h2><ul>
<li>C++11中生字符串语法：R”delimiter(raw_characters)delimiter”。</li>
<li>C++14生字符串，重载 “”s 运算符。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串操作练习</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生字符串 \n 被保留输出</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* s1 = <span class="string">R"(hello\n world)"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略分隔符</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* s2 = <span class="string">R"Nouse(hello\a world)Nouse"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动推导为 std::string 字符串字面量 \0 会被转义</span></span><br><span class="line">    <span class="keyword">auto</span> s3 = <span class="string">"he\0llo"</span>s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则为 \0 视为终止符</span></span><br><span class="line">    <span class="built_in">string</span> s4 = <span class="string">"he\0llo"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s4.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// \0 不转义</span></span><br><span class="line">    <span class="built_in">string</span> s5 = <span class="string">R"(he\0llo)"</span>s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Character literals</span></span><br><span class="line">    <span class="keyword">auto</span> c0 =   <span class="string">'A'</span>; <span class="comment">// char</span></span><br><span class="line">    <span class="keyword">auto</span> c1 = <span class="string">u8'A'</span>; <span class="comment">// char</span></span><br><span class="line">    <span class="keyword">auto</span> c2 =  <span class="string">L'A'</span>; <span class="comment">// wchar_t</span></span><br><span class="line">    <span class="keyword">auto</span> c3 =  <span class="string">u'A'</span>; <span class="comment">// char16_t</span></span><br><span class="line">    <span class="keyword">auto</span> c4 =  <span class="string">U'A'</span>; <span class="comment">// char32_t</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Multicharacter literals</span></span><br><span class="line">    auto m0 = 'abcd'; // int, value 0x61626364</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String literals</span></span><br><span class="line">    <span class="keyword">auto</span> s0 =   <span class="string">"hello"</span>; <span class="comment">// const char*</span></span><br><span class="line">    <span class="keyword">auto</span> s1 = <span class="string">u8"hello"</span>; <span class="comment">// const char*, encoded as UTF-8</span></span><br><span class="line">    <span class="keyword">auto</span> s2 =  <span class="string">L"hello"</span>; <span class="comment">// const wchar_t*</span></span><br><span class="line">    <span class="keyword">auto</span> s3 =  <span class="string">u"hello"</span>; <span class="comment">// const char16_t*, encoded as UTF-16</span></span><br><span class="line">    <span class="keyword">auto</span> s4 =  <span class="string">U"hello"</span>; <span class="comment">// const char32_t*, encoded as UTF-32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Raw string literals containing unescaped \ and "</span></span><br><span class="line">    <span class="keyword">auto</span> R0 =   <span class="string">R"("Hello \ world")"</span>; <span class="comment">// const char*</span></span><br><span class="line">    <span class="keyword">auto</span> R1 = <span class="string">u8R"("Hello \ world")"</span>; <span class="comment">// const char*, encoded as UTF-8</span></span><br><span class="line">    <span class="keyword">auto</span> R2 =  <span class="string">LR"("Hello \ world")"</span>; <span class="comment">// const wchar_t*</span></span><br><span class="line">    <span class="keyword">auto</span> R3 =  <span class="string">uR"("Hello \ world")"</span>; <span class="comment">// const char16_t*, encoded as UTF-16</span></span><br><span class="line">    <span class="keyword">auto</span> R4 =  <span class="string">UR"("Hello \ world")"</span>; <span class="comment">// const char32_t*, encoded as UTF-32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Combining string literals with standard s-suffix</span></span><br><span class="line">    <span class="keyword">auto</span> S0 =   <span class="string">"hello"</span>s; <span class="comment">// std::string</span></span><br><span class="line">    <span class="keyword">auto</span> S1 = <span class="string">u8"hello"</span>s; <span class="comment">// std::string</span></span><br><span class="line">    <span class="keyword">auto</span> S2 =  <span class="string">L"hello"</span>s; <span class="comment">// std::wstring</span></span><br><span class="line">    <span class="keyword">auto</span> S3 =  <span class="string">u"hello"</span>s; <span class="comment">// std::u16string</span></span><br><span class="line">    <span class="keyword">auto</span> S4 =  <span class="string">U"hello"</span>s; <span class="comment">// std::u32string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Combining raw string literals with standard s-suffix</span></span><br><span class="line">    <span class="keyword">auto</span> S5 =   <span class="string">R"("Hello \ world")"</span>s; <span class="comment">// std::string from a raw const char*</span></span><br><span class="line">    <span class="keyword">auto</span> S6 = <span class="string">u8R"("Hello \ world")"</span>s; <span class="comment">// std::string from a raw const char*, encoded as UTF-8</span></span><br><span class="line">    <span class="keyword">auto</span> S7 =  <span class="string">LR"("Hello \ world")"</span>s; <span class="comment">// std::wstring from a raw const wchar_t*</span></span><br><span class="line">    <span class="keyword">auto</span> S8 =  <span class="string">uR"("Hello \ world")"</span>s; <span class="comment">// std::u16string from a raw const char16_t*, encoded as UTF-16</span></span><br><span class="line">    <span class="keyword">auto</span> S9 =  <span class="string">UR"("Hello \ world")"</span>s; <span class="comment">// std::u32string from a raw const char32_t*, encoded as UTF-32</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello\n world</span><br><span class="line">hello\a world</span><br><span class="line">he llo</span><br><span class="line">he</span><br><span class="line">he\0llo</span><br></pre></td></tr></table></figure>
<h2 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h2><p>查找第一次出现的地方：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"cat"</span>;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="comment">// 在str中寻找c的位置，并返回，这里输出0</span></span><br><span class="line">    a = str.<span class="built_in">find</span>(<span class="string">"c"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多的查找操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"0123456789"</span>;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = str.<span class="built_in">find</span>(<span class="string">"01"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从2开始查找，包含 2</span></span><br><span class="line">    <span class="comment">// 范围内查找并返回第一个字符串 ab 在 str 的位置</span></span><br><span class="line">    a = str.<span class="built_in">find</span>(<span class="string">"23"</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 str[0]~str[2] 范围内查找并返回字符串 ab 在 str 的位置</span></span><br><span class="line">    a = str.rfind(<span class="string">"1"</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="first系列函数"><a href="#first系列函数" class="headerlink" title="first系列函数"></a>first系列函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// first 系列函数</span></span><br><span class="line"><span class="comment">// 返回 apple 中任何一个字符首次在 str 中出现的位置</span></span><br><span class="line">str.find_first_of(<span class="string">"apple"</span>);</span><br><span class="line"><span class="comment">// 返回 apple 中任何一个字符首次在 str[2]~str[n-1] 范围中出现的位置</span></span><br><span class="line">str.find_first_of(<span class="string">"apple"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 返回除 apple 以外的任何一个字符在 str 中首次出现的位置</span></span><br><span class="line">str.find_first_not_of(<span class="string">"apple"</span>);</span><br><span class="line"><span class="comment">// 返回除 apple 以外的任何一个字符在 str[2]~str[n-1] 范围中首次出现的位置</span></span><br><span class="line">str.find_first_not_of(<span class="string">"apple"</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h2 id="last系列函数"><a href="#last系列函数" class="headerlink" title="last系列函数"></a>last系列函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// last 系列函数</span></span><br><span class="line"><span class="comment">// 返回 apple 中任何一个字符最后一次在 str 中出现的位置</span></span><br><span class="line">str.find_last_of(<span class="string">"apple"</span>);</span><br><span class="line"><span class="comment">// 返回 apple 中任何一个字符最后一次在 str[0]~str[2] 范围中出现的位置</span></span><br><span class="line">str.find_last_of(<span class="string">"apple"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 返回除 apple 以外的任何一个字符在 str 中最后一次出现的位置</span></span><br><span class="line">str.find_last_not_of(<span class="string">"apple"</span>);</span><br><span class="line"><span class="comment">// 返回除 apple 以外的任何一个字符在 str[0]~str[2] 范围中最后一次出现的位置</span></span><br><span class="line">str.find_last_not_of(<span class="string">"apple"</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h2 id="没找到"><a href="#没找到" class="headerlink" title="没找到"></a>没找到</h2><p>没找到的话，返回值是无穷大。</p>
<h2 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"0123456789"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 [3] 及以后的子串</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str.substr(<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 返回 str[2]~str[2+(4-1)] 子串</span></span><br><span class="line">    <span class="comment">// 即从[2]开始4个字符组成的字符串</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str.substr(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">"aa1"</span>, <span class="number">0</span>) == <span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"找不到该子串！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回把 [2]~[2+(4-1)] 的内容替换为 "sz" 后的新字符串</span></span><br><span class="line">str.replace(<span class="number">2</span>, <span class="number">4</span>, <span class="string">"sz"</span>);</span><br><span class="line"><span class="comment">// 返回把 [2]~[2+(4-1)] 的内容替换为 "abcd" 的前3个字符后，得到新字符串</span></span><br><span class="line">str.replace(<span class="number">2</span>, <span class="number">4</span>, <span class="string">"abcd"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 [2] 位置之前，插入字符串 "sz"，并返回形成的新字符串</span></span><br><span class="line">str.insert(<span class="number">2</span>, <span class="string">"sz"</span>);</span><br><span class="line"><span class="comment">// 从 [2] 位置之前，插入字符串 "abcd" 的前3个字符，并返回形成的新字符串</span></span><br><span class="line">str.insert(<span class="number">2</span>, <span class="string">"abcd"</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 从 [2] 位置开始添加字符串 "abcd" 中从1开始，共插入3个，</span></span><br><span class="line"><span class="comment">// 即插入 bcd 并返回形成的新字符串</span></span><br><span class="line">str.insert(<span class="number">2</span>, <span class="string">"abcd"</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 从 [1] 插入四个相同的字符，不能插入子串</span></span><br><span class="line">str.insert(<span class="number">1</span>, <span class="number">4</span>, <span class="string">'+'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">str.push_back(<span class="string">'a'</span>); <span class="comment">// 在 str 末尾添加字符 'a'，只能插入一个</span></span><br><span class="line">str.append(<span class="string">"abc"</span>);  <span class="comment">// 在 str 末尾添加字符串 "abc"</span></span><br><span class="line">str.append(<span class="string">" to C and C++"</span>, <span class="number">3</span>, <span class="number">2</span>) <span class="comment">// 从3开始追加，追加2个</span></span><br><span class="line">str.append(<span class="string">" to C and C++"</span>, <span class="number">2</span>) <span class="comment">// 从0开始追加，追加2个</span></span><br><span class="line">str.append(<span class="number">4</span>, <span class="string">'!'</span>) <span class="comment">// 追加四次，同样只能追加字符，不能子串</span></span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">str.erase(<span class="number">3</span>);    <span class="comment">// 删除 [3] 及以后的字符，并返回新字符串</span></span><br><span class="line">str.erase(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 删除从 [3] 开始的 5 个字符，并返回新字符串</span></span><br></pre></td></tr></table></figure>
<h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">str1.swap(str2); <span class="comment">// 把 str1 与 str2 交换</span></span><br></pre></td></tr></table></figure>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>等于返回0，大于返回1，小于返回-1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.compare(pos1, n1, s2) <span class="comment">// 让s中从pos下标开始的n1个字符跟s2做比较</span></span><br><span class="line">s.compare(s1) <span class="comment">// 直接比较</span></span><br></pre></td></tr></table></figure>
<h2 id="求长度"><a href="#求长度" class="headerlink" title="求长度"></a>求长度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="number">0</span>, <span class="string">'a'</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// 大小</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str.empty() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">// 空为 1，不空为 0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str.length() &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// 和size输出相同</span></span><br></pre></td></tr></table></figure>
<h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><p>两个String类的字符串直接相加即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="number">10</span>, <span class="string">'a'</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str1</span><span class="params">(<span class="number">11</span>, <span class="string">'b'</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str + str1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="迭代器访问"><a href="#迭代器访问" class="headerlink" title="迭代器访问"></a>迭代器访问</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"iUEgFDBIWEJFIDB"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span>::iterator it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他操作-1"><a href="#其他操作-1" class="headerlink" title="其他操作"></a>其他操作</h2><p>输入数据并求和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, len;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">string</span> s = to_string(a + b);</span><br><span class="line">len = s.length();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s;</span><br></pre></td></tr></table></figure>
<p>字符倒序输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"cvicses"</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 反向迭代器，指定初始位置和结束位置</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str.rbegin(),str.rend())</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/string-and-character-literals-cpp?view=msvc-160" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/cpp/cpp/string-and-character-literals-cpp?view=msvc-160</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>DIY智能小车——超声波与液晶显示</title>
    <url>/2018/05/22/C51/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是我的第一篇小博客～本人正在参加电子设计竞赛的校赛，想起了多年前，啊呸，一年前学过的51单片机，自从学完后就放到了箱底被我冷落，今日重新拿起板子，既然学了，就要做点东西，学以致用嘛~（话说markdown写博客还真是爽~）</p>
<p>主要实现了以下的功能：</p>
<ul>
<li>超声波HCSR-04实现避障功能 </li>
<li>1602液晶显示与障碍物的距离 </li>
<li>自动避障 </li>
<li>寻迹（手机端控制是否进入寻迹模式） </li>
<li>调速（没用中断，自己写的PWM波形函数） </li>
<li>手机蓝牙控制（前进、后退、加速、减速等）</li>
</ul>
<a id="more"></a>
<p>如果对本文有疑问或者想找男朋友，可以联系我，<a href="https://muyuuuu.github.io/about/">点击此处有我联系方式</a>。</p>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><h3 id="电路图"><a href="#电路图" class="headerlink" title="电路图"></a>电路图</h3><p><img data-src="/2018/05/22/C51/1.png" alt></p>
<h3 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h3><p><img data-src="/2018/05/22/C51/2.jpg" alt></p>
<blockquote>
<p>Oh, no, PCB有点粗暴，就不放了，我队友花了几个星期学的Altium Designer，有课的情况下学了大概三个星期，弄得我也手痒，有空学一下~</p>
</blockquote>
<h2 id="超声波避障"><a href="#超声波避障" class="headerlink" title="超声波避障"></a>超声波避障</h2><p>HC-SR04模块的具体使用就不说了，百度一大把，以及，卖模块的淘宝商家手里肯定也有相关的资料。外加本人主要负责写代码，直接结合代码说明，都有备注，以及能运行~</p>
<p>超声波是根据发射声波后，接受回声，根据回声持续的时间计算的距离。 </p>
<h2 id="1602-显示距离"><a href="#1602-显示距离" class="headerlink" title="1602 显示距离"></a>1602 显示距离</h2><p>1602的话，emmmmmm，学过51单片机的应该都比较熟了。</p>
<h3 id="避障与距离部分程序"><a href="#避障与距离部分程序" class="headerlink" title="避障与距离部分程序"></a>避障与距离部分程序</h3><p>这里仅仅是超声波避免障碍和1602显示距离的程序哦～<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg52.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="comment">/****************1602的I/O口******************/</span></span><br><span class="line">sbit rs = P1^<span class="number">1</span>;      <span class="comment">//1602写命令模式</span></span><br><span class="line">sbit lcden = P3^<span class="number">3</span>;   <span class="comment">//1602使能端</span></span><br><span class="line">sbit state = P0^<span class="number">7</span>;   <span class="comment">//1说明液晶繁忙</span></span><br><span class="line"><span class="comment">/*********模式选择端口************/</span></span><br><span class="line">sbit key = P2^<span class="number">4</span>;    <span class="comment">//用来切换寻迹或者避障</span></span><br><span class="line"><span class="comment">/***************超声波**I/O口******************/</span></span><br><span class="line">sbit trig = P1^<span class="number">0</span>;      <span class="comment">//发射端与接收端，通过echo的      </span></span><br><span class="line">sbit echo = P3^<span class="number">2</span>;      <span class="comment">//电平变化来计算距离，与外部中断同一个IO口</span></span><br><span class="line"><span class="comment">/***************测试灯**I/O口******************/</span></span><br><span class="line">sbit led = P2^<span class="number">0</span>;       <span class="comment">//写代码用的测试口，keil这玩意又不能像其他编译器，输出个东西看看程序执行的怎么样，只能通过灯的亮灭进行判断了。</span></span><br><span class="line"><span class="comment">/***************定义全局变量******************/</span></span><br><span class="line">uchar table1[] = <span class="string">"Distance:"</span>;     <span class="comment">//1602显示</span></span><br><span class="line">uchar table2[] = <span class="string">"cm"</span>;</span><br><span class="line">uchar table3[] = <span class="string">"Tracing"</span>;      <span class="comment">//寻迹显示</span></span><br><span class="line">uchar flag_ula;                  <span class="comment">//超声波接收标志</span></span><br><span class="line"><span class="keyword">float</span> distance;                  <span class="comment">//计算距离</span></span><br><span class="line"><span class="comment">/****************函数声明******************/</span></span><br><span class="line"><span class="comment">/***********************延时类函数***********************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delayms</span><span class="params">(uint x)</span>           <span class="comment">//延时一毫秒      </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint a, b;</span><br><span class="line">    <span class="keyword">for</span>(a = x; a &gt; <span class="number">0</span>; a--)</span><br><span class="line">        <span class="keyword">for</span>(b = <span class="number">110</span>; b &gt; <span class="number">0</span>; b--); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay10us</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> i)</span>  <span class="comment">//延时10微秒</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> j; </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123; </span><br><span class="line">        j = <span class="number">10</span>; </span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123; </span><br><span class="line">            _nop_(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(--j); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(--i); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/***************初始化中断************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">init_T0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TMOD = <span class="number">0x01</span>;</span><br><span class="line">    TH0 = <span class="number">0</span>;          </span><br><span class="line">    TL0 = <span class="number">0</span>;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    IT0 = <span class="number">1</span>;       <span class="comment">//设置电平引发中断，与echo对应</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***************测量距离******************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">meas_distance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">        trig = <span class="number">0</span>;</span><br><span class="line">        Delay10us(<span class="number">2</span>);                <span class="comment">//给至少20微秒的延时，说明书这么说的，进而检测echo的电平</span></span><br><span class="line">        trig = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (trig == <span class="number">1</span>)               <span class="comment">//确认一下，不然代码到处可能是bug</span></span><br><span class="line">        &#123;</span><br><span class="line">            trig = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(trig == <span class="number">0</span>)            <span class="comment">//感觉多此一举了</span></span><br><span class="line">            &#123;</span><br><span class="line">                TR0 = <span class="number">1</span>;             <span class="comment">//开启中断了</span></span><br><span class="line">                EX0 = <span class="number">1</span>;             <span class="comment">//中断中计算距离</span></span><br><span class="line">                Delayms(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span>(flag_ula == <span class="number">1</span>)    <span class="comment">//测量成功的标志</span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag_ula = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***************利用中断计算距离*****************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time1</span><span class="params">()</span> interrupt 0   <span class="comment">// </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    TR0 = <span class="number">0</span>;                  <span class="comment">//一旦受到下降沿，立马停止定时器计数</span></span><br><span class="line">    distance = (TH0 * <span class="number">256</span> + TL0) * <span class="number">1.09</span> / <span class="number">58</span> - <span class="number">8</span>; <span class="comment">//先取出定时器里的时间值，之后再将定时器置0  </span></span><br><span class="line">    flag_ula = <span class="number">1</span>;<span class="comment">//将标志位置0  </span></span><br><span class="line">    TH0 = <span class="number">0</span>;  </span><br><span class="line">    TL0 = <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把距离写入液晶</span></span><br><span class="line"><span class="comment">/********************1602类**************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P0 = <span class="number">0xff</span>;                  <span class="comment">//判断液晶是否繁忙，繁忙不能写数据的</span></span><br><span class="line">    rs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(state == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        lcden = <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_com</span><span class="params">(uchar com)</span>       <span class="comment">//操作写命令的指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wait();</span><br><span class="line">    rs = <span class="number">0</span>;</span><br><span class="line">    P0 = com;</span><br><span class="line">    lcden = <span class="number">0</span>;</span><br><span class="line">    Delayms(<span class="number">10</span>);</span><br><span class="line">    lcden = <span class="number">1</span>;</span><br><span class="line">    Delayms(<span class="number">10</span>);</span><br><span class="line">    lcden = <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_date</span><span class="params">(uchar date)</span>     <span class="comment">//写入数据，数据送P0口</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wait();</span><br><span class="line">    rs = <span class="number">1</span>;</span><br><span class="line">    P0 = date;</span><br><span class="line">    Delayms(<span class="number">10</span>);</span><br><span class="line">    lcden = <span class="number">1</span>;</span><br><span class="line">    Delayms(<span class="number">10</span>);</span><br><span class="line">    lcden = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init1602</span><span class="params">()</span>                <span class="comment">//初始化1602</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wait();</span><br><span class="line">    lcden = <span class="number">0</span>;</span><br><span class="line">    write_com(<span class="number">0x38</span>);           <span class="comment">//这些命令就参考相关书籍了，我也背不过，都是抄的书</span></span><br><span class="line">    Delayms(<span class="number">10</span>);</span><br><span class="line">    write_com(<span class="number">0x0c</span>);</span><br><span class="line">    Delayms(<span class="number">10</span>);</span><br><span class="line">    write_com(<span class="number">0x06</span>);</span><br><span class="line">    Delayms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">float</span> dis)</span>                     <span class="comment">//1602写距离，还不显示</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> dis1 = dis;</span><br><span class="line">    uchar  bai, shi, ge, p1, p2;</span><br><span class="line">    bai = (dis1 / <span class="number">100</span>);                          <span class="comment">//浮点不能取模运算，浮点模运算keil会报错</span></span><br><span class="line">    shi = (dis1 - bai * <span class="number">100</span>) / <span class="number">10</span>;  </span><br><span class="line">    ge = dis1 - bai * <span class="number">100</span>-shi * <span class="number">10</span>;</span><br><span class="line">    p1 = (dis1 * <span class="number">10</span>) - bai * <span class="number">1000</span> - shi * <span class="number">100</span> - ge * <span class="number">10</span>;  </span><br><span class="line">    p2 = (dis1 * <span class="number">100</span>) - bai * <span class="number">10000</span> - shi * <span class="number">1000</span> - ge * <span class="number">100</span> - p1 * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    write_date(<span class="number">0x30</span> + bai);<span class="comment">//将数字转换为字符，必须+0x30，</span></span><br><span class="line">    Delay10us(<span class="number">10</span>); </span><br><span class="line">    write_date(<span class="number">0x30</span> + shi);<span class="comment">//另外，1602液晶只能接收字符型的数据   </span></span><br><span class="line">    Delay10us(<span class="number">10</span>);         <span class="comment">//写入数据后稍微延时，等待液晶稳定</span></span><br><span class="line">    write_date(<span class="number">0x30</span> + ge);</span><br><span class="line">    Delay10us(<span class="number">10</span>);  </span><br><span class="line">    write_date(<span class="string">'.'</span>);</span><br><span class="line">    Delay10us(<span class="number">10</span>);  </span><br><span class="line">    write_date(<span class="number">0x30</span> + p1);</span><br><span class="line">    Delay10us(<span class="number">10</span>);  </span><br><span class="line">    write_date(<span class="number">0x30</span> + p2);</span><br><span class="line">    Delay10us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span>                            <span class="comment">//1602的最终显示</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar a;</span><br><span class="line">    init1602();</span><br><span class="line"></span><br><span class="line">    write_com(<span class="number">0x80</span>);     <span class="comment">//设置地址，在第一行第一列显示distance：，0x80是第一行的起始地址 </span></span><br><span class="line">    Delayms(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(a = <span class="number">0</span>; a &lt; <span class="number">9</span>; a++)          <span class="comment">//写distance</span></span><br><span class="line">    &#123;</span><br><span class="line">        write_date(table1[a]);</span><br><span class="line">        Delayms(<span class="number">5</span>);     </span><br><span class="line">    &#125;</span><br><span class="line">    write_com(<span class="number">0x80</span> + <span class="number">0x40</span> + <span class="number">6</span>);<span class="comment">//设置地址，在第二行第7位显示cm，0x80+0x40是第二行的起始地址  </span></span><br><span class="line">    <span class="keyword">for</span>(a = <span class="number">0</span>; a &lt; <span class="number">2</span>; a++)        <span class="comment">//写“cm”</span></span><br><span class="line">    &#123;</span><br><span class="line">        write_date(table2[a]);</span><br><span class="line">        Delayms(<span class="number">5</span>);     </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//之前这里有死循环，没错我故意的，防止不断的刷新，以及子函数计算距离进入死循环。后来把死循环放到了主函数没，之前遇到了这个bug。</span></span><br><span class="line"></span><br><span class="line">        init_T0();   <span class="comment">//因此在显示子函数中测量距离，并显示，设置子函数中完成所有的死循环。</span></span><br><span class="line">        Delayms(<span class="number">1</span>);</span><br><span class="line">        meas_distance();</span><br><span class="line">        write_com(<span class="number">0x80</span> + <span class="number">0x40</span>); </span><br><span class="line">        Delayms(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">display</span>(distance);</span><br><span class="line">        Delayms(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************主函数****************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        init_T0();    <span class="comment">//初始化后进入show函数的死循环，然后就可以了</span></span><br><span class="line">        show();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
]]></content>
      <tags>
        <tag>microcomputer</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统『五』：CPU 上下文切换</title>
    <url>/2021/04/16/CPU-context-switch/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>进程 CPU 调度和资源分配的单位，是一个程序在一个数据集上的一次执行；线程是CPU上运行和调度的基本执行单位，进程内的一个代码片段可创建为线程，线程由进程创建，寄生在进程身上。</p>
<p>CPU 从一个<strong>任务</strong>切换到另一个<strong>任务</strong>，俗称上下文切换。理论上而言，进程负载了程序运行所有内容，开销较大。线程较轻量，和父进程共享各类资源，上下文切换的成本较低。可实际情况中具体如何？今天一探究竟。</p>
<a id="more"></a>
<h1 id="多任务系统与上下文切换"><a href="#多任务系统与上下文切换" class="headerlink" title="多任务系统与上下文切换"></a>多任务系统与上下文切换</h1><p>我们都知道，现代操作系统是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时间内，将 CPU 轮流分配给它们，每秒可能发生几百次上下文切换，造成多任务同时运行的错觉。</p>
<p>其中上下文的意思是指：某一时刻，寄存器内的数据和程序计数器的值；寄存器保留了CPU的指令，程序计数器表明了指令所在的地址，即当前指令之后立即执行的指令的地址。它们都是 CPU 在运行任何任务前，必须的依赖环境。</p>
<p>而在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好 CPU 寄存器和程序计数器，也就是上下文。涉及到具体的切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的位置，运行新任务。而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p>
<p>从上面的描述中可以知道，CPU 上下文切换无非就是更新了一些寄存器的值嘛，但这些寄存器，本身就是为了快速运行任务而设计的，为什么会影响系统的性能呢？在回答这个问题前，先得搞清楚操作系统管理的这些『任务』到底是什么呢？</p>
<p>进程和线程正是最常见的任务。但是除此之外，硬件通过触发信号，会导致中断处理程序的调用，也是一种常见的任务。所以，根据任务的不同，CPU上下文切换可分为几种场景：</p>
<ul>
<li>进程上下文切换</li>
<li>线程上下文切换</li>
<li>中断上下文切换</li>
<li>系统调用上下文切换</li>
</ul>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>现代操作系统按照特权等级，把进程的运行空间分为内核空间和用户空间，内核模式运行特权指令，用户程序在用户模式执行，主要是为了保护系统不受一些故障程序的影响。进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</p>
<p>因为特权指令只能在内核模式下运行，所以无法在用户模式运行特权指令。只能在用户模式下发出特权指令的系统调用，此时用户程序暂停，转换为内核模式执行系统调用，得到结果反馈给用户，在转换为用户模式，进程继续执行。具体流程为：</p>
<ol>
<li>保存 CPU 寄存器里原来用户态的指令位</li>
<li>为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。</li>
<li>跳转到内核态运行内核任务。</li>
<li>当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。</li>
</ol>
<p>所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。（用户态 <code>-&gt;</code> 内核态 <code>-&gt;</code> 用户态）</p>
<p>不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用过程中一直是同一个进程在运行。所以，系统调用过程通常称为特权模式切换，而不是上下文切换，系统调用属于同进程内的 CPU 上下文切换。</p>
<h1 id="进程上下文切换与系统调用"><a href="#进程上下文切换与系统调用" class="headerlink" title="进程上下文切换与系统调用"></a>进程上下文切换与系统调用</h1><p>首先，进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了内核堆栈、寄存器等内核空间的状态，还包括了虚拟内存、栈、全局变量等用户空间的资源。</p>
<p>因此，进程的上下文切换就比系统调用时多了一步：在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。如下图所示，保存上下文和恢复上下文的过程开销是很大的，此外，考虑到进程之间的相互的保护，只有操作系统能操作其它进程和了解其它进程的状态，因此这个过程需要在内核态完成。</p>
<p><img data-src="https://z3.ax1x.com/2021/04/16/chAMcR.png" alt></p>
<p>另外，我们知道，现代操作系统通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。如果发生运行时动态链接（进入系统态）、内存紧缩等情况，即虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢，不过这是进程上下文切换带来的副作用了。</p>
<p>发生进程上下文切换的场景</p>
<ol>
<li>基于时间片的操作系统，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。</li>
<li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</li>
<li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</li>
<li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</li>
<li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li>
</ol>
<h1 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h1><p>线程与进程最大的区别在于：线程是调度的基本单位，而进程则是资源拥有的基本单位。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p>
<p>发生线程上下文切换的场景：</p>
<ul>
<li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。切换线程，CPU 的各种寄存器都要重新刷一遍，从这个角度而言，你可以把进程和线程当作一种东西，只是共享度不同，其他没区别的。</li>
<li>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，内存命中率会高一些，只需要切换线程的私有数据、寄存器等不共享的数据。</li>
</ul>
<p>虽然同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源，这也正是多线程代替多进程的一个优势。</p>
<h1 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h1><p>中断处理程序运行于内核态。中断发生时CPU可能处于内核态（如执行系统调用的过程中）也可能处于用户态（执行应用空间代码）。所以前者不涉及特权级转换，后者涉及。</p>
<p>不涉及特权级转换的情况：</p>
<ul>
<li>压入寄存器现场、错误代码等</li>
<li>执行中断处理程序</li>
<li>恢复寄存器现场</li>
</ul>
<p>可以看到这里并没有发生堆栈的切换——因为本来就运行在内核栈上嘛！中断处理程序借用了应用程序的内核栈。说『借用』是因为进程的内核栈是给进程执行内核空间代码使用的（通常就是系统调用），由于中断并不一定和正在运行的进程有什么关联。</p>
<p>但是对于后者，也就是用户态中被中断，有一个用户 <code>-&gt;</code> 内核 <code>-&gt;</code> 用户的切换过程，伴随着相关栈的切换。具体过程：</p>
<ul>
<li>找到内核栈</li>
<li>压入寄存器现场、错误代码</li>
<li>转入中断处理程序</li>
<li>恢复第二步保存的现场</li>
<li>切换换回用户栈</li>
</ul>
<p>为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件，如断电和设备损坏等。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p>
<p>中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。跟进程上下文不同，中断上下文切换的东西不需要涉及到用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源；只需在内核态记录：当前进程的寄存器和程序计数器。如喜闻乐见的，硬盘传输文件时突然拔掉硬盘，传输文件进程的虚拟内存、全局变量等用户态资源都没有被保存，相当于白传输了。<del>例子有点生硬。</del></p>
<p>由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。另外，跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能。所以，当你发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。</p>
<h1 id="一些讨论"><a href="#一些讨论" class="headerlink" title="一些讨论"></a>一些讨论</h1><ul>
<li>CPU 上下文切换，是保证现代系统正常工作的核心功能之一，一般情况下不需要我们特别关注。根据 <a href="https://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html" target="_blank" rel="noopener">Tsuna</a> 的测试报告，每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。</li>
<li>CPU 执行的最小逻辑单元是线程，并不是一个 CPU 核心。所以切换进程，只是切换一个进程里的一个线程到另一个进程里的一个线程，说白了还是线程切换。如果对比的是单个进程和进程内线程的切换，线程共享资源，cache命中率会高很多；进程切换，不共享资源，cache命中率低。</li>
<li>上下文切换说的是 CPU 寄存器的切换，跟 cache 和内存没啥关系，后者只是上下文切换带来的副作用。也许你会有疑问，当切换到新的进程，进程所需的资源不在内存里，这不就开始调度了，调度的开销呢？但实际是，新建进程不会分配 CPU，进程就绪后等等待分配处理器，此时资源已经进内存了。</li>
<li>切换进程可能要刷 TLB，进程内线程切换不需要。进程切换要切页表，所以可能同时要刷 TLB，这个根据实现定。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://yang-docs.readthedocs.io/en/latest/linux/contextswitch.html" target="_blank" rel="noopener">本文大量参考，CPU切换</a></li>
<li><a href="https://whatis.techtarget.com/definition/context-switch" target="_blank" rel="noopener">什么是上下文</a></li>
<li><a href="https://freemandealer.github.io/2015/07/14/context-switch/" target="_blank" rel="noopener">中断上下文</a></li>
</ol>
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>一份不太简短的LaTeX简介</title>
    <url>/2018/11/07/Brief-introduction-to-LaTex/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我脑子不好使，有些代码不写一遍实在是记不住。<br>本文简述了$\LaTeX$的发展历史和使用方法，确切的说是使用方法，对历史我没有了解过，其实是我的$\LaTeX$速查笔记。<br>如果你想从这里面学习$\LaTeX$的操作，也不是不可以，涵盖了所有的基本操作～<br>后来有人提到：能不能整理Lshort这里面的MWE，我想想，把我之前学习时写过的代码整理一下是可以的，虽然不太全面，也欢迎大家补充或者有更好的方案。<br>但本文并不正规，你甚至能在里面发现几个错别字。</p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="收获与分享："><a href="#收获与分享：" class="headerlink" title="收获与分享："></a>收获与分享：</h2><blockquote>
<p>代码要多写</p>
<ul>
<li>代码这种东西，纸上得来终觉浅，学习 $\LaTeX$ 需要强大的耐心。只要你不是神仙，就多写代码，多犯错误。</li>
<li>新手一定不要直接套模板，第一报错不会改，第二不能按自己想要的要求改。先读文档，先读文档，读正规文档，磨刀不误砍柴工。</li>
<li>一定要读正规文档，谨慎考虑其他教育机构等（我看过里面的代码，已经过时）。</li>
<li>本文只是入门，$\LaTeX$博大精深，本文大概有 $\LaTeX$ 3%的内容，但是写论文足够。（应付建模，写科技论文等）</li>
<li>遇到问题不要百度，不要看CSDN的任何东西，这是自暴自弃的体现。这玩意发展很快，而且用这玩意的基本都是老师或者学生，他们学的很可能是几百年前的旧东西，不一定适用现在的情况。</li>
<li>遇到问题请用正规搜索引擎如bing而不是百度，并使用英文搜索，可以减少99%的麻烦。</li>
</ul>
</blockquote>
<p>关于 $\LaTeX$ 的文档有很多，其中有些内容过时地很快。所以有必要告诉大家，哪些文档应该看，那些文档不应该看。索性，这个问题，考虑到大家的英文水平，这里给出相对较好(我认为最好的)的中文教程：<br><a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf</a> 。我这种笨人的学习方法是：里面所有代码看三遍敲一遍，如果你够聪明，那么你会看得比我多，写的也比我多。</p>
<p>更为详细的宏包手册：Comprehensive $\TeX$ Archive Network（CTAN）， www.ctan.org  </p>
<p>不要无脑提问，多问多学、不懂就问这是中学时代落伍的想法。我们不排斥任何新手，但一上来就提很无脑的问题都很反感，什么是无脑的问题呢？就是能通过阅读教程很快就能解决的问题。</p>
<p>不会就问只会影响自己的探索能力和浪费别人的时间，手里有电脑能上网，学校图书馆有书，自己先去探索，别人的时间就不是时间了？学的是解决问题的能力，而不是解决某个具体问题。遇到问题如何解决，比在别人的教导下会解决一个问题要来的实在。首先一定要阅读一份合适的文档，这样你能解决掉70%的问题。剩下的30%不常见的问题可以通过谷歌解决。</p>
<p>提问的智慧：提问题时，不要一味的说代码错了，你说一千遍代码还是错了。如果控制变量法解决不了问题。那么你要提供报错信息，提供你原来的代码（居然还有智障怕自己的论文被别人看而不提供代码，可能你的垃圾论文我也不想看，我也不会给这种自以为是的人改代码），提供MWE，说明操作系统，说明使用的发行版。正确提问，虚心请教，交流技术。不要拍照，又不是只有你有手机，请截图，拍照看不清。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><blockquote>
<p>第二次读Lshort了，也有了新的收获。第一次读时观其大概，些许内容选择了跳过，为了赶deadline只求快速上手能用，重点放在了如何实现想要的排版。第二次读，更加关注其中的细节。</p>
<p>之前有人在群里说道能不能提供每个章节的MWE，正好，我可以试试。因为第一次学习时里面的代码我都敲过一次，这次来整理一下。（暂时先放到博客，不准备放到github）</p>
</blockquote>
<hr>
<h1 id="前期了解"><a href="#前期了解" class="headerlink" title="前期了解"></a>前期了解</h1><p>$\LaTeX$ 是一个文档准备系统，是一种格式，排版引擎为 $\TeX$ ，跨平台，稳定，支持多语言排版。 </p>
<p>$\LaTeX$ 中的命令以反斜线开头（回车键上方），大小写敏感。命令可以接受一些参数，可选参数在方括号[]中，必须参数在花括号内{}。</p>
<p>$\LaTeX$ 中的环境在<code>\begin{name}</code>和<code>\end{name}</code>之中包裹，部分环境可以嵌套使用。有些命令会产生全局作用，比如<code>\centering</code>。若要限制作用范围，可以将命令限制在一对花括号内，不会影响下文。如<code>{\centering test \par}</code>。</p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>现在使用的 TeX 的排版引擎<a href="https://mirrors.tuna.tsinghua.edu.cn/#" target="_blank" rel="noopener">点我下载</a>发布于1982年，稳定、跨平台、几乎没有BUG。 $\LaTeX$ 依赖的 $\TeX$ 排版引擎和其他软件完全开源免费，而且各种跨平台。WinEdt违背了开源的观念，所以更多的推荐使用Latex Studio。<a href="http://texstudio.sourceforge.net/" target="_blank" rel="noopener">点我下载</a>。当然，如果你是个写代码的高手，自然会使用其他的编辑器，如sublime，vscode。我就没必要多此一举的给这些软件的安装包了，毕竟你是写代码的高手。</p>
<h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[options]</span><span class="string">&#123;...&#125;</span></span> <span class="comment">% 指定文档类别</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;&#125;</span></span> <span class="comment">% 导言区，调用宏包和全局设置</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span> <span class="comment">% 开始写文档</span></span><br><span class="line">	hello world</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>文档类别由<code>documentclass</code>指定，包括article（科技论文、报告、说明文档），report（长篇论文，比如硕博论文），book（书籍），ctexart（支持中文的article的派生类），beamer（PPT）等，规定了生成文档的性质。</p>
<p>options可以全局规定包括字号（默认10pt）、公式与编号对齐方式（<code>fleqn</code>，<code>leqno</code>）、双栏排版、纸张类型、横纵排版、草稿模式等排版元素。常用：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[11pt,a4paper]</span><span class="string">&#123;ctexart&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><code>\usepackage{}</code> 中调用的宏包用于扩展和增强 $\LaTeX$ 。宏包内定义了环境和命令，查阅方式为命令行内：<code>texdoc yourfilename</code>。</p>
<h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>$\LaTeX$ 在编译中除了生成最终的pdf文件外，还会在同目录下生成辅助文件和日志，如<code>log</code>是日志记录文件，<code>aux</code>是记录交叉引用，<code>bbl</code>记录参考文献，一些特殊的功能如交叉引用需要编译生成辅助文件，再次编译读入辅助文件得到正确的结果，如：编译两次才能生成目录。</p>
<p>所以，没必要删除辅助性文件。当一份正确的代码无法编译过去时，可以尝试删除其中的<code>aux</code>文件。（一个简单的经验，不一定通用）</p>
<h2 id="组织多个文件"><a href="#组织多个文件" class="headerlink" title="组织多个文件"></a>组织多个文件</h2><p>脑补在写代码的过程中会将代码分为多个文件， $\LaTeX$ 也不例外。如在写毕业论文时，可以分为多个文件。使用<code>inlcude{filename}</code>来插入。但是<code>include</code>会另起一页，不如使用<code>\input</code>将文件里的内容插入。具体如下（两者在相同目录）：</p>
<p>MWE.tex<br><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">input</span><span class="string">&#123;MWE1.tex&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>MWE1.tex<br><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">section</span><span class="string">&#123;test&#125;</span></span></span><br><span class="line"></span><br><span class="line">hello <span class="tag">\<span class="name">LaTeX</span></span></span><br></pre></td></tr></table></figure></p>
<p>效果如下：</p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/32.png" alt></p>
<h1 id="命令、引擎、格式"><a href="#命令、引擎、格式" class="headerlink" title="命令、引擎、格式"></a>命令、引擎、格式</h1><p>通俗理解：引擎是编译器，将源程序翻译为二进制，CPU执行二进制机器代码输出最后的pdf文件。格式是定义命令的代码集合，命令是实际调用编译和格式的总和，调用引擎，分析格式，最终编译代码生成文档。中文排版推荐<code>xelatex</code>命令（结合了 <code>XeTeX</code> 引擎和 $\LaTeX$ 格式），支持系统预装字体（ttf）和支持UTF8编码。</p>
<hr>
<h1 id="排版中文"><a href="#排版中文" class="headerlink" title="排版中文"></a>排版中文</h1><blockquote>
<p>警告：此处开始会有图片，图片的源代码在图片的下方，两者结合观看效果更加。</p>
</blockquote>
<p>CCT、CJK退出历史舞台，如果不是被老师强迫，就不要再用了。<br>建议源代码的编码方式为UTF8（一到四个字节的可变长编码，支持各国语言，也就支持中文），xelatex命令原生支持UTF8编码，本文内容均使用UTF8编码，xelatex命令编译。</p>
<p>xeCJK宏包完善了排版中文的细节，可以简单的配置中文字体，支持简单命令配置中文字体。以下的代码只是设置中文而不是汉化：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;xeCJK&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">setCJKmainfont</span><span class="string">&#123;SimSun&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	中文</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>ctex宏包和文档类是对xeCJK的进一步封装，ctex文档类中包括ctexart（封装了标准文档类article），符合中文的排版习惯，如英文的排版习惯中，章节第一段不缩进，不符合中文的排版习惯。<code>UTF-8</code>编码下<code>xelatex</code>配合<code>xeCJK</code>或者<code>ctex</code>宏包的方式成为目前主流的中文排版方式。<br>于是上面代码何以简化为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;ctex&#125;</span></span> <span class="comment">% 进一步封装xeCJK</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	中文</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>也许感觉上述代码多此一举，但它确实有用。比如在使用国外大学写的<code>beamer</code>(一种ppt模板)时，发现无法显示中文，<code>\usepackage{ctex}</code>就是一个在国外的文档类中显示中文的很好的方法。（我只是测试过能用，好不好的就不了解）。也可以简化为（并不等价，只是都能显示中文）</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span> <span class="comment">% 彻底的汉化，包括文字</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	中文</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>多个空格为一个空格，一行开头的空格忽略不计，一个回车视为一个空格，多个回车视为分段。</li>
<li>\par命令也为分段，{}表示不要忽略后面的一个空格。</li>
<li>%表示注释，Ctrl+T多行注释，Ctrl+U取消多行注释。（仅限texstudio编辑器，matlab也是这个快捷键）</li>
<li>特殊字符用反斜杠\\转义反斜杠为：`\textbackslash’。</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	中文<span class="tag">\<span class="name">par</span></span>  <span class="comment">%此处分段</span></span><br><span class="line">	测试</span><br><span class="line">  <span class="tag">\<span class="name">TeX</span><span class="string">&#123;&#125;</span></span> users <span class="comment">% 取消花括号也会取消空格</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>连字处理，引号，破折号，省略号，波浪号，文字强调，间距。talk is cheap,show me your code。看下效果，这个图片里的内容是“文档”，代码提供参考。</p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/1.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;ulem&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	中文<span class="tag">\<span class="name">par</span></span>     <span class="comment">% 分段</span></span><br><span class="line">	        测试   <span class="comment">% 段落开始的空格无用</span></span><br><span class="line">	<span class="tag">\<span class="name">TeX</span><span class="string">&#123;&#125;</span></span> users</span><br><span class="line"></span><br><span class="line">	连字处理，看两个f之间的距离：different <span class="tag">\<span class="name">quad</span></span> dif&#123;&#125;f&#123;&#125;erent</span><br><span class="line"></span><br><span class="line">	引号：``单引号为`英文'双引号的左引号为键盘ESC下面那个"</span><br><span class="line"></span><br><span class="line">	连字符：X-input，范围：13--67, 破折号：孔夫子搬家---全是输  <span class="comment">% 注意个数不一样</span></span><br><span class="line"></span><br><span class="line">	省略号：1,2,3, <span class="tag">\<span class="name">dots</span></span> ,4,5,6 <span class="tag">\<span class="name">ldots</span></span> <span class="comment">% 两者相同</span></span><br><span class="line"></span><br><span class="line">    西文很少用波浪号：1<span class="tag">\<span class="name">~</span><span class="string">&#123;&#125;</span></span>2,<span class="tag">\<span class="name">quad</span></span> <span class="formula">$1<span class="tag">\<span class="name">sim</span></span> 2$</span> 。更多符号由特定宏包支持。</span><br><span class="line">    </span><br><span class="line">    have a <span class="tag">\<span class="name">emph</span><span class="string">&#123;emphasize in latex \emph&#123;environment&#125;</span></span>&#125;  <span class="comment">% 注意字体的变化</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">\<span class="name">uline</span><span class="string">&#123;下划线推荐使用ulem宏包的\textbackslash uline命令。&#125;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">LaTeX</span></span> 的空格和断行是自动调整的，尽可能使行距一致，单词间距匀称。在合适位置断页，尽量在两个单词之间断行。</span><br><span class="line">    加波浪号<span class="tag">\<span class="name">~</span><span class="string">&#123;&#125;</span></span>会产生不会产生断行的微小空格Fig.~2a 。<span class="tag">\<span class="name">\</span><span class="string">[6pt]</span></span>    <span class="comment">% 强行调换行的间距， </span></span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">textbackslash</span></span> <span class="tag">\<span class="name">textbackslash</span></span> *[6pt] 带有星号表示断行处禁止分页。换行时，<span class="tag">\<span class="name">textbackslash</span></span> newline 只能用于文本段落，</span><br><span class="line">    <span class="tag">\<span class="name">textbackslash</span></span> <span class="tag">\<span class="name">textbackslash</span></span> 可以用于表格、公式等环境的分段。&#123;<span class="tag">\<span class="name">textbackslash</span></span> newpage&#125;表示断页，或者另起一栏。</span><br><span class="line"></span><br><span class="line">    <span class="tag">\<span class="name">textbackslash</span></span> -指定英文断词位置，当然断词的前提是一行站不下了。muyu0223@outl<span class="tag">\<span class="name">-</span></span>ook.com</span><br><span class="line">    </span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="LaTeX大杀器——数学公式"><a href="#LaTeX大杀器——数学公式" class="headerlink" title="LaTeX大杀器——数学公式"></a>LaTeX大杀器——数学公式</h1><p>依赖宏包：amsmath，由美国数学学会American Mathematical Society提供，支持常见的<code>\notag</code>, <code>eqref</code>操作，主要内容：行内公式、行间公式、编号、特殊符号、多行公式、矩阵、定理。内容太多，分批来吧。</p>
<h2 id="行内公式、行间公式、编号、引用"><a href="#行内公式、行间公式、编号、引用" class="headerlink" title="行内公式、行间公式、编号、引用"></a>行内公式、行间公式、编号、引用</h2><p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/2.png" alt><br><img data-src="/2018/11/07/Brief-introduction-to-LaTex/2-1.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[fleqn]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">进入数学模式，行内公式：<span class="formula">$a+b=c$</span>，与文字混排。</span><br><span class="line"></span><br><span class="line">行间公式：<span class="formula">$$a^2+b^2=c^2$$</span></span><br><span class="line"></span><br><span class="line">编号与引用：</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">lim</span></span>_&#123;n <span class="tag">\<span class="name">to</span></span> <span class="tag">\<span class="name">infty</span></span>&#125;<span class="tag">\<span class="name">sum</span></span>_&#123;k=1&#125;^&#123;n&#125;<span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;k^2&#125;</span>=</span><span class="tag">\<span class="name">frac</span><span class="string">&#123;\pi ^2&#125;</span><span class="string">&#123;6&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">label</span><span class="string">&#123;eq1&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line"></span><br><span class="line">根据<span class="tag">\<span class="name">eqref</span><span class="string">&#123;eq1&#125;</span></span>，我们blablabla<span class="tag">\<span class="name">ref</span><span class="string">&#123;eq1&#125;</span></span>，两种引用方式的区别。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">int</span></span>_&#123;0&#125;^&#123;<span class="tag">\<span class="name">frac</span><span class="string">&#123;\pi&#125;</span><span class="string">&#123;2&#125;</span></span>&#125; f''(x)<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;d&#125;</span></span>x=1<span class="tag">\<span class="name">tag</span><span class="string">&#123;3&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">int</span></span>_&#123;0&#125;^&#123;<span class="tag">\<span class="name">frac</span><span class="string">&#123;\pi&#125;</span><span class="string">&#123;2&#125;</span></span>&#125; f''(x)<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;d&#125;</span></span>x=1<span class="tag">\<span class="name">notag</span></span></span><br><span class="line">  <span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line"></span><br><span class="line">不设置tag默认顺序编号，也可以用<span class="tag">\<span class="name">textbackslash</span></span> notag 取消编号的显示。</span><br><span class="line">设置了的话可以改变公式的编号。微分的<span class="formula">$<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;d&#125;</span></span>$</span>是正体，不是这个<span class="formula">$d$</span>。</span><br><span class="line"></span><br><span class="line">三种不同的行间公式实现方式 equation* ,displaymath 和  <span class="tag">\<span class="name">textbackslash</span></span> [   <span class="tag">\<span class="name">textbackslash</span></span> ]</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation*&#125;</span></span></span><br><span class="line">  f(x) + b</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation*&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">[</span></span></span><br><span class="line">  f(x) + b</span><br><span class="line"><span class="tag">\<span class="name">]</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;displaymath&#125;</span></span></span><br><span class="line">  f(x) + b</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;displaymath&#125;</span></span></span><br><span class="line">继续：<span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">&#123;3&#125;</span><span class="string">&#123;4&#125;</span></span>$</span>, <span class="formula">$<span class="tag">\<span class="name">displaystyle</span><span class="string">&#123;\frac&#123;3&#125;</span><span class="string">&#123;4&#125;</span></span>&#125;$</span> <span class="tag">\<span class="name">quad</span></span> <span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">[n]</span><span class="string">&#123;x^2+y^2&#125;</span></span>$</span>,<span class="tag">\<span class="name">quad</span></span> <span class="formula">$<span class="tag">\<span class="name">sum</span></span>_&#123;1&#125;^&#123;n&#125;$</span>，</span><br><span class="line">求和的这个在行内公式和行间公式不一样，看<span class="tag">\<span class="name">eqref</span><span class="string">&#123;eq1&#125;</span></span>。</span><br><span class="line">当然强行更改也可以：<span class="formula">$<span class="tag">\<span class="name">sum</span></span><span class="tag">\<span class="name">limits</span></span>_&#123;1&#125;^&#123;n&#125;$</span>。向量：<span class="formula">$<span class="tag">\<span class="name">vec</span><span class="string">&#123;a&#125;</span></span>_1$</span><span class="formula">$<span class="tag">\<span class="name">vec</span><span class="string">&#123;a_1&#125;</span></span>$</span>。</span><br><span class="line"></span><br><span class="line">不推荐使用四个<span class="tag">\<span class="name">$</span></span>符号输入行间公式，因为无法指定fleqn选项设置左对齐，不信看上文。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>行间公式不能用两个斜杠换行，多行公式应该用特殊的环境。</p>
</blockquote>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><ul>
<li>间距调整</li>
<li>数学模式插入文字</li>
<li>常用数学符号，定界符，箭头，巨算符等</li>
</ul>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/100.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">数学模式中几种调节间距的方式， 无法使用单纯的空格产生距离。</span><br><span class="line"></span><br><span class="line"><span class="formula">$$ax+b<span class="tag">\<span class="name">quad</span></span> ax+b$$</span></span><br><span class="line"><span class="formula">$$ax+b<span class="tag">\<span class="name">qquad</span></span> ax+b$$</span></span><br><span class="line"><span class="formula">$$ax+b<span class="tag">\<span class="name">,</span></span> ax+b$$</span></span><br><span class="line"><span class="formula">$$ax+b<span class="tag">\<span class="name">:</span></span> ax+b$$</span></span><br><span class="line"><span class="formula">$$ax+b<span class="tag">\<span class="name">;</span></span> ax+b$$</span></span><br><span class="line"><span class="formula">$$ax+b<span class="tag">\<span class="name">!</span></span> ax+b$$</span></span><br><span class="line"></span><br><span class="line">两种省略号：<span class="formula">$a_1, a_2, a_3, <span class="tag">\<span class="name">dots</span></span>, a_n, <span class="tag">\<span class="name">ldots</span></span>$</span>, <span class="formula">$a_1+a_2+a_3+<span class="tag">\<span class="name">cdots</span></span>+a_n$</span>, 前两种用于数学或者文本均可。</span><br><span class="line"></span><br><span class="line"><span class="formula">$f(x)=x^3 <span class="tag">\<span class="name">Longrightarrow</span></span> f'(x)=3x^2 <span class="tag">\<span class="name">Longrightarrow</span></span> f''(x)=6x <span class="tag">\<span class="name">Longrightarrow</span></span> f'(x)=<span class="tag">\<span class="name">frac</span><span class="string">&#123;\mathrm&#123;d&#125;</span></span>y&#125;&#123;<span class="tag">\<span class="name">mathrm</span><span class="string">&#123;d&#125;</span></span>x&#125; $</span>. </span><br><span class="line"><span class="formula">$x^2 <span class="tag">\<span class="name">geq</span></span> 0 <span class="tag">\<span class="name">text</span><span class="string">&#123; when &#125;</span></span> x=2$</span> 数学环境中插入文字，与文字环境中插入数学公式是两种不同的东西，切不可滥用。如<span class="formula">$<span class="tag">\<span class="name">text</span><span class="string">&#123;假设</span></span></span></span><br><span class="line"><span class="formula"><span class="tag"><span class="string">曲线上一点&#125;</span></span>x$</span>，就是不合理的行为。</span><br><span class="line"></span><br><span class="line">分数的不同表现形式：</span><br><span class="line"></span><br><span class="line">行内：3/8, <span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">&#123;3&#125;</span><span class="string">&#123;8&#125;</span></span>$</span>, <span class="formula">$<span class="tag">\<span class="name">dfrac</span><span class="string">&#123;3&#125;</span><span class="string">&#123;8&#125;</span></span>$</span>, <span class="formula">$<span class="tag">\<span class="name">tfrac</span><span class="string">&#123;3&#125;</span><span class="string">&#123;8&#125;</span></span>$</span> <span class="formula">$<span class="tag">\<span class="name">displaystyle</span><span class="string">&#123;\frac&#123;3&#125;</span><span class="string">&#123;8&#125;</span></span>&#125;$</span></span><br><span class="line"></span><br><span class="line">行间</span><br><span class="line"></span><br><span class="line"><span class="formula">$$3/8 <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">frac</span><span class="string">&#123;3&#125;</span><span class="string">&#123;8&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">dfrac</span><span class="string">&#123;3&#125;</span><span class="string">&#123;8&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">tfrac</span><span class="string">&#123;3&#125;</span><span class="string">&#123;8&#125;</span></span>$$</span></span><br><span class="line"></span><br><span class="line">公式符号的叠加<span class="formula">$g(x)<span class="tag">\<span class="name">stackrel</span><span class="string">&#123;*&#125;</span><span class="string">&#123;\approx&#125;</span></span>4x^3+3$</span>, 当然还有好多<span class="formula">$<span class="tag">\<span class="name">Delta</span></span>, <span class="tag">\<span class="name">div</span></span>, <span class="tag">\<span class="name">times</span></span>, <span class="tag">\<span class="name">mp</span></span>, <span class="tag">\<span class="name">pm</span></span>, <span class="tag">\<span class="name">Im</span></span>$</span> 用到的时候查阅相关</span><br><span class="line">资料即可。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/99.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amssymb&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">DeclareMathOperator</span><span class="string">&#123;\argh&#125;</span><span class="string">&#123;argh&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">也可以支持不同的小于号，后者需要amssymb宏包的支持。<span class="formula">$<span class="tag">\<span class="name">leq</span></span> <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">leqslant</span></span>$</span></span><br><span class="line"></span><br><span class="line">也可以使用DeclareMathOPerator自定义命令<span class="formula">$<span class="tag">\<span class="name">argh</span></span> abc$</span> (amsmath宏包支持).</span><br><span class="line">巨算符的大小和形状在行内和行间是有区别的，但也可以强行更改。</span><br><span class="line"></span><br><span class="line">行内：<span class="formula">$<span class="tag">\<span class="name">int</span></span>_0^1 <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">sum</span></span>_&#123;i=1&#125;^n <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">int</span></span><span class="tag">\<span class="name">limits</span></span>_0^1 <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">sum</span></span><span class="tag">\<span class="name">limits</span></span>_&#123;i=1&#125;^n$</span></span><br><span class="line"></span><br><span class="line">行间：<span class="formula">$$<span class="tag">\<span class="name">int</span></span>_0^1 <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">sum</span></span>_&#123;i=1&#125;^n <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">int</span></span><span class="tag">\<span class="name">nolimits</span></span>_0^1 <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">sum</span></span><span class="tag">\<span class="name">nolimits</span></span>_&#123;i=1&#125;^n$$</span></span><br><span class="line"></span><br><span class="line">公式下标上的表达式： <span class="formula">$<span class="tag">\<span class="name">displaystyle</span><span class="string">&#123;\sum_&#123;\substack&#123;i\to 0 \\ j \to \infty&#125;</span></span>&#125;P(i,j)=Q(n)&#125;$</span>。此外，subarray环境支持</span><br><span class="line">左对齐和居中对齐，但不支持右对齐。</span><br><span class="line"></span><br><span class="line"><span class="formula">$$<span class="tag">\<span class="name">sum</span></span>_&#123;<span class="tag">\<span class="name">begin</span><span class="string">&#123;subarray&#125;</span><span class="string">&#123;l&#125;</span></span></span></span><br><span class="line"><span class="formula">        i<span class="tag">\<span class="name">to</span></span> 0 <span class="tag">\<span class="name">\</span></span> j <span class="tag">\<span class="name">to</span></span> <span class="tag">\<span class="name">infty</span></span></span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">end</span><span class="string">&#123;subarray&#125;</span></span>&#125;</span></span><br><span class="line"><span class="formula">P(i,j)=Q(n)$$</span></span><br><span class="line"></span><br><span class="line"><span class="formula">$$<span class="tag">\<span class="name">sum</span></span>_&#123;<span class="tag">\<span class="name">begin</span><span class="string">&#123;subarray&#125;</span><span class="string">&#123;c&#125;</span></span></span></span><br><span class="line"><span class="formula">    i<span class="tag">\<span class="name">to</span></span> 0 <span class="tag">\<span class="name">\</span></span> j <span class="tag">\<span class="name">to</span></span> <span class="tag">\<span class="name">infty</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;subarray&#125;</span></span>&#125;</span></span><br><span class="line"><span class="formula">P(i,j)=Q(n)$$</span></span><br><span class="line"></span><br><span class="line">各种箭头：<span class="formula">$<span class="tag">\<span class="name">vec</span><span class="string">&#123;x&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">vec</span><span class="string">&#123;AB&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">overrightarrow</span><span class="string">&#123;AB&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> 0.<span class="tag">\<span class="name">overline</span><span class="string">&#123;3&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> </span></span><br><span class="line"><span class="formula">c<span class="tag">\<span class="name">xrightarrow</span><span class="string">[1+1]</span><span class="string">&#123;2+2+2+2+2+2+2&#125;</span></span>d$</span> </span><br><span class="line"></span><br><span class="line">overbrace 和 underbrace 命令生成上/下括号，自带上/下标的公式</span><br><span class="line"></span><br><span class="line"><span class="formula">$$<span class="tag">\<span class="name">underbrace</span><span class="string">&#123;\overbrace&#123;(1+2+3+4)&#125;</span></span>^&#123;10&#125; <span class="tag">\<span class="name">cdot</span></span> <span class="tag">\<span class="name">overbrace</span><span class="string">&#123;(5+6+7+8)&#125;</span></span>^&#123;26&#125;&#125;_<span class="tag">\<span class="name">text</span><span class="string">&#123;value&#125;</span>=<span class="number">260</span></span>$$</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h3><p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/98.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">几种常见的定界符  () [] <span class="tag">\<span class="name">&#123;</span></span><span class="tag">\<span class="name">&#125;</span></span> <span class="formula">$<span class="tag">\<span class="name">langle</span></span> <span class="tag">\<span class="name">rangle</span></span>$</span></span><br><span class="line"></span><br><span class="line">left和right是成对出现的定界符，大小根据公式的大小而变化。<span class="formula">$<span class="tag">\<span class="name">left</span></span>( ax+b <span class="tag">\<span class="name">right</span></span>) <span class="tag">\<span class="name">left</span></span>( <span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;9x-c&#125;</span></span> <span class="tag">\<span class="name">right</span></span>)$</span></span><br><span class="line"></span><br><span class="line">如果一方并不需要输入定界符，如左侧不需要，则需要写成left. <span class="formula">$<span class="tag">\<span class="name">left</span></span>. <span class="tag">\<span class="name">frac</span><span class="string">&#123;\partial y&#125;</span><span class="string">&#123;\partial x&#125;</span></span><span class="tag">\<span class="name">right</span></span>|_&#123;x=2&#125;$</span></span><br><span class="line"></span><br><span class="line">而用left和right分节符包裹的公式快不允许断行，所以不能在跨行公式内使用。如果执意要使用，需要使用<span class="tag">\<span class="name">textbackslash</span></span> big 等</span><br><span class="line">不必成对出现的定界符。(只有在输入左右括号的时候才需要输入 r l 表示左右的方位关键字)。</span><br><span class="line"></span><br><span class="line"><span class="formula">$$<span class="tag">\<span class="name">bigl</span></span>( <span class="tag">\<span class="name">Bigl</span></span>( <span class="tag">\<span class="name">biggl</span></span>( <span class="tag">\<span class="name">Biggl</span></span>( <span class="tag">\<span class="name">bigr</span></span><span class="tag">\<span class="name">&#125;</span></span> <span class="tag">\<span class="name">Big</span></span><span class="tag">\<span class="name">|</span></span> <span class="tag">\<span class="name">big</span></span><span class="tag">\<span class="name">|</span></span> <span class="tag">\<span class="name">Big</span></span><span class="tag">\<span class="name">|</span></span> $$</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="长公式与多行公式"><a href="#长公式与多行公式" class="headerlink" title="长公式与多行公式"></a>长公式与多行公式</h2><p>折行顺序：等号前 $\to$加减前 $\to$ 乘除前。此外</p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/3.png" alt></p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/4.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">最简单的是最丑的：</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;multline&#125;</span></span></span><br><span class="line">	a+b+c+d+e+f+g+h+i+k<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	=j+l+m+n+o+p+q<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	=r+s+t</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;multline&#125;</span></span></span><br><span class="line"></span><br><span class="line">限定对齐：<span class="tag">\<span class="name">textbackslash</span></span> tag 取消编号。</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;align&#125;</span></span></span><br><span class="line">	Y &amp;= a+b+c+d+e+f+g+h+i+k<span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">notag</span></span></span><br><span class="line">	  &amp;= j+l+m+n+o+p+q<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	  &amp;= r+s+t</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;align&#125;</span></span></span><br><span class="line"></span><br><span class="line">多组对齐：</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;align&#125;</span></span></span><br><span class="line">	a &amp;= ((x+1)(y-1))^2 &amp; c &amp;= <span class="tag">\<span class="name">epsilon</span></span><span class="tag">\<span class="name">\</span></span></span><br><span class="line">	b &amp;= <span class="tag">\<span class="name">Bigl</span></span>((x+1)(y-1)<span class="tag">\<span class="name">Bigr</span></span>)^2 &amp; d &amp;<span class="tag">\<span class="name">to</span></span> <span class="tag">\<span class="name">theta</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;align&#125;</span></span></span><br><span class="line"></span><br><span class="line">胡乱对齐：</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;gather&#125;</span></span></span><br><span class="line">	a<span class="tag">\<span class="name">stackrel</span><span class="string">&#123;*&#125;</span><span class="string">&#123;\approx&#125;</span></span>b<span class="tag">\<span class="name">mp</span></span> c<span class="tag">\<span class="name">\</span></span>d=e<span class="tag">\<span class="name">pm</span></span> f<span class="tag">\<span class="name">times</span></span> g<span class="tag">\<span class="name">\</span></span>h<span class="tag">\<span class="name">cdot</span></span> a=3<span class="tag">\<span class="name">div</span></span> 6</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;gather&#125;</span></span></span><br><span class="line"></span><br><span class="line">只有一个编号的对齐：</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;aligned&#125;</span></span></span><br><span class="line">Y &amp;= a+b+c+d+e+f+g+h+i+k<span class="tag">\<span class="name">\</span></span></span><br><span class="line">&amp;= j+l+m+n+o+p+q<span class="tag">\<span class="name">\</span></span></span><br><span class="line">&amp;= r+s+t</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;aligned&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="矩阵、分段函数、行列式"><a href="#矩阵、分段函数、行列式" class="headerlink" title="矩阵、分段函数、行列式"></a>矩阵、分段函数、行列式</h3><p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/5.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">特意翻了下线代书，这个叫矩阵：</span><br><span class="line"><span class="tag">\<span class="name">[</span></span><span class="tag">\<span class="name">mathbf</span><span class="string">&#123;X&#125;</span>=</span><span class="tag">\<span class="name">left</span></span>(</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;array&#125;</span><span class="string">&#123;cccc&#125;</span></span></span><br><span class="line">	x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; <span class="tag">\<span class="name">cdots</span></span> &amp; x_&#123;1n&#125;<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	<span class="tag">\<span class="name">vdots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> &amp; <span class="tag">\<span class="name">ddots</span></span>  &amp; x_&#123;nn&#125;<span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;array&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">right</span></span>)</span><br><span class="line"><span class="tag">\<span class="name">]</span></span></span><br><span class="line"></span><br><span class="line">分段函数：</span><br><span class="line"><span class="tag">\<span class="name">[</span></span> |x| =</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;cases&#125;</span></span></span><br><span class="line">-x &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;if&#125;</span></span> <span class="tag">\<span class="name">,</span></span>x &lt; 0,<span class="tag">\<span class="name">\</span></span></span><br><span class="line">x &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;if&#125;</span></span> <span class="tag">\<span class="name">,</span></span>x <span class="tag">\<span class="name">geq</span></span> 0. <span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;cases&#125;</span></span>  <span class="tag">\<span class="name">]</span></span></span><br><span class="line"></span><br><span class="line">行列式：</span><br><span class="line"><span class="tag">\<span class="name">[</span></span></span><br><span class="line"><span class="tag">\<span class="name">left</span></span>|<span class="tag">\<span class="name">begin</span><span class="string">&#123;array&#125;</span><span class="string">&#123;cccc&#125;</span></span></span><br><span class="line">1 &amp;    6    &amp; 9 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">7 &amp;    90   &amp; f(x)<span class="tag">\<span class="name">\</span></span></span><br><span class="line">9 &amp; <span class="tag">\<span class="name">psi</span></span>(x) &amp; g(x)</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;array&#125;</span></span><span class="tag">\<span class="name">right</span></span>|</span><br><span class="line"><span class="tag">\<span class="name">]</span></span></span><br><span class="line"></span><br><span class="line">另一种矩阵：</span><br><span class="line"><span class="tag">\<span class="name">[</span></span></span><br><span class="line"><span class="tag">\<span class="name">left</span><span class="string">[\begin&#123;array&#125;&#123;cccc&#125;</span></span></span><br><span class="line"><span class="tag"><span class="string">1 &amp;    6    &amp; 9 \\</span></span></span><br><span class="line"><span class="tag"><span class="string">7 &amp;    90   &amp; f(x)\\</span></span></span><br><span class="line"><span class="tag"><span class="string">9 &amp; \psi(x) &amp; g(x)</span></span></span><br><span class="line"><span class="tag"><span class="string">\end&#123;array&#125;\right]</span></span></span><br><span class="line"><span class="tag">\<span class="name">]</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>重点：数学公式中的排版。也许你用过mathtype这款软件，我在这里准备逼死一下强迫症，在mathtype里面选中数学符号，然后按Ctrl+ $\to$ ，还有Ctrl+shift+&gt;试试，公式位置被移动，大小被改变，刺不刺激。</p>
<p>有一款新的国产软件，叫Axmath，好像是浙江大学研发的，<a href="http://www.amyxun.com/" target="_blank" rel="noopener">点我下载</a>。2018年暑假购买的，用过一次，说实话，甩mathtype几条街，安装后word提供接口，支持mathtype格式输入和 LaTeX格式输入，能画图，也能画动图，但是个人感觉跟word的交互感不是很好，近期没有折腾过。</p>
<p>说到这里，还是提倡不要搞破解，以为破解是很技术的事，其实破解这种东西一点都不尊重别人的劳动成果，完全是在“偷鸡摸狗”。每个人都不希望自己的劳动成果被别人窃取，如果有一天发现自己努力的成果被别人窃取、贩卖、侮辱，自己是什么心情呢？所以，从自己做起，说好听的叫尊重别人的成果，说难听的叫积点阴德。所以，我是正儿八经的购买的Axmath，没有用所谓的破解。</p>
<p>我也提倡去购买，还有一个事，可以去办理edu邮箱，国外的好多软件很重视对学生的教育，如果你有edu邮箱，好多软件都会有优惠，甚至将近一折的优惠，甚至免费。比如jetbrains公司旗下的软件，python的IDE：pycharm，数据库的IDE：DataGrip等，如果有edu邮箱，这些东西完全免费。</p>
<h3 id="说正事：LaTeX中的公式排版。"><a href="#说正事：LaTeX中的公式排版。" class="headerlink" title="说正事：LaTeX中的公式排版。"></a>说正事：LaTeX中的公式排版。</h3><p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/6.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amssymb&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\diff&#125;</span><span class="string">&#123;\mathrm&#123;d&#125;</span></span>&#125; <span class="comment">%自定义命令</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">花体：<span class="formula">$<span class="tag">\<span class="name">mathcal</span><span class="string">&#123;R&#125;</span></span>$</span></span><br><span class="line"></span><br><span class="line">在花一点：<span class="formula">$<span class="tag">\<span class="name">mathfrak</span><span class="string">&#123;R&#125;</span></span>$</span>，太花的依赖宏包amssymb。</span><br><span class="line"></span><br><span class="line">公式尺寸：行间公式<span class="tag">\<span class="name">textbackslash</span></span> textstyle，比如<span class="formula">$P=<span class="tag">\<span class="name">frac</span><span class="string">&#123;num&#125;</span><span class="string">&#123;den&#125;</span>=</span>&#123;<span class="tag">\<span class="name">displaystyle</span><span class="string">&#123;\frac&#123;num&#125;</span><span class="string">&#123;\iint f(x)\diff x&#125;</span></span>&#125;&#125;$</span>。</span><br><span class="line"></span><br><span class="line">行间公式大小控制：<span class="tag">\<span class="name">textbackslash</span></span> displaystyle</span><br><span class="line"><span class="formula">$$<span class="tag">\<span class="name">mathcal</span><span class="string">&#123;X&#125;</span>=</span><span class="tag">\<span class="name">frac</span><span class="string">&#123;\sum_&#123;i=1&#125;</span></span>^&#123;10&#125;(x_i-<span class="tag">\<span class="name">bar</span><span class="string">&#123;x&#125;</span></span>)&#125;&#123;<span class="tag">\<span class="name">displaystyle</span></span><span class="tag">\<span class="name">sum</span></span>_&#123;i=1&#125;^&#123;12&#125;&#123;(x_i^2-<span class="tag">\<span class="name">hat</span><span class="string">&#123;x&#125;</span></span>)&#125;&#125;$$</span></span><br><span class="line"></span><br><span class="line">公式字体加粗：</span><br><span class="line"><span class="formula">$R = <span class="tag">\<span class="name">mathbf</span><span class="string">&#123;R&#125;</span></span>$</span></span><br><span class="line"></span><br><span class="line">希腊数学符号加粗：</span><br><span class="line"><span class="formula">$<span class="tag">\<span class="name">boldsymbol</span><span class="string">&#123;\mu&#125;</span></span> <span class="tag">\<span class="name">,</span> =</span><span class="tag">\<span class="name">,</span></span> <span class="tag">\<span class="name">mu</span></span>$</span></span><br><span class="line"></span><br><span class="line">调公式间距：</span><br><span class="line"><span class="formula">$aa$</span>，</span><br><span class="line"><span class="formula">$a<span class="tag">\<span class="name">,</span></span>a$</span>，</span><br><span class="line"><span class="formula">$a<span class="tag">\<span class="name">:</span></span>a$</span>，</span><br><span class="line"><span class="formula">$a<span class="tag">\<span class="name">;</span></span>a$</span>，</span><br><span class="line"><span class="formula">$a<span class="tag">\<span class="name"> </span></span>a$</span>，</span><br><span class="line"><span class="formula">$a<span class="tag">\<span class="name">!</span></span> a$</span>。</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="公式识别"><a href="#公式识别" class="headerlink" title="公式识别"></a>公式识别</h3><p>神器推荐：<a href="http://detexify.kirelabs.org/classify.html?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">点我是网址。</a>。不认识的字在里面画一下，后台告诉你叫啥，没准后台是是CNN，我瞎猜的，看下效果比如：</p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/7.png" alt></p>
<hr>
<h2 id="LaTeX灵魂——字体设置"><a href="#LaTeX灵魂——字体设置" class="headerlink" title="LaTeX灵魂——字体设置"></a>LaTeX灵魂——字体设置</h2><p>字体的倾斜、加粗、大小、行间距、段间距设置等。</p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/8.png" alt></p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/9.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;fouriernc&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;fontspec&#125;</span><span class="string">[no-math]</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">这个是fouriernc宏包下，fourier风格的数学字体<span class="formula">$<span class="tag">\<span class="name">mu</span></span>$</span>，New Century Schoolbook字体。</span><br><span class="line"></span><br><span class="line">normal typeface</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">textbf</span><span class="string">&#123;bold typeface&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">textit</span><span class="string">&#123;tilted typeface&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">emph</span><span class="string">&#123;emphasized typeface&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">fontsize</span><span class="string">&#123;12&#125;</span><span class="string">&#123;14&#125;</span></span><span class="tag">\<span class="name">selectfont</span></span></span><br><span class="line">Settings to font size and row spacing，<span class="tag">\<span class="name">textbackslash</span></span> fontsize<span class="tag">\<span class="name">&#123;</span></span><span class="tag">\<span class="name">&#125;</span></span><span class="tag">\<span class="name">&#123;</span></span><span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line">的第一个参数是字体大小，第二个参数是行间距，必须加上<span class="tag">\<span class="name">textbackslash</span></span> selectfont才能立刻生效。</span><br><span class="line"></span><br><span class="line">更改字体的宏包要设置选项<span class="tag">\<span class="name">textbackslash</span></span> usepackage<span class="tag">\<span class="name">&#123;</span></span>fontspec<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line">[no-math]，不然选择的数学字体会被覆盖。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">setmainfont</span><span class="string">[BoldFont=&#123;Arial Bold&#125;]</span><span class="string">&#123;Arial&#125;</span></span></span><br><span class="line">这里是Arial字体。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">setmainfont</span><span class="string">&#123;Times New Roman&#125;</span></span></span><br><span class="line">这里是Times New Roman字体。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">songti</span></span> 宋体</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">heiti</span></span> 黑体</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">fangsong</span></span> 仿宋</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">kaishu</span></span> 楷书</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="全文排版：间距。"><a href="#全文排版：间距。" class="headerlink" title="全文排版：间距。"></a>全文排版：间距。</h2><p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/10.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> linespread<span class="tag">\<span class="name">&#123;</span></span><span class="tag">\<span class="name">&#125;</span></span>是改变行距的命令，里面的参数是一个因子，</span><br><span class="line">默认行距是<span class="formula">$1.2$</span>倍的字体大小，</span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> linespread<span class="tag">\<span class="name">&#123;</span></span>1.5<span class="tag">\<span class="name">&#125;</span></span> 意味着有<span class="formula">$1.8$</span>倍的行间距。</span><br><span class="line">使用的时候要配合<span class="tag">\<span class="name">textbackslash</span></span> selectfont 和<span class="tag">\<span class="name">textbackslash</span></span> par命令。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">linespread</span><span class="string">&#123;0.8&#125;</span></span><span class="tag">\<span class="name">selectfont</span></span> 为了显示行间距，配一段文字，</span><br><span class="line">《简·爱》是2011年焦点电影公司出品的一部美国爱情片，</span><br><span class="line">由凯瑞·福永执导，由迈克尔·法斯宾德、米娅·华希科沃斯卡、杰米·贝尔、朱迪·丹奇等联袂主演。</span><br><span class="line">影片于2011年3月11日在美国上映。影片改编自英国女作家夏洛蒂·勃朗特的同名小说，</span><br><span class="line">讲述一位从小变成孤儿的英国女子在各种磨难中不断追求自由与尊严，</span><br><span class="line">坚持自我，最终获得幸福的故事。<span class="tag">\<span class="name">par</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">noindent</span></span> <span class="tag">\<span class="name">linespread</span><span class="string">&#123;1&#125;</span></span><span class="tag">\<span class="name">selectfont</span></span> 取消缩进：从小失去父母的简·爱（米娅·华希科沃斯卡饰）寄居在舅妈家，</span><br><span class="line">自幼受尽表兄（克雷格·罗伯兹饰）欺辱和舅妈（莎莉·霍金斯饰）冷眼，稍大些后即被送入管教严格的教会女子学校。</span><br><span class="line">在冷漠、刻板环境中长大的简·爱并没有成为心理扭曲的女孩，而是自立自强，</span><br><span class="line">还积累了不凡的学识修养，成年后她成为桑菲尔德贵族庄园的家庭教师。<span class="tag">\<span class="name">par</span></span></span><br><span class="line"></span><br><span class="line">另外，LaTeX在section，chapter后面默认第一段不缩进，不习惯的话，调用indentfirst宏包。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/11.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 看一下 <span class="tag">\<span class="name">LaTeX</span></span> 的段落间距设置。间距即为长度，<span class="tag">\<span class="name">&#123;</span></span>1ex plus 0.5ex minus 0.2ex<span class="tag">\<span class="name">&#125;</span></span>意思是</span><br><span class="line"> 段落间的距离在<span class="formula">$[1+0.5,1-0.2]$</span>之间变动。</span><br><span class="line"> 具体变动多少看排版的情况。<span class="tag">\<span class="name">par</span></span></span><br><span class="line"><span class="tag">\<span class="name">setlength</span><span class="string">&#123;\parskip&#125;</span><span class="string">&#123;1ex plus 0.5ex minus 0.2ex&#125;</span></span></span><br><span class="line">水平间距：常用的为<span class="tag">\<span class="name">textbackslash</span></span> quad，<span class="tag">\<span class="name">textbackslash</span></span> qquad。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">setlength</span><span class="string">&#123;\parskip&#125;</span><span class="string">&#123;1ex plus 0.5ex minus 0.2ex&#125;</span></span></span><br><span class="line"></span><br><span class="line">竖直间距：<span class="tag">\<span class="name">textbackslash</span></span> vspace，这个命令产生的间距会被断页被吞噬</span><br><span class="line">，而<span class="tag">\<span class="name">textbackslash</span></span> vspace<span class="tag">\<span class="name">*</span></span> 不会。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">TeX</span></span>  增加12pt的段间距。 <span class="tag">\<span class="name">vspace</span><span class="string">&#123;12pt&#125;</span></span> <span class="tag">\<span class="name">par</span></span></span><br><span class="line"><span class="tag">\<span class="name">TeX</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="LaTeX未走之路——tikz绘图"><a href="#LaTeX未走之路——tikz绘图" class="headerlink" title="LaTeX未走之路——tikz绘图"></a>LaTeX未走之路——tikz绘图</h2><p>为什么叫未走之路呢？因为这玩意我没用过，而且没有这个需求，为了体现latex的强大，乱入一段有关tikz绘图的东西。</p>
<p>在绘制流程框图时，有许多工具可以采用，最著名的有微软的Viso，而开源的有Graphviz、PGF/TikZ，Graphviz是采用dot语言的一个矢量图生成系统，但是不支持 LaTeX 公式，安装也比较麻烦。PGF是用于生成矢量图的一种语言，而TikZ则是在 TeX 环境下的一个宏包，实现了对PGF的封装，所以我们要使用TikZ，就需要先配置 LaTeX 环境，用TikZ绘制出来的图形效果非常好，原生支持所有 LaTeX 语法，同时能和正文的文字字体保持高度一致，但是学习曲线略微陡峭，适合有排版强迫症的同学。</p>
<p> 看下效果，因为我不会TiKz，所以，下面的图不是我画的，所以给出源代码的地址，画图的源代码在<a href="http://www.latexstudio.net/archives/9774.html" target="_blank" rel="noopener">这里</a>。你没猜错，这些图都是用程序画的，直接“封装”进了文档，不是插图进来的。</p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/12.png" alt></p>
<p>  <img data-src="/2018/11/07/Brief-introduction-to-LaTex/13.png" alt></p>
<hr>
<h2 id="LaTeX颜值——特殊工具和文档元素"><a href="#LaTeX颜值——特殊工具和文档元素" class="headerlink" title="LaTeX颜值——特殊工具和文档元素"></a>LaTeX颜值——特殊工具和文档元素</h2><h3 id="页边距设置"><a href="#页边距设置" class="headerlink" title="页边距设置"></a>页边距设置</h3><p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/14.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;geometry&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">newgeometry</span><span class="string">&#123;left=1.25in,right=1.25in,top=1in,bottom=1in&#125;</span></span></span><br><span class="line"></span><br><span class="line">	页面参数设置使用geometry宏包，我记得geometry这个单词是几何学的意思，</span><br><span class="line">	然而不知道为啥这个宏包起了这么个名字。</span><br><span class="line"></span><br><span class="line">	第一种：<span class="tag">\<span class="name">textbackslash</span></span> geometry<span class="tag">\<span class="name">&#123;</span></span>left=1cm,right=1cm,top=2.5cm,bottom=2.5cm<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line">	第二种：microsoft word 习惯的页面设定是A4，上下边距1英寸，左右边距1.25英寸。</span><br><span class="line">	<span class="tag">\<span class="name">textbackslash</span></span> geometry<span class="tag">\<span class="name">&#123;</span></span>left=1.25in,right=1.25in,top=1in,bottom=1in<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line">	还有个问题，也是去年遇到的，第一页摘要页是一种页边距，</span><br><span class="line">	但是不想影响后面论文的边距，又该怎么操作呢。</span><br><span class="line"></span><br><span class="line">	设置当前页：</span><br><span class="line"></span><br><span class="line">	<span class="tag">\<span class="name">textbackslash</span></span> newgeometry<span class="tag">\<span class="name">&#123;</span></span>left=3cm,bottom=1cm<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line">	新的一页在new一个。</span><br><span class="line">	<span class="tag">\<span class="name">textbackslash</span></span> newgeometry<span class="tag">\<span class="name">&#123;</span></span>left=5cm,right=5cm,top=2cm,bottom=2cm<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line">	有关页边距的测试。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="页眉页脚设置"><a href="#页眉页脚设置" class="headerlink" title="页眉页脚设置"></a>页眉页脚设置</h3><p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/15.png" alt><img data-src="/2018/11/07/Brief-introduction-to-LaTex/16.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;fancyhdr&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">pagestyle</span><span class="string">&#123;fancy&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">页眉页脚为空：</span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> pagestyle<span class="tag">\<span class="name">&#123;</span></span>empty<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line">当前页面的页眉页脚为空：</span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> thispagestyle<span class="tag">\<span class="name">&#123;</span></span>empty<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line">页眉空，页脚为页码：</span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> pagestyle<span class="tag">\<span class="name">&#123;</span></span>plain<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line">页脚空，页眉为章节标题和页码：</span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> pagestyle<span class="tag">\<span class="name">&#123;</span></span>headings<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line">自定义页眉：</span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> markboth<span class="tag">\<span class="name">&#123;</span></span>左上角的页眉<span class="tag">\<span class="name">&#125;</span></span><span class="tag">\<span class="name">&#123;</span></span>右上角的页眉<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line">但是，说实话自定义的这个不对，也不是不对，和原有的ctexart中的页眉设置冲突了。</span><br><span class="line">所以，介绍种新技术：fancyhdr宏包。</span><br><span class="line"></span><br><span class="line">导言区：</span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> usepackage<span class="tag">\<span class="name">&#123;</span></span>fancyhdr<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> pagestyle<span class="tag">\<span class="name">&#123;</span></span>fancy<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line">清空所有页眉页脚：</span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> fancyhf<span class="tag">\<span class="name">&#123;</span></span><span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line">左上页眉：</span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> fancyhead[L]<span class="tag">\<span class="name">&#123;</span></span>test1<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line">中间页眉：</span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> fancyhead[C]<span class="tag">\<span class="name">&#123;</span></span>test2<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line">右上页眉：</span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> fancyhead[R]<span class="tag">\<span class="name">&#123;</span></span>test3<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line">页脚为页数：</span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> fancyfoot[C]<span class="tag">\<span class="name">&#123;</span></span><span class="tag">\<span class="name">textbackslash</span></span> bfseries<span class="tag">\<span class="name">textbackslash</span></span> thepage<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h3><p>此处遇到一个坑，在使用{geometry}宏包设置边距和{fancyhdr}宏包设置页眉的时候，一定要先设置页面在设置页眉，否则先设置页眉在设置页面的话，页眉不够长。</p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/17.png" alt><br><img data-src="/2018/11/07/Brief-introduction-to-LaTex/18.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;geometry&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">geometry</span><span class="string">&#123;left=2.25cm,right=2.25cm&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;fancyhdr&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">pagestyle</span><span class="string">&#123;fancy&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">fancyhead</span><span class="string">[L]</span><span class="string">&#123;test1&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">fancyhead</span><span class="string">[C]</span><span class="string">&#123;test2&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">fancyhead</span><span class="string">[R]</span><span class="string">&#123;test3&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">fancyfoot</span><span class="string">[C]</span><span class="string">&#123;\bfseries\thepage&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">tableofcontents</span></span></span><br><span class="line"><span class="tag">\<span class="name">newpage</span></span></span><br><span class="line"></span><br><span class="line">在 <span class="tag">\<span class="name">LaTeX</span></span> 中编写论文时，肯定要考虑到大标题小标题，在report和book中使用的是<span class="tag">\<span class="name">textbackslash</span></span> chapter，</span><br><span class="line">但是更常用的是<span class="tag">\<span class="name">textbackslash</span></span> section，</span><br><span class="line">所以这里重点介绍<span class="tag">\<span class="name">textbackslash</span></span> section。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">section</span><span class="string">&#123;简短介绍&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> section[目录、页眉页脚显示的内容]<span class="tag">\<span class="name">&#123;</span></span>正文显示的标题<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">section*</span><span class="string">&#123;不带编号&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">addcontentsline</span></span> &#123;toc&#125;&#123;section&#125;&#123;1.1不带编号&#125;</span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> section*<span class="tag">\<span class="name">&#123;</span></span>正文显示的标题<span class="tag">\<span class="name">&#125;</span></span>这样操作的标题没有编号。</span><br><span class="line">而且这样形式的标题不会出现在页眉页脚和目录中，怎么解决呢？</span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> tableofcontents 在命令的当前位置生成目录章节，而且生成的标题为``Contents"。</span><br><span class="line"></span><br><span class="line">在使用了<span class="tag">\<span class="name">textbackslash</span></span> section*<span class="tag">\<span class="name">&#123;</span></span><span class="tag">\<span class="name">&#125;</span></span>的位置，如果想在目录和页眉页脚加入此章节，在标题后面使</span><br><span class="line">用<span class="tag">\<span class="name">textbackslash</span></span> addcontentsline<span class="tag">\<span class="name">&#123;</span></span>toc<span class="tag">\<span class="name">&#125;</span></span><span class="tag">\<span class="name">&#123;</span></span>sect<span class="tag">\<span class="name">-</span></span>ion或chapter<span class="tag">\<span class="name">&#125;</span></span><span class="tag">\<span class="name">&#123;</span></span>出现于目录的标题<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">section</span><span class="string">&#123;有关小标题&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">subsection</span><span class="string">&#123;小标题&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">subsubsection</span><span class="string">&#123;小小标题&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> subsection<span class="tag">\<span class="name">&#123;</span></span>小标题<span class="tag">\<span class="name">&#125;</span></span>生成小标题</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> subsubsection<span class="tag">\<span class="name">&#123;</span></span>小小标题<span class="tag">\<span class="name">&#125;</span></span>生成小标题</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/21.png" alt><br><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">有序列表：<span class="tag">\<span class="name">textbackslash</span></span> begin <span class="tag">\<span class="name">&#123;</span></span>enumerate<span class="tag">\<span class="name">&#125;</span></span>，</span><br><span class="line">无序列表：<span class="tag">\<span class="name">textbackslash</span></span> begin <span class="tag">\<span class="name">&#123;</span></span>itemize<span class="tag">\<span class="name">&#125;</span></span>。</span><br><span class="line">如下所示：</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;enumerate&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">item</span></span> 假设我说的都对</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;enumerate&#125;</span></span></span><br><span class="line">		<span class="tag">\<span class="name">item</span></span> 这么说是有参考文献的</span><br><span class="line">		<span class="tag">\<span class="name">item</span></span> 但是那个参考文献我找不到了</span><br><span class="line">		<span class="tag">\<span class="name">item</span><span class="string">[·]</span></span> 我好像在说废话</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;enumerate&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">item</span></span> 假设别人说的都不对</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;itemize&#125;</span></span></span><br><span class="line">		<span class="tag">\<span class="name">item</span></span>  因为他们不会做</span><br><span class="line">		<span class="tag">\<span class="name">item</span></span> 而且还是抄的</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;itemize&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">item</span></span>  这么说肯定不行</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;enumerate&#125;</span></span></span><br><span class="line"></span><br><span class="line">列表中第一个重点词加粗：<span class="tag">\<span class="name">textbackslash</span></span> begin <span class="tag">\<span class="name">&#123;</span></span>description<span class="tag">\<span class="name">&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;description&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">item</span><span class="string">[blablabla]</span></span>  和后面的blablabla</span><br><span class="line">	<span class="tag">\<span class="name">item</span><span class="string">[test]</span></span> 和后面的test</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;description&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/22.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;center&#125;</span></span></span><br><span class="line">标题要居中对齐。</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;center&#125;</span></span></span><br><span class="line"></span><br><span class="line">来一段无关的文字，体现出了恢复两端对齐。《挪威的森林》是日本作家村上春树于1987年所著的一部长篇爱情小说。</span><br><span class="line">故事讲述主角纠缠在情绪不稳定且患有精神疾病的直子和开朗活泼的小林绿子之间，</span><br><span class="line">展开了自我成长的旅程。<span class="tag">\<span class="name">par</span></span></span><br><span class="line"></span><br><span class="line">一般我很少用居中对齐的环境，居中对齐有两种表达形式：<span class="tag">\<span class="name">textbackslash</span></span> centering ，</span><br><span class="line">这个后面的一句话会居中对齐，但是不产生额外的间距。而<span class="tag">\<span class="name">textbackslash</span></span> begin<span class="tag">\<span class="name">&#123;</span></span>center<span class="tag">\<span class="name">&#125;</span></span>会产生一个间距。</span><br><span class="line">所以提倡在文章居中使用<span class="tag">\<span class="name">textbackslash</span></span> begin<span class="tag">\<span class="name">&#123;</span></span>center<span class="tag">\<span class="name">&#125;</span></span>，</span><br><span class="line">在表格、图片中插入居中的标题使用<span class="tag">\<span class="name">textbackslash</span></span> centering 。</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="LaTeX论文必备——参考文献"><a href="#LaTeX论文必备——参考文献" class="headerlink" title="LaTeX论文必备——参考文献"></a>LaTeX论文必备——参考文献</h2><p>之前折腾过有关参考文献的东西，但好像一直不如人意，所以这次又来光顾参考文献了。一点一点来：</p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/26.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;geometry&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">geometry</span><span class="string">&#123;left=2.25cm,right=2.25cm&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;fancyhdr&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">pagestyle</span><span class="string">&#123;fancy&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">不同文章对参考文献的需求不一样，自己书写参考文献还有点头疼。介绍下 <span class="tag">\<span class="name">LaTeX</span></span> 中的操作。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> cite<span class="tag">\<span class="name">&#123;</span></span>citation<span class="tag">\<span class="name">&#125;</span></span>命令在正文引用参考文献，citation是引用的标签。</span><br><span class="line">参考文献由thebibliography环境包裹，每条参考文献由<span class="tag">\<span class="name">textbackslash</span></span> bibitem<span class="tag">\<span class="name">&#123;</span></span>citation<span class="tag">\<span class="name">&#125;</span></span>开头。</span><br><span class="line">而thethebibliography带一个参数，99表示不超过参考文献的编号不超过两位数。</span><br><span class="line">说到这里，来动手实践<span class="tag">\<span class="name">cite</span><span class="string">&#123;c1&#125;</span></span>：可见，这样的参考文献已经符合美赛的格式要求，</span><br><span class="line">当然这不是重点，以及注意右上角的页眉。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">section</span><span class="string">&#123;正文&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;thebibliography&#125;</span><span class="string">&#123;99&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">bibitem</span><span class="string">[1]</span><span class="string">&#123;c1&#125;</span></span> 李洋,方滨兴,郭莉,田志宏.  基于主动学习和TCM-KNN方法的有指导入侵检测技术[J]. 计算机学报. 2007(08)</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;thebibliography&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="有关bibtex做参考文献数据库"><a href="#有关bibtex做参考文献数据库" class="headerlink" title="有关bibtex做参考文献数据库"></a>有关bibtex做参考文献数据库</h3><p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/28.png" alt></p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/29.png" alt></p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/30.png" alt></p>
<h3 id="bib文件的书写"><a href="#bib文件的书写" class="headerlink" title="bib文件的书写"></a>bib文件的书写</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;geometry&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;hologo&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">[numbers,sort&amp;compress]</span><span class="string">&#123;natbib&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">geometry</span><span class="string">&#123;left=2.25cm,right=2.25cm&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;fancyhdr&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">pagestyle</span><span class="string">&#123;fancy&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">bibliographystyle</span><span class="string">&#123;plain&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">section</span><span class="string">&#123;正文&#125;</span></span></span><br><span class="line"></span><br><span class="line">&#123;<span class="tag">\<span class="name">color</span><span class="string">&#123;teal&#125;</span></span>有关使用<span class="tag">\<span class="name">hologo</span><span class="string">&#123;BibTeX&#125;</span></span>做参考文献数据库的介绍：&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="tag">\<span class="name">color</span><span class="string">&#123;teal&#125;</span></span><span class="tag">\<span class="name">hologo</span><span class="string">&#123;BibTeX&#125;</span></span>是目前最为流行的参考文献的数据组织格式之一，</span><br><span class="line">数据库以.bib为扩展名，是一个单独的文件，放在与当前tex文件相同目录下。&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;<span class="tag">\<span class="name">color</span><span class="string">&#123;teal&#125;</span></span><span class="tag">\<span class="name">hologo</span><span class="string">&#123;BibTeX&#125;</span></span>数据库对文件的格式要求：<span class="tag">\<span class="name">begin</span><span class="string">&#123;lstlisting&#125;</span></span></span><br><span class="line">	@article&#123;Alice13,</span><br><span class="line">	  title = &#123;brief introduction to LaTeX&#125;</span><br><span class="line">	  author = &#123;LIU JIA WEI&#125;,</span><br><span class="line">	  year = &#123;2018&#125;</span><br><span class="line">	  journal = &#123;Journal&#125;,</span><br><span class="line">	  volume = &#123;36&#125;,</span><br><span class="line">	  number = &#123;7&#125;,</span><br><span class="line">	  pages = &#123;114-120&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;lstlisting&#125;</span></span></span><br><span class="line">其中，article处有四个选项，article，book，incollection，inbook。</span><br><span class="line">article是科技论文，必须有author，year，journal；book是书籍，必须有author，title，publisher，year；</span><br><span class="line">inbook是书中的一章，在book的基础上必须有chapter项，</span><br><span class="line">incollection是论文集中的一篇，在article的基础上必须有publisher和booktitle；</span><br><span class="line">Alice1是引用时使用的标签。</span><br><span class="line">是不是很麻烦？不是，因为很多时候不用自己写<span class="tag">\<span class="name">hologo</span><span class="string">&#123;BibTeX&#125;</span></span>的条目，</span><br><span class="line">期刊的网站或者Google Scholar都能导出<span class="tag">\<span class="name">hologo</span><span class="string">&#123;BibTeX&#125;</span></span>文献的条目<span class="tag">\<span class="name">cite</span><span class="string">&#123;Alice1&#125;</span></span>，</span><br><span class="line">开源软件JabRef支持生成<span class="tag">\<span class="name">hologo</span><span class="string">&#123;BibTeX&#125;</span></span>文献条目的导出管理等。</span><br><span class="line">不同的文献写法在不用的文献里千差万别，在使用<span class="tag">\<span class="name">hologo</span><span class="string">&#123;BibTeX&#125;</span></span>时，用style样式来管理写法。</span><br><span class="line">预定义的样式有plain，unsrt，alpha等，如果是给定的期刊，按给定期刊的来，</span><br><span class="line">期刊会给你一个.bst的文件<span class="tag">\<span class="name">cite</span><span class="string">&#123;Alice2&#125;</span></span>，样式就在这个文件里。</span><br><span class="line">在使用<span class="tag">\<span class="name">hologo</span><span class="string">&#123;BibTeX&#125;</span></span>时，导言区使用<span class="tag">\<span class="name">textbackslash</span></span> bibliographystyle<span class="tag">\<span class="name">&#123;</span></span>style样式<span class="tag">\<span class="name">&#125;</span></span>，</span><br><span class="line">而且在列出参考文献的位置使用<span class="tag">\<span class="name">textbackslash</span></span> bibliography<span class="tag">\<span class="name">&#123;</span></span>数据库名<span class="tag">\<span class="name">&#125;</span></span>代替thebibliography。</span><br><span class="line">然后，四遍编译过程，第一遍xelatex编译原文件，</span><br><span class="line">第二遍以Bibtex的形式编译bib文件，第三遍xelatex编译原文件，</span><br><span class="line">第四遍xelatex编译源文件。然后搞定~&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">bibliography</span><span class="string">&#123;books&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="LaTeX图文并茂—-插图与表格"><a href="#LaTeX图文并茂—-插图与表格" class="headerlink" title="LaTeX图文并茂—-插图与表格"></a>LaTeX图文并茂—-插图与表格</h2><p>插图为单幅图片，左右子图；表格就是三线表。</p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/19.png" alt><br><img data-src="/2018/11/07/Brief-introduction-to-LaTex/20.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;geometry&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">geometry</span><span class="string">&#123;left=2.25cm,right=2.25cm&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;fancyhdr&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">pagestyle</span><span class="string">&#123;fancy&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;subfig&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;graphicx&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">图片里面有个浮动体，那个不太容易操作。</span><br><span class="line">好的论文是不是要图文并茂，好的，再来个图。此时发现图片跑到了文本的上面，为什么会这样呢？</span><br><span class="line">figure是浮动体的环境，因为<span class="tag">\<span class="name">LaTeX</span></span> 排版会把尺度大的东西脱离上下文。</span><br><span class="line">所以，要加上限制浮动体的东西。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> figure[placement]中，placement里面有四个参数：htdp，h：当前位置，t：顶部，b：底部，p：单独成页。</span><br><span class="line">加上h他就去他该去的地方了。</span><br><span class="line"><span class="tag">\<span class="name">begin</span></span> &#123;figure&#125;[h]</span><br><span class="line"><span class="tag">\<span class="name">centering</span></span> <span class="comment">% 居中显示</span></span><br><span class="line"><span class="tag">\<span class="name">includegraphics</span><span class="string">[width=10cm,height=6cm]</span><span class="string">&#123;aaa.png&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">caption</span><span class="string">&#123;第一个破图&#125;</span></span> <span class="comment">% 标题</span></span><br><span class="line"><span class="tag">\<span class="name">end</span></span> &#123;figure&#125;</span><br><span class="line"></span><br><span class="line">再来看一个并排显示子图的东西。<span class="tag">\<span class="name">textbackslash</span></span> subfig宏包。</span><br><span class="line">其中，每页不超过3个浮动体，底部不超过2个，顶部不超过1个。</span><br><span class="line">一页里面不要放太多图片和表盒，不然调着真挺费劲的。并排的图尽量小点，不然占不下。</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;figure&#125;</span><span class="string">[hb!p]</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;minipage&#125;</span><span class="string">[t]</span><span class="string">&#123;0.5\linewidth&#125;</span></span><span class="comment">%设定图片下字的宽度，在此基础尽量满足图片的长宽</span></span><br><span class="line">		<span class="tag">\<span class="name">centering</span></span></span><br><span class="line">		<span class="tag">\<span class="name">includegraphics</span><span class="string">[height=5.5cm,width=8cm]</span><span class="string">&#123;bbb.png&#125;</span></span></span><br><span class="line">		<span class="tag">\<span class="name">caption*</span><span class="string">&#123;(a) This is the left picure.&#125;</span></span><span class="comment">%加*可以去掉默认前缀，作为图片单独的说明</span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;minipage&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;minipage&#125;</span><span class="string">[t]</span><span class="string">&#123;0.5\linewidth&#125;</span></span><span class="comment">%需要几张添加即可，注意设定合适的linewidth</span></span><br><span class="line">		<span class="tag">\<span class="name">centering</span></span></span><br><span class="line">		<span class="tag">\<span class="name">includegraphics</span><span class="string">[height=5.5cm,width=8cm]</span><span class="string">&#123;ccc.png&#125;</span></span></span><br><span class="line">		<span class="tag">\<span class="name">caption*</span><span class="string">&#123;(b)This is the right picture.&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;minipage&#125;</span></span></span><br><span class="line"></span><br><span class="line">	<span class="tag">\<span class="name">caption</span><span class="string">&#123;This is total name.&#125;</span></span><span class="comment">%n张图片共享的说明</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;figure&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/23.png" alt></p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/24.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;geometry&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">geometry</span><span class="string">&#123;left=2.25cm,right=2.25cm&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;fancyhdr&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">pagestyle</span><span class="string">&#123;fancy&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;booktabs&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;multirow&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">表格的环境tabular一般放在<span class="tag">\<span class="name">textbackslash</span></span> table 浮动体环境中，</span><br><span class="line">直接使用tabular的话会容易和周围的文字混排。<span class="tag">\<span class="name">textbackslash</span></span><span class="tag">\<span class="name">&#123;</span></span>tabular<span class="tag">\<span class="name">&#125;</span></span><span class="tag">\<span class="name">&#123;</span></span>参数<span class="tag">\<span class="name">&#125;</span></span>，</span><br><span class="line">其中参数用于设置对齐方式和列宽。l：左对齐，c：居中，r：右对齐，p<span class="tag">\<span class="name">&#123;</span></span>6em<span class="tag">\<span class="name">&#125;</span></span>，设置列宽。</span><br><span class="line">参数之间使用|能够画竖线， <span class="tag">\<span class="name">textbackslash</span></span> hline用于绘制每行之间的直线。</span><br><span class="line"></span><br><span class="line">还是多动手吧：</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;table&#125;</span><span class="string">[h]</span></span></span><br><span class="line">	<span class="tag">\<span class="name">centering</span></span></span><br><span class="line">	<span class="tag">\<span class="name">caption</span><span class="string">&#123;某些特殊符号&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;c|c|c|c|c|c&#125;</span></span></span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		test1 &amp; <span class="formula">$<span class="tag">\<span class="name">eta</span></span>$</span> &amp; <span class="formula">$<span class="tag">\<span class="name">Omega</span></span>$</span> &amp; <span class="formula">$<span class="tag">\<span class="name">ddagger</span></span>$</span> &amp;  <span class="formula">$<span class="tag">\<span class="name">subseteq</span></span>$</span>  &amp; <span class="formula">$<span class="tag">\<span class="name">clubsuit</span></span>$</span> <span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		test1 &amp; <span class="formula">$<span class="tag">\<span class="name">eta</span></span>$</span> &amp; <span class="formula">$<span class="tag">\<span class="name">Omega</span></span>$</span> &amp; <span class="formula">$<span class="tag">\<span class="name">ddagger</span></span>$</span> &amp;  <span class="formula">$<span class="tag">\<span class="name">subseteq</span></span>$</span>  &amp; <span class="formula">$<span class="tag">\<span class="name">clubsuit</span></span>$</span> <span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;table&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">textbackslash</span></span> cline<span class="tag">\<span class="name">&#123;</span></span><span class="formula">$i<span class="tag">\<span class="name">leftrightarrow</span></span> j$</span><span class="tag">\<span class="name">&#125;</span></span>用于绘制<span class="formula">$i<span class="tag">\<span class="name">leftrightarrow</span></span> j$</span>之间的线。</span><br><span class="line">动手如下：（注意表1和表格的间距，表2和表格的间距）</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;table&#125;</span><span class="string">[h]</span></span></span><br><span class="line">	<span class="tag">\<span class="name">centering</span></span></span><br><span class="line">	<span class="tag">\<span class="name">caption</span><span class="string">&#123;cline操作&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">vspace</span><span class="string">&#123;3pt&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|c|c|c|&#125;</span></span></span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		1 &amp; 2 &amp; 3 <span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">cline</span><span class="string">&#123;2-3&#125;</span></span></span><br><span class="line">		4 &amp; 5 &amp; 6 <span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">cline</span><span class="string">&#123;1-1&#125;</span></span></span><br><span class="line">		7 &amp; 8 &amp; 9 <span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;table&#125;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">单元格合并问题：使用<span class="tag">\<span class="name">textbackslash</span></span> muticolumn<span class="tag">\<span class="name">&#123;</span></span>合并的列数<span class="tag">\<span class="name">&#125;</span></span><span class="tag">\<span class="name">&#123;</span></span>合并后的格式<span class="tag">\<span class="name">&#125;</span></span><span class="tag">\<span class="name">&#123;</span></span>合并后的标题<span class="tag">\<span class="name">&#125;</span></span>。操作：</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;table&#125;</span><span class="string">[h]</span></span></span><br><span class="line">	<span class="tag">\<span class="name">centering</span></span></span><br><span class="line">	<span class="tag">\<span class="name">vspace</span><span class="string">&#123;3pt&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;cccc&#125;</span></span></span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		<span class="tag">\<span class="name">multicolumn</span><span class="string">&#123;4&#125;</span><span class="string">&#123;c&#125;</span><span class="string">&#123;标题&#125;</span></span><span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		1 &amp; 2 &amp; 3 &amp; 4 <span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;table&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="三线表"><a href="#三线表" class="headerlink" title="三线表"></a>三线表</h3><p>切记，合并完后加一个 &amp; 符号，用于占位。表示合并完了也要占点位置。</p>
<p><img data-src="/2018/11/07/Brief-introduction-to-LaTex/25.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;geometry&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">geometry</span><span class="string">&#123;left=2.25cm,right=2.25cm&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;fancyhdr&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">pagestyle</span><span class="string">&#123;fancy&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;booktabs&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;multirow&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">由<span class="tag">\<span class="name">textbackslash</span></span> booktabs宏包支持，科技论文常用的三线表，居中显示配标题：</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;table&#125;</span><span class="string">[h]</span></span></span><br><span class="line">	<span class="tag">\<span class="name">centering</span></span></span><br><span class="line">	<span class="tag">\<span class="name">caption</span><span class="string">&#123;三线表&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">vspace</span><span class="string">&#123;3pt&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;cccc&#125;</span></span></span><br><span class="line">		<span class="tag">\<span class="name">toprule</span></span> <span class="comment">% 绘制第一条线</span></span><br><span class="line">		<span class="tag">\<span class="name">multicolumn</span><span class="string">&#123;4&#125;</span><span class="string">&#123;r&#125;</span><span class="string">&#123;textnumber&#125;</span></span> <span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">cmidrule</span><span class="string">&#123;2-4&#125;</span></span></span><br><span class="line">		&amp; 1 &amp; 2 &amp; 3 <span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">midrule</span></span></span><br><span class="line">		<span class="tag">\<span class="name">multirow</span><span class="string">&#123;2&#125;</span><span class="string">&#123;*&#125;</span><span class="string">&#123;TEST&#125;</span></span> &amp;</span><br><span class="line">		 A &amp; B &amp; C <span class="tag">\<span class="name">\</span></span> &amp;</span><br><span class="line">		 I &amp; II &amp; III <span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">bottomrule</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;table&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>对抗攻击篇：CW 攻击算法</title>
    <url>/2021/05/04/CW-attack/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>五一闲的没事继续开坑，差不多也该做论文了。等看完一些经典的攻击算法后，做一些复现和对比实验，然后去看经典的防御算法。CW 算法是一种基于优化的攻击算法 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，而论文的创新点在于损失函数的定义与梯度的截断。</p>
<a id="more"></a>
<h1 id="L-BFGS"><a href="#L-BFGS" class="headerlink" title="L-BFGS"></a>L-BFGS</h1><p>从最开始的 L-BFGS <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 出发，通过 $L_2$ 范数距离寻找和原始样本 $x$ 最接近的对抗样本 $x’$，而寻找对抗样本的过程就是解决以下优化问题：</p>
<p>\begin{equation}<br>\begin{aligned}<br>\min &amp; \; c\Vert x-x’ \Vert_2 + \text{loss}_{F,t}(x’) \\<br>\text{s.t.} &amp; \; x’ \in [0,1]<br>\end{aligned}<br>\end{equation}</p>
<p>其中 $c$ 是一个常数，表示损失函数权重为 1 的情况下，对抗样本与原始样本距离的权重应该是多少；$t$ 表示错误分类的标签，$x$ 是已知的可以视为常量，那么唯一的变量就是 $x’$，可以通过一维线搜索的问题求解到 $c$ 的取值。</p>
<p>论文中给出了 $t$ 的选择方法。假设当前为 10 分类任务，正确类别是 0，那么 $t$ 可以取 $1,2,\cdots,9$，那么取哪一个合适呢？换句话说，手写字体识别中，1 和 7 在字迹潦草的情况下容易被认错，那么正确类别是 1 时，对抗样本向 7 靠近，更容易攻击成功。</p>
<ul>
<li>平均选择，均匀的在错误类别中随机选择</li>
<li>最佳选择，在所有错误类别上进行攻击，选择最容易攻击的</li>
<li>最差选择，在所有错误类别上进行攻击，选择最难以攻击的</li>
</ul>
<h1 id="CW"><a href="#CW" class="headerlink" title="CW"></a>CW</h1><p>从最终输出概率的角度而言，获取最容易攻击的类别和最难以攻击的类别并不难。理解上述公式后，转换到 CW 算法论文中的攻击算法，用公式描述：</p>
<p>\begin{equation}<br>\begin{aligned}<br>\min &amp; \; \ D(x, x+\delta) \\<br>\text{s.t.} &amp; \; \ C(x+\delta) = t \\<br>{ } &amp; \; \ x + \delta \in [0,1]<br>\end{aligned}<br>\end{equation}</p>
<p>$t$ 依然是被错误分类的标签，$C$ 表示分类结果，$D$是距离度量函数，而本文选择的距离是 $L_0, L_2, L_\inf$ 三种范数距离。论文中指出：没有任何一种距离能衡量人类感知的差异，现有距离的度量方式都有或多或少的缺陷，所以本文选取了三种范数距离，但每一种距离也达到了目前最好的攻击效果。未来的工作中，可以好好研究下如何构造合适的距离度量函数。</p>
<h1 id="解非线性优化"><a href="#解非线性优化" class="headerlink" title="解非线性优化"></a>解非线性优化</h1><p>回到主题，将攻击公式化后，尝试借助优化的方法去求解问题。但由于 $C(x+\delta)=t$ 具有高度的非线性，所以选择一种更适合优化的表达方式。定义一个目标函数 $f$，当且仅当 $f(x+\delta) \leq 0$ 时，$C(x+\delta)=t$。论文中给出了 7 种 $f$ 的选择，但我懒，准备少写几个，不影响</p>
<p>\begin{equation}<br>\begin{aligned}<br>f_1(x’) &amp;= -\text{loss}_{F,t}(x’) + 1 \\<br>f_2(x’) &amp;= \Big( \max_{i\neq t} \big(Z(x’)_i\big) - Z(x’)_t \Big)^+ \\<br>f_3(x’) &amp;= \big( 0.5-F(x’)_t \big)<br>\end{aligned}<br>\end{equation}</p>
<p>其中，$e^+$ 运算表示 $\max(e,0)$；$-\text{loss}$ 表示交叉熵损失；$F(x’)_i$ 表示神经网络使用 $x’$ 作为输入，产生类别是 $i$ 的概率；$Z(x’)$ 表示 softmax 前的输出，即 $F(x)=\text{softmax}(Z(x))$。其中，效果最好的是第二个。那我们就用第二个公式解释下这些都是什么。</p>
<p>在论文中，$i$ 表示 $x’$ 对应的正确类别；$t$ 表示 $x’$ 对应的错误类别。而 $C(x+\delta)=t$ 表示希望对抗样本被错误分类，此时按照假设，$f(x+\delta) \leq 0$。我们带入$f_2$，$\max_{i\neq t} \big(Z(x’)_i\big)$ 表示除了类别 $t$ 以外，网络以最大概率认为这是第 $i$ 个类，但第 $i$ 类的概率仍然低于第 $t$ 类的概率，以此认为攻击成功。$f_3$ 同理，表示分类错误的概率大于 0.5。因此，优化目标修改为：</p>
<p>\begin{equation}<br>\begin{aligned}<br>\min &amp; \; \ D(x, x+\delta) \\<br>\text{s.t.} &amp; \; \ f(x+\delta) \leq 0 \\<br>{ } &amp; \; \ x + \delta \in [0,1]<br>\end{aligned}<br>\end{equation}</p>
<p>为了便于优化，按着 L-BFGS 的形式就行修改，将约束条件转为目标函数。第一项表示对抗样本要接近原始样本，第二项表示分类越错越好。</p>
<p>\begin{equation}<br>\begin{aligned}<br>\min &amp; \; \ \Vert \delta \Vert_p + c f(x+\delta)\\<br>\text{s.t.} &amp; \; \ x + \delta \in [0,1]<br>\end{aligned}<br>\end{equation}</p>
<p>其中，$c$ 的选择是一个坑，如果 $c\to 0$，那么梯度下降时，损失大部分来自图像误差；如果 $c$ 很大，那么分类损失将占主导，两者的损失应该相似。论文中，作者使用实验的方式确定了 $c$ 的最佳取值。</p>
<h1 id="梯度截断"><a href="#梯度截断" class="headerlink" title="梯度截断"></a>梯度截断</h1><p>因为对抗样本增加、减去梯度后很容易超出 $[0,1]$ 的范围，所以目前有一些截断的方法：</p>
<ul>
<li>梯度投影下降，对溢出部分直接截断，把截断后的对抗样本带入下一轮，但容易将截断带来的误差给传入下一轮迭代，这样会让误差越来越大。</li>
<li>梯度截断下降，不直接截断样本，而是将样本的截断代入要最小化的目标函数中，用 $f(\min(\max(x+\delta,0),1))$ 来代替 $f(x+\delta)$，但会带来梯度消失的问题。如当 $x$ 很大时取值为 1，且偏导数取值为 0。但反向传播时，无法更新 $x$。</li>
</ul>
<p>因此，本文引入变量 $w$，对抗样本可以表示为：</p>
<p>\begin{equation}<br>x+\delta=\frac{1}{2}\big( \tanh(w) + 1 \big)<br>\end{equation}</p>
<p>因为 $\tanh$ 的取值范围是 $[-1,1]$，所以 $x+\delta$ 的取值范围是 $[0,1]$，这样就满足了约束，也是一种光滑的截断，也算是本文比较大的创新点吧。</p>
<h1 id="开始攻击"><a href="#开始攻击" class="headerlink" title="开始攻击"></a>开始攻击</h1><p>我看论文中，$L_0$ 和 $L_\inf$ 都有一些缺陷，所以重点写 $L_2$ 攻击了。此时的方程为：</p>
<p>\begin{equation}<br>\begin{aligned}<br>\min &amp; \; \ \Big| \frac{1}{2}\big(\tanh(w) + 1\big) - x \Big|_2 + c f\big(\frac{1}{2}(\tanh(w) + 1)\big) \\<br>f(x) &amp; = \max\Big( \max\big(Z(x)_{i:i\neq t}\big) - Z(x)_t, -k\Big)<br>\end{aligned}<br>\end{equation}</p>
<p>参数 $k$ 用于控制错误分类的置信度，论文中 $k=0$，即保证被正确分类的概率低于被错误分类的概率。他人实现的程序 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>，但是程序的实现和论文的内容有一些出入。论文中，$Z(x)_t$ 表示错误分类。在实现用，用真实标签的概率 $y_\text{true}$ 减去被错误识别的概率 $y_\text{false}$ 中最大的一个。</p>
<ul>
<li>若这一项大于0，会有损失，表示要降低对真实标签的可信度；</li>
<li>若这一相小于0，取值为0，表示无法识别正确分类。此时没有损失，满足之前的当且仅当 $f(x+\delta) \leq 0$ 时，$C(x+\delta)=t$，也就是，分类错误后，就不用优化这一项了；换句话说，在不满足 $C(x+\delta)=t$ 约束下，是没有目标函数的损失值的。这里的确需要好好理解。</li>
</ul>
<h1 id="程序-4"><a href="#程序-4" class="headerlink" title="程序 4"></a>程序 <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></h1><ul>
<li><code>fgsm_attack.py</code>，使用 <code>fgsm</code> 算法制作对抗样本</li>
<li><code>resnet</code>，使用 <code>ResNet50</code> 制作对抗样本</li>
<li><code>vgg</code>，黑盒攻击，使用 <code>VGG16</code> 作为目标模型</li>
<li><code>eval.py</code>，验证目标模型在对抗样本攻击下的准确率</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>攻击模型</th>
<th>目标模型</th>
<th>原始准确率</th>
<th>L2攻击</th>
</tr>
</thead>
<tbody>
<tr>
<td>ResNet50</td>
<td>VGG16</td>
<td>94.27</td>
<td>53.63</td>
</tr>
</tbody>
</table>
</div>
<p>预训练模型<a href="https://github.com/laisimiao/classification-cifar10-pytorch" target="_blank" rel="noopener">下载</a>。</p>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><ul>
<li><code>python cw_attack.py</code>，制作对抗样本</li>
<li><code>python eval.py</code>，验证目标模型在对抗样本攻击下的准确率</li>
</ul>
<h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">https://arxiv.org/abs/1608.04644</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">https://arxiv.org/pdf/1312.6199.pdf</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">https://github.com/Harry24k/CW-pytorch/blob/master/CW.ipynb</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">https://github.com/muyuuuu/Adversarial-Attack/tree/main/CW_L2</span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>长白山之旅</title>
    <url>/2018/10/02/Chang-Bai-Mountain-2018-10-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="再逢明月照九州"><a href="#再逢明月照九州" class="headerlink" title="再逢明月照九州"></a>再逢明月照九州</h2><p>此为长白山之旅，纪念我20年来第一次离开河北省。</p>
<p>远山红叶，兰铃漫声，江空林染山，天远不宜秋。山高，林深，风景美。</p>
<p>山顶中的瞭望，击鼓与此，以至四方；天池中的仰望，淡泊明志，宁静致远；丛林的穿梭，古树下的许愿，没有飞黄腾达的兴趣，只有随心所欲不逾矩的追求。</p>
<a id="more"></a>
<p><img data-src="/2018/10/02/Chang-Bai-Mountain-2018-10-2/IMG_20181003_162152.jpg" alt><br><img data-src="/2018/10/02/Chang-Bai-Mountain-2018-10-2/IMG_20181003_162155.jpg" alt><br><img data-src="/2018/10/02/Chang-Bai-Mountain-2018-10-2/IMG_20181003_162157.jpg" alt><br><img data-src="/2018/10/02/Chang-Bai-Mountain-2018-10-2/IMG_20181003_162158.jpg" alt><br><img data-src="/2018/10/02/Chang-Bai-Mountain-2018-10-2/IMG_20181003_162159.jpg" alt><br><img data-src="/2018/10/02/Chang-Bai-Mountain-2018-10-2/IMG_20181003_162165.jpg" alt><br><img data-src="/2018/10/02/Chang-Bai-Mountain-2018-10-2/IMG_20181003_162166.jpg" alt><br><img data-src="/2018/10/02/Chang-Bai-Mountain-2018-10-2/IMG_20181003_162170.jpg" alt><br><img data-src="/2018/10/02/Chang-Bai-Mountain-2018-10-2/IMG_20181003_162174.jpg" alt><br><img data-src="/2018/10/02/Chang-Bai-Mountain-2018-10-2/IMG_20181003_162180.jpg" alt><br><img data-src="/2018/10/02/Chang-Bai-Mountain-2018-10-2/IMG_20181003_162187.jpg" alt><br><img data-src="/2018/10/02/Chang-Bai-Mountain-2018-10-2/IMG_20181003_162188.jpg" alt><br><img data-src="/2018/10/02/Chang-Bai-Mountain-2018-10-2/IMG_20181003_162192.jpg" alt></p>
]]></content>
      <categories>
        <category>东北风光</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>字符数组，字符串与数组名</title>
    <url>/2021/02/01/CharArray-vs-ArrayName-vs-String/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基础不牢，地动山摇。当初学C语言的时候，指针，数组等概念一直分不清楚，十分混乱。后期字符串与字符数组的出现更是云里雾里。现在学了C++，加上一些C++11后的特性数组，对这玩意的用法更加迷惑，时而<code>&amp;arr</code>时而<code>&amp;arr[0]</code>。今日来做个了结。</p>
<a id="more"></a>
<h1 id="字符与ASC码"><a href="#字符与ASC码" class="headerlink" title="字符与ASC码"></a>字符与ASC码</h1><p>我们知道在计算机内部，所有信息最终都是一个二进制值，这称为数字数据。而字符数据通常称为文本，如记事本文件，word文件等。计算机使用多种类型的编码方式来展示字符数据。其中之一的编码方式为ASC码，使用8个bit位来表示一个字符。所以，在计算机设备上显示的文档是经过ASC,Unicode或UTF-8编码后的一串二进制数字。我们可以通过以下程序来观察字符<code>A</code>的二进制：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a&#123;<span class="number">65</span>&#125;;</span><br><span class="line">  <span class="comment">// 十进制数字65 对应的 ASC 字符</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(a) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> b&#123;<span class="string">'b'</span>&#125;;</span><br><span class="line">  <span class="comment">// 字符对应的十进制数字</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(b)) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  <span class="comment">// 数字的二进制表示</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(b)) &lt;&lt;  <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h1><p>在C语言中没有专门的字符串变量，通常用一个字符数组来存放一个字符串，且以’\0’作为串的结束符。在C语言中，它有多种初始化方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> c1[] = &#123;<span class="string">"abcd"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> c2[] = <span class="string">"asdasd"</span>;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，C语言中数组名表示该数组的首地址，整个数组是以首地址开头的一块连续的内存单元。也就是，对于字符数组<code>c</code>而言，若从键盘读入，<code>scanf(&quot;%s&quot;, &amp;c)</code>是错误的，不应该取地址：<code>scanf(&quot;%s&quot;, c)</code>。在执行输出函数时，按数组<code>c</code>找到首地址，然后逐个输出数组中各个字符直到遇到字符串终止标志<code>\0</code>为止。自己不添加终止符时，编译器会帮你添加，但最好自己添加。</p>
<p>我们可以使用格式化字符串<code>%s</code>整体输出字符数组，这样不会尴尬的输出数组的首地址。但对于非字符型数组而言，输出的就是数组首地址了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, c);                     <span class="comment">// 打印字符数组</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;           <span class="comment">// 打印字符数组</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, c[<span class="number">0</span>]);                  <span class="comment">// 打印第一个字符</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> a[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);                     <span class="comment">// 打印数组首地址</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[<span class="number">0</span>]);                  <span class="comment">// 打印第一个元素</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="整型数组转字符数组整体输出"><a href="#整型数组转字符数组整体输出" class="headerlink" title="整型数组转字符数组整体输出"></a>整型数组转字符数组整体输出</h2><p>看了上面的代码，既然输出整型数组的数组名时，输出的是地址。总所周知数组名是指针，那么把<code>int*</code>的指针强制改为<code>char*</code>的指针会出现什么情况？这里需要注意的是：<code>int</code>占4个字节，<code>char</code>占一个字节，强制类型转化时，<code>char</code>类型的开头会是<code>0</code>，也就是C语言中字符数组的结尾。所以以下程序是没有反应的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下内存就懂了：<img data-src="https://static01.imgkr.com/temp/1b6ddc4ae3564c3181279eb4edf72855.png" alt></p>
<p>此时突发奇想，如果一定要按照<code>%s</code>格式的方法输出整型数组里面的全部内容，该如何实现呢？先补充点额外知识，假设有一个数据单元，长度是$n$个bit，那么两个数据单元就是$2n$个比特。如果让这两个数据单元内的数值一致，假设想要两个数据单元里面存储的都是$x$，那么写入的数据应该是：$x\times 2^n+x$。</p>
<p>如下图所示，长度为4的两个数据单元写入170时，两个数据单元内都是10。<img data-src="https://static01.imgkr.com/temp/d6e5c10f070442b1be13f34b6ee63e6e.png" alt></p>
<p>这样，使用<code>uint_16</code>（两个字节）类型转化为<code>char</code>类型是，就容易控制些了。因为<code>256*65+65=16705</code>，来个一次性输出整型数组内容的操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint16_t</span> a[] = &#123;<span class="number">16705</span>, <span class="number">16705</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(a));</span><br><span class="line">  <span class="comment">// 输出 AAAA  </span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，就不会在有<code>0x0</code>的存在打断输出了，且，整型的65会转换为<code>char</code>类型的<code>A</code>输出。</p>
<h1 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>我们接着往下看，虽然初学指针令人头疼，但掌握指针的确会对程序以及内存有更好的理解。内存可以看成一系列连续编址的单元，而指针是能存放地址的一组单元。假设指针<code>p</code>指向数据<code>c</code>，那么就<code>p = &amp;c</code>，可以画图为：</p>
<p><img data-src="https://static01.imgkr.com/temp/1aee647969ec440794730f2b5bb6e6fb.png" alt></p>
<p>可以使用一元运算符<code>*</code>来间接寻址，找到地址存储的内从，可以通过简单的程序来观察指针如何使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">  *p -= <span class="number">9</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在复杂一点点，可以通过传递参数的地址，来避免临时变量形参带来的问题，以交换数据为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* tmp1, <span class="keyword">int</span>* tmp2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp;</span><br><span class="line">  tmp = *tmp1;</span><br><span class="line">  *tmp1 = *tmp2;</span><br><span class="line">  *tmp2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">16</span>;</span><br><span class="line">  swap(&amp;a, &amp;b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>假设此时定义的数组为<code>int a[10]</code>，指针为<code>int* pa = &amp;a[0]</code>，那么指针<code>pa</code>指向了数组<code>a</code>的第0个元素，也就是说，<code>pa</code>的值为数组元素<code>a[0]</code>的地址。<strong>因为数组名所代表的就是数组最开始的一个元素的地址</strong>，所以<code>pa = &amp;a[0]</code>和<code>pa = a</code>等价。</p>
<p><img data-src="https://static01.imgkr.com/temp/764c42144a8e40ff95be9d37785ed077.png" alt></p>
<ul>
<li>数组引用的形式<code>a[i]</code>和<code>*(a + i)</code>也是一样的，表示取数组<code>a</code>的第<code>i</code>个元素</li>
<li><code>&amp;a[i]</code>和<code>a + i</code>的含义也是相同的，表示数组<code>a</code>的第<code>i</code>个元素的地址</li>
<li><code>pa[i]</code>和<code>*(pa + i)</code>也是一样的，表示取数组<code>a</code>的第<code>i</code>个元素</li>
<li>两者之间的不同之处在于，指针是一个变量，所以<code>pa++</code>是可以的，但<code>a++</code>是不行的，因为数组名不是变量。</li>
</ul>
<p>所以：如果在调用子函数时传递数组名，实际传递的是一个地址，因此子函数的<strong>形参应该为指针类型</strong>，假设写一个求字符串长度的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数类型为指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (len; *s != <span class="string">'\0'</span>; s++)&#123;</span><br><span class="line">        len ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"as 0 as"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-风格的数组"><a href="#C-风格的数组" class="headerlink" title="C++ 风格的数组"></a>C++ 风格的数组</h1><p>在使用C++的<code>array</code>数组时需要注意的是，假设生命的数组为：<code>std::array a{1, 2, 3, 4, 5};</code>，那么<code>&amp;a</code>表示取出a这个数组对象的地址，<code>&amp;a[0]</code>才是取出存储数组位置的首地址。看程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">array</span> a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 第三个元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(&amp;a[<span class="number">0</span>] + <span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* p = &amp;a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(p + i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h2><p>引用相当于给变量起了个外号，引用附着在存在的变量上。对引用做的读写操作，作用在原来变量上，所以引用在定义的时候就必须被初始化，否则引用不存在。</p>
<p>当引用作为参数传递时，在被调函数中，改变引用参数值，会改变实际参数的值。可以查看上文的交换变量的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_refer</span><span class="params">(<span class="keyword">int</span>&amp; tmp1, <span class="keyword">int</span>&amp; tmp2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp3 = <span class="number">0</span>;</span><br><span class="line">    tmp3 = tmp1;</span><br><span class="line">    tmp1 = tmp2;</span><br><span class="line">    tmp2 = tmp3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    a = c;</span><br><span class="line">    c = d;</span><br><span class="line">    d = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">swap(a, b);         <span class="comment">// 不会交换</span></span><br><span class="line">swap_refer(a, b);   <span class="comment">// 会交换</span></span><br><span class="line">swap_refer(a, <span class="number">4</span>);   <span class="comment">// 错误，引用没有可依赖的变量</span></span><br></pre></td></tr></table></figure>
<p>如果想要使<code>swap_refer(a, 4)</code>不报错，且函数的参数仍然是引用，这时需要引入常量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>&amp; tmp1, <span class="keyword">const</span> <span class="keyword">int</span>&amp; tmp2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp1 + tmp2;</span><br><span class="line">&#125;</span><br><span class="line">swap_refer(a, <span class="number">4</span>);   <span class="comment">// 正确 常量左值引用，可以绑定在右值上。</span></span><br></pre></td></tr></table></figure>
<p>使用引用或指针的优势是：避免传参过程中的变量拷贝带来额外的开销。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络原理</title>
    <url>/2019/06/12/Computer-network/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>距离计算机网络考试结束一周了。大概从计算机系挑几门讲的比较好的课的话，也只有《计算机组成及结构》、《计算机网络》和《数据库原理》了。</p>
<p>其他老师在念ppt。或者，感觉其他任课老师当老师只是个养老的副业，主业是外面的公司或者项目。</p>
<p>先挖个坑，计算机的几大浪漫：《计算机组成及结构》，《操作系统》，《数据结构》，《编译原理》，《计算机接口》，《数据库原理》在之后会逐渐填完的。</p>
<p>顺便还能解答几个疑问：为什么有的时候网速慢，有时候网速快？为什么上网要有modem（俗称猫，专业术语是调制解调器）？校园网为什么要去联通or移动办理业务才能上网？本地网和外网如何接通？如何屏蔽某网？QQ发送的消息为啥不会出错？如何从网页上下载文档？什么是网卡？为何连不上校园网但是能连手机热点？</p>
<p>以下内容纯属为作者背写的，理解的，并非考试重点。可能词汇不够严谨，但思维和观念是易于理解的。</p>
<p>中间出了点插曲，写的内容过于详细发现写不完了，于是，写了个粗暴的汇总版本。关于其中具体的知识，还建议查阅相关书籍，不要企图靠网络资源能学会什么东西。</p>
<a id="more"></a>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/ad820267da1c" target="_blank" rel="noopener">https://www.jianshu.com/p/ad820267da1c</a></p>
<p>互联网相隔n公里路的两台计算机，是如何进行数据的传送的呢？在成千上万台的计算机中，一台计算机是如何正确着找到另外一个计算机，并把数据传给它的呢？</p>
<p>学过计算机网络的同学可能知道，在这互联网中，计算机与计算机之间的数据传送，主要是基于各种“协议”串联起来的。不过今天要讲的，并不会详细去讲各种协议，而是通过各种简化之后，让你大概知道数据之间传送的原理。</p>
<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>互联网中数据的传送，其实分为好几层来处理数据的，每一层有它自己明确的功能。例如就像流水线生产一样，一部分人负责这部分的工作，处理完之后就把剩余的工作扔给另外一部分人来处理……</p>
<p>对于互联网数据传送的分层模型，有分成七层的，有分成5层的，还有分成4层的。例如分成七层模型的如下(从上到下)：应用层，传输层，网络层，数据链路层，物理层。五层中，越往下越靠近计算机底层，越往上越靠近用户。通信模型如下图所示</p>
<p><img data-src="/2019/06/12/Computer-network/network.png" alt></p>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>一台计算机与另一台计算机要进行通信，第一件要做的事是什么？当然是要把这台计算机与另外的其他计算机连起来啊，例如可以通过光纤啊，电缆啊，双绞线啊等物体把他们联起来。然后才能进行通信，也就是说，物理层负责把两台计算机连起来，然后在计算机之间传送 0，1 这样的电信号。</p>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>前面说了，物理层它只是单纯着负责在计算机之间传输 0，1 这样的电信号。假如这些 0，1 组合的传送毫无规则，计算机是解读不了的。因此，我们需要制定一套规则来进行 0，1 的传送。例如多少个电信号为一组啊，每一组信号应该如何标识才能让计算机读懂啊等。</p>
<p>数据链路层工作在物理层之上，负责给这些 0，1 制定传送的规则，然后另一方再按照相应的规则来进行解读。</p>
<h2 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h2><p>以太网协议规定，一组电信号构成一个数据包，把这个数据包称之为“桢”。每一个桢由标头(Head)和数据(Data)两部分组成。这个桢的最大长度是1518个字节，最小长度为64字节。假如需要传送的数据很大的话，就分成多个桢来进行传送。</p>
<p>对于表头和数据这两个部分，他们存放的都是一些什么数据呢？我猜你眯着眼睛都能想到他们应该放什么数据。 毫无疑问，我们至少得知道这个桢是谁发送，发送给谁的等这些信息吧？所以标头部分主要是一些说明数据，例如发送者，接收者等信息。而数据部分则是这个数据包具体的，想给接受的内容。</p>
<p>大家想一个问题，一个桢的长度是64~1518个字节，也就是说桢的长度不是固定的，那你觉得标头部分的字节长度是固定的吗？它当然是固定的啊，假如不是固定的，每个桢都是单独发的，那计算机怎么知道标头是几个字节，数据是几个字节。所以标头部分的字节是固定的，并且固定为18个字节。</p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>把一台计算的的数据通过物理层和链路层发送给另一台计算机，究竟是谁发给谁的，计算机与计算机之间如何区分，你总得给他们一个唯一的标识吧？</p>
<p>这就是MAC地址，连入网络的每一个计算机都会有网卡接口，每一个网卡都会一个地址，这个地址就叫做MAC地址。计算机之间的数据传送，就是通过MAC地址来唯一寻找、传送的。MAC地址在网卡生产是就被唯一标识了。</p>
<h2 id="广播与ARP协议"><a href="#广播与ARP协议" class="headerlink" title="广播与ARP协议"></a>广播与ARP协议</h2><p>假如计算机A知道了计算机B的MAC地址，然后计算机A想要给计算机B传送数据，虽然计算机A知道了计算机B的MAC地址，可是它要怎么给它传送数据呢？计算机A不仅连着计算机B，而且计算机A顺着网线可能还连着其他的计算机C， D， E， F。 虽然计算机A知道计算机B的MAC地址，可是计算机A是无法知道计算机B是分布在哪边路线上的。实际上，计算机A是通过广播的方式把数据发送给计算机B。在同一个子网中，计算机A要向计算机B发送一个数据包，这个数据包包含接收者的MAC地址。这个时候同一个子网中的计算机 C，D 也会收到这个数据包的，然后收到这个数据包的计算机，会把数据包的MAC地址取出来，与自身的MAC地址对比，如果两者相同，则接受这个数据包，否则就丢弃这个数据包。这种发送方式我们称之为广播，就像我们平时在广场上通过广播的形式呼叫某个人一样。</p>
<p>那么问题来了，计算机A是如何知道计算机B的MAC地址的呢？这个时候就得由ARP协议这个家伙来解决了，不过ARP协议会涉及到IP地址，不过我们下面才会扯到IP地址。因此我们先放着，就当作是有这么一个ARP协议，通过它我们可以知道子网中其他计算机的MAC地址。</p>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>上面我们有说到子网这个关键词，实际上我们所处的网络，是由无数个子网络构成的。广播的时候，也只有同一个子网里面的计算机能够收到。假如没有子网这种划分的话，计算机A发一个数据包给计算机B，其他所有计算机也都能收到这个数据包，然后进行对比再舍弃。世界上有那么多它计算机，每一台计算机都能收到其他所有计算机的数据包，那就不得了了。那还不得奔溃。 因此产生了子网这么一个东西。</p>
<p>那么问题来了，我们如何区分哪些MAC地址是属于同一个子网的呢？假如是同一个子网，那我们就用广播的形式把数据传送给对方，如果不是同一个子网的，我们就会把数据发给网关，让网关进行转发。</p>
<p>为了解决这个问题我们引入了一套新的地址协议，这个地址协议能够帮助我们区分MAC地址是否处于同一个子网中。这也是网络层负责解决的问题。</p>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>这个协议就是IP协议，它所定义的地址，我们称之为IP地址。IP协议有两种版本，一种是IPv4，另一种是IPv6。不过我们目前大多数用的还是IPv4，我们现在也只讨论IPv4这个版本的协议。</p>
<p>这个IP地址由32为的二进制数组成，我们一般把它分成4段的十进制表示，地址范围为0.0.0.0~255.255.255.255</p>
<p>每一台想要联网的计算机都会有一个IP地址。这个IP地址被分为两部分，前面一部分代表网络部分，后面一部分代表主机部分。并且网络部分和主机部分的二进制位数是不固定的。</p>
<p>假如两台计算机的网络部分是一模一样的，我们就说这两台计算机是处于同一个子网中。例如192.168.43.1和192.168.43.2，假如这两个IP地址的网络部分为24为，主机部分为8位。那么他们的网络部分都为192.168.43，所以他们处于同一个子网中。</p>
<p>可是问题来了，你怎么知道网络部分是占几位。也就是说，单单从两台计算机的IP地址，我们是无法判断他们的是否处于同一个子网中的。</p>
<p>这就引申出了另一个关键词————子码掩码。子码掩码和IP地址一样也是32位二进制数，不过它的网络部分规定全部为1，主机部分规定全部为0.也就是说，假如上面那两个IP地址的网络部分为24为，主机部分为8为的话，那他们的子码掩码都为11111111.11111111.11111111.00000000，即255.255.255.0。</p>
<p>那有了子字码掩码，如何来判端IP地址是否处于同一个子网中呢。显然，知道了子码掩码，相当于我们知道了网络部分是几位，主机部分是几位。我们只需要把IP地址与它的子码掩码做与(and)运算，然后把各自的结果进行比较就行了，如果比较的结果相同，则代表是同一个子网，否则不是同一个子网。</p>
<p>例如，192.168.43.1和192.168.43.2的子码掩码都为255.255.255.0，把IP与子码掩码相与，可以得到他们都为192.168.43.0，进而他们处于同一个子网中。</p>
<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>有了上面IP协议的知识，我们回来讲一下ARP协议。<br>有了两台计算机的IP地址，我们就可以判断出它们是否处于同一个子网之中。 假如他们处于同一个子网之中，计算机A要给计算机B发送数据时。我们可以通过ARP协议来得到计算机B的MAC地址。ARP协议也是通过广播的形式给同一个子网中的每台电脑发送一个数据包(当然，这个数据包会包含接收方的IP地址)。对方收到这个数据包之后，会取出IP地址与自身的对比，如果相同，则把自己的MAC地址回复给对方，否则就丢弃这个数据包。这样，计算机A就能知道计算机B的MAC地址了。</p>
<p>可能有人会问，知道了MAC地址之后，发送数据是通过广播的形式发送，询问对方的MAC地址也是通过广播的形式来发送，那其他计算机怎么知道你是要传送数据还是要询问MAC地址呢？其实在询问MAC地址的数据包中，在对方的MAC地址这一栏中，填的是一个特殊的MAC地址，其他计算机看到这个特殊的MAC地址之后，就能知道广播想干嘛了。</p>
<p>假如两台计算机的IP不是处于同一个子网之中，这个时候，我们就会把数据包发送给网关，然后让网关让我们进行转发传送</p>
<h2 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h2><p>这里再说一个问题，我们是如何知道对方计算机的IP地址的呢？这个问题可能有人会觉得很白痴，心想，当然是计算机的操作者来进行输入了。这没错，当我们想要访问某个网站的时候，我们可以输入IP来进行访问，但是我相信绝大多数人是输入一个网址域名的，例如访问百度是输入www.baidu.com这个域名。其实当我们输入这个域名时，会有一个叫做DNS服务器的家伙来帮我们解析这个域名，然后返回这个域名对应的IP给我们的。</p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>虽然我们已经把数据成功从计算机A传送到计算机B了，可是，计算机B里面有各种各样的应用程序，计算机该如何知道这些数据是给谁的呢？</p>
<p>这个时候，端口(Port)这个家伙就上场了，也就是说，我们在从计算机A传数据给计算表B的时候，还得指定一个端口，以供特定的应用程序来接受处理。<br>也就是说，传输层的功能就是建立端口到端口的通信。相比网络层的功能是建立主机到主机的通信。</p>
<p>也就是说，有了IP和端口，我们就可以进行通信了。这个时候可能有人会说，我输入IP地址的时候并没有指定一个端口啊。其实呢，对于有些传输协议，已经有设定了一些默认端口了。例如http的传输默认端口是80，这些端口信息也会包含在数据包里的。</p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>终于说到应用层了，应用层这一层最接近我们用户了。</p>
<p>虽然我们收到了传输层传来的数据，可是这些传过来的数据五花八门，有html格式的，有mp4格式的，各种各样。你确定你能看的懂？</p>
<p>因此我们需要指定这些数据的格式规则，收到后才好解读渲染。而应用层的功能，就是用来规定应用程序的数据格式的。</p>
<p>五层模型至此讲到这里。对于有些层讲的比较简洁，就随便概况了一下。如果你想详细去了解，可以去买计算机网络相应的资料。希望我的讲解能让你对计算机之间数据的传输有个大概的了解。</p>
]]></content>
      <tags>
        <tag>Computer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++数据结构篇『二』顺序容器：向量、链表与双端队列</title>
    <url>/2019/05/01/Cpp-Sequential-Container/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>发现每个数据结构都单独成文会显得文章有点多，且内容不充实。于是决定分组放了，下一部分就是『集合、映射和栈了』，基础数据结构复习完毕后，刷题就提上日程。在进入之前，先扯一点STL的东西。</p>
<a id="more"></a>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>Standard template library，C++标准库的重要组成部分，由这几部分组成：</p>
<ul>
<li>容器：保存一组数据，各种各样的类型，数据个体是元素。</li>
<li>迭代器：一种泛型指针，和容器共同使用，访问容器中的元素(非下标)。是将*, ++, -&gt;进行了重载的类模板，不同容器的迭代器不一样。</li>
<li>算法：操作容器里面数据的一种方法，和具体容器无关。查找，排序，替换等。</li>
<li>函数对象</li>
<li>空间分配器</li>
</ul>
<h2 id="容器分类"><a href="#容器分类" class="headerlink" title="容器分类"></a>容器分类</h2><ul>
<li>顺序容器：线性数据结构，<code>vector, list, deque</code>，多个元素的有序集合，元素有前有后</li>
<li>关联容器：非线性数据结构，<code>map, set</code>，多个元素的无序集合，元素无前无后，用于存储键值对</li>
<li>容器适配器：依赖顺序容器的受限版本，处理特殊情况。<code>stack, queue, priority_queue</code>。</li>
</ul>
<ul>
<li>vector，直接访问任意元素，快速插入、删除尾部元素</li>
<li>deque，直接访问任意元素，快速插入、删除头部和尾部元素，但开销大</li>
<li>list，快速插入删除任意位置的元素，不能使用数组下标，所以没办法访问任意位置元素</li>
<li>set，快速查询元素，无重复关键字</li>
<li>multiset，允许重复关键字</li>
<li>map，键值对，不允许重复关键字，使用关键字快速查询元素</li>
<li>multimap，允许重复关键字</li>
<li>stack，后进先出</li>
<li>queue，先进先出</li>
<li>priority_queue，元素出队顺序取决于优先级的队列</li>
</ul>
<p>所有容器的共同函数：</p>
<ul>
<li>构造函数</li>
<li>拷贝函数</li>
<li>empty()判空</li>
<li>size()元素数目</li>
<li>operator()=将容器复制</li>
<li>>, &lt;, ==, !=的判断</li>
</ul>
<p>一级容器的共同函数（顺序容器+关联容器）：</p>
<ul>
<li>a.swap(b)交换</li>
<li>a.max_size()最大容纳的元素数量</li>
<li>clear()删除</li>
<li>begin()返回容器首元素的迭代器</li>
<li>end()返回容器尾元素之后位置的迭代器</li>
<li>rbegin()容器最后位置的迭代器，逆序遍历</li>
<li>rend()容器首元素之前位置的迭代器</li>
<li>erase(begin, end)删除[begin, end-1]位置的元素，两者都是迭代器</li>
</ul>
<h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><ul>
<li>随机迭代器：vector，deque（双端队列）</li>
<li>双向迭代器：list</li>
<li>vector：一端操作的数组，满了之后申请新的数组，并拷贝原有数组</li>
<li>deque：双端操作，先入先出，内部有多个数组容纳新的元素</li>
<li>list：若干节点，节点有两个指针，有前驱和后继，插入和删除快</li>
</ul>
<p>共同函数：</p>
<ul>
<li>assign(n, elem)元素做n份拷贝，覆盖原有内容</li>
<li>assign(beg, end)迭代器[beg, end)之间的元素赋值给当前容器</li>
<li>push_back尾部添加</li>
<li>pop_back删除尾部</li>
<li>front返回首部</li>
<li>back返回尾部</li>
<li>insert(pos, elem)元素插入到指定位置</li>
</ul>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p>使用key快速存取元素，元素按默认规则进行排序。共同函数：</p>
<ul>
<li>find(key)搜索容器中具有key的元素，返回指向的迭代器，没找到返回指向容器最后一个元素后面的迭代器</li>
<li>lower_bound(key)搜索具有key的第一个元素，返回指向元素的迭代器</li>
<li>upper_bound(key)搜索具有key的最后一个元素，返回指向元素之后位置的迭代器</li>
<li>count(key)具有key元素的数量</li>
</ul>
<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>相对于<code>array</code>数组大小固定不能动态变化的缺陷，<code>vector</code>能很好的避免这一点。同<code>array</code>，使用时需要引入头文件，并在<code>std</code>空间中声明。</p>
<h2 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">double</span> values[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="comment">// values 是数组首地址的指针，这里隐式转换为迭代器</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">v</span><span class="params">(values, values + <span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="comment">// 也可以 resize 重新制定大小</span></span><br><span class="line">v.resize(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 也可以直接赋值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v5 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支持随机访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign 用法 分配 3 个 11.8</span></span><br><span class="line">v.assign(<span class="number">3</span>, <span class="number">11.8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机访问</span></span><br><span class="line">v.at(<span class="number">0</span>) = <span class="number">22.4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::iterator itr = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// 1 号元素之前</span></span><br><span class="line">v.insert(itr + <span class="number">1</span>, <span class="number">321</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert 之后，itr可能指歪了，所以重新赋值</span></span><br><span class="line">itr = v.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素，区间左闭又开</span></span><br><span class="line">v.erase(itr, itr + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空与判空</span></span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">if</span> (v.empty())&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"True"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问第一个元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v5.front() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="comment">// 访问最后一个元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v5.back() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="comment">// 删除最后一个元素</span></span><br><span class="line">v5.pop_back(); </span><br><span class="line"><span class="comment">// 加入一个元素并把它放在最后</span></span><br><span class="line">v5.push_back(<span class="number">6</span>); </span><br><span class="line"><span class="comment">// 删除索引为3的元素</span></span><br><span class="line">v5.erase(v5.<span class="built_in">begin</span>() + <span class="number">3</span>);  </span><br><span class="line"><span class="comment">// 连续插入 7 个 8</span></span><br><span class="line">v5.insert(v5.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">// 判断容器中元素的数量   </span></span><br><span class="line">v5.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<p>也许你会有疑问，<code>insert</code>可以在队首插入元素，为啥<code>vector</code>还是单端操作的容器呢？因为<code>push_back</code>只会在队尾追加元素，不到迫不得已<code>vector</code>是不会在内存中移动的，除非申请新的空间或删除大部分元素。而<code>insert</code>会强制<code>vector</code>去移动元素，这就造成了大量的内存开销。这里脑补『数据结构』中顺序结构插入元素时，其它元素的移动吧。或者这里的<a href="https://stackoverflow.com/questions/13324431/c-vectors-insert-push-back-difference" target="_blank" rel="noopener">回答</a>。</p>
<h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><p>de表示单词double，que取自单词queue，表示这是可以双端操作的队列。因其开销较大，所以一般使用<code>vector</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">double</span> values[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="comment">// values 是数组首地址的指针，这里用作迭代器</span></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt; <span class="title">q</span><span class="params">(values, values + <span class="number">7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他和 vector 类似</span></span><br><span class="line"><span class="comment">// insert, erase 等改变元素数量的操作可能会导致迭代器失效</span></span><br><span class="line"><span class="comment">// 所以要重新赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队首操作</span></span><br><span class="line">q.push_front(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : q)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">q.pop_front();</span><br><span class="line">q.pop_back();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : q)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p><code>list</code>是链表，众所周知链式结构不支持随机访问。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;     // 引入头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明与初始化</span></span><br><span class="line">    <span class="keyword">int</span> values[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(values, values + <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持随机访问</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator p;</span><br><span class="line">    <span class="keyword">for</span> (p = l.<span class="built_in">begin</span>(); p != l.<span class="built_in">end</span>(); p++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list 插入后，迭代器所指内容不受影响，仍然指向上次所指的内容</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator itr = l.<span class="built_in">begin</span>();</span><br><span class="line">    itr ++;</span><br><span class="line">    l.insert(itr, <span class="number">90</span>);</span><br><span class="line">    <span class="keyword">for</span> (p = l.<span class="built_in">begin</span>(); p != l.<span class="built_in">end</span>(); p++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *itr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push_front, pop_back, pop_front 一样</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="list特有"><a href="#list特有" class="headerlink" title="list特有"></a>list特有</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list 特有，升序和反转</span></span><br><span class="line">l.sort();</span><br><span class="line">l.reverse();</span><br><span class="line"><span class="keyword">for</span> (p = l.<span class="built_in">begin</span>(); p != l.<span class="built_in">end</span>(); p++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 特有，有序链表的合并</span></span><br><span class="line"><span class="keyword">int</span> values1[] = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l1</span><span class="params">(values1, values1 + <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">l.sort();</span><br><span class="line"><span class="comment">// merge 后 l1 被清空</span></span><br><span class="line">l.merge(l1);</span><br><span class="line"><span class="keyword">for</span> (p = l.<span class="built_in">begin</span>(); p != l.<span class="built_in">end</span>(); p++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有和 90 相等的元素</span></span><br><span class="line">l.<span class="built_in">remove</span>(<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">p = l.<span class="built_in">end</span>();</span><br><span class="line">l1.push_back(<span class="number">32</span>);</span><br><span class="line"><span class="comment">// 列表插入到指定位置 同样 l1 被清空</span></span><br><span class="line">l.splice(p, l1);</span><br><span class="line"><span class="keyword">for</span> (p = l.<span class="built_in">begin</span>(); p != l.<span class="built_in">end</span>(); p++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中protected继承的成员放到public域下面好不好？</title>
    <url>/2021/01/29/Cpp-public-vs-protected/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>众所周知</p>
<ul>
<li><code>public</code> 继承时，所有的基类成员的访问属性在派生类中不会改变。派生类中只能访问基类的 <code>public</code> 和 <code>protected</code> 成员，不能访问 <code>private</code> 成员；在外部派生类对象只能访问 <code>public</code> 的成员；</li>
<li><code>protected</code> 继承时，基类的 <code>public</code> 成员到派生类中变成 <code>protected</code>，其余成员的属性不变。派生类只能访问基类的 <code>public</code> 和 <code>protected</code> 成员；在类的外面，派生类无法访问基类的任何成员。</li>
</ul>
<p>但覆写抽象类（形状）的纯虚函数（求面积）时，想在派生类（三角形）的外面调用成员（求面积）。如果求面积的方法位于 <code>protected</code> 域，此时需要把覆写的成员移动到 <code>public</code> 域下面，这样好吗？还是说，采取某些手段，仍然保持覆写的成员在 <code>protected</code> 域下面？</p>
<p><del>如果看不懂本文提到的概念，请回去补C++基础。</del></p>
<a id="more"></a>
<h1 id="派生类的同名函数"><a href="#派生类的同名函数" class="headerlink" title="派生类的同名函数"></a>派生类的同名函数</h1><p>先引入一丢丢其它的知识，在循序渐进到本文开篇的问题。假设一个场景，许多派生类源自一个基类，但每个类的展示信息是不一样的。现在写一个叫 <code>print</code> 的函数，用于打印不同类的信息。利用继承中的重定义函数，注意不是重载，来隐藏基类中的同名函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"I am base"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"I am A"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"I am B"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">show</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"I am C"</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>什么？你要每个类中功能一致的函数不同名？不嫌累么，之后会讲覆写，同名函数会简化程序的开发流程。</del></p>
<p>假设我要打印信息了。如果直接利用类型信息来重载函数，每个类型都需要写一个函数，有多少类就需要写多少函数（这里是重载），但这样会很麻烦：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Base* b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b-&gt;show() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(A* a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a-&gt;show() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(B* b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b-&gt;show() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(C* c)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c-&gt;show() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p>为避免上述情况的发生，可以借助虚函数来简化代码。虚函数的用途就是：<strong>支持动态联编，可以访问指针指向的对象的成员</strong>。在基类中通过关键字 <code>virtual</code> 来声明虚函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Base"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 关键字可写可不写 </span></span><br><span class="line">    <span class="comment">// 指明覆写，函数内容一致，避免语法错误</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时的 <code>print</code> 函数会变得很简单，避免大量无聊的重复代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用传参 发生了动态类型的隐式转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Base&amp; p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.show() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Base a; B b; C c;</span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line">    <span class="built_in">print</span>(b);</span><br><span class="line">    <span class="built_in">print</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，不同类型的实体对同一消息有不同的响应，<strong>这就是多态</strong>。上述程序在多态期间会发生一个叫<strong>联编</strong>的过程，即将源代码中的函数调用解释为执行特定的函数代码块，也就是说，确定到底该执行哪个函数。分为静态联编和动态联编：</p>
<ul>
<li>静态联编：编译器查看参数和参数名，如函数重载、非虚方法根据指针类型确定调用函数等，在编译时期确定该执行哪个方法，上面展示的一堆 <code>print</code> 函数就是静态联编；</li>
<li>动态联编：运行时才能确定调用哪个函数，使用虚方法实现，程序调用基类对象的指针或引用指向对象的对应<strong>同名虚函数</strong>。</li>
</ul>
<p>这时我们在派生类中重定义一个与基类中虚函数同名的虚函数，称为覆写。建议写上关键字 <code>override</code>，这会对函数名、类型、参数进行检查，防止低级错误的出现。当然虚函数不是必须需要覆写的，<strong>纯虚函数</strong>才需要。关于虚方法涉及的联编，在细节一下：</p>
<ul>
<li>如果一个方法不是虚方法，那么将根据引用类型或指针类型选择执行的方法，静态联编</li>
<li>如果一个方法是虚方法，将根据指针或引用指向对象的类型选择执行的方法，动态联编</li>
</ul>
<h2 id="虚函数的注意事项"><a href="#虚函数的注意事项" class="headerlink" title="虚函数的注意事项"></a>虚函数的注意事项</h2><p>对于指针或引用该调用哪个虚函数，这里有一些注意事项：</p>
<ul>
<li>基类对象的指针或引用指向派生类，这叫向上强制类型转换；父类有的子类一定有，允许转换</li>
<li>派生类对象的指针或医用指向基类，这叫向下强制类型转换；子类有的父类不一定有，不允许转换</li>
<li>只有成员才能是虚函数，所以友元函数不能是虚函数</li>
<li>基类的构造函数不能是虚函数；而基类的析构函数推荐写成虚函数</li>
<li>调用的函数不由指针类型决定，由指针所指的实际对象的类型决定该调用哪个类的函数</li>
<li>运行时，检查指针所指对象的类型，如果该类型重定义了虚函数，则使用，否则使用基类的虚函数</li>
<li>可以使用纯虚函数将类声明为抽象类，不能定义函数，也不能实例化抽象类</li>
<li>虚函数的重定义不会生成函数的重载版本，子类的同名函数会隐藏基类的函数。所以，继承中重定义虚函数时，要保证除返回值以外的其它函数原型相同，这称为返回型协变</li>
<li>如果想实现虚函数的重载，那么要从基类开始。如果基类的某个虚函数是重载的，那么子类要重定义所有版本，否则无法使用。如果不需要重定义，只需要调用基类的版本：<code>void A::show() {Base::show();}</code></li>
<li>虚函数的传递性：如果基类定义了虚函数，那么派生类的同名函数自动变为虚函数，所以派生类可以不写 <code>virtual</code> 关键字，写上会更清楚</li>
<li>如果一不小心写错了，且没有关键字 <code>override</code> 早检查，比如派生类中 <code>show</code> 写成了 <code>Show</code>，那么不执行自己的虚函数，转而执行基类的虚函数</li>
</ul>
<p><code>override</code> 是标志符，指定虚函数覆写另一个虚函数。注意事项：</p>
<ul>
<li><code>void foo() const override</code> 不能覆写 <code>void foo()</code>，类型不匹配</li>
<li>不能覆写非虚函数</li>
<li><code>override</code> 避免写出 <code>bug</code> 的代码，参考上述内容最后一条</li>
</ul>
<h2 id="如何实现虚函数"><a href="#如何实现虚函数" class="headerlink" title="如何实现虚函数"></a>如何实现虚函数</h2><p>如图所示：</p>
<p><img data-src="https://z3.ax1x.com/2021/07/21/WwtQMD.png" alt></p>
<p>编译器给每个对象添加一个隐藏成员，隐藏成员中保存一个指向函数地址的数组的指针，这种数组就是虚函数表。虚函数表存储为类进行声明的虚函数的地址。如 <code>Base</code> 类，包含一个指针，指向这个虚函数表。派生类也有指向<strong>独立地址表</strong>的指针，如果派生类提供了虚函数的定义，那么该虚函数表就保存为新的函数的地址，如 <code>A</code> 函数；如果没有定义，就保留基类的虚函数的地址，如 <code>B</code> 函数。</p>
<p>因此我们可以知道静态联编和动态联编各有优缺点：</p>
<ul>
<li>动态联编是程序在运行阶段决策，造成额外的开销，如虚函数表等，涉及的类、对象会增大，函数调用时的查表也会造成开销；</li>
<li>静态联编效率高，可以在编译时期进行优化，是 C++ 的默认选择</li>
</ul>
<p>如果不需要覆写基类的任何方法，就不需要动态联编，因此仅将预期的方法定义为虚的。</p>
<h1 id="protected-继承"><a href="#protected-继承" class="headerlink" title="protected 继承"></a>protected 继承</h1><p>回到最初的问题，假设有个抽象类 <code>shape</code> 形状，包括三角形、矩形、圆形等。形状类提供两个纯虚函数，一个是求面积，一个是展示信息。当声明为纯虚函数时，其子类必须覆写纯虚函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>公有继承时，可以这么写，十分简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle()=<span class="keyword">default</span>;</span><br><span class="line">    Circle(<span class="keyword">double</span> r)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;radius * <span class="keyword">this</span>-&gt;radius * <span class="number">3.14</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Circle"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果是保护继承，那么是保持覆写函数的所在域的一致还是不一致呢？一致的话是在 <code>protected</code> 域内，不一致是在 <code>public</code> 域内，两种写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">protected</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;radius * <span class="keyword">this</span>-&gt;radius * <span class="number">3.14</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Circle"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>放到 <code>protected</code> 域内时，这样保持了 <code>protected</code> 继承的一致性。但考虑到在类外调用，需要改写一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">protected</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCircle</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;getArea();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showCircle</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;show();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;radius * <span class="keyword">this</span>-&gt;radius * <span class="number">3.14</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Circle"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样，如果我们在写 <code>print</code> 展示信息的函数，那么又要回到<strong>每个类都需要单独写一个函数</strong>的繁琐场景，不能使用动态联编的优良特性，这并不推荐。所以，个人建议，在 <code>protected</code> 继承时，如果要覆写函数且需要在外部调用，那么将需要覆写的函数放到 <code>public</code> 域下，这样会更简洁。给个完整代码感受一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle()=<span class="keyword">default</span>;</span><br><span class="line">    Circle(<span class="keyword">double</span> r)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;radius * <span class="keyword">this</span>-&gt;radius * <span class="number">3.14</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Circle"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> side = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rectangle()=<span class="keyword">default</span>;</span><br><span class="line">    Rectangle(<span class="keyword">double</span> s)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;side = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;side * <span class="keyword">this</span>-&gt;side; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要写一次 调用 show 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Shape&amp; p)</span></span>&#123;</span><br><span class="line">    p.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 错误 抽象类不能实例化</span></span><br><span class="line">    <span class="comment">// Shape s;</span></span><br><span class="line">    Circle c&#123;<span class="number">3.2</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c.getArea() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shape* p = &amp;c;</span></span><br><span class="line">    Circle* p = &amp;c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p-&gt;getArea() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Rectangle r&#123;<span class="number">2.0</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r.getArea() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(c);</span><br><span class="line">    <span class="built_in">print</span>(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，直接 <code>public</code> 继承多省事：</p>
<p><img data-src="/2021/01/29/Cpp-public-vs-protected/1.png" alt></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的引用</title>
    <url>/2021/07/15/Cpp-refer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>引用是 C++ 中一个比较神奇的东西。在这之前或者说 C 语言中，一般是使用指针来减少传参所带来的不必要的开销。如函数传递的参数是数组或结构体时，使用指针会省很多事，毕竟传递的是地址。而 C++ 中引用变量的主要用途也是函数传参，子函数直接操作原始数据，而不是其副本，这样处理大型数据结构也会佷便捷。</p>
<a id="more"></a>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>以一维数组为例。众所周知数组名是是数组首元素的地址。因此调用子函数时，主函数传递的是数组首元素的地址，所以子函数接收的是地址，无法预知数组的长度，需要增加额外的参数指明数组元素的数量。</p>
<p>对于函数，一般用 <code>int arr[]</code> 这样的形式指明 <code>arr</code> 接收的是数组，这样的可读性强；换一种方法，因为传递的是数组首元素的地址，而数组首元素为 <code>int</code> 类型，地址是 <code>int*</code> 类型，因此可以用 <code>int* arr</code> 来接收一个数组，但是这样表意不明确。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        t += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    sum(arr, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>升级到二维数组，二维数组的类型本质就是指向『多个 <code>int</code> 组成的数组』的指针，因此参数的形式为 <code>int (*arr)[4]</code>，而不是 <code>int* arr[4]</code>。</p>
<ul>
<li>前者是一个『由 4 个指向 int 的指针』组成的数组；即一个数组，数组元素是四个 int 指针；</li>
<li>后者是一个指向『由 4 个 int 组成数组』的指针；即一个指针，指向 4 个 int 的数组。为了更好的可读性，一般声明如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">4</span>], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            t += arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 数组有三个元素，每个元素是数组</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line">    sum(arr, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>二维数组的指针是不是感觉有点晕？先来看一下简单的引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a&#123;<span class="number">11</span>&#125;;</span><br><span class="line"><span class="comment">// 类型是 int&amp;，指向 int 的引用</span></span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br></pre></td></tr></table></figure>
<p>这样 <code>b</code> 和 <code>a</code> 就指向了相同的值和内存单元，只是名字不一样。此外，引用必须在声明的时候进行初始化，否则这个变量不知道指向哪个内存单元和值，但是指针可以先声明在赋值。</p>
<p>此外，声明一旦绑定，就无法在修改。可以通过初始化声明来设置引用，不能通过赋值来设置。如下所示的程序，只是对引用 <code>b</code> 进行了赋值，而不是修改引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a&#123;<span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line"><span class="keyword">int</span> c&#123;<span class="number">32</span>&#125;;</span><br><span class="line">b = c;</span><br></pre></td></tr></table></figure>
<h2 id="引用传参"><a href="#引用传参" class="headerlink" title="引用传参"></a>引用传参</h2><p>回到主题，一般将引用用做函数传参时。主函数中的变量名是被调用函数中对应变量的别名，在调用时用实参初始化形参，因此引用参数被初始化为：函数调用时传递过来的实参。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n1&#123;<span class="number">12</span>&#125;, n2&#123;<span class="number">21</span>&#125;;</span><br><span class="line">swap(n1, n2);</span><br></pre></td></tr></table></figure>
<p>此外，传递引用时对类型的限制更加严格，以求和函数为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">12</span>&#125;;</span><br><span class="line"><span class="comment">// 临时变量</span></span><br><span class="line">sum(a);</span><br><span class="line">sum(<span class="number">6.2</span>);</span><br><span class="line"><span class="comment">// 临时变量</span></span><br><span class="line">sum(a + <span class="number">6.3</span>);</span><br></pre></td></tr></table></figure>
<p>换句话说，当实参和形参的类型不匹配时，将会生成临时变量传给形参。但是引用则不行，限制相对严格，<code>sum(a + 6.3)</code> 会报错，传递的实参是表达式不是变量，而引用不能绑定到表达式上，且此时不会生成临时变量。</p>
<p>但是当参数为 const 引用时，会创建一个临时的无名变量，临时变量的值初始化为 <code>a + 6.3</code>，而后再将无名变量赋给引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a&#123;<span class="number">10</span>&#125;;</span><br><span class="line">    sum(a + <span class="number">6.3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许你会有疑问，这个时候为什么会生成临时变量？<code>const</code> 为什么合理呢？如果引用参数是 <code>const</code>，两种情况会生成临时变量：</p>
<ul>
<li>实参类型正确，但不是左值，如 <code>a + 6.3</code> 这样的表达式</li>
<li>实参类型不正确，但可以转为正确类型，如 <code>int</code> 隐式转换为 <code>double</code>；<code>double</code> 到 <code>int</code> 则错误</li>
</ul>
<blockquote>
<p>左值：左值是可以被引用的数据对象，变量、数组、元素等，非左值有字面常量，多项的表达式等。或者说，可以放在赋值语句左侧 and 能访问地址的就是左值，也就是说，赋值语句左侧是可修改的内存块，const 变量也是左值，只是不可修改。</p>
</blockquote>
<p>回到原问题，如果形参加上 <code>const</code> 修饰，意思是函数只使用这个值，不修改这个值。即使因类型不匹配生成了临时变量，引用参数引用这个临时变量，都不会造成任何不好的副作用。但此时就是值传递而不是地址传递，因为要用临时变量来存储数值。所以也推荐尽可能使用 <code>const</code>：</p>
<ul>
<li>避免无意修改数据造成结果错误</li>
<li>能更好的接收实参，生成并使用临时变量</li>
</ul>
<h2 id="返回值为引用"><a href="#返回值为引用" class="headerlink" title="返回值为引用"></a>返回值为引用</h2><p>对于传统的调用函数而言，返回结果的这个值被复制到临时位置，也就是产生值的副本，调用程序将使用这个值。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    len += <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// len 复制到临时位置</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">// 从临时位置获取值</span></span><br><span class="line">a = sum(a);</span><br></pre></td></tr></table></figure>
<p>而返回引用的函数实际上是返回被引用变量的别名。返回引用值时，并不产生值的副本。而是将返回值直接复制给接收函数的变量或对象，言简意赅，当函数返回引用类型时，没有复制返回值创建临时变量，相反，返回的是对象本身，并复制到接收变量那里。</p>
<p>对于一个大型的数据结构如结构体，将结构体复制到额外的地址的开销会很大；如果返回引用，将返回的引用的结构体直接赋值给接收值，避免额外的开销。</p>
<p>但是，避免返回指向临时变量的引用，临时变量在执行完毕后会消失，引用会指向乱七八糟的地址，就跟避免指向临时变量的指针一样。有两种解决方法：</p>
<ul>
<li>使用 new，将数据放到堆区，不过内存模型的坑准备后续开</li>
<li>传递一个额外的参数，传递给函数的引用，将该参数返回。因此返回引用时，要求在函数的参数中，包含有以引用方式需要被返回的参数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">double</span> value&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 返回变量 t 的引用</span></span><br><span class="line"><span class="function">node&amp; <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len, node&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        n.value += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    node t;</span><br><span class="line">    <span class="comment">// a 被 t 的引用给赋值</span></span><br><span class="line">    node a = sum(<span class="number">5</span>, t);</span><br><span class="line">    <span class="comment">// 修改 a 不会修改 t</span></span><br><span class="line">    a.value = <span class="number">13.2</span>;</span><br><span class="line">    <span class="comment">// a 是 t 的引用，修改 a 也会修改 b</span></span><br><span class="line">    <span class="comment">// node&amp; a = sum(5, t);</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.value &lt;&lt; <span class="string">" "</span> &lt;&lt; t.value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，非引用函数的返回值类型是右值，这种语句位于表达式的右侧，也无法通过地址访问这个值，也无法放到复制语句的左侧。因为返回值的地址在执行完毕后就消失了，也就是说无法引用。如果一定要引用返回值，将返回值类型声明为引用，这样返回的就是左值，就可以引用。</p>
<p>总结一下：当返回结果需要做为左值时，就要用引用返回。即重载函数的返回结果需要出现在赋值语句左边时，必须用引用返回。如果不用引用返回，那么重载函数的返回结果会是一个临时变量，临时变量是不能放在赋值语句左边的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误，右值不能在赋值语句左侧</span></span><br><span class="line"><span class="function">node <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len, node&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        n.value += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">5</span>, t).value = <span class="number">12.3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t.value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，返回的引用是左值</span></span><br><span class="line"><span class="function">node&amp; <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len, node&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        n.value += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">5</span>, t).value = <span class="number">12.3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t.value;</span><br></pre></td></tr></table></figure>
<p>如果不想返回的引用被修改，就加 <code>const</code> 修饰：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">double</span> value&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 返回变量 t 的引用</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> node&amp; <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len, node&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        n.value += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    node t;</span><br><span class="line">    <span class="comment">// 将 t 引用的值赋值给 a，所以可以修改 a</span></span><br><span class="line">    node a = sum(<span class="number">5</span>, t);</span><br><span class="line">    a.value = <span class="number">13</span>;</span><br><span class="line">    <span class="comment">// b 引用 t，不可修改</span></span><br><span class="line">    node&amp; b = sum(<span class="number">5</span>, t);</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    b.value = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络中的数据问题</title>
    <url>/2021/05/07/DNN-data-normal/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今日在写程序时，遇到了一个蜜汁 <code>bug</code>，加载别人训练好的 <code>ResNet18</code>，识别精度很低，只有 16%，但理论上而言应该有 92%，我也好奇那 80% 的准确率去哪里了。而程序和数据本身又无错误，所以来探究一下这是为什么。</p>
<a id="more"></a>
<p>首先，网络结构和预训练的模型来自这里 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，这里声明一下，他提供的网络、参数都是没任何问题的，准确率低是我自己的原因。</p>
<h1 id="错误程序"><a href="#错误程序" class="headerlink" title="错误程序"></a>错误程序</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> resnet18 <span class="keyword">import</span> ResNet18</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testdataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data_path, label_path)</span>:</span></span><br><span class="line">        <span class="comment"># 模型是预训练好的，取后面 10000 个做测试</span></span><br><span class="line">        self.x_data = np.load(data_path)</span><br><span class="line">        <span class="comment"># 数据到 [0, 1] 之间</span></span><br><span class="line">        self.x_data = self.x_data / <span class="number">255</span></span><br><span class="line">        self.x_data = self.x_data[<span class="number">50000</span>:]</span><br><span class="line">        self.y_data = np.load(label_path)</span><br><span class="line">        self.y_data = self.y_data[<span class="number">50000</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        x_ = self.x_data[index]</span><br><span class="line">        x_ = x_.transpose(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        y_ = self.y_data[index]</span><br><span class="line">        <span class="keyword">return</span> torch.from_numpy(x_), torch.from_numpy(y_)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.x_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_error</span><span class="params">(model, X, y)</span>:</span></span><br><span class="line">    out = model(X)</span><br><span class="line">    prediction = torch.argmax(out, <span class="number">1</span>)</span><br><span class="line">    prediction = prediction.unsqueeze(<span class="number">1</span>)</span><br><span class="line">    correct = (prediction == y).sum().float()</span><br><span class="line">    <span class="keyword">return</span> correct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_eval</span><span class="params">(model, device, test_loader)</span>:</span></span><br><span class="line">    model.eval()</span><br><span class="line">    model.to(device)</span><br><span class="line">    natural_err_total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">        data, target = data.to(device,</span><br><span class="line">                               dtype=torch.float), target.to(device,</span><br><span class="line">                                                             dtype=torch.float)</span><br><span class="line">        X, y = Variable(data, requires_grad=<span class="literal">True</span>), Variable(target)</span><br><span class="line">        err_natural = _error(model, X, y)</span><br><span class="line">        natural_err_total += err_natural</span><br><span class="line">    print(<span class="string">'acc: '</span>, natural_err_total / <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载 resnet</span></span><br><span class="line">    resnet = ResNet18()</span><br><span class="line">    resnet_path = <span class="string">"resnet18_ckpt.pth"</span></span><br><span class="line">    checkpoint = torch.load(resnet_path, map_location=<span class="string">'cpu'</span>)</span><br><span class="line">    print(<span class="string">'loaded model...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里只是为了对应模型参数</span></span><br><span class="line">    net_state = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> checkpoint[<span class="string">'net'</span>]:</span><br><span class="line">        net_state[key[<span class="number">7</span>:]] = checkpoint[<span class="string">'net'</span>][key]</span><br><span class="line">    resnet.load_state_dict(net_state)</span><br><span class="line">    print(<span class="string">'set model...'</span>)</span><br><span class="line"></span><br><span class="line">    data_path = <span class="string">"cifar10_data.npy"</span></span><br><span class="line">    label_path = <span class="string">"cifar10_label.npy"</span></span><br><span class="line">    test_data = testdataset(data_path=data_path, label_path=label_path)</span><br><span class="line">    test_loader = DataLoader(test_data, batch_size=<span class="number">128</span>)</span><br><span class="line">    print(<span class="string">'load data...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 干净样本准确率</span></span><br><span class="line">    print(<span class="string">'natural'</span>, end=<span class="string">', '</span>)</span><br><span class="line">    _eval(model=resnet, device=<span class="string">'cpu'</span>, test_loader=test_loader)</span><br></pre></td></tr></table></figure>
<p>在这样操作下，准确率只有 <code>16.89%</code> ，我也很奇怪是哪里错了。</p>
<h1 id="正确程序"><a href="#正确程序" class="headerlink" title="正确程序"></a>正确程序</h1><p>从师兄那里找到了一份正确的程序，准确率是 <code>92.84%</code>。后文会进行说明，这份代码只是结果对，但逻辑不对。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> resnet18 <span class="keyword">import</span> ResNet18</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TensorDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dataPath, labelPath)</span>:</span></span><br><span class="line">        x = np.load(dataPath)</span><br><span class="line">        x = x[<span class="number">50000</span>:] / <span class="number">255.</span></span><br><span class="line">        x = x.astype(<span class="string">"float32"</span>)</span><br><span class="line">        data = x.transpose(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        label = np.load(labelPath)[<span class="number">50000</span>:]</span><br><span class="line">        label = np.reshape(label, (data.shape[<span class="number">0</span>], ))</span><br><span class="line">        data, label = torch.from_numpy(data), torch.from_numpy(label)</span><br><span class="line">        self.data_tensor = data</span><br><span class="line">        self.target_tensor = label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.data_tensor[index], self.target_tensor[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.data_tensor.size(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = ResNet18()</span><br><span class="line">resnet_path = <span class="string">"resnet18_ckpt.pth"</span></span><br><span class="line">d = torch.load(resnet_path, map_location=torch.device(<span class="string">'cpu'</span>))[<span class="string">'net'</span>]</span><br><span class="line">d = OrderedDict([(k[<span class="number">7</span>:], v) <span class="keyword">for</span> (k, v) <span class="keyword">in</span> d.items()])</span><br><span class="line">net.load_state_dict(d)</span><br><span class="line">dataPath = <span class="string">"cifar10_data.npy"</span></span><br><span class="line">labelPath = <span class="string">"cifar10_label.npy"</span></span><br><span class="line">dataset = TensorDataset(dataPath, labelPath)</span><br><span class="line">dataloader = torch.utils.data.DataLoader(dataset,</span><br><span class="line">                                         batch_size=<span class="number">64</span>,</span><br><span class="line">                                         shuffle=<span class="literal">True</span>,</span><br><span class="line">                                         num_workers=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line">correct = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> batch_idx, (inputs, targets) <span class="keyword">in</span> enumerate(dataloader):</span><br><span class="line">    outputs = net(inputs)</span><br><span class="line">    _, predicted = outputs.max(<span class="number">1</span>)</span><br><span class="line">    total += targets.size(<span class="number">0</span>)</span><br><span class="line">    correct += predicted.eq(targets).sum().item()</span><br><span class="line">acc = <span class="number">100.</span> * correct / total</span><br><span class="line">print(acc)</span><br></pre></td></tr></table></figure>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>两份代码的数据加载、准确率计算都是正确的。经过二分法逐行注释，终于找到了问题所在，来依次分析一下。</p>
<p>第一个问题，因为网络的输入是 <code>channel first</code>，而 <code>numpy</code> 的数据中 <code>channel</code> 位于最后面，所以需要对数据进行转置处理。<strong>但是这里有坑</strong>。假设，图片之前的维度是 <code>height, width, channel</code>，大小是 <code>32 X 32 X 3</code>。</p>
<ul>
<li>假设此时转置的方法是 <code>np.transpose(2, 0, 1)</code>，得到矩阵的维度是 <code>channel, height, width</code>，大小是 <code>3 X 32 X 32</code>，这样输入网络是没有问题的。</li>
<li>假设此时转置的方法是 <code>np.transpose(2, 1, 0)</code>，得到矩阵的维度是 <code>channel, width, height</code>，大小是 <code>3 X 32 X 32</code>，这样输入网络不会报错，但准确率会很低，大概只有 <code>50%</code>，究其原因是数据增强所导致的。</li>
</ul>
<p>第二个问题，是 <code>model.eval()</code> 导致的，如果开启这个，准确率就会很低；如果不开启，准确率又正常，所以来深究一下这是为哈。<del>踩坑无数。</del>首先来回顾下 <code>pytorch</code> 的训练过程：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> dataloader:</span><br><span class="line">    <span class="comment"># 模型输出</span></span><br><span class="line">    y_pre = model(x)</span><br><span class="line">    <span class="comment"># 计算损失</span></span><br><span class="line">    loss = criterion(y_pre, y)</span><br><span class="line">    <span class="comment"># 上次计算遗留的梯度清空，准备反向传播</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    <span class="comment"># 计算梯度，不反向传播</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    <span class="comment"># 更新参数</span></span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure>
<p>而 <code>model.eval()</code> 会将 <code>batchnormal</code> 和 <code>dropout</code> 固定住，用训练好的值。否则，一旦测试时数据的 <code>batchsize</code> 变小，就会导致图像失真，模型准确率降低。这<strong>可能</strong>是问题所在。且在使用 <code>pytorch</code> 训练模型时，一定要注意 <code>train</code> 和 <code>eval</code> 模式的切换。</p>
<p>沿着这个思路，先在一些网站先找到一些<strong>可能</strong>的解决方案 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>。这里说可能是因为：任何问题都需要上下文才能知道准确的解决方案，即使描述的是同一个问题，也可能有多种解决方案。里面大概的解决方案如下：</p>
<ul>
<li><code>batchsize</code> 很小导致的，但我这里 <code>batchsize</code> 已经是 128 了，显然并不是这个原因</li>
<li>许多地方用同一个 <code>bn</code> 层，但我打开训练代码 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> ，里面 <code>bn</code> 层没有共用，所以也不是这个原因</li>
<li>在训练阶段，将模型设置为 <code>model.train()</code> 之前，一定要更新参数，包括 <code>zero_grad</code>，但我看了代码，不是这个问题</li>
<li><code>bn</code> 层的参数 <code>track_running_stats</code> 导致的。那我们来看看这个参数是啥意思，打开原文档 <sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> ，发现描述的佷晦涩，我没看懂。所以在网上找了找 <sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup> ，意思是，如果这个参数为 <code>True</code>，<code>bn</code> 就会追踪历史数据，以滑动加权平均的方式来更新 $\mu$ 和 $\sigma$。而 <code>track_running_stats</code> 取值为 <code>False</code>，就不会追踪历史数据，只会根据当前的 <code>batch</code> 计算均值和方差。<ul>
<li>可能由于数据比较不稳且 <code>batchsize</code> 很小影响了精度，但我打开程序，也不是这个原因。何况 <code>model.eval()</code> 模式下，<code>track_running_stats</code> 取值为 <code>True</code>，使用训练好的模型参数，且 <code>bn</code> 的参数也不会更新。</li>
<li>多说一些，<code>bn</code> 的均值和方差是在 <code>forward</code> 方法中更新的 <sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup> ，而不是在 <code>optimizer.step</code> 中更新。所以处于训练模式，<code>bn</code> 的参数不需要反向传播仍然能更新。<strong>这里需要注意。</strong></li>
</ul>
</li>
</ul>
<p>以上，也就是打开搜索引擎，能看到了解决方案了。<del>我屏蔽了某DN，某园等，以及另外的一些抄袭社区等等，他们的解决方案我看不到。</del>捕获回过头来分析下我看到的解决方案，也能意识到是数据处理部分的问题了。反过来想，训练模式下精度很高，说明 <code>bn</code> 层在动，而 <code>bn</code> 影响的是数据。众所周知，颠覆结果的不是模型，是数据，所以猜测是数据的问题。</p>
<p>打开源程序，我们发现训练阶段对数据做了标准化处理 <sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup>；而我们处理测试数据时，只是单纯的除以 255，保证数据在 0 到 1 之间，<strong>但这是不对的</strong>。那么也大概找到了解决方案，加载测试数据的时候进行标准化，此时模型的精度终于正确了！！！原因居然是：数据没有标准化处理。而 <code>train</code> 模式下精度很高，可能是因为通过 <code>bn</code> 层调整了数据分布。所以正确代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testdataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data_path, label_path)</span>:</span></span><br><span class="line">        <span class="comment"># 模型是预训练好的，取后面 10000 个做测试</span></span><br><span class="line">        self.x_data = np.load(data_path)</span><br><span class="line">        <span class="comment"># 数据到 [0, 1] 之间</span></span><br><span class="line">        self.x_data = self.x_data / <span class="number">255</span></span><br><span class="line">        self.x_data = self.x_data[<span class="number">50000</span>:]</span><br><span class="line">        self.y_data = np.load(label_path)</span><br><span class="line">        self.y_data = self.y_data[<span class="number">50000</span>:]</span><br><span class="line"></span><br><span class="line">        mean = np.array([<span class="number">0.4914</span>, <span class="number">0.4822</span>, <span class="number">0.4465</span>]).reshape(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        var = np.array([<span class="number">0.2023</span>, <span class="number">0.1994</span>, <span class="number">0.2010</span>]).reshape(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        self.x_data = (self.x_data - mean) / var</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        x_ = self.x_data[index]</span><br><span class="line">        x_ = x_.transpose(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        y_ = self.y_data[index]</span><br><span class="line">        <span class="keyword">return</span> torch.from_numpy(x_), torch.from_numpy(y_)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.x_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ...</span><br><span class="line">    net.eval()</span><br><span class="line">    ...</span><br><span class="line">    predict(net, testloader)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h1 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h1><p>既然标准化如此重要，就来回顾下标准化的用途。</p>
<ul>
<li>第一步，数据归一化，也就是映射到 0 到 1 之间，这是为了防止梯度爆炸以及特征尺度的缩放。<ul>
<li>因为误差反向传播求偏导的时候，会作用到原始数据 $x$，如果 $x$ 的取值是 255，梯度瞬间爆炸。</li>
<li>一个特征的变化范围可能是[1000,10000]，另一个特征的变化范围可能是[−0.1,0.2]，在进行距离有关的计算时，单位的不同会导致计算结果的不同，尺度大的特征会起决定性作用。所以要归一化，消除特征间单位和尺度差异的影响。刚才代码归一化的方式很简单，就是除以 255，当然还有很多其它的方式以及优缺点 <sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup> <sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup>。</li>
</ul>
</li>
</ul>
<p>在数据归一化后，可以标准化也可以不标准化，上述代码所用的 Z-Score 标准化的意思就是将数据映射到均值为 0，方差为 1 的分布空间中。</p>
<p>\begin{equation}<br>x = \frac{x-\mu}{\sigma}<br>\end{equation}</p>
<ul>
<li>此类标准化是通过特征的平均值和标准差，将特征缩放成一个标准的正态分布，缩放后均值为0，方差为1。特别适用于数据的最大值和最小值未知，或存在孤立点。</li>
<li>标准化是为了方便数据的下一步处理，而进行的数据缩放等变换，不同于归一化，并不是为了方便与其他数据一同处理或比较。归一化是为了消除纲量压缩到 <code>[0, 1]</code> 区间；标准化只是调整特征整体的分布，也就是平移到原点附近。且，归一化与最大，最小值有关；标准化与均值，标准差有关。</li>
<li>估算均值与方差需要总体的平均值与方差，但是这一值在真实的分析与挖掘中很难得到，大多数情况下是用样本的均值与标准差替代，所以一般要求数据符合正态分布。</li>
</ul>
<p>因此，也很容易定位到问题所在。训练的时候归一化处理的数据，而预测的时候没有，数据在两种不同的分布空间，所以导致预测精度降低。<del>本文记录了全部 debug 的过程，学到了好多东西（误</del></p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">https://github.com/laisimiao/classification-cifar10-pytorch</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">https://www.zhihu.com/question/354742972</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">https://github.com/laisimiao/classification-cifar10-pytorch/blob/master/models/resnet.py#L60-L64</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">https://discuss.pytorch.org/t/performance-highly-degraded-when-eval-is-activated-in-the-test-phase/3323</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">https://pytorch.org/docs/stable/generated/torch.nn.BatchNorm2d.html</span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;">https://www.zhihu.com/question/282672547</span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;">https://pytorch.org/docs/stable/_modules/torch/nn/modules/batchnorm.html#BatchNorm2d</span><a href="#fnref:7" rev="footnote"> ↩</a></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">8.</span><span style="display: inline-block; vertical-align: top;">https://github.com/laisimiao/classification-cifar10-pytorch/blob/master/main.py#L38-L41</span><a href="#fnref:8" rev="footnote"> ↩</a></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">9.</span><span style="display: inline-block; vertical-align: top;">https://ssjcoding.github.io/2019/03/27/normalization-and-standardization/</span><a href="#fnref:9" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络常见问题</title>
    <url>/2021/09/04/DNN-issue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写深度学习的代码多了，经常会发现网络准确率低、难以收敛等错误，大多时候不是算法问题，而是人为的 bug，特此记录。</p>
<p>比如：为何网络的误差一直是一个定值？为何同样的网络、同样的优化器和学习率，训练得到的准确率比别人低 20% ？</p>
<a id="more"></a>
<ol>
<li>神经网络处理数据时不进行<a href="https://muyuuuu.github.io/2021/05/07/DNN-data-normal/">标准化</a>，准确率会下降很多；</li>
<li>神经网络的学习率至关重要，batch 大而学习率小，batch 小而学习率大，都会导致不收敛问题。此外，学习率衰减很重要，能有效提升<a href="https://github.com/bearpaw/pytorch-classification" target="_blank" rel="noopener">卡在瓶颈</a>中的神经网络的准确率。</li>
<li>复现去噪器时，噪音数据在损失函数<a href="https://github.com/muyuuuu/Paper-ReImplement/tree/main/ADP-ICML-2021" target="_blank" rel="noopener">内部生成</a>。如果在损失外部生成噪音并输入网络，会导致网络的误差恒定为噪音的方差。</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文持续整理中。</p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>可变形卷积 DCN，从 V1 到 V2</title>
    <url>/2021/05/26/Deform-CNN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前了解到，可变形卷积 DCN（Deformable Convolutional Networks）是上分常用小技巧，所以把论文找来读了一下，V1 和 V2 两个版本都读了一下，个人感觉以及他人复现的结果显示 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> ，V1写的很好且够用，V2 写的实在是晕头转向。感觉还挺有创意，后期准备复现后，以后可能会用到。</p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>传统的 CNN 在建模时，几何变化能力受限，感受野都是规则的相邻矩形。于是，提出了可变形卷积，通过无监督的形式学习额外的偏移参数，加强模型的几何变换能力。也就是说，有了偏移参数，此时的卷积核读取的输入不再是规则的矩阵。且像传统 CNN 一样，支持端到端训练和反向传播，可以通过插拔的形式替换传统模型中的 CNN 。</p>
<ul>
<li>偏移参数是在输入的特征图上增加额外的网络分支，自己学出来的，所以这是一种自适应的方式</li>
<li>在 ROI 时，也可以学习这种偏移参数，自适应的定位到感兴趣区域</li>
<li>两者都是通过添加额外的网络分支实现的，但计算量不大</li>
</ul>
<p>其实这种形式挺重要的，尤其是算法部署到真实世界，是无法提前预知目标和图像的大小的。而如果模型有这种自适应感知目标区域大小和调节感受野的能力则再好不过。如下图所示，DCN 相比 CNN 而言，能更好的感知目标区域。</p>
<p><img data-src="https://z3.ax1x.com/2021/05/27/2P4Q1J.png" alt></p>
<h1 id="变形卷积算法"><a href="#变形卷积算法" class="headerlink" title="变形卷积算法"></a>变形卷积算法</h1><p>首先定义区域 $R$ 是输入特征图 $x$ 中的规则矩形，卷积核的权重是 $w$，区域 $R$ 中的元素的含义为横坐标的偏移与纵坐标的偏移量，所以可以通过 $R$ 了解到卷积核的大小和扩张大小。</p>
<p>\begin{equation}<br>R = \bigl( (-1, 1), (-1, 0), \cdots, (0,1), (1,1) \bigr)<br>\end{equation}</p>
<p>上面公式中，卷积核的大小就是 3，元素数量是 9，扩张大小为 1。以 $y$ 表示输出特征图，那么 $y$ 在 $p_0$ 位置的取值为 ：</p>
<p>\begin{equation}<br>y(p_0) = \sum_{p_n \in R} w(p_n) x (p_0 + p_n)<br>\label{traditional}<br>\end{equation}</p>
<p>$(p_0 + p_n)$ 的意思是偏移到目标像素 $p_n$，原文没有解释，我看了半天才看懂。这也就是传统的卷积。如果我们对 $R$ 中的每一个位置的元素都有一个通过神经网络学习得来的偏移量 $(\Delta p_n | n=1,\cdots,N)$，那么公式 $\eqref{traditional}$ 可以改写为：</p>
<p>\begin{equation}<br>y(p_0) = \sum_{p_n \in R} w(p_n) x (p_0 + p_n + \Delta p_n)<br>\end{equation}</p>
<p>此时的卷积可视化如下图中的 b c d 部分，a 是标准的卷积。</p>
<p><img data-src="https://z3.ax1x.com/2021/05/27/2Py8mD.png" alt></p>
<p>因为 $p_n + \Delta p_n$ 可能是一个小数，所以需要使用双线性插值来对坐标取整，用 $p$ 来表示 $p_0 + p_n + \Delta p_n$，公式如下：</p>
<p>\begin{equation}<br>x(p) = \sum_{q} G(q,p)x(q)<br>\end{equation}</p>
<p>$q$ 是输入特征图中的像素，其实只用到了和 $p$ 相邻的一部分。而 $G$ 是一个二维的双线性插值核函数，可以用两部分表示：</p>
<p>\begin{equation}<br>G(q,p) = g(q_x,p_x) \cdot g(q_y,p_y)<br>\end{equation}</p>
<p>其中，$g(a,b) = \max(0, 1- |a-b|)$，所以这里也能看出来，如果 $a,b$ 相差很大，取值会为 0，所以每次计算取 $q$ 时，其实只用到了和 $p$ 相邻的一部分。</p>
<h1 id="变形卷积训练流程"><a href="#变形卷积训练流程" class="headerlink" title="变形卷积训练流程"></a>变形卷积训练流程</h1><p><img data-src="https://z3.ax1x.com/2021/05/27/2Pg4jP.png" alt></p>
<p>如上图所示，假设 $R$ 中卷积核的元素数量是 $N$，比如 $3\times 3$ 卷积核的元素数量就是 9。那么就增加一个旁路卷积，这个卷积的通道数就是 $2N$，且卷积前后尺寸不变。这样做的原因是，计算 $x$ 方向和 $y$ 方向共两个方向的偏移量。取前两个通道，就是当前卷积核处理像素点的横坐标偏移和纵坐标偏移。</p>
<h1 id="变形-ROI-Pooling"><a href="#变形-ROI-Pooling" class="headerlink" title="变形 ROI Pooling"></a>变形 ROI Pooling</h1><p>其实道理也和上面一样了，假设此时在目标检测中将特征图 ROI pool 到 $k\times k$ 的矩阵中，以平均池化为例，输出 $y$ 中第 $(i,j)$ 个元素的取值就是</p>
<p>\begin{equation}<br>y(i,j)=\sum_{p\in bin(i,j)} x(p + p_0) / n_{ij}<br>\end{equation}</p>
<p>$bin$ 表示要被池化的区域，$n_{ij}$ 是对应区域中的像素点的数量。而此时，可以学习一个偏移量参数 $\Delta p_{ij}$，新的 ROI Pooling 公式就是</p>
<p>\begin{equation}<br>y(i,j)=\sum_{p\in bin(i,j)} x(p + p_0 + \Delta p_{ij}) / n_{ij}<br>\end{equation}</p>
<p>双线性取整部分就和之前的一样了。不过论文中注明了一点，网络学习到的是 $\Delta \hat{p}_{ij}$，如下图所示，使用全连接计算每个像素点的偏移量。</p>
<p><img data-src="https://z3.ax1x.com/2021/05/27/2PhOOI.png" alt></p>
<p>而 $\Delta p_{ij} = \gamma \cdot \Delta \hat{p}_{ij} \circ (w,h)$，$\gamma$ 的取值是 0.1，$(w,h)$ 是 ROI Pooling 之前的特征图的宽度和高度，$\circ$ 运算是什么，文中没有声明。</p>
<h1 id="V2"><a href="#V2" class="headerlink" title="V2"></a>V2</h1><p>DCN V2 看的我属实头晕，不过大体贡献还是能看清的，集中改进了两点：</p>
<ul>
<li>采样时，如果采到了背景区域，会对目标分类与检测造成影响，所以要抑制背景区域的贡献</li>
<li>训练一个教师网络，类似判别器，用于指导检测网络的检测，文中称为特征模仿（feature mimicking），没读懂这个和前文改进的联系，唯一的相似点是摘要中指出的：提高模型捕获特征的能力，但我感觉这里是重点</li>
</ul>
<p>以可变形卷积为例，原有 DCN 的输出通道是 $2N$，那么作者将输出通道改为 $2N+1$，最后一个维度用 sigmoid 激活到 (0, 1) ，表示为符号 $\Delta m_k$ ，含义为当前像素点的贡献程度，如果是背景噪音，那么贡献会趋于 0。所以此时可变形卷积的公式为：</p>
<p>\begin{equation}<br>y(p_0) = \sum_{p_n \in R} w(p_n) x (p_0 + p_n + \Delta p_n) \cdot \Delta m_k<br>\end{equation}</p>
<p>至于 ROI Pooling 也是一个道理了。</p>
<h2 id="特征模仿"><a href="#特征模仿" class="headerlink" title="特征模仿"></a>特征模仿</h2><p>而另一个创新点是特征模仿，在主干网络 RPN 后，将得到的题夷旷送到另一个 RCNN 分支，两个分支的输出的相似性做对比作为损失，相似度越高，损失越小，相似度越低，损失越大。相似度是用 $\cos$ 函数计算的。</p>
<ul>
<li>测试时，不适用右侧的 RCNN分支</li>
<li>两个分支的 bacbone 部分共享参数</li>
<li>三个损失一起反向传播</li>
</ul>
<p><img data-src="https://z3.ax1x.com/2021/05/27/2PTMUx.png" alt></p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">https://github.com/open-mmlab/mmdetection/tree/master/configs/dcn</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>对抗攻击篇：FGSM 与 PGD 攻击算法</title>
    <url>/2021/04/26/DNN-safe-basic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>博客的进阶使用：在指定位置插入脚注<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，这样就不用在文末列出参考文献，显得对不上号了。回归正题，如果不出什么特别大的意外，就应该去搞网络安全了。注：此网络安全非彼网络安全，指：对抗样本而非网络入侵。所以准备来开个坑，先整理基础知识，基础不劳，地动山摇。</p>
<a id="more"></a>
<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>所谓对抗样本，即向原始样本中添加一些人眼无法察觉的噪声，这样的噪声不会影响人类的识别，但是却很容易欺骗 DNN <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，使其作出与正确答案完全不同的判定。如下图所示，使用基于梯度<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>的攻击方式，很容易欺骗神经网络：</p>
<p><img data-src="https://z3.ax1x.com/2021/04/26/gpwOwd.png" alt></p>
<p>将肉眼不可见的细小扰动加入到原图中，网络识别出粗，甚至有 99.3% 的概率认为这是长臂猿。试想，如果犯罪分子将人烟稀少地区的交通信号牌改为立即停车，人眼不会觉得有什么不妥，但是无人驾驶系统却会乖乖停车，那么此时车上人员的安全何以保障？将禁止右转改为右转，造成交通事故就只在弹指一挥间了。究其本质原因，还是因为现有的 DNN 不能完全区分哪些特征是对分类有用的，哪些是可以忽略的。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li>白盒攻击：攻击者能够获知机器学习所使用的算法，以及算法所使用的参数。</li>
<li>黑盒攻击：攻击者并不知道机器学习所使用的算法和参数，但攻击者仍能与机器学习的系统有所交互，比如可以通过传入任意输入观察输出，判断输出。</li>
<li>无目标攻击：对于一张图片，生成一个对抗样本，使得标注系统在其上的标注与原标注无关，即只要攻击成功就好，对抗样本的最终属于哪一类不做限制。</li>
<li>有目标攻击：对于一张图片，生成一个对抗样本，使得标注系统在其上的标注与目标标注完全一致，即不仅要求攻击成功，还要求生成的对抗样本属于特定的类。</li>
</ul>
<h1 id="基于梯度的攻击算法"><a href="#基于梯度的攻击算法" class="headerlink" title="基于梯度的攻击算法"></a>基于梯度的攻击算法</h1><h2 id="FGSM-攻击算法"><a href="#FGSM-攻击算法" class="headerlink" title="FGSM 攻击算法"></a>FGSM 攻击算法</h2><p>设 $x$ 是原始样本，$x’$ 是对抗样本，其中：$x’ = x + \eta$，为了让对抗样本不被机器所识别，$\eta$ 应该足够小，这里使用无穷阶范数来表述 $\eta$ 足够小这一限制：$\Vert \eta \Vert_\inf &lt; \epsilon$。事实上，常说的 $l_\inf-\text{ball}$ 就是这个意思。</p>
<p>考虑输入层对对抗样本的线性变换：</p>
<p>\begin{equation}<br>w^Tx’=w^Tx+w^T\eta<br>\end{equation}</p>
<p>如果假设 $\eta = \text{sign} (w)$，$w$ 是一个 $n$ 维的矩阵，每一维的模长是 $m$，那么经过线性映射后，输入将增大 $\epsilon mn$。尽管 $\Vert \eta \Vert_\inf$ 不会变换，但随着维度的升高、矩阵权重的变换和非线性激活，回导致最终结果变化很大。这也就是为什么对抗样本与原始样本相差无几，但却产生了不同的输出。</p>
<p>因此，FGSM<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> 产生对抗样本的方式为：</p>
<p>\begin{equation}<br>\eta=\epsilon \text{sign} \big( \nabla_x J(\theta, x, y) \big)<br>\end{equation}</p>
<p>其中，$J$是分类损失函数，通过梯度上升，最大化损失函数，企图使得原始的 $x$ 不在属于 $y$ 类。<del>好坏啊</del>。torch 官方<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>也给出了对抗样本的程序：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># FGSM attack code</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fgsm_attack</span><span class="params">(image, epsilon, data_grad)</span>:</span></span><br><span class="line">    <span class="comment"># Collect the element-wise sign of the data gradient</span></span><br><span class="line">    sign_data_grad = data_grad.sign()</span><br><span class="line">    <span class="comment"># Create the perturbed image by adjusting each pixel of the input image</span></span><br><span class="line">    perturbed_image = image + epsilon*sign_data_grad</span><br><span class="line">    <span class="comment"># Adding clipping to maintain [0,1] range</span></span><br><span class="line">    perturbed_image = torch.clamp(perturbed_image, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># Return the perturbed image</span></span><br><span class="line">    <span class="keyword">return</span> perturbed_image</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    data_grad = data.grad.data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Call FGSM Attack</span></span><br><span class="line">    perturbed_data = fgsm_attack(data, epsilon, data_grad)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Re-classify the perturbed image</span></span><br><span class="line">    output = model(perturbed_data)</span><br></pre></td></tr></table></figure>
<h2 id="PGD-攻击算法"><a href="#PGD-攻击算法" class="headerlink" title="PGD 攻击算法"></a>PGD 攻击算法</h2><p>PGD 攻击算法<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>是 FSGM 的变体，它即是产生对抗样本的攻击算法，也是对抗训练的防御算法。</p>
<p>论文先抛出了两个问题：</p>
<ol>
<li>如何产生强有效的对抗样本，只需要一点点扰动就可以欺骗神经网络？</li>
<li>如何训练模型，使得没有对抗样本轻易能欺骗网络？</li>
</ol>
<p>在论文中，为了防止网络只能抵御某一特定类型的攻击，应该保证模型有足够的对抗鲁棒性，接下来，使用一种方法来训练模型，达到这种保证。在传统的网络中，损失函数通常是优化网络参数 $\theta$，使得损失函数达到最小：$\mathbb{E}_{x\sim D}[L(x,y,\theta)]$。但是，对于对抗样本而言，就是要误导神经网络的输出。同样，这篇论文中，对抗样本的扰动范围也限制在 $l_\inf-\text{ball}$ 内。</p>
<p>但是在训练损失函数$\mathbb{E}_{x\sim D}[L]$之前，先考虑对抗样本的扰动，所以先不把干净样本 $x$ 输入到网络，而是用对抗样本作为网络的输入。所以论文的公式将攻击和防御放入统一框架内，对抗训练就是在一个马鞍面内求鞍点。</p>
<p>\begin{equation}<br>\min \mathbb{E}_{x\sim D} \big[ \max_{\sigma\in S} L(\theta, x, y) \big]<br>\end{equation}</p>
<p>其中的 $S$ 表示球面限制，即无穷范数不能超过 $S$。这个统一的框架包括了内部最大化和外部最小化，因此可以视为鞍点问题，也清晰的描述了鲁棒模型应该达到的目标。内部最大化的期望是，寻找最优的对抗样本达到很高的损失；外部最小化的期望是，寻找模型参数，能抵抗对抗样本的攻击。所以，最终训练得到的模型也具有稳定的对抗鲁棒性。</p>
<p>在攻击部分，对抗样本的制作方法为：</p>
<p>\begin{equation}<br>x+\epsilon \text{sign} \big( \nabla_x L(\theta, x, y) \big)<br>\end{equation}</p>
<p>这可以解释为内部期望最大化的单步攻击。但多步攻击会更加有效，因为 DNN 是复杂的非线性映射，不要企图一步到位。在数据点的 $l_\inf$ 球边界的许多点运行PGD，来探索损失函数中的大部分位置，即在这个球的范围内，探索到绝大多数地方，以能够找到最强的对抗样本。虽然在 $x_i+S$ 的范围内有许多局部最大值，但是他们的损失值往往相似，也就是说，解决了最大化内部非凹函数的问题。</p>
<p>\begin{equation}<br>x^{t+1}=\prod_{x+S}\bigg(x^t+\epsilon \text{sign} \big( \nabla_x L(\theta, x, y) \big)\bigg)<br>\end{equation}</p>
<p>$\prod_{x+S}$ 符号的意思是，先计算原图像的损失梯度得到对抗样本，对抗样本减去原图像得到扰动值，并通过 <code>torch.clamp</code> 限制在球面范围内，原图像加上扰动值就是最终的对抗样本。还是看代码吧：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pgd_attack</span><span class="params">(model, images, labels, eps=<span class="number">0.3</span>, alpha=<span class="number">2</span>/<span class="number">255</span>, iters=<span class="number">40</span>)</span> :</span></span><br><span class="line">    images = images.to(device)</span><br><span class="line">    labels = labels.to(device)</span><br><span class="line">    loss = nn.CrossEntropyLoss()</span><br><span class="line">    <span class="comment"># 原图像</span></span><br><span class="line">    ori_images = images.data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(iters) :</span><br><span class="line">        images.requires_grad = <span class="literal">True</span></span><br><span class="line">        outputs = model(images)</span><br><span class="line"></span><br><span class="line">        model.zero_grad()</span><br><span class="line">        cost = loss(outputs, labels).to(device)</span><br><span class="line">        cost.backward()</span><br><span class="line">        <span class="comment"># 图像 + 梯度得到对抗样本</span></span><br><span class="line">        adv_images = images + alpha*images.grad.sign()</span><br><span class="line">        <span class="comment"># 限制扰动范围</span></span><br><span class="line">        eta = torch.clamp(adv_images - ori_images, min=-eps, max=eps)</span><br><span class="line">        <span class="comment"># 进行下一轮对抗样本的生成。破坏之前的计算图</span></span><br><span class="line">        images = torch.clamp(ori_images + eta, min=<span class="number">0</span>, max=<span class="number">1</span>).detach_()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> images</span><br></pre></td></tr></table></figure>
<p>实验发现，通过PGD发现的局部最大值在正常训练的网络和对抗训练的网络中都有着相似的损失值；换句话说，PGD 训练对抗样本，和普通网络训练干净样本的损失是类似的；这也说明，只要能够防御住PGD，就会对所有的一阶攻击手段具有鲁棒性。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>剩下的这些都是论文中实验部分所提及的了，更多内容，还可以参考这里<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>的解读和这里<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup>的代码。</p>
<ul>
<li>在模型容量较小时，模型对 FGSM 对抗样本产生了过拟合，这种行为被称为label leaking。而且，模型无法防御 PGD 攻击。</li>
<li>对抗样本的复杂性，是决策边界也变得复杂，因此模型需要更大的容量，才能抵御对抗样本。</li>
</ul>
<h1 id="常见防御算法"><a href="#常见防御算法" class="headerlink" title="常见防御算法"></a>常见防御算法</h1><ul>
<li>对抗训练：对抗训练旨在训练一个更加鲁棒的模型，其训练集由真实数据集和加入了对抗扰动的数据集组成，因此叫做对抗训练。</li>
<li>去噪模块：在输入模型进行判定之前，先对当前对抗样本进行去噪，剔除其中造成扰动的信息，使其不能对模型造成攻击。</li>
</ul>
<p>上述几种防御类型对对抗样本扰动都具有一定的防御能力，效果参差不齐。本来想都放到这篇博客里，后来发现任务量太大了，后续我会读一些论文，列举一些代表性算法。当然，也可以移步这里，有很多关于网络安全算法<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>的介绍。</p>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>使用 <code>ResNet50</code> 制作对抗样本，攻击类型为黑盒攻击，使用 <code>VGG16</code> 作为目标模型，程序 <sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup> 放到了 Github。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>攻击算法</th>
<th>目标模型</th>
<th>原始准确率</th>
<th>扰动0.05</th>
<th>扰动0.1</th>
<th>扰动0.15</th>
<th>扰动0.3</th>
</tr>
</thead>
<tbody>
<tr>
<td>FGSM</td>
<td>VGG16</td>
<td>94.27</td>
<td>52.52</td>
<td>47.37</td>
<td>42.86</td>
<td>32.24</td>
</tr>
<tr>
<td>PGD</td>
<td>VGG16</td>
<td>94.27</td>
<td>43.01</td>
<td>31.53</td>
<td>23.92</td>
<td>14.53</td>
</tr>
</tbody>
</table>
</div>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://guanqr.com/tech/website/hexo-theme-next-customization/#%E6%8F%92%E5%85%A5%E8%84%9A%E6%B3%A8" target="_blank" rel="noopener">如何加入脚注</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/pdf/1312.6199.pdf" target="_blank" rel="noopener">对抗样本</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/pdf/1412.6572.pdf" target="_blank" rel="noopener">FGSM攻击</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://aisafety.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">网络安全系列算法</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;"><a href="https://pytorch.org/tutorials/beginner/fgsm_tutorial.html" target="_blank" rel="noopener">pytorch实现FSGM</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/pdf/1706.06083.pdf" target="_blank" rel="noopener">PGD攻击算法</a></span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;"><a href="https://baidinghub.github.io/2020/04/03/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89PGD%E5%8F%8A%E9%98%B2%E5%BE%A1/#5-1-Network-Capacity-and-Adversarial-Robustness" target="_blank" rel="noopener">PGD论文笔记</a></span><a href="#fnref:7" rev="footnote"> ↩</a></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">8.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/Harry24k/PGD-pytorch/blob/master/PGD.ipynb" target="_blank" rel="noopener">PGD攻击程序</a></span><a href="#fnref:8" rev="footnote"> ↩</a></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">9.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/muyuuuu/Adversarial-Attack" target="_blank" rel="noopener">PGD与FGSM的黑盒攻击</a></span><a href="#fnref:9" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>端午&amp;高考乱弹</title>
    <url>/2019/06/08/DuanWu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>怀念的，也许只是怀念本身。一年前，不是2016年，而是2018年。高考对我来说是3年前的事情了。</p>
<a id="more"></a>
<h1 id="乱弹1-计算机"><a href="#乱弹1-计算机" class="headerlink" title="乱弹1-计算机"></a>乱弹1-计算机</h1><p>谁能想到3年后来了计算机专业呢？大一调剂到了测绘工程，对此专业无感，对专业的人也无感。隔壁几个宿舍和本宿舍大概是打游戏的那种吧，打起来没完没了的。凌晨两点还在大吼大叫or声音不断，所以大一下开始就选择性睡实验室了。</p>
<p>我爱写代码，尽管写的不是很好。于是有了这样的写代码界面。不知所云。也许每一个coder都有一个geek的心吧。</p>
<p><img data-src="/2019/06/08/DuanWu/1.jpg" alt></p>
<h1 id="乱弹2-三年前"><a href="#乱弹2-三年前" class="headerlink" title="乱弹2-三年前"></a>乱弹2-三年前</h1><p>我记得三年前的现在，考完了很平静吧，把书搬了把宿舍搬了，然后回家整理了下，安心的玩着游戏。第二天五点自然醒还真不习惯，又翻身睡了下去。</p>
<p>第二天约了自己喜欢的女孩出去玩，始终没有成功，总是在找各种借口拒绝我。后来自己安静的打游戏，聊天，吹嘘，怀念。</p>
<p>2016-6-23，出了成绩倒在了床上。在她怀里撕心裂肺的大哭了一个下午。后来也没调节好自己情绪，每天醒来枕巾都是湿的。</p>
<p>2016-7-12，性格不合安静的吵了一架，做了极度的各种的挽留，各种丧，各种想不开还是各奔东西。朋友说我做的不对。一度连续的失败后，不应该那样失落，也不应该精神涣散到丢了魂。目光游离，想死又不敢。</p>
<p>2016-7-15，写了封情书。可惜删了也找不到原稿。我这辈子也写不出那种富含个人感情的八千多字的情书了。也不会在没有暖气的北国冬天，把身上唯一的袄脱下来给你。</p>
<p>2016-8月，差三分就能去她的学校。也许当初手抖一下一个选择题的事。3分，几百公里，一生的遗憾。一个月也没怎么吃饭，整天靠吃水果度日。一个月瘦了15斤，哭到不受控制。我爸说你读书有什么用，我妈不说话，感觉被世界抛弃。</p>
<p>2016-9-03，她要去大学，想见最后一次也没成功。在她家门外做了两个小时的傻瓜，反正我知道这辈子也见不到了。后来我就想，不再对任何要走的人做任何形式的挽留。删好友or屏蔽，我不会做挽留，不想理我，我自己走。</p>
<p>想起了当初传的纸条，借过的衣服，赌过的气，砸过的墙。想当年，其实我们都一样，没啥可说的，还与历史，归于天地就好。</p>
<p>2019-6-07，我还活着，一切正常。许多事情实在想不起来了。</p>
<p><img data-src="/2019/06/08/DuanWu/2.jpg" alt></p>
<p><img data-src="/2019/06/08/DuanWu/3.jpg" alt></p>
<h1 id="乱弹3-现在"><a href="#乱弹3-现在" class="headerlink" title="乱弹3-现在"></a>乱弹3-现在</h1><p>大学一切OK，我在刷题我就是智障。有那时间真的不如搞搞技术和看看知识，多看多想少刷题。纸上得来终觉浅，觉知此事要躬行。</p>
<p>建模面试的时候，我总要问：线性代数中特征向量和特征值的物理含义。他们都会做题，可是学的都是不懂背景的死知识。</p>
<p>前几天他们举办了桌游，三国杀、象棋、扑克、斗地主、五子棋、狼人杀。就在教室玩了起来，放下了手中的电路板和代码我们都一样。</p>
<p>好久不玩，想起了小时候，在我家的丝瓜架下，点上蚊香，也是玩象棋、扑克、三国杀到快要日落，快日落就趁天气凉快去打球。那是我最快乐的时光。</p>
<p>一切正常，只是不在怀念。</p>
<p><img data-src="/2019/06/08/DuanWu/4.jpg" alt></p>
<h1 id="乱弹4-童话"><a href="#乱弹4-童话" class="headerlink" title="乱弹4-童话"></a>乱弹4-童话</h1><p>hold不住《童话》的前奏钢琴曲了。</p>
<p>也许是时代进步了，是我们这一代自己落后了吧。诸多感叹和怀念，时不时来个“想当年”，也证明我们逐渐老了，过时了～</p>
<p>在特殊的日子里，我们会发现，总喜欢回忆一些人、一些事、一些物，也许是那一首歌，也许是那一道风景。有时候我们会陶醉于这种怀念之中，却不知道，可能我们怀念的并不是那些人和事物，而是怀念本身。</p>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>大漠飞沙</title>
    <url>/2020/01/17/DunHuangDesert/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>鸣沙山月牙泉，每人100现金骑了骆驼，真饿死的骆驼比马大。看到了大漠，看到了孤烟，看到了长河，可惜冲上最后一座山顶，没看到落日。（傍晚，啊呸，下午都是天气寒冷，注意配戴帽子和手套等）</p>
<p>此处适合配上《沙漠骆驼》这首BGM。</p>
<p><img data-src="/2020/01/17/DunHuangDesert/42.jpg" alt></p>
<a id="more"></a>
<p><img data-src="/2020/01/17/DunHuangDesert/45.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/48.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/50.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/52.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/56.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/58.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/59.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/60.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/61.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/62.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/64.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/65.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/66.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/67.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/68.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/69.jpg" alt><br><img data-src="/2020/01/17/DunHuangDesert/70.jpg" alt></p>
]]></content>
      <categories>
        <category>塞上西北行</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>电商搜索召回</title>
    <url>/2022/03/24/E-commerce-Search-Recall/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://s1.ax1x.com/2022/03/24/q806pT.png" alt></p>
<p>阿里灵杰问天引擎电商搜索算法赛，来详细的记录一下参加这个天池比赛的流程以及我眼中的检索。因为之前从未涉足 NLP 领域，对 NLP 的了解也仅限于大二的时候看完《数学之美》手写过 TF-IDF 算法，我甚至不知道什么是 bert。</p>
<p>为了防止更多的人踩坑，能愉快的参与进来，于是决定把我的做法和程序分享出来，供参赛选手参考。之前在交流群里大概说了我的做法，私聊我的人我也都告诉了他们大概怎么去做，在那几天看到好多人在排名突飞猛进保送到了 0.2 分左右，甚至超过了我，还是比较开心的。这次做一个系统的分享，我甚至会告诉你怎么做是不对的，也希望你能有更创新的想法。<strong>走过路过给我的 github 点个 star 就行了，孩子要秋招了，这对我比较重要</strong>。（2022年3月20日，0.22的得分排名 21，3月24日，这个得分只能90名，大家太卷了）。</p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每天坐在电脑面前查方案、读论文、写代码，每天都加班到凌晨，提交了近一周的 0.0X 的成绩，提交这么多成绩意味着我写了更多的代码。可还是排名倒数，提交成绩的时候一度不敢看排行榜。还有很多反向优化的操作，期间写错代码的次数更是数不胜数。单刷比赛确实感觉不容易，尤其是对我这种到处借显卡的人。除了思路出错和程序出错，读论文和尝试代码的速度也不如组队，写完程序满心欢喜，出来结果满眼失望，经历了一周这样的反反复复，还好稳住了心态，坚持了下来。<del>大型诉苦现场。</del></p>
<p>在 21 年 7 月的时候，接到了某互联网研究院的项目。我这里简化一下，给定一张图片，在数据库中快速的检索出相似的图片。因为对面采用的方法是使用欧式距离一张一张的比对，速度很慢，我表示对这种做法很震惊，从大学随便找个本科生至少也知道不应该这么做。而检索任务可以分为两阶段，第一阶段为特征提取，第二阶段为特征比对。因为当时对面提供了原始数据提取后的特征，于是当时只完成了特征比对任务。</p>
<p>时隔半年，我又遇到了相同场景的任务，不过此时要解决的是第一阶段，如何将原始数据提取为一个好的表示，也是这个比赛的关键内容。本文从数据、损失、模型等多个方面来阐述一下如何才能 work，以及为什么能 work。</p>
<h1 id="关于向量索引"><a href="#关于向量索引" class="headerlink" title="关于向量索引"></a>关于向量索引</h1><p>从计算机视觉、自然语言与语音处理，这三大类的搜索与推荐，只要物品能够被向量化表示，就可能会看到向量索引的身影。因为向量索引不是本文的重点，这里就简单略过。可以参考我之前的文章：<a href="https://muyuuuu.github.io/2021/08/04/LSH-consine/">局部敏感哈希算法的C++实现</a>。</p>
<p>特征检索也叫向量索引，学术上对应的专有名词叫 Approximate Nearest Neighbor Search (ANNS)，即近似最近邻搜索。为什么是近似，而不是我们想要的精确？这就是精度与时间、算力资源的折中，采用了牺牲精度换取时间和空间的方式，从海量的样本中实时获取跟查询最相似的样本。一种高效的向量索引算法，应该满足3个基本条件：</p>
<ol>
<li>实时查询，支持海量（百亿、千亿级别）规模库量级的实时查询；</li>
<li>存储高效，要求构建的向量索引模型数据压缩比高，达到大幅缩减内存使占用的目的；</li>
<li>召回精度好，top@K有比较好的召回率；</li>
</ol>
<p>目前主要的方法有：基于树的索引（KD 树）、基于哈希的索引（局部敏感哈希方法）、矢量量化方法（OPQ）和基于图的索引（HNSW ）等。更多内容可以参考这里：<a href="https://yongyuan.name/blog/vector-ann-search.html" target="_blank" rel="noopener">https://yongyuan.name/blog/vector-ann-search.html</a></p>
<p>当时通过编写线程池、空间换时间等操作优化了他人开源的局部敏感哈希算法，修复了他人开源线程池存在的 bug，达到了令人满意的速度和精度。</p>
<h1 id="关于特征提取"><a href="#关于特征提取" class="headerlink" title="关于特征提取"></a>关于特征提取</h1><p>这是一个很经典也很实用的问题，在 2022 年的今天，随着对比学习的发展，特征提取也迎来了新的热度。而 TF-IDF（文本），SIFT（图像）等非深度学习提取特征的方法本文就不谈了。</p>
<p>如果使用深度学习来提取特征，如果是图像，模型可以使用 resnet 或者 ViT 等成功的模型，如果是本文，那么可以使用他人预训练好的 bert，我比较推荐 hugging face 和 Nezha。因为前些日子看了 CV 领域的自监督论文，随着模型结构越来越简单，改进集中体现在损失函数上，常用的就是 SimCLR 论文中的对比损失，也叫 InfoNCE 损失函数，而好巧不巧，SimCSE 也用的是这个损失函数。因此，详细来讨论一下这些损失函数，<del>我也没有足够的算力去调网络结构</del>。</p>
<h2 id="简单的优化距离"><a href="#简单的优化距离" class="headerlink" title="简单的优化距离"></a>简单的优化距离</h2><p>一开始我的想法很简单，既然标注了样本对，那么一个样本视为 anchor，人工标注的答案视为 positive，在数据库中随机选取一个视为 negative，当然在这里也可以进行在线难例挖掘，不过这种改进还是要在实现 baseline 之后再进行。</p>
<p>选择样本后，将提取到的特征进行标准化，优化 anchor 和 positive 的距离，使他们更加接近，使 anchor 和 negative 的距离更远。为了达到这个目标，在叠加一个交叉熵损失。距离可以选择余弦距离或者欧氏距离，我看 github 的开源项目大部分是余弦距离。具体示意图如下所示：</p>
<p><img data-src="https://s1.ax1x.com/2022/03/24/q8D2w9.png" alt></p>
<p>我想大部分人最开始的想法都是这样，但是这么做合理嘛？显然不合理。</p>
<ol>
<li>因为即使使用随机数，两者的余弦距离也会很高：<br><img data-src="https://s1.ax1x.com/2022/03/24/q8sADe.png" alt></li>
<li><blockquote>
<p>负样本对的目标都“过低”了，因为对于“困难样本”来说，虽然语义不同，但依然是“相似”，相似度不至于0甚至-1那么低，如果强行让它们往0、-1学，那么通常的后果就是造成过度学习，从而失去了泛化能力，又或者是优化过于困难，导致根本学不动。这句话引自科学空间。</p>
</blockquote>
</li>
</ol>
<p>别看这种损失函数差劲，triplet loss 也一样，面临模型坍塌损失持续为零的现象。至少我两次在工程中使用 triplet loss 都出现了这种情况，而 triplet loss 模型坍塌在 ECCV 2020 的一篇论文【Semi-Siamese Training for Shallow Face Learning】中也解释过，出现坍塌的场景均为：样本种类多，但是每类的样本很少。而实际证明，这种方案做出来的特征向量，检索的 MRR@10 指标很低，大概在 0.05 就是极限了。心态爆炸的一周：</p>
<p><img data-src="https://s1.ax1x.com/2022/03/24/q8yfFs.png" alt></p>
<h2 id="CoSENT-使用"><a href="#CoSENT-使用" class="headerlink" title="CoSENT 使用"></a>CoSENT 使用</h2><p>顺着这个思路，查到了苏神的 CoSENT，不得不说从思路到代码都很新颖。如果让我总结一下，那么就是只需要让负样本之间的距离比正样本之间的距离更远就好了，远多少让模型去决定。遂有如下的损失函数（以我的使用经验，损失值会收敛到 0.0X 左右，而且很稳定），而且这个损失函数的代码写法也很棒，建议仔细阅读源码。</p>
<p>\begin{equation}<br>\log \Biggl(1 + \sum_{(i,j)\in \Omega_{pos}, (k,l)\in \Omega_{neg}} e^{\lambda (\cos(x_k, x_l)-\cos(x_i, x_j))}\Biggr)<br>\end{equation}</p>
<p>在最开始的时候，我设置正样本和负样本的比例为 1：1，效果不怎么好，可以说是负优化。我又读了一些论文，发现公司的模型都有两部分，其中离线的部分数据量大且训练慢，这么做的好处是训练到更多的数据。那么思路来了，我把正负样本调节到 1：10，负样本并不随机选取，而是顺序遍历全部语料库，因为 1:10 的比例可以囊括所有的样本，这种方法训练时常线性增加，毕竟数据量大了，但是效果好了很多。在 3080 卡，batch size = 2 的情况下，训练时间为 36 小时，得分在 0.15 左右。</p>
<p><img data-src="https://s1.ax1x.com/2022/03/24/q8ct5d.png" alt></p>
<h2 id="SimCSE"><a href="#SimCSE" class="headerlink" title="SimCSE"></a>SimCSE</h2><p>SimCSE 是做 NLP 的，但是仔细看了它的损失函数，会发现这种对比损失在 CV 领域也是存在的，比如 SimCLR 算法。这篇论文的想法简单却有效：</p>
<ul>
<li>如果是无监督，同一个 batch 中，同一个句子经过模型两次会得到不同的结果视为正样本，不同句子视为负样本。使得正样本之间距离近，负样本之间距离远。</li>
<li>如果是有监督，那么输入三个句子，一个为 anchor，一个为 positive，一个为 negative，使同一个 batch 中，正样本距离近，负样本距离远。正样本只有同一个句子的 anchor 和 positive，负样本包括两部分：anchor 和 negative，当前 anchor 和其他句子的 positive 与 negative。</li>
</ul>
<p>因为 SimCSE 支持无监督和有监督训练，那么想法自然也就来了：我看之前的比赛，RMB 玩家为了使得模型更加贴合当前任务的数据集，都要进行 MLM 预训练，但这种方法很耗时间，不适合我这种到处借显卡的人。所以，我用 SimCSE 的无监督方法训练语料库，使得模型贴合当前任务，在这之后，使用标注数据再训练模型来完成任务，岂不完美。个人的参数是，无监督训练 1 个 epoch，有监督训练 5 个 epoch（损失还很大，没有收敛），得分在 0.2 左右，而且 batch 越大，得分越好。</p>
<p><img data-src="https://s1.ax1x.com/2022/03/24/q82rNQ.png" alt></p>
<p>那么 SimCSE 和 CoSENT 如此相似，都是不优化距离，为什么 SimCSE 简单有效呢？这得从他们的损失函数说起：</p>
<ul>
<li>对于 CoSENT，只让负样本的距离大于正样本的距离，但是：负样本对之间的不同，正样本对之间的不同却没有考虑到，也就是利用的信息少。</li>
<li>而 SimCSE 却没有这个缺陷，一个 anchor 会计算 batch 中全部句子的距离并 softmax，并经过交叉熵损失，仅仅将与 positive 的距离视为标签 1，其他视为距离 0。也就是说，读取 batch 含有的全部的信息，并抑制除正样本对外其他表示的距离，利用的信息更多。这也就是前文说的，为什么 batch 越大效果越好。</li>
</ul>
<h1 id="其他-trick"><a href="#其他-trick" class="headerlink" title="其他 trick"></a>其他 trick</h1><p>数据不做任何形式的预处理，为什么呢？因为 query 来自用户的输入，这里面存在特殊字符、语序错误、错别字等现象很正常，处理掉反而不好。至于 item 则是商品信息，大家逛淘宝也会发现，商品信息的标注文字几乎没有标点符号，而是很多形容词的堆叠，处理掉也不好。比如：优质木制办公室家用卧室可调接高度带灯光插座多功能折叠桌，它是病句吗？是的，但是就是要查找这样的句子，没必要纠错和预处理。（我没有做消融实验，也没有做数据预处理的实验，这一点仅凭个人分析）。</p>
<p>使用 pool output 而不是 max pool 最后的隐层输出，也许你会问：使用 max pool 捕获最强的特征，也就是捕获句子中最关键的词，只要词匹配对就匹配完成了。但是想一个例子：优质木制办公室家用卧室可调接高度带灯光插座多功能<strong>折叠桌</strong> 和 优质木制办公室家用卧室可调接高度带灯光插座多功能<strong>支架</strong>，如果使用 max pool，模型初始阶段很容易捕捉错关键词，但是 pool output 就不一样了，我是全部的语义表示，哪怕只有一个词不一样，输出的表示也不一样。（这个我做了实验）。</p>
<p>模型输出的最后经过 normalization（p=2），为什么呢？我们来看个例子：假设 anchor 的表示是 <code>[0.5, 0.8]</code>，positive 的表示是 <code>[0.6, 0.7]</code>，如果计算欧式距离，此时是 0.14。如果我标准化之后，anchor 的表示是 <code>[0.53, 0.85]</code>，positive 的表示是 <code>[0.65, 0.76]</code>，此时的欧氏距离是 0.15。那么有什么用呢？<code>[0.6, 0.7]</code> 和 <code>[0.5, 0.8]</code> 虽然在每一维都很接近，但是维度间的差距却很大，因此 <code>[0.6, 0.7]</code> 并不是很好的表示，需要加大惩罚力度。而 <code>[0.4, 0.9]</code> 这样的 positive 的表示在标准化之后，和 anchor 的距离是 0.14。可见，如果不标准化，那么 <code>[0.4, 0.9]</code> 和 <code>[0.6, 0.7]</code> 等价；如果标准化，<code>[0.6, 0.7]</code> 就不是一个好表示。（这个也做了实验）。</p>
<p>交互式匹配（我没有尝试）。这个灵感来自于早年间看过的一个<a href="https://github.com/Lanping-Tech/Multi-modal-Valuation-Forecast-System" target="_blank" rel="noopener">多模态项目</a>，这个项目通过评论和股票的时序数据作为两个模态来预测股价，两个模态进行了四不像的 <a href="https://github.com/Lanping-Tech/Multi-modal-Valuation-Forecast-System/blob/main/models/fusion.py#L37-L45" target="_blank" rel="noopener">transformer</a> 操作，我没理解这是为什么，两者进行了注意力的融合，但是取得了不错的结果。我在想，这次任务没办法进行交互式匹配，但我可以在模型的隐层进行这样的注意力融合，并增加一个分类的分支给注意力提供标签。</p>
<ul>
<li>Dense Passage Retrieval for Open-Domain Question Answering 这个论文我看了，想法粗暴简洁，和 SimCSE 差不多，但我没算力去尝试。</li>
<li>SWA（stochastic weight averaging），我查别人的比赛代码看到了它，效果看着不错。而且早年间用 mmdetection 的时候，确实发现模型在最后几个 epoch 涨分很厉害，但是调参不够友好，在最后阶段我会尝试，现阶段不考虑。</li>
<li>难例挖掘，我觉得付出和收益不成正比，没有尝试。</li>
<li>以上 trick 可以拿到一个不错的分数，另外其他的 trick 我会在初赛结束后分享，真心太卷了。</li>
</ul>
<h1 id="排雷"><a href="#排雷" class="headerlink" title="排雷"></a>排雷</h1><ul>
<li>双塔结构不要尝试了，即 query 一个全连接，doc 一个全连接，两者共享一个 bert，企图让两者的表示分开不混杂在一起，但效果奇差无比。</li>
<li>SimCSE 的损失函数在 CV 的自监督领域也有应用，我尝试把 CV 自监督领域最新的损失套用到这里，但结果很难收敛。</li>
</ul>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p><a href="https://github.com/muyuuuu/E-commerce-Search-Recall" target="_blank" rel="noopener">https://github.com/muyuuuu/E-commerce-Search-Recall</a></p>
<p>为什么不用 tensorflow？我 17 年 10 月学 tf 的时候，它那个 with session 和 placeholder 我实在理解不了，那会儿才大二，编程功底很差。19 年 4 月再去看的时候，编程风格和语法大改，好像是什么磁带？梯度一会儿有一会儿没有，混乱的api设计导致代码写的晕晕的，而且和 keras 的关系我也没理解。20 年 7 月的时候我又去看，仿佛完全 keras 化，<code>tf.keras</code> 我实在是被震惊到了，编程风格和语法又又又有改动。我怕我学会了它又出现了 <code>tf.torch</code>，20 年 10 月左右入坑 pytorch，API 稳定，用着也很顺手，也就放弃了学 tf。</p>
<p>不过还是建议各位用 tf，毕竟这个项目最终要落地到工程，这就涉及到部署和性能优化，不是简简单单实现一个算法就可以完美解决所有问题。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>CoSENT：<a href="https://kexue.fm/archives/8847/comment-page-1" target="_blank" rel="noopener">https://kexue.fm/archives/8847/comment-page-1</a></li>
<li>Pytorch CoSENT 损失函数：<a href="https://github.com/shawroad/CoSENT_Pytorch" target="_blank" rel="noopener">https://github.com/shawroad/CoSENT_Pytorch</a></li>
<li>simcse 的有监督和无监督训练：<a href="https://github.com/zhengyanzhao1997/NLP-model/tree/main/model/model/Torch_model/SimCSE-Chinese" target="_blank" rel="noopener">https://github.com/zhengyanzhao1997/NLP-model/tree/main/model/model/Torch_model/SimCSE-Chinese</a></li>
</ol>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习——句子结构</title>
    <url>/2020/08/31/English-sentence/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>继续上文，补充句子结构，各种从句等。这也是最后一篇了。</p>
<a id="more"></a>
<h1 id="简单陈述句"><a href="#简单陈述句" class="headerlink" title="简单陈述句"></a>简单陈述句</h1><p>句子成分出现的顺序排列。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>When</th>
<th>who<br>which<br>what</th>
<th>action</th>
<th>who<br>which<br>what</th>
<th>how</th>
<th>where</th>
<th>(when)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>I</td>
<td>have had</td>
<td>breakfast.</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Yesterday</td>
<td>I</td>
<td>saw</td>
<td>a movie.</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>He</td>
<td>opened</td>
<td>the door</td>
<td>quietly.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Last week</td>
<td>I</td>
<td>went</td>
<td></td>
<td>to the park.</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>The play</td>
<td>was(系动词)</td>
<td>very interesting.（表语）</td>
<td></td>
<td></td>
<td>—</td>
</tr>
</tbody>
</table>
</div>
<p>主谓宾：动词的发出者，动词是谓语，动词的承受者是宾语。I love you，I 是主语，love 是谓语，you 是宾语。</p>
<p>时间状语：表示时间，去年，刚才，以后等。</p>
<p>方式状语：by car，表示方式。</p>
<p>地点状语：表示地点。</p>
<h1 id="五种基本句型"><a href="#五种基本句型" class="headerlink" title="五种基本句型"></a>五种基本句型</h1><ol>
<li>主语 + 不及物动词（主语+谓语），没有宾语。The telephone rang. 需要记住动词是否及物。（vi. 不及物，vt. 及物动词）。</li>
<li>主语 + 及物动词 + 宾语 （主谓宾）。</li>
<li>主语 + 及物动词 + 双宾语。（某些动词支持）He lent a book to me. He lent me a book.</li>
<li>主语 + 及物动词 + 宾语 + 宾补（补充说明宾语）。He is finding this trip very exciting. （发现越来越有趣）。</li>
<li>主语 + 系动词 + 表语。(linking verb 是系动词)。系动词后面是形容词。be动词、变得、感觉这类的动词。The play was very interesting. 表语是形容词，一般的动词后面是副词。</li>
</ol>
<h1 id="主谓一致"><a href="#主谓一致" class="headerlink" title="主谓一致"></a>主谓一致</h1><ol>
<li>可数名词单数或不可数名词做主语，谓语单词是单数；<br>The dog is cute, Water is necessary to life.</li>
<li>one of, each of, either of, neither of, none of + 复数名词，谓语动词单数</li>
<li>不定代词主语，谓语单词单数。<br>Someone is waiting for you.</li>
<li>the + 一类人，做主语谓语用复数。<br>Only the good（好人） die young.</li>
<li>时间、金钱、质量、距离等名词，主语是单数。<br>Three years is too long for me to wait.<br>Two million dollars is needed by me.</li>
<li>不定式，动名词，一句话做主语，谓语用单数。<br>Eating is my favorite.<br>It’s nice to be with you.<br>what you said is true.</li>
<li>either…or, neither…nor, not only…but also, or 连接两个主语，谓语动词就近原则。<br>Not only the teacher but also the students were invited.<br>Not only the students but also the teacher was invited.</li>
<li>There be 取决于靠近的主语。<br>There is a pan and three books on the desk.<br>There are three books and a pan on the desk.</li>
<li>both…and连接两个主语，谓语动词复数。</li>
<li>and连接两个主语，主语是一个还是两个，一个整体单数，两个复数。<br>The singer and dancer <strong>is</strong> coming to our city. （指一个人）<br>Bread and butter is fattening. （一道菜）<br>Going to bed early and getting up early is a good habit.<br>To love and to be loved is great happiness.</li>
</ol>
<h1 id="双宾语动词"><a href="#双宾语动词" class="headerlink" title="双宾语动词"></a>双宾语动词</h1><p>give, teach, buy, lend, make, hand（传递）, sell（卖）, read, pay, find, offer, pass（递过来）, bring, show. 宾语分别是人和物，两个宾语不能都是人和物。</p>
<p>give(read) sb sth, give sth to sb. （短的东西在前，长的东西在后），buy(make) sth for sb。</p>
<h2 id="双宾语的被动"><a href="#双宾语的被动" class="headerlink" title="双宾语的被动"></a>双宾语的被动</h2><ul>
<li>宾语提前变被动：sb be given sth 或者 sth be given to sb。be 根据时态而变换。A large sum of money has been offered to me. （不可数名词主语，单词第三人称单数）</li>
</ul>
<h1 id="时间副词在句子中的位置"><a href="#时间副词在句子中的位置" class="headerlink" title="时间副词在句子中的位置"></a>时间副词在句子中的位置</h1><p>never, sometimes, rarely, seldom, usually, always。位于实义动词（具体动作）之前，助动词（帮助动词做谓语 do, be, have，不止一个助动词第一个助动词之后。）和情态动词（can, should, may）之后。I sometimes stay in bed until lunchtime. You should never trust him.</p>
<p>疑问句：位于主语之后。Do you always get up so late?</p>
<h1 id="感叹句"><a href="#感叹句" class="headerlink" title="感叹句"></a>感叹句</h1><ul>
<li>what + a/an + 形容词（可以去掉）+ 可数名词单数 + 主谓（可以去掉）。What a beautiful girl (she is )! What a day!  Thanks a lot. 没有形容词，需要上下文。</li>
<li>what + 形容词 + 可数名词复数/不可数名词 + 主谓（可以去掉）。What lovely children (they are)! What terrible weather (it is)!</li>
<li>how + 形容词/副词 + (主语谓语)，How handsome (the boy is)! </li>
<li>how + 形容词 + a/an + 可数名词单数 + （主谓）。How cute a boy (he is) !</li>
</ul>
<h1 id="直接引语与间接引语"><a href="#直接引语与间接引语" class="headerlink" title="直接引语与间接引语"></a>直接引语与间接引语</h1><p>都是宾语，引语就是引用别人的话。</p>
<ul>
<li><p>直接引语，一字不差的引用，放在单引号内；</p>
</li>
<li><p>间接引语，用自己的话转述别人的话，以宾语从句的形式出现。人称与时态的变化：</p>
</li>
<li><p>人称正常变换</p>
</li>
<li><p>时态的变化：当时就转化，动词用一般现在时，直接引语的时态不做改变，He says: ‘I am busy’=He says that he is busy；时态不改，时态中的助动词改；过了一段时间在转述，主句的谓语动词用过去时，间接引用中的时态：</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>直接引语</th>
<th>间接引语</th>
</tr>
</thead>
<tbody>
<tr>
<td>一般现在时</td>
<td>一般过去时</td>
</tr>
<tr>
<td>一般过去时（说的时候是过去）</td>
<td>过去完成时（动作是过去的过去）</td>
</tr>
<tr>
<td>现在进行时</td>
<td>过去进行时</td>
</tr>
<tr>
<td>一般将来时（will）</td>
<td>过去将来时（would）</td>
</tr>
<tr>
<td>现在完成时</td>
<td>过去完成时</td>
</tr>
<tr>
<td>情态动词</td>
<td>对应过去时</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>宾语从句的时态和主语保持一致：</p>
<ol>
<li>主句现在时，从句任意</li>
<li>主句过去时，从句必须用过去的某种时态（客观真理除外）</li>
</ol>
</li>
</ul>
<h1 id="条件状语从句"><a href="#条件状语从句" class="headerlink" title="条件状语从句"></a>条件状语从句</h1><ul>
<li><p>if 引导的条件状语从句</p>
<ul>
<li><p>真实条件句，假设有可能发生</p>
</li>
<li><p>非真实条件句，假设发生的可能性很小（虚拟语气）</p>
</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>if 从句</th>
<th>主句</th>
</tr>
</thead>
<tbody>
<tr>
<td>现在时态（一般现在，现在进行，现在完成）</td>
<td>一般将来时或情态动词或祈使句</td>
</tr>
</tbody>
</table>
</div>
<p>  If you move,  I will shoot you.<br>  If he is sleeping, don’t（祈使句） wake him.<br>  If you have finished homework, you can（情态动词） see the movie.<br>  If winter comes, can spring be far behind?</p>
<h1 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h1><p>一句话做宾语。连接词：</p>
<ol>
<li>that 引导，陈述句放在宾语从句中，之前加 that。I know that you are right.</li>
<li>特殊疑问词引导的宾语从句，特殊疑问句放在宾语从句中，改为陈述句。I want to know what you are talking about. （助动词放到主语之后）。I want to know where you have been. I want to know when tom to left.（注意时态）。I know who he is.</li>
<li>If/Whether引导，表示是否。一般疑问句放在宾语从句中，需要在疑问句句首加上If/Whether，改为陈述句。I want to know if you are a doctor. I want to know if you have finished your work. I want to know if you will go abroad. I want to know you are listening to me. </li>
<li>以下情况只能是 whether：<ol>
<li>做介词宾语：I worry about whether I hurt his feelings.</li>
<li>跟 or 结构：She always tells me whether my picture is good or not.</li>
</ol>
</li>
</ol>
<h1 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h1><p>形容词性从句。</p>
<ul>
<li>定义：一句话做定语。修饰句子中的名词，代词或者名词短语。位于被修饰成分之后，被修饰的是先行词。</li>
<li>划分：限定性和非限定性定语从句。非限定性，用逗号隔开主句和从句，不能用 that。</li>
<li>引导词：关系代词 who whom whose that which，关系副词，when where why。指代先行词，以先行词的身份在定语从句中充当一定成分。</li>
</ul>
<p>who：先行词是人，从句是主语或宾语。<br>whom：先行词是人，从句中做宾语，不能是主语。<br>which：先行词是物，从句中做主语或宾语。<br>that：先行词是人或物，从句中做主语或宾语。<br>whose：先行词是人或物，从句中做定语。<br>when：先行词是表示时间的名词，从句中做时间状语。<br>where：先行词是表示地点的名词，从句中做地点状语。<br>why：先行词是reason，从句中做原因状语。<br>what 和 how 不能引导定语从句。</p>
<ul>
<li>I like the girl who has big eyes.</li>
<li>I like the girl whose eyes are very big. Please pass me the book whose cover is green. （表示什么什么的）</li>
<li>I like the novel which you are reading. That was a fault which couldn’t be forgiven.</li>
<li>Who is the man about whom you are talking? （当宾语，that 和 who 之前不能有介词，只能用  which 和 whom）。I’m the guy from whom you’re trying to get away (from 提前)。</li>
<li>I will never forget the day when I came to Beijing. (on which)</li>
<li>The police searched the house where he lived. (in which)</li>
<li>I don’t know the reason why he is angry. (for which)</li>
</ul>
<p>副词 = 介词 + which，定语从句在先行词之后。</p>
<ul>
<li>I never forget the day which we spent together。（spent后面跟宾语，能做宾语的只有 which 或者 that）。<br>I never forget the day when we first met。（不缺宾语，用作时间状语） 。</li>
<li>This is the movie that I want to see it （错误，that充当了宾语，不能出现重复的成分 it）</li>
</ul>
<p>关系词省略：</p>
<ol>
<li>非限定性定语从句不能省略</li>
<li>关系代词：做宾语或表语可以省略，前提是不在介词之后</li>
<li>when 和 why 可以省略。</li>
</ol>
<h2 id="主谓一致问题"><a href="#主谓一致问题" class="headerlink" title="主谓一致问题"></a>主谓一致问题</h2><ul>
<li>关系代词作从句主语，从句谓语动词和先行词保持一致。</li>
<li>只能用 that：<ul>
<li>先行词有形容词最高级来修饰；the greatest men</li>
<li>先行词有序数词来修饰；the first, the second</li>
<li>先行词有 the only, the very 修饰；This is the very book that I am looking（very加强语气）</li>
<li>先行词为不定代词：something, anything, nothing, everything</li>
<li>先行词即含有表示人的名词和表示物的名词，men and money that he needed.</li>
</ul>
</li>
</ul>
<h2 id="非谓语动词做定语"><a href="#非谓语动词做定语" class="headerlink" title="非谓语动词做定语"></a>非谓语动词做定语</h2><h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><p>具有形容词的特征。单个分词做前置定语，分词短语做后置定语。</p>
<ul>
<li>过去分词作定语。<ul>
<li>表示被动。单个过去分词位于修饰词前；过去分词短语，放在修饰词之后。（A beautiful book, a book on the desk），A broken glass，一个<strong>被</strong>打碎的玻璃杯，A glass broken by my sister。A damaged car，A car damaged in an accident。The forbidden fruit. </li>
<li>也可以表示完成：fallen leaves（已经落下来的叶子），retired workers（退休工人）。</li>
</ul>
</li>
<li>现在分词作定语。<ul>
<li>表示动作正在进行：A passing boat, a running dog。</li>
<li>动名词作定语，表示功能：A sleeping pill（助眠药丸）。</li>
<li>表示主动：I heard a noise coming (that came) from upstairs（主动关系，不是正在进行）。The man sitting next to Mary is our teacher. I like the smiling baby. The man named John is my brother. Talking to Mary.</li>
</ul>
</li>
</ul>
<h2 id="不定式"><a href="#不定式" class="headerlink" title="不定式"></a>不定式</h2><p>不定式做后置定语，表示没有做的事情。</p>
<p>I have a lot of work to do.<br>I need a pan to write with.<br>We will buy a house to live in.</p>
<h2 id="非限定性定语从句"><a href="#非限定性定语从句" class="headerlink" title="非限定性定语从句"></a>非限定性定语从句</h2><ul>
<li>限定性：从句与先行词有不可分割的关系，去掉后指代不明；</li>
<li>非限定性：从句对意义很明确的先行词做补充说明，去掉不影响句子含义。（引导词前面有个逗号）</li>
</ul>
<p>I like the baby who is yawning.（三个宝宝，限定性，表明说谁）<br>I like the baby, who is yawning. （只有一个宝宝，不用表明说谁）<br>Beijing, which is my hometown, is a beautiful city.<br>I’ll move to Melbourne, which is the second largest city in Australia.</p>
<p>which 或 as 引导的非限定性定语从句，用逗号和主句分开。</p>
<ol>
<li>可以修饰整个主句；</li>
<li>as 有『正如』的意思，主句前后均可；</li>
<li>which 含义没有限制，只能位于主句后。</li>
</ol>
<p>I said nothing, which made him more angry.<br>He was a policeman in disguise, which surprised me a lot。（不能用 as，没有『正如』的意思）<br>He is a god at English, as we all know.<br>As we all know, he is good at English. （放到句首）</p>
<p>As Napoleon once pointed it out, attack is the best method of defense. As 充当宾语，指代主句，去掉 it。</p>
<h1 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h1><p>一句话作表语。和宾语从句类似，属于名词性从句。与宾语从句的比较：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>陈述句</th>
<th>一般疑问句</th>
<th>特殊疑问句</th>
</tr>
</thead>
<tbody>
<tr>
<td>宾语从句</td>
<td>that</td>
<td>whether/if （特殊情况只能whether）</td>
<td>特殊疑问词</td>
</tr>
<tr>
<td>表语从句</td>
<td>that</td>
<td>whether</td>
<td>特殊疑问词</td>
</tr>
</tbody>
</table>
</div>
<p>系动词之后（表示<strong>是</strong>）：The fact <strong>is that</strong> I can’t finish the job in two days。<br>The question is <strong>whether</strong> it is true or not.（原一般疑问句：Is it true or not ?）<br>This is not <strong>what</strong> I mean.</p>
<h1 id="状语从句"><a href="#状语从句" class="headerlink" title="状语从句"></a>状语从句</h1><p>副词性从句，表示时间、地点、方式、原因等状态的从句。省略的前提：</p>
<ul>
<li>从句主语和主句主语一致，借用主句的主语；</li>
<li>从句中有 be 动词，从句主语和 be 动词<strong>一起</strong>省略；</li>
</ul>
<p>He fall asleep when (he was) doing his homework.<br>When I was surfing the net, the power was off.（主语不一致，不能省略）<br>His father died when he was only three. （主语不一致，不能省略）<br>He always cut class when (he was) a boy.<br>When I say I love you, I mean it. （没有 be 动词，不能省略）</p>
<p>特例：</p>
<ul>
<li>Call me when (it is) necessary，从句主语 it 后有 be 动词，可以省略。</li>
</ul>
<h2 id="分词作状语"><a href="#分词作状语" class="headerlink" title="分词作状语"></a>分词作状语</h2><p>非谓语：过去分词，现在分词，不定式，动名词。</p>
<p>分词有形容词副词的特征，做定语（形容词，表达被动）或状语（副词，表达被动）。状语从句中若主语和主句的主语保持一致，则可以换成分词做状语。</p>
<ol>
<li>从句主语和主句主语是否一致；</li>
<li>一致找从句的谓语动词；</li>
<li>判断从句的和主语的谓语关系，主动用现在分词，被动用过去分词。</li>
</ol>
<p>If you turn to left, you will find the station. 转换 Turning to left, you will find the station.<br>While I was walking to school yesterday, I met a friend. 转换 Walking to school yesterday, I met a friend. 主动关系。<br>As I didn’t receive her letter, I called her up. 转换 Not receiving her letter, I called her up.<br>I stood there awkwardly, as I didn’t know what to say. 转换 I stood there awkwardly, not knowing what to say.<br>As I didn’t want to be seen, I hid behind a table. 转换 Not wanting to be seen, I hid behind a table.<br>The little girl was sitting on the ground, crying.<br>He lay in bed, thinking about what happened in the day.<br>He went home, beaten black and blue all over. </p>
<p>Having waited in the queue for half an hour, the old man suddenly realized he had left his check in the car. 现在分词的完成形式，动作发生在谓语动作之前，不是同时发生。</p>
<p>being 分词作状语，可以省略。Being tired of 等价 Tired of，Tired of watching TV, we went out for a walk.<br><strong>(Being)</strong> Hungry for 3 days, he could hardly move.</p>
<h1 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h1><p>一句话中两个句子成分指代的东西相同，后者是前者的同位语。同位语以句子的形式出现，就是同位语从句。主语、宾语、同位语、表语从句称为名词性从句。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>陈述句</th>
<th>一般疑问句</th>
<th>特殊疑问句</th>
</tr>
</thead>
<tbody>
<tr>
<td>宾语从句</td>
<td>that（可省略）</td>
<td>whether /if</td>
<td>特殊疑问词</td>
</tr>
<tr>
<td>同位语从句</td>
<td>that（不可以省略）</td>
<td>whether</td>
<td>特殊疑问词</td>
</tr>
</tbody>
</table>
</div>
<p>同位语从句的先行词多为：fact, news, idea, thought, reply, answer, remark, plan, possibility, question. 连接词一般为 that（question 除外）。</p>
<p>No one could account for（解释） the fact that one of the boxes was extremely heavy.<br>The question whether Tom will arrive on time is still unknown. Please tell me whether Tom will arrive on time.（宾语从句）<br>The child’s question why the sky is blue is hard to answer. </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>that 引导的同位语从句</th>
<th>that 引导的定语从句</th>
</tr>
</thead>
<tbody>
<tr>
<td>进一步解释前面的名词</td>
<td>修饰前面的名词</td>
</tr>
<tr>
<td>连接符号，that 不翻译</td>
<td>that 是关系代词，从句中做主语、宾语或表语</td>
</tr>
</tbody>
</table>
</div>
<p>The replay that he gave me hurt my feelings. （定语从句）<br>The replay that he couldn’t help me hurt my feelings. （同位语从句）</p>
<p>The news that the airplane crashed in the Indian Ocean shocked me. （飞机坠毁了，这个消息让我很震惊）<br>The news that he told me shocked me. （定语从句，他告诉我<strong>的</strong>那个消息）<br>The question whether the plane could be found was hard to answer.<br>The question that you asked was hard to answer. （定语从句）</p>
<h1 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h1><p>引导主句。</p>
<ol>
<li>原来是陈述句，that引导，that在句首不可忽略。<br>It is certain that she will succeed. 转换为 That she will succeed is certain.</li>
<li>一般疑问句，用 whether/if 来引导，句首只能用 whether，从句陈述语气。<br>It is not known whether she will come. Whether she will come is not known.</li>
<li>原来是特殊疑问句，用特殊疑问词引导。<br>It is a mystery how the prisoner escaped 转换 How the prisoner escaped is a mystery.</li>
</ol>
<p>A storm is coming. It is clear. 转换 It is clear that a storm is coming. That a storm is coming is clear.</p>
<p>Does he like it? It is not known. 转换 It is not known whether he likes it. Whether he likes it is not known.</p>
<p>Why did she fail the exam? It is uncertain. 转换 It is uncertain why she failed the exam. Why she failed the exam is uncertain.</p>
<h1 id="完全倒装语序"><a href="#完全倒装语序" class="headerlink" title="完全倒装语序"></a>完全倒装语序</h1><p>谓语动词在主语之前，全部倒装（所有谓语动词都在主语前面）或部分倒装（部分谓语动词在主语前面）。表示“位置”，“次序”的状语位于句首，全部倒装。</p>
<p>Miss Green came in 等价 In came Miss Green.<br>A temple stands on the hill 等价 On the hill stands a temple.<br>Your turn comes now 等价 Now comes your turn.<br>A horse came next 等价 Next came a horse.<br>In the town where I was born <strong>lived</strong> a man who sailed to sea and he told us of his life in the land of submarines.<br>There is a cat under the table. A cat is there under the table.</p>
<p>He went off 等价 Off he went. （he 是代词，不倒桩），Here you are。<br>John saw Mary on the hill 等价 On the hill John saw the Mary。（saw 是及物动词，不倒装）</p>
<h1 id="部分倒装"><a href="#部分倒装" class="headerlink" title="部分倒装"></a>部分倒装</h1><p>助动词提到主语前（be 动词 或 情态动词，谓语动词仍然在主语后）。使用场合：</p>
<ol>
<li>so , such, well, often, only 在句首<br>The weather was so fine that we all went out lying in the sun. 转换为 So fine was the weather that we all went out lying in the sun.<br>I knew him well and he knew me well. 转换为 Well did I know him and well did he know me。（well 相当的）<br>We often see each other 转换为 Often do we see each other.<br>He realized that he was wrong only then（直到才）. 转换为 Only then did he realize he was wrong.<br>You can trust only me. 转换为 Only me can you trust.<br>He eats only vegetables 转换为 Only vegetables he eats.<br>We can succeed in doing anything only by working hard 转换为 Only by working hard can we succeed in doing anything.<br>Only you understand me。only修饰主语不倒装。</li>
<li>否定词句首，需要部分倒装：not, no, neither, nor, hardly, rarely, seldom, not only, little, few.<br>Never have I seen such a good movie. 等价 I have never seen such a good movie.</li>
</ol>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习——时态</title>
    <url>/2020/08/27/English-tense/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>想来自己英语太差劲了，去youbute上随便搜了搜，发现这个<a href="https://www.youtube.com/watch?reload=9&amp;v=qkYU7cp6hEU" target="_blank" rel="noopener">老师</a>讲的还不错。<del>如果能娶到这么好的老师当老婆</del>。啊，不是。如果当初有这么好的老师来教英语，也不至于学成一团糟。</p>
<p>老师讲的比较系统，初高中都是做题看到一个讲一个，到时候学一个记一个，很乱。我整理了老师讲课的笔记之类，做了归纳整理。一是这是我自己的学习笔记，二是万一方便后来者呢？</p>
<a id="more"></a>
<h1 id="现在进行时"><a href="#现在进行时" class="headerlink" title="现在进行时"></a>现在进行时</h1><p>表示正在进行的动作（having breakfast）；表示即将发生的动作（He’s dying, I’m moving this weekend）；</p>
<ul>
<li>肯定句：subject + (am, is, are) + doing.</li>
<li>否定句：subject + be + not + doing.</li>
<li>疑问句：be + subject + doing?</li>
<li>特殊疑问句：疑问词 + be + subject + doing?</li>
</ul>
<h1 id="一般过去时"><a href="#一般过去时" class="headerlink" title="一般过去时"></a>一般过去时</h1><p>时间与谓语动词的形态。和表示过去的时间状语连用，yesterday, last week, two years ago, in 1999, since（主句现在完成，从句一般过去式）。</p>
<h2 id="使用场合："><a href="#使用场合：" class="headerlink" title="使用场合："></a>使用场合：</h2><ul>
<li>过去事件发生的动作或存在的状态，动作（其他动词）和状态（be）区分开；</li>
<li>过去某个时间段的习惯，反复发生的动作（我奶奶过去经常给我讲故事）；</li>
<li>讲到已经死去的人。</li>
</ul>
<h2 id="谓语动词结构"><a href="#谓语动词结构" class="headerlink" title="谓语动词结构"></a>谓语动词结构</h2><ul>
<li>一般动词：subject + 动词过去时，subject + didn’t + 动词原形, Did + subject + 动词原形？（均借助助动词）</li>
<li>be动词（没有动词，表达状态，如他昨天在那）：subject + was/were（wasn’t, weren’t） …</li>
</ul>
<h1 id="现在完成时"><a href="#现在完成时" class="headerlink" title="现在完成时"></a>现在完成时</h1><p>使用场合：</p>
<ul>
<li>表示动作一致持续到现在。I have lived in Beijing for ten years. So far, there has been no news of him.</li>
<li>动作过去发生，发生时间不明，影响持续到现在。I have just lost my key. I lost the key this morning.（有具体时间点） ，I had breakfast at 8 o’clock.</li>
</ul>
<p>标志词：just, lately, recently, yet（还….，否定句，句子末尾）, already（肯定句，句子中间）, ever（曾经）, never, so far, up to now, before（之后没有东西）, for …, sicnce…。</p>
<p>不可延续性动词不能和表示一段时间的状语连用。die, marry（嫁）, come, arrive, leave, go, finish, buy。借助 be 动词，My dog has been dead for three years. He has been in Beijing for three years. </p>
<h2 id="谓语动词结构-1"><a href="#谓语动词结构-1" class="headerlink" title="谓语动词结构"></a>谓语动词结构</h2><ol>
<li>肯定句：subject + have/has（表示现在） + done（动词过去分词，表示完成）</li>
<li>否定句：subject + haven’t/hasn’t + done</li>
<li>疑问句：have/has + subject + done</li>
</ol>
<h1 id="过去完成时"><a href="#过去完成时" class="headerlink" title="过去完成时"></a>过去完成时</h1><p>使用条件：表示动作发生在过去某时之前，强调过去的过去。</p>
<ul>
<li>肯定句：subject + had + done （had 是体现时态的助动词，表示过去）</li>
<li>否定句：subject + had not /hadn’t + done</li>
<li>疑问句：had + subject + done?</li>
</ul>
<p>Before I got home, the rain had stopped.</p>
<p>After I had turned off the light, I left the room. = After I turned off the light, I left the room.（也可以用一般过去时）</p>
<h1 id="一般将来时"><a href="#一般将来时" class="headerlink" title="一般将来时"></a>一般将来时</h1><p>表示将来发生的动作。shall 只用于第一人称。</p>
<ul>
<li>肯定句：subject + will / shall + do</li>
<li>否定句：subject + will/shall + not + do (won’t, shan’t)</li>
<li>疑问句：will/shall + subject +do</li>
</ul>
<p>将来时态及结构：</p>
<ul>
<li>will + do</li>
<li>be + doing  表示即将发生的动作</li>
<li>be + going + to + do 表示打算或者即将发生的事</li>
<li>mean to do, plan to do, intend to do, hope to do. 打算的意思，用于将来时</li>
<li>be to do，表示即将发生的动作</li>
<li>be about to do，表示马上发生的动作</li>
<li>will be doing 将来进行时，表示意料之中将会发生的事</li>
</ul>
<h1 id="将来进行时"><a href="#将来进行时" class="headerlink" title="将来进行时"></a>将来进行时</h1><p>结构：will be doing。</p>
<p>时间：</p>
<ol>
<li>将来将正在做的事情（疑问句时，多个助动词，将第一个助动词提到主语之前）</li>
<li>表示将要做的事，类似于一般将来，强调一个计划的安排性</li>
<li>可预见性的将来，询问别人的计划</li>
</ol>
<h1 id="被动语态"><a href="#被动语态" class="headerlink" title="被动语态"></a>被动语态</h1><p>应用场合：不知道主语是谁；没必要表达主语是谁（语法成分重要的东西在前面：The temple is being repaired） ；强调动作的承受者。</p>
<p>A + do + B = B + be（体现时态，过去，现在，将来） + done（过去分词，表被动） + (by A)。被动语态：</p>
<ul>
<li>一般现在：am/is/are + done</li>
<li>一般过去时：was/were + done</li>
<li>现在进行：am/is/are + being + done</li>
<li>过去进行：was/were  + being + done</li>
<li>现在完成：has/have + been + done</li>
<li>过去完成：had + been + done</li>
<li>一般将来：wiil + be + done</li>
<li>过去将来：would + be + done</li>
</ul>
<p>History is made by people.<br>The boy has been found by them.<br>The house is being repaired by him.<br>The bridge was built (by them) in 1980. </p>
<h1 id="将来完成时"><a href="#将来完成时" class="headerlink" title="将来完成时"></a>将来完成时</h1><ul>
<li>使用场合：从现在看，截止到将来某时将已经完成的动作。</li>
<li>谓语动词：will have done。</li>
</ul>
<p>By the end of next month( by 表示截止 ), they will have been( 谓语动词 ) married ( 表示结婚的状态，结婚了的) for thirty years.<br>By the end of last month, they had been married for 30 years.<br>We will have finished the book by the end of this month.</p>
<h1 id="现在完成进行时"><a href="#现在完成进行时" class="headerlink" title="现在完成进行时"></a>现在完成进行时</h1><p>过去一个动作发生，一直持续到现在，而且有可能持续下去。动作可能没有完成，如果完成也是刚刚完成。</p>
<p>subject + have /has been + doing </p>
<p>It has been raining for three days and it is still raining.<br>I have been waiting for an hour but she hasn’t come.<br>He has been running after her 8 years. （run after 追求）<br>I have been looking for you.</p>
<p>与现在完成时的区别：</p>
<ol>
<li>现在完成时强调对现在的影响，进行时强调动作的持续；</li>
<li>不用于进行时态的动词不能用于现在完成进行时：<br>I have known him for 8 years. 对<br>I have been knowing him for 8 years. 错</li>
<li>肯定句中，表示一段时间的状语连用，时态可以互换；<br>We’ve lived here for 2 years.<br>We’ve been living here for 2 years.</li>
<li>不与时间状语连用是意义不同；<br>I have been waiting for you. （还在等）<br>I have waited for you. （已经走了）</li>
</ol>
<h1 id="过去完成进行时"><a href="#过去完成进行时" class="headerlink" title="过去完成进行时"></a>过去完成进行时</h1><p>subject + had + been doing，过去某时发生，一直延续到另一个过去的时刻。可能没有完成，完成也是刚刚完成。</p>
<p>I had been studying English before 2005.<br>Nobody knew what he had been doing all these years. （knew 体现过去的过去）</p>
<p>与过去完成时的区别：</p>
<ol>
<li>过去完成：动作发生在过去；完成进行，强调过去某时的动作一直持续；</li>
<li>不用于进行时的动词不能用于过去完成进行时；<br>He had loved her before they divorced. （正确）<br>He had been loving her before they divorced. （错误）</li>
<li>肯定句中，与时间状语连用，可以互换，口语常用过去完成时。<br>She had been waiting for him for 3 hours before he came back.</li>
<li>不与时间状语连用，意义不同。<br>She had cleand the room so it was tidy. （打扫得很干净）<br>She had been cleaning the room so we had to wait outside. （过去一直打扫，）</li>
</ol>
<h1 id="将来完成进行时"><a href="#将来完成进行时" class="headerlink" title="将来完成进行时"></a>将来完成进行时</h1><p>subject + will + have + been doing，某一个动作从某一个时刻开始，一直延续到将来的某一个时刻。</p>
<p>By this time next week, I will have been working for this company for 10 years.<br>Mr.Page will have been teaching for a total of forty years.</p>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>分割篇：开山之作 FCN</title>
    <url>/2021/05/24/FCN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CV 系列的论文和程序得一点点开坑了。目前准备的计划任务是：FCN，OHEM，Mask RCNN，YOLO，Focal loss，Seesaw loss。别问，问就是网上一点点查阅得到的，然后写写代码。这个系列完结后，大概会结合对抗样本 and 目标检测做一些东西。自己还是差的太远。</p>
<a id="more"></a>
<h1 id="什么是语义分割"><a href="#什么是语义分割" class="headerlink" title="什么是语义分割"></a>什么是语义分割</h1><p>语义分割的直观解释可以见下图，计算照片中的每一个像素点的类别，进而得到哪些像素点属于同一类，把一些物体给分割出来：</p>
<p><img data-src="http://mi.eng.cam.ac.uk/research/projects/VideoRec/CamVid/pr/DBOverview1_1_huff_0000964.jpg" alt></p>
<h1 id="FCN"><a href="#FCN" class="headerlink" title="FCN"></a>FCN</h1><p>CNN 能够对图片进行分类，可是怎么样才能识别图片中特定部分的物体，在这篇论文之前，还是一个未解难题。</p>
<ul>
<li>对于传统的分类网络，经过 CNN 不断卷积、池化的处理，最后进入全连接网络，预测当前图片的分类。但会丢失空间信息，无法预测每个像素的分类。</li>
<li>对于目标检测的网络，也是经过 CNN 不断卷积、池化的处理，在最后的特征图上预测类别和位置。但识别出来的是目标框，并非物体的轮廓边界。</li>
</ul>
<p>而 FCN 的创新之处在于，使用卷积操作替换了分类网络的全连接，使得输入输出保持在相同尺寸，这样就可以预测每个像素点的类别。加上使用了卷积，自然而然也就可以处理任意尺寸的图像。网络结构如下，用下面的卷积替换上面的全连接：</p>
<p><img data-src="https://z3.ax1x.com/2021/05/24/gvGwrQ.png" alt></p>
<h1 id="上采样"><a href="#上采样" class="headerlink" title="上采样"></a>上采样</h1><p>经过不断的卷积，图像的尺寸会减少而维度会增加。所以为了使得网络输出的图像尺寸和原图像一致，需要进行一些上采样，使它恢复到输入图像相同的尺寸，从而可以对每个像素都产生了一个预测, 同时保留了原始输入图像中的空间信息, 最后在与输入图等大小的特征图上对每个像素进行分类，逐像素地用 softmax 分类计算损失，相当于每个像素对应一个训练样本。这部分在论文的第三章有所描述。</p>
<p>而上采样采用的操作是<strong>转置卷积</strong>，如下图 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 所示，蓝色是输入，青色是输出，将图像的尺寸瞬间增加了一倍。而文中发现，这种形式的上采样是最有效的，且，可以通过叠加之前的输入（类此残差），获得更好的精度。此外文中特意表明了转置卷积也是卷积层，按照普通的卷积层进行训练即可。</p>
<p><img data-src="https://z3.ax1x.com/2021/05/24/gvNSo9.gif" alt></p>
<h1 id="融合操作"><a href="#融合操作" class="headerlink" title="融合操作"></a>融合操作</h1><p><img data-src="https://z3.ax1x.com/2021/05/24/gva3Vg.png" alt></p>
<p>如上图所示，论文给出了 FCN 的三种版本。</p>
<ul>
<li>对于 FCN-32s，直接在最后一层进行 32 倍的上采样，原始空间信息倍大量丢失</li>
<li>对于 FCN-16s，将 pool5 后的结果进行 2 倍上采样，与 pool4 的结果相加，得到结果 $F$，而后进行 16 倍上采样</li>
<li>对于 FCN-8s，将 $F$ 与 pool3 后的结果相加，而后进行 8 倍上采样</li>
</ul>
<p>论文中的结论是，FCN-8s 的效果要好一些，毕竟更多的利用了原始空间信息。网络结构图如下 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> ：</p>
<p><img data-src="https://z3.ax1x.com/2021/05/24/gvwICd.png" alt></p>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>网上看到了份程序，逻辑写的还不错：</p>
<p><a href="https://github.com/pochih/FCN-pytorch/blob/master/python/fcn.py" target="_blank" rel="noopener">https://github.com/pochih/FCN-pytorch/blob/master/python/fcn.py</a></p>
<p>尺寸在我裁剪图片的时候进行了放缩，不要太在意。</p>
<p><img data-src="https://z3.ax1x.com/2021/05/24/gvBWfH.png" alt></p>
<h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p>若要可视化展示结果，需要对网络输出的结果进行解码。如标注图片上的类别等。假设输入图像的尺寸是 [800, 800] 的，当前类别数量是 21，会得到 [bacthsize, num_classes, height, width] 的输出。假设当前 batchsize 是 1，那么就需要在 num_classes 张 [height, width] 大小的图片中选择出每个像素点的类别。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">out = fcn(data)[<span class="string">'out'</span>]</span><br><span class="line"><span class="comment"># 选择每个像素点的最大的类别</span></span><br><span class="line">om = torch.argmax(out.squeeze(), dim=<span class="number">0</span>).detach().cpu().numpy()</span><br><span class="line">decode_segmap(om)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_segmap</span><span class="params">(image, nc=<span class="number">21</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 类别颜色，画图用</span></span><br><span class="line">    label_colors = np.array([</span><br><span class="line">        (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),  <span class="comment"># 0=background</span></span><br><span class="line">        <span class="comment"># 1=aeroplane, 2=bicycle, 3=bird, 4=boat, 5=bottle</span></span><br><span class="line">        (<span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        (<span class="number">0</span>, <span class="number">128</span>, <span class="number">0</span>),</span><br><span class="line">        (<span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>),</span><br><span class="line">        (<span class="number">0</span>, <span class="number">0</span>, <span class="number">128</span>),</span><br><span class="line">        (<span class="number">128</span>, <span class="number">0</span>, <span class="number">128</span>),</span><br><span class="line">        <span class="comment"># 6=bus, 7=car, 8=cat, 9=chair, 10=cow</span></span><br><span class="line">        (<span class="number">0</span>, <span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">        (<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">        (<span class="number">64</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        (<span class="number">192</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        (<span class="number">64</span>, <span class="number">128</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="comment"># 11=dining table, 12=dog, 13=horse, 14=motorbike, 15=person</span></span><br><span class="line">        (<span class="number">192</span>, <span class="number">128</span>, <span class="number">0</span>),</span><br><span class="line">        (<span class="number">64</span>, <span class="number">0</span>, <span class="number">128</span>),</span><br><span class="line">        (<span class="number">192</span>, <span class="number">0</span>, <span class="number">128</span>),</span><br><span class="line">        (<span class="number">64</span>, <span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">        (<span class="number">192</span>, <span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">        <span class="comment"># 16=potted plant, 17=sheep, 18=sofa, 19=train, 20=tv/monitor</span></span><br><span class="line">        (<span class="number">0</span>, <span class="number">64</span>, <span class="number">0</span>),</span><br><span class="line">        (<span class="number">128</span>, <span class="number">64</span>, <span class="number">0</span>),</span><br><span class="line">        (<span class="number">0</span>, <span class="number">192</span>, <span class="number">0</span>),</span><br><span class="line">        (<span class="number">128</span>, <span class="number">192</span>, <span class="number">0</span>),</span><br><span class="line">        (<span class="number">0</span>, <span class="number">64</span>, <span class="number">128</span>)</span><br><span class="line">    ])</span><br><span class="line">    r = np.zeros_like(image).astype(np.uint8)</span><br><span class="line">    g = np.zeros_like(image).astype(np.uint8)</span><br><span class="line">    b = np.zeros_like(image).astype(np.uint8)</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">0</span>, nc):</span><br><span class="line">        <span class="comment"># 目标类的索引</span></span><br><span class="line">        idx = image == l</span><br><span class="line">        r[idx] = label_colors[l, <span class="number">0</span>]</span><br><span class="line">        g[idx] = label_colors[l, <span class="number">1</span>]</span><br><span class="line">        b[idx] = label_colors[l, <span class="number">2</span>]</span><br><span class="line">    rgb = np.stack([r, g, b], axis=<span class="number">2</span>)</span><br><span class="line">    plt.imshow(rgb)</span><br><span class="line">    plt.savefig(<span class="string">'result.png'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p>此外，U-Net <sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> 的网络结构也适合做分割，先记下来，也许某一天做语义分割的任务会用到。</p>
<p><img data-src="https://z3.ax1x.com/2021/05/24/gv6rd0.png" alt></p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/abs/1411.4038" target="_blank" rel="noopener">Fully Convolutional Networks for Semantic Segmentation</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/vdumoulin/conv_arithmetic" target="_blank" rel="noopener">卷积动画演示</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="http://flyrie.top/2018/06/22/%E5%85%A8%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%EF%BC%88FCN%EF%BC%89/" target="_blank" rel="noopener">FCN-8s 结构图</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://learnopencv.com/pytorch-for-beginners-semantic-segmentation-using-torchvision/" target="_blank" rel="noopener">分割后的图片解码 </a></span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/milesial/Pytorch-UNet" target="_blank" rel="noopener">U-Net 网络实现</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习——词汇与虚拟语气</title>
    <url>/2020/08/30/English-word/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>继续上文，补充词汇的用法，和虚拟语气。</p>
<a id="more"></a>
<h1 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h1><h2 id="冠词"><a href="#冠词" class="headerlink" title="冠词"></a>冠词</h2><p>a an the. </p>
<p>a/an 不定冠词，不一定修饰哪个冠词，只修饰可数名词单数。</p>
<p>the 定冠词，知道修饰哪个冠词，修饰任何名词。the dog, the dogs.</p>
<ul>
<li>特指的人和物</li>
<li>世界上独一无二的事物前</li>
<li>用于上文提到过的人或物之前</li>
<li>地理名词之前加 the （江河、山脉、海峡等）：The Pacific, The Alps, The Penghu Islands，哪怕没名气的小河 The river。</li>
<li>国家不加 the，个别国家例外：The United Kingdom。</li>
<li>艺术娱乐场所前加 the，go to the theatre, go to the museum。</li>
<li>乐器前面加 the，play the piano, the guitar。</li>
<li>船舶、飞机名称前面加 the，The Titanic。</li>
</ul>
<p>表示事物种类：</p>
<ul>
<li>不可数名词不加冠词，Milk is very refreshing.</li>
<li>独山独岛不加冠词，Mount Tai，Taiwan Island</li>
<li>湖泊的面前不加冠词the，Lake Tongting。</li>
<li>名字前面不用 the.</li>
<li>可数名词：单词复数，the + 单数名词，a/an + 单数名词。horses are beautiful animals.</li>
<li>棋、球、游戏面前不加 the，play chess, play football, play bridge（桥牌）</li>
</ul>
<h3 id="零冠词"><a href="#零冠词" class="headerlink" title="零冠词"></a>零冠词</h3><ol>
<li>三餐前：have breakfast</li>
<li>不可数名词泛指：Water is necessary to life. （没有特指某些水）</li>
<li>复数名词泛指：Horses are beautiful animals.</li>
<li>交通工具：by bike, bus, plane, ship. in <strong>a</strong> car.</li>
<li>名字、称呼前不加。I’m not feeling well, doctor.</li>
<li>语言前，study English.</li>
<li>强调场所的功能：go to bed, go to college, go to court, go to hospital. 艺术文娱场所前面还是要加 the。go to the museum, go to the theatre.</li>
</ol>
<h2 id="形容词副词的比较级最高级"><a href="#形容词副词的比较级最高级" class="headerlink" title="形容词副词的比较级最高级"></a>形容词副词的比较级最高级</h2><p>两者比较用比较级，三者比较用最高级。（wrong, favorite）没有比较级。</p>
<h3 id="变化规则"><a href="#变化规则" class="headerlink" title="变化规则"></a>变化规则</h3><ul>
<li>一般情况：单音节词（单词元音音标的数量）和以 y 结尾的双音节词，+ er 和 est</li>
<li>以 e 结尾 + r 和 st</li>
<li>辅音字母 + y 结尾，把 y 变 i + er 和 est</li>
<li>双辅加一元，双写最后一个字母 + er 和 est</li>
<li>多音节词：more + 原形，most + 原形</li>
</ul>
<p>far (farther, further, farthest, furthest)，前者指具体距离上的远，后者指抽象意义上的远。<br>old(older, elder, oldest, eldest)，前者用于比较，后者不用于比较，如：the elder sister，我的姐姐。</p>
<p>形容词最高级前加the，副词最高级可以省略。表示范围的词加 in，群体的词加 of 或者 among。the richest man in BeiJing. He earns the most among us. </p>
<p>than 引导比较状语从句，在形容词或副词比较级之后。She is more beautiful than joe (is), He runs faster than joe does. 动词和之前的动词对应。does指代任何动词。前后的事物是同一类：mary’s English is better than susan’s，his computer is better than mine。</p>
<h2 id="比较级前面的修饰词"><a href="#比较级前面的修饰词" class="headerlink" title="比较级前面的修饰词"></a>比较级前面的修饰词</h2><p>very 不能修饰比较级，只能修饰原级。</p>
<ul>
<li>强：much, even, far, a lot</li>
<li>弱：a bit, a little, slightly</li>
<li>否定疑问：any，不做翻译</li>
</ul>
<p>This movie is <strong>much(even, far, a lot)</strong> more interesting than that one.（更….的多）<br>I am <strong>even</strong> less lucky. （我更不幸运的多）<br>This picture is <strong>far</strong> better.</p>
<p>It is <strong>a bit(a little, slightly)</strong> hotter than yesterday.</p>
<p>I can’t go any farther.<br>Do you have any further questions to ask?<br>Are you feeling any better?</p>
<h2 id="名词所有格"><a href="#名词所有格" class="headerlink" title="名词所有格"></a>名词所有格</h2><p>名词归谁所有该用什么样的形式。</p>
<ol>
<li>加 ‘s，有生命的，<ul>
<li>Jim’s football</li>
<li>以 s 结尾的复数名词，the students’ books, the workers’ club</li>
<li>不规则复数名词，children’s Day</li>
<li>表示两人各自所有的两个东西，两个名词后面都加 ‘s，后面加复数名词。Tom’s and Mike’s rooms，各自住各自的。</li>
<li>表示两人共同所有的一个东西，后面名词加 ‘s，后面加名词单数。Tom and Mike’s room，两人同居。</li>
<li>in five minutes’ time，五分钟的时间，an hour’s walk，一个小时走路的距离，five pounds’ worth of candy，五块钱的糖果。（时间，距离，价值）</li>
<li>省略商店和住宅等地点，at the butcher’s, at my mother’s.</li>
</ul>
</li>
<li>叫 of，没生命的<ul>
<li>the legs of the table （of the table 是定语，介词短语做定语，后置）</li>
</ul>
</li>
</ol>
<h2 id="动名词"><a href="#动名词" class="headerlink" title="动名词"></a>动名词</h2><p>构成：动词原形 + ing，具有动词特征的名词。</p>
<p>动词特征：</p>
<ol>
<li>可以跟宾语：I like surfing the Internet</li>
<li>可以用副词修饰：Driving fast is very dangerous</li>
<li>I often fish for hours without catching anything. He told me the news after（表明了动作的顺序） entering the room. 将共同主语的两个句子合并为一个。动名词的主语和主句的主语保持一致。</li>
<li>强调动名词的动作先发生，将 doing 替换为 having（形式不变） done（完成形式）。After having entered the room, he told me the news. He apologized to me for having broken my favorite vase. </li>
<li>动名词逻辑主语和主句的主语的逻辑不一致，需要保证没有歧义（最好保持一致）。</li>
</ol>
<p>用法：</p>
<ol>
<li>充当主语、表语和宾语（动词原形不能当主语，名词和代词可以）。</li>
<li>主语和宾语：Fishing is my favorite sport，I like fishing（动词宾语，可能有动词不定式），I am fond  of fishing（介词宾语，直接加 ing）。</li>
<li>表语：系动词之后。My favorite sport is fishing. 和现在进行时进行区分，它们是现在分词，be 动词不翻译。这里的 be 动词表示是。</li>
</ol>
<h2 id="need"><a href="#need" class="headerlink" title="need"></a>need</h2><ol>
<li><p>情态动词：作为助动词，无人称和时态的变换，多用于疑问句和否定句。<br>need + do，现在有无必要做某事，You needn’t hurry. Need you go so soon?<br>need + have done，<strong>过去</strong>有无必要做某事，情态动词 + have 表示过去时候。You needn’t have waited for me yesterday. 现实是昨天等了。Need you have been so angry with him?</p>
</li>
<li><p>肯定句多是实义动词：有人称和时态的变换。</p>
<p>need + to do<br>need + n，后面是名词只能是实义动词，I need your help, you don’t need to know it. 等价于 You needn’t know it.</p>
</li>
</ol>
<h2 id="不定式的时态和语态"><a href="#不定式的时态和语态" class="headerlink" title="不定式的时态和语态"></a>不定式的时态和语态</h2><p>时态：与谓语动词的关系。语态：与逻辑主语的关系。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>主动</th>
<th>被动</th>
</tr>
</thead>
<tbody>
<tr>
<td>一般时（动作与谓语动词同时，或谓语动词之后）</td>
<td>to do</td>
<td>to be done</td>
</tr>
<tr>
<td>进行时（与谓语动词同时发生，且正在进行）</td>
<td>to be doing</td>
<td>—</td>
</tr>
<tr>
<td>完成时（谓语动词之前）</td>
<td>to have done</td>
<td>to have been done</td>
</tr>
<tr>
<td>完成进行时（谓语动词之前，一直持续到谓语动词发生）</td>
<td>to have been doing</td>
<td>—</td>
</tr>
</tbody>
</table>
</div>
<p>I helped him to do it.<br>I hope to see you soon.</p>
<p>I advised him to save the money. I advised the money to be saved.</p>
<p>It’s nice to be lying on the beach.</p>
<p>I’m sorry to have lost your key.<br>He was thought to have been killed 20 years before.</p>
<p>He was happy to have been staying with his uncle.</p>
<h2 id="with-名词"><a href="#with-名词" class="headerlink" title="with + 名词"></a>with + 名词</h2><p>with + 抽象动词，表示 ….地。做方式状语。</p>
<p>I smoked with concentration and pleasure.<br>He jumped with delight.<br>He shouted with anger.<br>She listened with sympathy.<br>She pass the exam with easy.<br>He drove the car with great care.<br>She answered with a smile.</p>
<h1 id="虚拟语气"><a href="#虚拟语气" class="headerlink" title="虚拟语气"></a>虚拟语气</h1><h2 id="if-引导的条件状语从句"><a href="#if-引导的条件状语从句" class="headerlink" title="if 引导的条件状语从句"></a>if 引导的条件状语从句</h2><ol>
<li><p>真实条件句（可能性比较大，主将从现）；</p>
</li>
<li><p>非真实条件句（虚拟语气）</p>
</li>
</ol>
<p>(1) 与现在事实相反；</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>从句谓语</th>
<th>主句谓语</th>
</tr>
</thead>
<tbody>
<tr>
<td>一般过去时 (be 只用 were)</td>
<td>would should could might + do</td>
</tr>
</tbody>
</table>
</div>
<p>If you ate more and talked less, we would both enjoy our dinner.<br>If it were not for hope, the heart would break. 人为希望而活<br>If there were no clouds, we should not enjoy the sun。如果没有云彩的话（现在有），我们就能享受云彩了。<br>If I were a bird, I could fly to you.<br>If I had time, I would help you. （现在很忙，没时间）</p>
<p>(2) 与过去事实相反；</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>从句谓语</th>
<th>主句谓语</th>
</tr>
</thead>
<tbody>
<tr>
<td>had done</td>
<td>would should could might + have done</td>
</tr>
</tbody>
</table>
</div>
<p>If I had known your telephone number, I would have called you yesterday. 事实是没打。<br>If he had listened to his teacher’s advice, he would have passed the exam.<br>If he had been more careful, he would not have made mistake.<br>If I hadn’t come to Beijing, I wouldn’t have met you.</p>
<p>(3) 与未来趋势相反。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>从句谓语</th>
<th>主句谓语</th>
</tr>
</thead>
<tbody>
<tr>
<td>did (be 用 were)<br>should do<br>were to do（几乎不太可能发生的事）</td>
<td>should could might would + do</td>
</tr>
</tbody>
</table>
</div>
<p>If we missed the train tomorrow, we should wait an hour at the station.（万一）<br>If it should rain tomorrow, I would not go there. 真实语气： If it rains tomorrow, I will not go there.<br>If the sun were to rise in the west, I would lend you the money. （几乎不可能）</p>
<h2 id="should型的虚拟语气"><a href="#should型的虚拟语气" class="headerlink" title="should型的虚拟语气"></a>should型的虚拟语气</h2><p>从句的谓语动词是 should + 动词原形，should 可以省略，大体意思是应该。</p>
<ol>
<li>下列动词后的宾语从句用 should do。order, ask, decide, demand, require, advise, recommend, suggest, insist。<br>I suggested that we <strong>(should)</strong> help them with English. I suggested that we <strong>(should)</strong> not help them with English.<br>The teacher ordered that the homework <strong>(should)</strong> be finished within half an hour.</li>
<li>下列名词后的同位语从句用 should do。suggestion, order, request, demand, proposal（建议）。<br>He made a suggestion that we <strong>(should)</strong> have a fancy dress party.<br>The proposal that John <strong>(should)</strong> be dismissed is unacceptable.</li>
<li>下列形容词后的主语从句用 should do。important, necessary, natural, essential, advisable, strange, surprising。<br>It’s strange that you <strong>(should)</strong> say such a thing.<br>It’s important that you <strong>(should)</strong> tell me all the information.</li>
</ol>
]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测篇：FPN</title>
    <url>/2021/05/01/FPN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在目标检测领域，很难保证所要检测目标的大小都是类似的，MNIST，cifar10，imageNet 等玩具数据集除外。实际场景中，往往目标大小不一致、长宽比例不一致、图片的大小也不一致。长宽比例不一致可以通过之前提到的 Faster R-CNN <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 来解决。FPN 的全称是 Feature Pyramid Networks <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> ，本算法重点关注目标多尺度的问题。因为传统两阶段检测（区域提议、区域识别）算法基于特征图进行预测，通常来自网络骨干的最后一层，回导致小物体信息的丢失。</p>
<a id="more"></a>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><img data-src="https://z3.ax1x.com/2021/05/01/gVYavt.png" alt></p>
<p>来看一下传统的多尺度检测方法：</p>
<ul>
<li>图 a 中，一看就是常规的方法，将一张图片的多个尺度的特征进行预测。对某一输入图片我们通过压缩或放大从而形成不同尺寸的图片作为模型输入，使用同一模型对这些不同尺寸的图片分别处理后，最终再将这些分别得到的特征（feature maps）组合起来。此种方法缺点在于需要对同一图片在更改维度后输入处理多次，计算缓慢。</li>
<li>图 b 中，用单一尺寸的图片做为输入，然后经 CNN 模型处理后，拿最终一层的feature maps 作为最终的特征集。优点是计算简单，如大多数 R-CNN 系列目标检测方法所用，如 Faster R-CNN 等。因此最终这些模型对小维度的目标检测性能不是很好。我曾遇到过在 $8000\times 8000$ 的图像中检测 $10\times 10$ 目标的任务，使用普通的 backbone 去卷积时，一不小心由于 <code>stride</code> 过大，直接错过了目标，导致小目标检测的性能急剧下降。</li>
<li>图 c 中，用单一尺寸的图片做为输入，此方法除选取最后一层的特征外，选用稍靠下的反映图片 low level 信息的 feature maps。然后将这些不同层次的特征简单合并起来，用于最终的特征组合输出。但依然会忽略一些具有更低级别信息，对更小维度的目标检测效果就不大好。</li>
<li>图 d 中，用单一尺寸的图片作为输入，选取所有层的特征联合起来做为最终的特征输出。另外还对各层所反映的不同级别的特征信息进行了自上向下的整合，能更好检测目标。而此方法正是我们本文中要讲的 FPN CNN 特征提取方法。</li>
</ul>
<p>注意：</p>
<ul>
<li>对于卷积神经网络而言，不同深度对应着不同层次的语义特征，浅层网络分辨率高，学的更多是浅层特征，如细节、边缘等；深层网络分辨率低，学的更多是深层语义特征，如物体轮廓、类别等。</li>
</ul>
<h1 id="FPN"><a href="#FPN" class="headerlink" title="FPN"></a>FPN</h1><p>FPN 是传统 CNN 网络对图片信息进行表达的一种增强整合。目的是为了改进 CNN 网络的特征提取方式，从而可以使最终输出的特征更好地涵盖输入图片各个维度的信息。它包括两个基本过程：自下至上的通路，即计算不同尺寸的特征；自上至下的通路，即自上至下的特征补充。</p>
<h2 id="自下而上"><a href="#自下而上" class="headerlink" title="自下而上"></a>自下而上</h2><p>也就是网络的前向计算部分，而每层的输出都是上一层输出尺寸的 1/2，就完成了传统金字塔方法和 CNN 网络的名词的对应。</p>
<h2 id="自上而下"><a href="#自上而下" class="headerlink" title="自上而下"></a>自上而下</h2><p>将深层的有更强语义信息的 feature 经过上采样变成具有高分辨率特征图像的过程。然后再与下一层得到的 feature 经过侧边连接相加，进行增强。最底层的输出会有细节信息和高层特征，检测大目标的同时，也不会忽略小目标。</p>
<p>增强后的数据经过一个 <code>3×3</code> 卷积的处理，原文的意思是这个卷积能减少上采样导致混叠的不利影响，就可以作为网络的输出了。这个图看不懂的话，可以看下面的代码。代码看不懂的话，<del>我也没办法了</del>。</p>
<p>这里需要注意的是，<strong>每一层，也就是这三个 predict，输出的通道数是相同的。</strong></p>
<p><img data-src="https://z3.ax1x.com/2021/05/01/gVNOHK.png" alt></p>
<h1 id="与-RPN-结合"><a href="#与-RPN-结合" class="headerlink" title="与 RPN 结合"></a>与 RPN 结合</h1><p>FPN 将提取到的特征送到 RPN 中用于目标检测，RPN 再去用于用于预测边界框和前景、背景。因为 FPN 有多个层次的输出，所以在每一层的输出后面接入一个 <code>3×3</code> 卷积的处理，在共用两个并联的 <code>1x1</code> 的卷积层用于预测前景背景和目标框的位置。所以一般而言，称特征提取器为 backbone，FPN 为 neck，RPN 预测部分为 head。图片来源 <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>：</p>
<p><img data-src="https://miro.medium.com/1*Hi3mCsgTEjPLtWnRyXx47w.jpeg" alt></p>
<h1 id="与-Faster-RCNN-结合"><a href="#与-Faster-RCNN-结合" class="headerlink" title="与 Faster RCNN 结合"></a>与 Faster RCNN 结合</h1><p>这里，就参考这篇文章 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> 吧，我就不照抄了。大体意思就是。在 backbone 中接入 FPN，生成不同尺寸的特征图。使用 RPN 生成不同的 ROI。根据 ROI 尺寸的不同，在不同尺寸的特征图中选择特征块，如下图所示 <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>： </p>
<p><img data-src="https://miro.medium.com/max/2000/1*Wvn0WG4XZ0w9Ed2fFYPrXw.jpeg" alt></p>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>讲真，挺容易理解的。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个卷积残差块</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottleneck</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    expansion = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, in_planes, planes, stride=<span class="number">1</span>)</span>:</span></span><br><span class="line">        super(Bottleneck, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=in_planes,</span><br><span class="line">                               out_channels=planes,</span><br><span class="line">                               kernel_size=<span class="number">1</span>,</span><br><span class="line">                               bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(planes)</span><br><span class="line"></span><br><span class="line">        self.conv2 = nn.Conv2d(in_channels=planes,</span><br><span class="line">                               out_channels=planes,</span><br><span class="line">                               kernel_size=<span class="number">3</span>,</span><br><span class="line">                               stride=stride,</span><br><span class="line">                               padding=<span class="number">1</span>,</span><br><span class="line">                               bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(planes)</span><br><span class="line"></span><br><span class="line">        self.conv3 = nn.Conv2d(in_channels=planes,</span><br><span class="line">                               out_channels=self.expansion * planes,</span><br><span class="line">                               kernel_size=<span class="number">1</span>,</span><br><span class="line">                               bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(num_features=self.expansion * planes)</span><br><span class="line"></span><br><span class="line">        self.shortcut = nn.Sequential()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 步长不为 1 或者 输入特征不等于输出特征</span></span><br><span class="line">        <span class="keyword">if</span> stride != <span class="number">1</span> <span class="keyword">or</span> in_planes != self.expansion * planes:</span><br><span class="line">            <span class="comment"># 残差块</span></span><br><span class="line">            self.shortcut = nn.Sequential(</span><br><span class="line">                nn.Conv2d(in_channels=in_planes,</span><br><span class="line">                          out_channels=self.expansion * planes,</span><br><span class="line">                          kernel_size=<span class="number">1</span>,</span><br><span class="line">                          stride=stride,</span><br><span class="line">                          bias=<span class="literal">False</span>), nn.BatchNorm2d(self.expansion * planes))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        out = F.relu(self.bn1(self.conv1(x)))</span><br><span class="line">        out = F.relu(self.bn2(self.conv2(out)))</span><br><span class="line">        out = self.bn3(self.conv3(out))</span><br><span class="line">        out += self.shortcut(x)</span><br><span class="line">        out = F.relu(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FPN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, block, num_blocks)</span>:</span></span><br><span class="line">        super(FPN, self).__init__()</span><br><span class="line">        self.in_planes = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=<span class="number">3</span>,</span><br><span class="line">                               out_channels=<span class="number">64</span>,</span><br><span class="line">                               kernel_size=<span class="number">7</span>,</span><br><span class="line">                               stride=<span class="number">2</span>,</span><br><span class="line">                               padding=<span class="number">3</span>,</span><br><span class="line">                               bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Bottom-up layers, backbone of the network</span></span><br><span class="line">        <span class="comment"># planes 是输出特征</span></span><br><span class="line">        <span class="comment"># channel 变化：3 -&gt; 64 -&gt; 64 -&gt; 256</span></span><br><span class="line">        self.layer1 = self._make_layer(block=block,</span><br><span class="line">                                       planes=<span class="number">64</span>,</span><br><span class="line">                                       num_blocks=num_blocks[<span class="number">0</span>],</span><br><span class="line">                                       stride=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># channel 变化：64*4 -&gt; 128 -&gt; 128 -&gt; 512</span></span><br><span class="line">        self.layer2 = self._make_layer(block=block,</span><br><span class="line">                                       planes=<span class="number">128</span>,</span><br><span class="line">                                       num_blocks=num_blocks[<span class="number">1</span>],</span><br><span class="line">                                       stride=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># out_channel: 1024</span></span><br><span class="line">        self.layer3 = self._make_layer(block=block,</span><br><span class="line">                                       planes=<span class="number">256</span>,</span><br><span class="line">                                       num_blocks=num_blocks[<span class="number">2</span>],</span><br><span class="line">                                       stride=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># out_channel 2048</span></span><br><span class="line">        self.layer4 = self._make_layer(block=block,</span><br><span class="line">                                       planes=<span class="number">512</span>,</span><br><span class="line">                                       num_blocks=num_blocks[<span class="number">3</span>],</span><br><span class="line">                                       stride=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Top layer</span></span><br><span class="line">        <span class="comment"># layer4 后面接一个1x1, 256 conv，得到金字塔最顶端的feature</span></span><br><span class="line">        self.toplayer = nn.Conv2d(in_channels=<span class="number">2048</span>,</span><br><span class="line">                                  out_channels=<span class="number">256</span>,</span><br><span class="line">                                  kernel_size=<span class="number">1</span>,</span><br><span class="line">                                  stride=<span class="number">1</span>,</span><br><span class="line">                                  padding=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Smooth layers</span></span><br><span class="line">        <span class="comment"># 这个是上面引文中提到的抗 『混叠』 的3x3卷积</span></span><br><span class="line">        <span class="comment"># 由于金字塔上的所有feature共享classifier和regressor</span></span><br><span class="line">        <span class="comment"># 要求它们的channel dimension必须一致</span></span><br><span class="line">        <span class="comment"># 这个用于多路预测</span></span><br><span class="line">        self.smooth1 = nn.Conv2d(in_channels=<span class="number">256</span>,</span><br><span class="line">                                 out_channels=<span class="number">256</span>,</span><br><span class="line">                                 kernel_size=<span class="number">3</span>,</span><br><span class="line">                                 stride=<span class="number">1</span>,</span><br><span class="line">                                 padding=<span class="number">1</span>)</span><br><span class="line">        self.smooth2 = nn.Conv2d(in_channels=<span class="number">256</span>,</span><br><span class="line">                                 out_channels=<span class="number">256</span>,</span><br><span class="line">                                 kernel_size=<span class="number">3</span>,</span><br><span class="line">                                 stride=<span class="number">1</span>,</span><br><span class="line">                                 padding=<span class="number">1</span>)</span><br><span class="line">        self.smooth3 = nn.Conv2d(in_channels=<span class="number">256</span>,</span><br><span class="line">                                 out_channels=<span class="number">256</span>,</span><br><span class="line">                                 kernel_size=<span class="number">3</span>,</span><br><span class="line">                                 stride=<span class="number">1</span>,</span><br><span class="line">                                 padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Lateral layers</span></span><br><span class="line">        <span class="comment"># 为了匹配channel dimension引入的1x1卷积</span></span><br><span class="line">        <span class="comment"># 注意这些backbone之外的extra conv，输出都是256 channel</span></span><br><span class="line">        self.latlayer1 = nn.Conv2d(in_channels=<span class="number">1024</span>,</span><br><span class="line">                                   out_channels=<span class="number">256</span>,</span><br><span class="line">                                   kernel_size=<span class="number">1</span>,</span><br><span class="line">                                   stride=<span class="number">1</span>,</span><br><span class="line">                                   padding=<span class="number">0</span>)</span><br><span class="line">        self.latlayer2 = nn.Conv2d(in_channels=<span class="number">512</span>,</span><br><span class="line">                                   out_channels=<span class="number">256</span>,</span><br><span class="line">                                   kernel_size=<span class="number">1</span>,</span><br><span class="line">                                   stride=<span class="number">1</span>,</span><br><span class="line">                                   padding=<span class="number">0</span>)</span><br><span class="line">        self.latlayer3 = nn.Conv2d(in_channels=<span class="number">256</span>,</span><br><span class="line">                                   out_channels=<span class="number">256</span>,</span><br><span class="line">                                   kernel_size=<span class="number">1</span>,</span><br><span class="line">                                   stride=<span class="number">1</span>,</span><br><span class="line">                                   padding=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make_layer</span><span class="params">(self, block, planes, num_blocks, stride)</span>:</span></span><br><span class="line">        strides = [stride] + [<span class="number">1</span>] * (num_blocks - <span class="number">1</span>)</span><br><span class="line">        layers = []</span><br><span class="line">        <span class="keyword">for</span> stride <span class="keyword">in</span> strides:</span><br><span class="line">            layers.append(block(self.in_planes, planes, stride))</span><br><span class="line">            self.in_planes = planes * block.expansion</span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(*layers)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## FPN的lateral connection部分: upsample以后，element-wise相加</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_upsample_add</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        _, _, H, W = y.size()</span><br><span class="line">        <span class="comment"># 上采样到指定尺寸</span></span><br><span class="line">        <span class="keyword">return</span> F.upsample(x, size=(H, W), mode=<span class="string">'bilinear'</span>) + y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># Bottom-up</span></span><br><span class="line">        c1 = F.relu(self.bn1(self.conv1(x)))</span><br><span class="line">        c1 = F.max_pool2d(c1, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">        c2 = self.layer1(c1)</span><br><span class="line">        c3 = self.layer2(c2)</span><br><span class="line">        c4 = self.layer3(c3)</span><br><span class="line">        c5 = self.layer4(c4)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Top-down</span></span><br><span class="line">        <span class="comment"># P5: 金字塔最顶上的feature 2048 -&gt; 256</span></span><br><span class="line">        p5 = self.toplayer(c5)</span><br><span class="line">        <span class="comment"># P4: 上一层 p5 + 侧边来的 c4</span></span><br><span class="line">        <span class="comment"># 其余同理</span></span><br><span class="line">        p4 = self._upsample_add(p5, self.latlayer1(c4))</span><br><span class="line">        p3 = self._upsample_add(p4, self.latlayer2(c3))</span><br><span class="line">        p2 = self._upsample_add(p3, self.latlayer3(c2))</span><br><span class="line"></span><br><span class="line">        p4 = self.smooth1(p4)</span><br><span class="line">        p3 = self.smooth2(p3)</span><br><span class="line">        p2 = self.smooth3(p2)</span><br><span class="line">        <span class="keyword">return</span> p2, p3, p4, p5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FPN101</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 2 通过步长，控制上一层的图片尺寸是下一层图片尺寸的几倍，这里都是 2</span></span><br><span class="line">    <span class="keyword">return</span> FPN(Bottleneck, [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    net = FPN101()</span><br><span class="line">    fms = net(torch.randn((<span class="number">1</span>, <span class="number">3</span>, <span class="number">600</span>, <span class="number">900</span>), requires_grad=<span class="literal">True</span>))</span><br><span class="line">    <span class="keyword">for</span> fm <span class="keyword">in</span> fms:</span><br><span class="line">        print(fm.size())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ref: https://github.com/kuangliu/pytorch-fpn/blob/master/fpn.py</span></span><br></pre></td></tr></table></figure>
<h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://muyuuuu.github.io/2021/04/28/faster-rcnn/">Faster R-CNN</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/pdf/1612.03144.pdf" target="_blank" rel="noopener">FPN 论文</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://xmfbit.github.io/2018/04/02/paper-fpn/" target="_blank" rel="noopener">FPN 用于 Faster R0CNN</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://jonathan-hui.medium.com/understanding-feature-pyramid-networks-for-object-detection-fpn-45b227b9106c" target="_blank" rel="noopener">FPN与RPN结合</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>云雾缭绕，人间仙境——翡翠湖</title>
    <url>/2020/01/15/FeiCuiHu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下午一路坐车到翡翠湖，原以为黄山的云海已经是天下一绝，直到见了西北的雪山。如果说黄山的云海是婉约的大家闺秀，亲切不失优雅，西北的云海更像是高冷的女神，可远观而不可亵玩。<code>不见祁连山上雪，错把甘州作江南</code>。</p>
<p>晚上吃得柴旦地区的特产，炕锅羊肉，这是吃过最香的土豆片，另外估计也只有在西北地区能这么便宜、这么大口的吃羊肉了。</p>
<p>依山傍水，雪山云雾缭绕，以山生薄云，薄云连青空，像云裳像轻纱，如玉似锦，苦寒之地的高冷美景，真人间仙境。</p>
<p><img data-src="/2020/01/15/FeiCuiHu/105.jpg" alt></p>
<a id="more"></a>
<p><img data-src="/2020/01/15/FeiCuiHu/2.jpg" alt></p>
<p><img data-src="/2020/01/15/FeiCuiHu/4.jpg" alt></p>
<p><img data-src="/2020/01/15/FeiCuiHu/6.jpg" alt></p>
<p><img data-src="/2020/01/15/FeiCuiHu/7.jpg" alt></p>
<p><img data-src="/2020/01/15/FeiCuiHu/16.jpg" alt></p>
<p><img data-src="/2020/01/15/FeiCuiHu/19.jpg" alt></p>
<p><img data-src="/2020/01/15/FeiCuiHu/42.jpg" alt></p>
<p><img data-src="/2020/01/15/FeiCuiHu/47.jpg" alt></p>
<p><img data-src="/2020/01/15/FeiCuiHu/101.jpg" alt></p>
<p><img data-src="/2020/01/15/FeiCuiHu/102.jpg" alt></p>
<p><img data-src="/2020/01/15/FeiCuiHu/103.jpg" alt></p>
<p><img data-src="/2020/01/15/FeiCuiHu/104.jpg" alt></p>
<p><img data-src="/2020/01/15/FeiCuiHu/106.jpg" alt></p>
<p><img data-src="/2020/01/15/FeiCuiHu/107.jpg" alt></p>
<p><img data-src="/2020/01/15/FeiCuiHu/108.jpg" alt></p>
]]></content>
      <categories>
        <category>塞上西北行</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记 GAP:Generalizable Approximate Graph Partitioning Framework</title>
    <url>/2020/07/08/GAP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在解决大规模图划分时，读过了很多论文，无非是在目标方程中做出一些策略上的改动，并没有什么创新的地方，最严肃的问题是，可能收敛不了。而深度学习发展的今天，获取可以考虑用DeepLearning的形式来改善大规模图划分。读了些许的论文，只有这篇是沾点边的，遂精读并做笔记，这篇论文八成是日后的对比对象了。</p>
<p>在论文中，最重要的一点是如何使用网络处理图数据，并定义损失函数，即如何将图划分问题迁移到<code>NN</code>中。</p>
<a id="more"></a>
<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><ol>
<li>大规模图划分，显然要划分的图的规模是很大的，节点在百万、千万、亿级别，并不是 <code>cora</code> 数据集这样只有两千多个节点。将大规模的图划分为多个子图；</li>
<li>此外，大规模图图划分涉及生物、化学和社交网络等多个领域，在图划分结束后，将划分结果提交到分布式平台用于计算，因此图划分仅仅是数据处理阶段，仅给使用者提供划分服务，但也是很重要的一环；</li>
<li>边割率：将大规模划分为多个子图后，子图之间的联系应该尽可能的少，因为子图之间的边是沟通信息的桥梁，为方便计算，子图间的通信应尽可能少；定义为：<br>\begin{equation}<br>\text{edge_cut}=\frac{E_{\text{cut}}}{|E|}<br>\end{equation}<br>其中，$E_{\text{cut}}$是切割边的边数，$|E|$是总边数。</li>
<li>负载均衡：多个子图的规模应该尽可能相似，不然一个子图的规模很大，其他子图的规模很小，在分布式计算平台会严重影响计算速度，即常见的短板效应。定义为：<br>\begin{equation}<br>\text{load_balance}=\frac{\text{ver}_{\text{max}}g}{|V|}<br>\end{equation}<br>其中，$\text{ver}_{\text{max}}$表示子图中最大的节点数，$g$为最终划分子图的数量，$|V|$是图节点数。</li>
</ol>
<h1 id="边割率损失定义"><a href="#边割率损失定义" class="headerlink" title="边割率损失定义"></a>边割率损失定义</h1><p>假设此时要切割$g$个子图，以$S_k,(k=1,2,\cdots, g)$表示子图的集合。那么$cut(S_k,\bar{S_k})$表示切割出子图$S_k$时要切割的边数，为了防止节点度过大和过小导致的不平衡切割，所以提出了标准化切割$Ncut$：</p>
<p>\begin{equation}<br>Ncut(S_1,S_2,\cdots,S_g)=\sum_{i=1}^g\frac{cut(S_k,\bar{S_k})}{vol(S_k,V)}<br>\label{Ncut}<br>\end{equation}</p>
<p>其中，$vol(S_k,V)$是子图$k$内的节点度数。</p>
<h2 id="使用网络学习边割率"><a href="#使用网络学习边割率" class="headerlink" title="使用网络学习边割率"></a>使用网络学习边割率</h2><p>之后的任务就简单了，用神经网络学习出公式 \eqref{Ncut} 的分子和分母即可。假设网络的最后一层的输出是计算当前节点属于子图的概率，那么当划分子图数量为$g$时，输出维度也应该是$g$。$Y\in \mathbb{R}^{n\times g}$，图数据中有$n$个节点，最后的矩阵$Y$的维度就是$n \times g$了，$Y_{ik}$表示第$i$个图节点属于第$k$个子图的概率。</p>
<p>此时计算切分子图$k$的期望：</p>
<p>\begin{equation}<br>\mathbb{E}[cut(S_k,\bar{S_k})]=\sum _{v_i \in S_k, v_j\in N(v_i)} \sum_{z=1}^g Y_{iz}(1-Y_{jz})<br>\end{equation}</p>
<p>其中，$N(v_i)$是节点$v_i$的邻居节点，$1-Y_{jz}$表示节点$v_j$不属于子图$z$的概率。两者相乘，表示切割出子图$S_k(k=1,2,\cdots,g)$的期望，而邻接节点很容易通过邻接矩阵$A$获取，至此，分子计算完毕。</p>
<p>之后考虑分母的计算，假设矩阵$D\in \mathbb{R}^{n\times 1}$表示节点的度的矩阵，那么计算一个子图内节点的度的期望就很容易了：</p>
<p>\begin{equation}<br>\Gamma = Y^T D，\mathbb{E}[vol(S_k,V)]=\Gamma_k<br>\end{equation}</p>
<p>此时，便很容易得到边割率的损失$\mathcal{L}_1=\mathbb{E}[cut]/\mathbb{E}[vol]$。</p>
<h1 id="负载均衡损失定义"><a href="#负载均衡损失定义" class="headerlink" title="负载均衡损失定义"></a>负载均衡损失定义</h1><p>考虑边割率的同时，也要考虑到子图之间的负载均衡，即各个子图的规模大小应尽可能的相似。当图节点为$n$，切分为$g$个子图时，每个子图内的节点的数量应该和$n/g$相近。所以负载均衡的损失$\mathcal{L}_2$计算方式为：</p>
<p>\begin{equation}<br>\mathcal{L}_2 =\sum_{j=1}^g\Big( \sum_{i=1}^nY_{ij}-\frac{n}{g}\Big)^2<br>\end{equation}</p>
<p>综上，损失函数为$\mathcal{L}_1+\mathcal{L}_2$。</p>
<h1 id="节点的嵌入学习"><a href="#节点的嵌入学习" class="headerlink" title="节点的嵌入学习"></a>节点的嵌入学习</h1><p><strong>在论文中，最重要的一点是如何使用网络处理图数据，并定义损失函数，即如何将图划分问题迁移到NN中。</strong></p>
<p>所以对图嵌入模块，只想忽略的介绍。在图划分模块之前还有图嵌入模块，即使用 GNN 来学习节点的嵌入表示，随着层数的加深不断的更新节点的表示。文中使用的网络为 GraphSAGE 和 maxpool 策略，在图划分的过程中不断的学习节点的嵌入表示，两者同时进行。</p>
<p>此外需要注意的是，损失函数是要对$Y$求偏导并计算梯度的，$Y$在反向传播回$x$的嵌入表示并调整。</p>
<p>本文并不想在这里展开 GNN 的介绍，如果想简单理解可以参考 bilibili 李宏毅最新的机器学习课程，里面讲的很详细。在图规模不断扩大时，基于谱方法的 GNN 之类不再适用，如 <a href="https://muyuuuu.github.io/2020/06/16/GCN/">GCN</a>，因为这种网络需要传入邻接矩阵这样大规模的参数。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>有人用 pytorch 复现了一份 ：<br><a href="https://github.com/saurabhdash/GCN_Partitioning" target="_blank" rel="noopener">https://github.com/saurabhdash/GCN_Partitioning</a></p>
<p>代码我看过了，并做了一定的修改，上面的代码很多地方不够规范（懂得都懂）。额外添加了详细的中文注释以及$\mathcal{L}_2$的损失函数和梯度下降，待目前工作结束后开源。</p>
]]></content>
      <tags>
        <tag>PaperNote</tag>
      </tags>
  </entry>
  <entry>
    <title>花样繁多的GAN</title>
    <url>/2021/08/11/GAN-basic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在做对抗样本的时候，我发现对抗防御和 GAN 在某种程度上很像：</p>
<ul>
<li>对抗防御：内部生成对抗样本攻击分类器，分类器更新参数防御攻击；</li>
<li>GAN：生成器 $G$ 生成样本欺骗判别器，判别器更新防御 $G$ 的欺骗。</li>
</ul>
<p>所以说，这俩在某种程度上真的很像，所以决定整理一下 GAN 的知识，开拓一下思路，视频内容来自<a href="https://www.bilibili.com/video/BV1JE411g7XF?from=search&amp;seid=17206901754423397958" target="_blank" rel="noopener">这里</a>。警告：里面有大量数学公式的推导，而我就不一样了，<del>不仅有公式推导</del>还有代码。</p>
<a id="more"></a>
<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>我发现我在看论文或者别人的博客的时候，经常发现数据分布、概率分布等，然而时间长了竟然不知道所谓的分布是什么，这里来提前说一下：</p>
<ul>
<li>数据分布：可以理解为字面意思，数据的分布。比如一个数据集：<code>1,2,3</code>，只有三条数据，可能是 1，可能是 2，可能是 3，这就是数据的分布；</li>
<li>概率分布：可以理解为字面意思，概率的分布。比如一枚硬币，正面朝上的概率是 50%，反面朝上的概率也是 50%，这就是概率分布，类似的，正态分布、泊松分布等都是概率分布。</li>
</ul>
<h1 id="朴素-GAN"><a href="#朴素-GAN" class="headerlink" title="朴素 GAN"></a>朴素 GAN</h1><p><img data-src="https://z3.ax1x.com/2021/08/11/fNaeNF.png" alt></p>
<p>以图像为例，GAN 的生成器 $G$ 输入为某种随机分布的数据，输出为一张图像；而判别器 $D$ 的输入是一张图像，输出是一个数字，数字越大表示当前图像的质量越高，我们设置 $G$ 生成的图片是假的。两者相互博弈，$G$ 企图去欺骗 $D$，$D$ 防止来自 $G$ 的欺骗。</p>
<ul>
<li>$G$ 只适合生成，不适合做判别，因为 $G$ 的主要任务是生成图像。如果 $G$ 要判别图像的好坏，如何定义生成图像的好坏？生成图像的每个像素点的位置、偏移、颜色、旋转，以及像素点之间的联系将会很复杂，模型将会很复杂，所以由 $D$ 来做判别；</li>
<li>$D$ 只适合判别，不适合生成。$D$ 的判别是宏观角度的判断当前图像好不好，并不会纠结于某个像素的颜色、旋转、偏移的好坏。如果 $D$ 要做生成，那么需要遍历所有数据 $x$，来看看哪个数据使得网络的输出得分最高。这样虽然可以生成，但枚举所有数据是不可能的操作。</li>
</ul>
<p>或者说，这是一种<strong>另类的小样本</strong>，网络不可能见过所有生成的数据，但是要求 $D$ 能判断没见过的数据是好是坏。此外，<strong>足够强的 $D$ 才能迫使 $G$ 生成的图片足够逼真，足够好的 $G$ 才会使 $D$ 的判别越来越准。</strong> 在接下来的实验中将见识到这一点。</p>
<p><img data-src="https://z3.ax1x.com/2021/08/11/fN64Kg.png" alt></p>
<p>如上图所示：横坐标为 $G$ 和 $D$ 的演化过程，纵坐标表示概率分布，红色曲线表示 $G$，红色的点表示 $G$ 生成的数据，绿色的线表示 $D$,绿色的点表示真实数据。</p>
<ol>
<li>首先，图的最左侧，$G$ 生成的数据和真是数据不符，那么判别器抑制 $G$ 把数据生成到其他分布，并希望 $G$ 生成的数据分布和真实数据的分布较为接近；</li>
<li>其次，图的中间，因为 $G$ 的目的是无限度找 $D$ 的漏洞，虽然相比左图，生成数据的分布和真实数据的分布接近了，但是把更多的数据生成到了另外的分布，这也是不行的；</li>
<li>经过多次的博弈，最终达到右侧图的效果。</li>
</ol>
<h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><h3 id="G-的目标"><a href="#G-的目标" class="headerlink" title="$G$ 的目标"></a>$G$ 的目标</h3><p>我们的目标可以用公式表述为：通过 $G$，寻找数据 $x$ 的分布 $P_G(x)$，但是目前只有数据 $x$，也就是知道近似的 $P(x)$。可以通过极大似然估计来求解问题，使 $P_G(x)$ 逐渐逼近 $P(x)$，即在 $P(x)$ 中采 $m$ 个样本，使得 $\prod_{i=1}^mP_G(x_i;\theta)$ 的概率最大，逐步采样与迭代求出模型的参数 $\theta$。</p>
<p>\begin{aligned}<br>\theta &amp;= \arg \max_\theta \prod_{i=1}^mP_G(x_i;\theta) \\<br>       &amp;\Leftrightarrow \arg \max_\theta \log \prod_{i=1}^mP_G(x_i;\theta) \\<br>       &amp;= \arg \max_\theta \sum_{i=1}^m \log P_G(x_i;\theta) \\<br>       &amp;\Leftrightarrow \arg \max_\theta \mathbb{E}_{x\sim p(x)} \bigl[ \log P_G(x;\theta) \bigr] \\<br>       &amp;\Leftrightarrow \arg \max_\theta \int_x p(x) \log P_G(x;\theta) dx - \int_x p(x) \log P(x) dx \\<br>       &amp;= \arg \min_\theta KL(P(x) || P_G(x;\theta))<br>\end{aligned}</p>
<p>也就是说，生成模型的求出的 $P_G(x;\theta)$ 最好情况就是与真是数据的分布 $P(x)$ 的 $KL$ 散度距离最小。当然你也可以用其他距离，详情可以参考 f-GAN <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 这篇论文，不过究其到底，都可以描述为寻找一个 $P_G(x;\theta)$，使其生成的数据分布和 $P(x)$ 最为接近， $G^\star=\arg\min_G D(P_G(x;\theta), P(x))$。</p>
<p>当然在模型参数过多的情况下，极大似然估计求解困难，可以使用神经网络的反向传播，来求解出模型的参数。</p>
<h3 id="D-的目标"><a href="#D-的目标" class="headerlink" title="$D$ 的目标"></a>$D$ 的目标</h3><p>对于 $D$ 而言，其目标是期望真实数据的评分很高，$G$ 生成数据的评分很低，以此来鼓励 $G$ 生成更加逼真的数据达到内卷的目的。那么 $D$ 的目标可以描述为：</p>
<p>\begin{equation}\label{D}<br>\max \mathbb{E}_{x\sim P(x)} \bigl[ \log D(x) \bigr] + \mathbb{E}_{x\sim P_G(x;\theta)} \bigl[ \log(1-D(x)) \bigr]<br>\end{equation}</p>
<p>此时固定 $G$，训练 $D$，式 $\eqref{D}$ 继续推导：</p>
<p>\begin{aligned}<br>\eqref{D} &amp;= \int_x P(x) \log (D(x)) dx+ \int_x P_G(x) \log (1 - D(x)) dx \\<br>&amp;= \int_x P(x) \log (D(x)) + P_G(x) \log (1 - D(x)) dx\\<br>\end{aligned}</p>
<p>为了使积分最大，可以等价转换为使积分内部的元素取值最大，即对于以下公式求对 $D(x)$ 微分，微分等于0的时候，取得极值，且下述公式是极大值：</p>
<p>\begin{equation}<br>f(D(x)) = P(x) \log (D(x)) + P_G(x) \log (1 - D(x))<br>\end{equation}</p>
<p>此时求出的 $D(x)$：</p>
<p>\begin{equation}<br>D(x) = \frac{P(x)}{P(x)+P_G(x)}<br>\end{equation}</p>
<p>把 $D(x)$ 带回式 $\eqref{D}$ ：</p>
<p>\begin{aligned}<br>\eqref{D} &amp;= \mathbb{E}_{x\sim P(x)} \bigl[ \log \frac{P(x)}{P(x)+P_G(x)} \bigr] + \mathbb{E}_{x\sim P_G(x)} \bigl[ \log \frac{P_G(x)}{P(x)+P_G(x)} \bigr] \\<br>&amp;= \int_x P(x)\log \frac{P(x)}{P(x)+P_G(x)} dx + \int_x P_G(x)\log \frac{P_G(x)}{P(x)+P_G(x)} dx \\<br>&amp;= -2\log 2 + KL(P(x) || \frac{P(x) + P_G(x)}{2}) + KL(P_G(x) || \frac{P(x) + P_G(x)}{2}) \\<br>&amp;= -2\log 2 + 2 JS(P(x) || P_G(x))<br>\end{aligned}</p>
<p>而 JS 散度的取值范围是 $[0, \log2]$，因此 式 $\eqref{D}$ 的最大值为 0。而这里的代码实现可以使用 <code>torch.BCE</code>，但要按照负梯度进行反向传播，所以损失那里直接加了负数，因此代码的损失是正数不要感到意外。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>既然有了模型结构和公式推导，那么来看一下代码改怎么写，以 <code>MNIST</code> 数据集为例，全部代码在 <a href="https://github.com/muyuuuu/colab/blob/main/GAN/minmaxGAN.ipynb" target="_blank" rel="noopener"><code>github</code></a>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment"># g_input_dim = 100, g_output_dim=784</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, g_input_dim, g_output_dim)</span>:</span></span><br><span class="line">        super(Generator, self).__init__()       </span><br><span class="line">        self.fc1 = nn.Linear(g_input_dim, <span class="number">256</span>)</span><br><span class="line">        self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features*<span class="number">2</span>)</span><br><span class="line">        self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features*<span class="number">2</span>)</span><br><span class="line">        self.fc4 = nn.Linear(self.fc3.out_features, g_output_dim)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span> </span><br><span class="line">        x = F.leaky_relu(self.fc1(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.leaky_relu(self.fc2(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.leaky_relu(self.fc3(x), <span class="number">0.2</span>)</span><br><span class="line">        <span class="keyword">return</span> torch.tanh(self.fc4(x))</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment"># d_input_dim = 784</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d_input_dim)</span>:</span></span><br><span class="line">        super(Discriminator, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(d_input_dim, <span class="number">1024</span>)</span><br><span class="line">        self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features//<span class="number">2</span>)</span><br><span class="line">        self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features//<span class="number">2</span>)</span><br><span class="line">        self.fc4 = nn.Linear(self.fc3.out_features, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = F.leaky_relu(self.fc1(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.dropout(x, <span class="number">0.3</span>)</span><br><span class="line">        x = F.leaky_relu(self.fc2(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.dropout(x, <span class="number">0.3</span>)</span><br><span class="line">        x = F.leaky_relu(self.fc3(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.dropout(x, <span class="number">0.3</span>)</span><br><span class="line">        <span class="keyword">return</span> torch.sigmoid(self.fc4(x))</span><br><span class="line"></span><br><span class="line">n_epoch = <span class="number">200</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, n_epoch+<span class="number">1</span>):           </span><br><span class="line">    D_losses, G_losses = [], []</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (x, _) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            D_train(x)</span><br><span class="line">        D_losses.append(D_train(x))</span><br><span class="line">        G_losses.append(G_train(x))</span><br></pre></td></tr></table></figure>
<p>$D$ 为什么要比 $G$ 多训练两次？因为只有去够好的 $D$，此案能使得 $G$ 也好，$G$ 好了 $D$ 也会好；否则 $D$ 很差，$G$ 也懒得更新，生成的结果会很差。此外，如果两者都只训练一次，我发现 $D$ 的损失是逐步上升的。如下图所示，右侧是 $D$ 训练三次的，左侧是 $D$ 训练一次的效果，明显发现右侧的效果要好一些。</p>
<p><img data-src="https://z3.ax1x.com/2021/08/11/fNru9O.png" alt></p>
<h1 id="WGAN-GP"><a href="#WGAN-GP" class="headerlink" title="WGAN-GP"></a>WGAN-GP</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过前文我们可以了解到，如果 $D$ 训练得太弱，指示作用不显著，则 $G$ 不能进行有效的学习；但是，如果 $D$ 训练得太好， $G$ 就无法得到足够的梯度继续优化，这样一来， $D$ 的训练火候就非常难把控，这就是 GAN 训练难的根源。如下图所示：</p>
<p><img data-src="https://z3.ax1x.com/2021/08/11/fUlFNn.png" alt></p>
<ul>
<li>左侧的 $D$ 很弱，$G$ 也不知道哪边好哪边弱；</li>
<li>右侧的 $D$ 很强，存在梯度消失和梯度爆炸问题，即在区域 $G$ 获取到的梯度近似为0而无法获得有效的更新。</li>
</ul>
<blockquote>
<p>说点通俗的话，你在学习，你的老师太弱，你学不出来；你的老师太强，无论你怎么学老师都说你是错的，即使进步是有效的，但还是被你的老师说没用，那么之前的进步也可能会回退，你还是学不出来。</p>
</blockquote>
<h2 id="朴素-GAN-的缺陷"><a href="#朴素-GAN-的缺陷" class="headerlink" title="朴素 GAN 的缺陷"></a>朴素 GAN 的缺陷</h2><p>虽然有着完备的理论推导，但是朴素 GAN 仍有以下的缺陷：</p>
<ul>
<li>对于 $D$ 的目标，经过推导会发现竟然要最大化 $P(x)$ 和 $P_G(x;\theta)$ 的距离，显然违背了 $D$ 的初衷，或者说，不是这样判别的；关于 $D$ 计算距离的缺陷，这里 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> 有详细公式推导。</li>
<li>对于 $G$ 的目标，如果一味的最小化 $P_G(x;\theta)$ 和 $P(x)$ 的距离，会使生成的数据只有安全性，没有多样性，这显然也是不好的。</li>
</ul>
<h2 id="Wasserstein-距离"><a href="#Wasserstein-距离" class="headerlink" title="Wasserstein 距离"></a>Wasserstein 距离</h2><p>于是，如何巧妙的<strong>衡量生成分布与真实分布之间的距离</strong>，WGAN 定义了 Wasserstein 距离。即：</p>
<p>\begin{equation}<br>W(P(x), P_G(x;\theta))=\inf_{\gamma\sim\prod(P(x), P_G(x;\theta))} \mathbb{E}_{(x,y)\sim \gamma} \bigl[ \Vert| x-y \Vert \bigr]<br>\end{equation}</p>
<p>$\prod(P(x), P_G(x;\theta))$ 是 $P(x)$ 和 $P_G(x;\theta)$ 联合分布的集合，对于每一个联合分布 $\gamma$ 从中取样，得到一个真实样本 $x$ 和一个虚假样本 $y$，并计算联合分布 $\gamma$ 中两两样本的距离 $\Vert x-y \Vert$，这也就是 Wasserstein 距离。意思是，从 $y$ 移动到 $x$ 需要多远，即便两个分布没有重叠，Wasserstein 距离仍然能够反映它们的远近。</p>
<p>既然如此，那么就把 Wasserstein 距离用到 GAN 中，由于 $\inf$ 是最大下确界，所以：</p>
<p>\begin{aligned}<br>W(P(x), P_G(x;\theta)) &amp; \leq \int_{P(x), P_G(x;\theta)} \Vert x-y \Vert d\gamma \\<br>{ }&amp; = \mathbb{E}_{(x,y)\sim \gamma} \bigl[ \Vert x-y \Vert \bigr] \\<br>&amp;= \mathbb{E}_{x\sim P(x)} D(x) - \mathbb{E}_{x\sim P_G(x;\theta)} D(G(x))<br>\end{aligned} </p>
<p>至此，真实分布与生成分布之间的 Wasserstein 距离融入到了 GAN 中。朴素 GAN 的 $D$ 做的是真假二分类任务，所以最后一层是 sigmoid，但是现在 WGAN 中的 $D$ 做的是近似拟合 Wasserstein 距离，属于回归任务，所以要把 $D$ 最后一层的 sigmoid 拿掉。</p>
<p>接下来 $G$ 要最小化 Wasserstein 距离，$D$ 要最大化 Wasserstein 距离的优良性质，也不需要担心 $D$ 导致的梯度消失的问题，这样就得到了WGAN的两个loss，$G$ 的 loss 是 $- \mathbb{E}_{x\sim P_G(x;\theta)} D(G(x))$，$D$ 的 loss 是 $-\mathbb{E}_{x\sim P(x)} D(x) + \mathbb{E}_{x\sim P_G(x;\theta)} D(G(x))$ （距离最小，取负号）。</p>
<p>为了使距离不在梯度消失问题和梯度爆炸，后续有论文进行了改进 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，并不是直接对 $D$ 的权重进行裁剪限制在某个范围内，而是加入了惩罚项，因此 $D$ 的损失函数变为：</p>
<p>\begin{equation}<br>-\mathbb{E}_{x\sim P(x)} D(x) + \mathbb{E}_{x\sim P_G(x;\theta)} D(G(x)) + \lambda \mathbb{E}_{\hat{x}\sim P(\hat{x})} \bigl( \Vert \nabla_\hat{x} D(\hat{x}) \Vert_2 - 1 \bigr)^2<br>\end{equation}</p>
<p>$\hat{x}$ 是真实数据和虚假数据的随机采样，也就是说，希望 $D$ 对 $\hat{x}$ 数据的梯度保持在都是 1 左右，这样就不用再考虑梯度消失问题和梯度爆炸问题，虚假数据也好往真实数据去移动。最终的算法如下所示：</p>
<p><img data-src="https://z3.ax1x.com/2021/08/11/fU5bh4.png" alt></p>
<p>WGAN 有以下优势：</p>
<ul>
<li>不再需要纠结如何平衡 $G$ 和 $D$ 的训练程度，大大提高了GAN 训练的稳定性,$D$ 训练得越好，对提升 $G$ 就越有利。</li>
<li>即使网络结构设计得比较简陋，WGAN 也能展现出良好的性能，包括避免了样本不够多样性的现象，体现了出色的鲁棒性。</li>
<li>$D$ 的 loss 很准确地反映了 $G$ 生成样本的质量，因此可以作为展现 GAN 训练进度的定性指标。</li>
</ul>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><p>完整代码在 <a href="https://github.com/muyuuuu/colab/blob/main/GAN/WGAN-GP.ipynb" target="_blank" rel="noopener"><code>github</code></a>，这里只展示计算惩罚项的部分：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_gradient_penalty</span><span class="params">(D, real_samples, fake_samples)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># [0, 1] 之间的随机数</span></span><br><span class="line">    alpha = torch.rand(<span class="number">1</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成 \hat&#123;x&#125;</span></span><br><span class="line">    x = (alpha * real_samples + ((<span class="number">1</span> - alpha) * fake_samples)).requires_grad_(<span class="literal">True</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># D 对生成数据的梯度控制为 1 左右，所以计算梯度</span></span><br><span class="line">    interpolates = D(x)</span><br><span class="line"></span><br><span class="line">    fake = torch.ones(bs, <span class="number">1</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算 D(x) 对 interpolates 的梯度</span></span><br><span class="line">    gradients = torch.autograd.grad(</span><br><span class="line">        outputs=interpolates, <span class="comment"># 用来求导的</span></span><br><span class="line">        inputs=x,             <span class="comment"># 被求导的梯度值</span></span><br><span class="line">        grad_outputs=fake,    <span class="comment"># 求梯度时对输出的权重</span></span><br><span class="line">        create_graph=<span class="literal">True</span>,    <span class="comment"># 创建计算图</span></span><br><span class="line">    )[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    gradient_penalty = ((gradients.norm(<span class="number">2</span>, dim=<span class="number">1</span>) - <span class="number">1</span>) ** <span class="number">2</span>).mean()</span><br><span class="line">    <span class="keyword">return</span> gradient_penalty</span><br></pre></td></tr></table></figure>
<p>可能是我网络设置的比较简单，效果并不是很好：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><center> After 100 epochs </center></th>
<th style="text-align:center"><center>After 200 epochs</center></th>
<th style="text-align:center"><center>After 300 epochs</center></th>
<th style="text-align:center"><center>After 400 epochs</center></th>
<th style="text-align:center"><center>After 500 epochs</center></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwc9JA.png" alt></td>
<td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwcnij.png" alt></td>
<td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwclQ0.png" alt></td>
<td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwcBy6.png" alt></td>
<td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwcseO.png" alt></td>
</tr>
</tbody>
</table>
</div>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文涉及了大量的公式推导，从朴素的 GAN 推到了 WGAN-GP。此外，还有啥 conditional GAN，infoGAN，BigGAN，cycleGAN，XGAN 等等等等，不过那些东西脱离了我要做的内容，所以，等哪天空闲了，会简单的整理这些模型的框架和 idea，如果不忙会尝试复现一个 photo shop。</p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/pdf/1606.00709.pdf" target="_blank" rel="noopener">f-GAN论文</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/pdf/1704.00028.pdf" target="_blank" rel="noopener">Improved WGAN</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zhuanlan.zhihu.com/p/25071913" target="_blank" rel="noopener">判别器JS散度距离缺陷</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>从代码角度理解局部敏感哈希算法</title>
    <url>/2021/08/04/LSH-consine/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为开发图像检索系统的需要，需要学习局部敏感哈希算法。我在网上看了很多局部敏感哈希算法的讲解，也没有一个能讲清楚的。什么打乱表格、计数 1 最开始出现的索引、minHash 等没啥用的东西把人说的云里雾里。</p>
<p>而如何设计哈希函数、如何把相似内容放到同一个桶中、计算相似度则闭口不谈。所以，关于数学理论推导，本文就不描述了，网上其他博客多的是，本文从代码的角度来理解局部敏感哈希算法，相对更清晰，附 <code>C++</code> 程序实现。</p>
<a id="more"></a>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p><img data-src="https://z3.ax1x.com/2021/08/04/fAhTfK.png" alt></p>
<p>如上图所示有两张不同的哈希表。在查询阶段，对于输入的每条数据，都会在这两个哈希表中进行查询，因此更多的查询结果可以保证查询的召回率。但是，也会带来查询时间、构建哈希表时间线性增加的弊端。会在文末给出如何设置合理的哈希表数目，这里只需要理解哈希表多了、少了的优缺点即可。</p>
<p>在程序中，我们设置哈希表为三维容器，维度为 $T \times 2^{F} \times 0$，$T$ 表示哈希表的数量，$F$ 表示哈希函数的数量，用 $2^F$ 表示桶的数量，$0$ 是每个桶的容量，初始化为 0, 后期桶内添加数据时容量会增加，维度也会随即发生变化。</p>
<h1 id="哈希函数与哈希过程"><a href="#哈希函数与哈希过程" class="headerlink" title="哈希函数与哈希过程"></a>哈希函数与哈希过程</h1><p>对于任何局部敏感哈希函数 $f(x)$ 而言，它都应该实现：在处理数据库数据时，相似的特征放入同一个桶，不相似特征放入不同的桶中，每个桶可以有多个结果。在处理查询数据时，同样通过哈希函数 $f(x)$，将当前查询的向量映射到桶中，而后在那个桶中返回最接近的 $K$ 个向量。此时，会触发 $f(x)$ 的隐藏条件，在处理数据库数据和查询数据的时候，$f(x)$ 保持不变。</p>
<p>在程序中，我使用了二级哈希，也就是有两个哈希函数：</p>
<ul>
<li>一级哈希函数 $f_1$ 是一个二维矩阵，维度是 $T \times F$，每个元素都是 $[0, F)$ 区间内的随机整数。之后会讲述这么做的原因是为了防止越界。</li>
<li>二级哈希函数 $f_2$ 是一个二维矩阵，维度是 $F \times D$，$D$ 是数据的维度数，其元素取值为以 0 为均值，以 0.2 为方差的服从正太分布的随机数。</li>
</ul>
<h2 id="哈希运算"><a href="#哈希运算" class="headerlink" title="哈希运算"></a>哈希运算</h2><p>重点来了，在对数据进行哈希时，按照表、哈希函数、数据维度的顺寻进行三层遍历，程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历哈希表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="keyword">this</span>-&gt;n_tables; t++) &#123;</span><br><span class="line">    <span class="comment">// 遍历这些哈希函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> f = <span class="number">0</span>; f &lt; <span class="keyword">this</span>-&gt;n_functions; f++) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;n_dim; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;bFile &gt;&gt; x;</span><br><span class="line">            <span class="comment">// 一级哈希，this-&gt;f_1[t][f]，哈希到某个哈希函数</span></span><br><span class="line">            <span class="comment">// 二级哈希，this-&gt;f_2 访问当前哈希函数的第 i 个值</span></span><br><span class="line">            sum += x * <span class="keyword">this</span>-&gt;f_2[ <span class="keyword">this</span>-&gt;f_1[t][f] ][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">            pos += <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>, f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>, <span class="keyword">this</span>-&gt;n_functions))</span><br><span class="line">        pos = <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>, <span class="keyword">this</span>-&gt;n_functions) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 容器追加，避免处理哈希冲突</span></span><br><span class="line">    <span class="comment">// 追加到第 t 个表的第 pos 个桶中</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;hashTables[t][pos].push_back(line);</span><br></pre></td></tr></table></figure>
<ul>
<li>一级哈希 <code>this-&gt;f_1[t][f]</code> ，确定使用哪个哈希函数 $i$，因此取值范围是 $[0, F)$</li>
<li>二级哈希，使用第 $i$ 个哈希函数，对当前数据进行哈希，哈希的运算为乘积并求和。这里需要注意的是，「查询数据处理的阶段」和「数据库数据处理阶段」的哈希形式必须一致，否则无法保证查到近似结果。因此，查询阶段的哈希运算也是乘积并求和。</li>
<li>针对哈希结果，确定将当前数据放入哪个桶中，也就是 <code>pos</code></li>
</ul>
<p>至于上述程序中为何 <code>sum &gt; 0</code> 和 <code>pos += std::pow(2, f);</code>，都是哈希函数的机制，也可以自己定义新的运算，这个没有统一的标准。</p>
<h1 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段"></a>查询阶段</h1><p>对于查询数据，首先要查找当前数据位于哪个桶，而 <code>pos</code> 的计算和上述的哈希运算完全一致：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LSH::hash_query</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> sum&#123;<span class="number">0</span>&#125;, x&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> pos&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;n_functions; i++) &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>-&gt;n_dim; j++) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;qFile &gt;&gt; x;</span><br><span class="line">      sum += x * <span class="keyword">this</span>-&gt;hashFunction[<span class="keyword">this</span>-&gt;amplifyFunction[t][i]][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">      pos += <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获取这个桶后，遍历这个桶内的所有元素，按照相似性距离压入优先级队列，这样就可以逐个访问最相似的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// t 是当前哈希表，pos 是查询到的桶</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i: <span class="keyword">this</span>-&gt;hashTables[t][pos]) &#123;</span><br><span class="line">    <span class="keyword">double</span> dis = <span class="keyword">this</span>-&gt;calcute_cosine_distance(i, line);</span><br><span class="line">    <span class="comment">// 距离与项，按照第一项进行排序</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;res.emplace(dis, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算相似度"><a href="#计算相似度" class="headerlink" title="计算相似度"></a>计算相似度</h2><p>也就是上述程序中的 <code>calcute_cosine_distance</code> 函数，这个还是比较容易实现的。$\text{cos}$ 相似性计算为：</p>
<p>\begin{equation}<br>\text{sim}= \frac{x \cdot y}{ \Vert x \Vert \Vert y \Vert}<br>\end{equation}</p>
<p>分子是内积，分母是模长。</p>
<h1 id="关于参数设置"><a href="#关于参数设置" class="headerlink" title="关于参数设置"></a>关于参数设置</h1><p>如何确定哈希函数、哈希表的数量呢？</p>
<ul>
<li>一个极端的假设，我有很多的哈希函数和哈希表，这无疑会增加建立哈希表的复杂度</li>
<li>一个极端的假设，我只有一个哈希函数和一个哈希表，在查询阶段会查询到大量无关的结果</li>
</ul>
<p>那么，假设数据库里面有 10000 条数据，那么我可以设置 10 个哈希函数，因为 $2^{10}=1024$，这样就有了 1024 个桶。而如果 10000 数据分布均匀，每个桶就可以有 10 条左右的数据，查询也快。至于哈希表，2个，3个都是可以的，但是不能太多。</p>
<p>此外还要注意的是，每个哈希桶内的元素数最好是均匀的，这样查询时间也更稳定。所以要设置合理的哈希函数的机制，也就是 <code>pos</code> 的分布一定要均匀。</p>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>我自己实现了一份<a href="https://github.com/muyuuuu/SeetaFace-Retri/tree/main/CosineLSH" target="_blank" rel="noopener">局部敏感哈希程序</a>，我是 C++ 初学者，代码写的不是很难，相信你看完代码是可以理解局部敏感哈希算法的。计算相似度是使用的余弦距离，因为欧拉距离会面临维灾。<code>modules</code> 里面的 <code>config.cpp</code> 可以忽略，那个是为了衔接其他业务设计的。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>处理 <code>13466 X 2048</code> 大小的数据，即 13466 条数据，每条数据的维度是 2048 维。构建 1024 个哈希函数，两张哈希表。log 日志显示每秒哈希 50 条数据。 对 100 条数据进行查询，每条数据返回最接近的 5 条数据。每条数据的平均查询时间为 0.86 秒，最低时间为 0.34 秒，召回率接近 100% 。</p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>核密度聚类</title>
    <url>/2020/03/30/KDE-cluster/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当问题需要自动地确定聚类数目时，传统的KMeans等聚类方法不在适用。因此，使用“核概率密度估计”的思路自行设计了两种聚类方法。本文收录：</p>
<ul>
<li>核是什么</li>
<li>核密度估计</li>
<li>基于核密度估计的两种聚类方法</li>
<li>代码实现</li>
</ul>
<a id="more"></a>
<h1 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h1><p>有一些数据，想“看看”它长什么样，基于高中的知识，我们一般会画频率分布直方图（Histogram）。但基于大学的知识，此时也可以用核密度估计，因为之前的知识水平让我们默认为频率等于概率，但实际情况不一定如此。</p>
<p>这里的“核”是一个函数，用来提供权重。例如高斯函数 (Gaussian) 就是一个常用的核函数。举个例子，假设我们现在想买房，钱不够要找亲戚朋友借，我们用一个数组来表示 5 个亲戚的财产状况： [8, 2, 5, 6, 4]。我们是中间这个数 5。“核”是一个权重函数，假设这个核函数的取值为[0.1, 0.4, 1, 0.3, 0.2]，以此来代表同的亲戚朋友亲疏有别。</p>
<p>在借钱的时候，关系好的朋友出力多，关系不好的朋友出力少，于是我们可以用权重来表示。总共能借到的钱是： $8\times 0.1 + 2\times 0.4 + 5\times 1 + 6\times 0.3 + 4\times 0.2 = 9.2$。</p>
<p>那么“核”的作用就是用来决定权重，例如高斯函数（即正态分布），呈现出距离中心越远，权重越小；反之，距离中心越近，权重越大的特点。核函数还有以下重要的性质：</p>
<ul>
<li>$\int_{-\infty}^{+\infty}K(x)\text{d}x=1$</li>
<li>$K(-x)=K(x)$</li>
</ul>
<h1 id="核密度估计"><a href="#核密度估计" class="headerlink" title="核密度估计"></a>核密度估计</h1><p>如果我们画频率分布直方图，其实目的是画出“概率密度函数”，因为统计直方图的组距无限接近于0时，得到的函数就是概率密度函数。</p>
<p>但直方图本质上是认为频率等于概率，但这种假设不是必然的。</p>
<p>核密度估计方法是一种非参数估计方法，非参数估计法指：如果一个估计问题所涉及的分布未知或不能用有穷参数来刻划，称这种估计为非参数估计。非参数估计是一种“平滑(smooth)”的手段：设 $(x_1,x_2,\cdots,x_n)$ 是独立同分布的 $n$ 个样本点，于是我们的估计：</p>
<script type="math/tex; mode=display">\hat{p}(x)=\frac{1}{n}\sum_{i=1}^nK_h(x-x_i)=\frac{1}{nh}\sum_{i=1}^nK(\frac{x-x_i}{h})</script><p>上面式子中 $x−x_i$ 要提前归一化到 $[-1, 1]$ 之间。</p>
<p>这个公式的意思相当于是<strong>“我说的你可能不信，一起看看别人怎么说我的你就信了”</strong>。别人是指除自己外的其他样本点，距离越远的样本点权重越小，说话没有分量；距离样本点越近则权重越大，说话的可信度也就越高。当然权重的大小取决于实际采用的核函数，也可能距离越远权重越大，这里只是举个例子。</p>
<p>其中距离的远近通过$x-x_i$的大小来衡量。相当于加权平均后，就能更好地了解我了，于是乎得到新的函数值作为这一点概率的取值。$h$ 是人为指定的，代表“朋友圈”的大小，正式的叫法是“带宽”(bandwidth)，且带宽越大曲线越平滑。</p>
<p>看一下核密度估计和频率分布直方图就能更好的理解了，蓝色的线为概率密度估计，橙色的柱状图为数据出现的频率统计。</p>
<p><img data-src="/2020/03/30/KDE-cluster/1.png" alt></p>
<h1 id="核密度聚类"><a href="#核密度聚类" class="headerlink" title="核密度聚类"></a>核密度聚类</h1><p>当然文章到这里还没有结束，要是到这里结束我就真成了抄袭文章的了。这组数据看上去很有聚类的趋势不是么，有两种聚类方法：</p>
<ol>
<li>第一种方法。取曲线中的极大值和极小值分成几个区间，将数据的出现频率完成分类，此时会将出现频率相近的数据聚合在一起。按出现频率的高低分为四个居间A,B,C,D共四个类。则A类的数据出现频率最高，D类的数据出现频率最低。如下图所示：<img data-src="/2020/03/30/KDE-cluster/2.png" alt></li>
<li>第二种方法。既然曲线有多个极大值和极小值，那么何不以极大值极小值为分界点进行划分区间？按极值点的横坐标取值将数据分为四个居间A,B,C,D共四个类。那么此时对数据的含义也有了要求，即：每个数据段都有不同的含义，不能以数据出现的频率进行笼统划分。如下图所示：<img data-src="/2020/03/30/KDE-cluster/3.png" alt>举个例子：图片的灰度值的取值范围是[0,255]，假设[0,50]区间数据的出现频率和[200,255]区间数据的出现频率相近，但一定不能把这两组数据放在一起，因为前者代表黑色图层，后者代表白色图层。此时应以极大值、极小值等极值点的横坐标的取值划分区间，而后进行聚类更为合适。</li>
<li>无论哪种方法，都能自动确定聚类数量。</li>
</ol>
<h2 id="核密度估计-1"><a href="#核密度估计-1" class="headerlink" title="核密度估计"></a>核密度估计</h2><p>本文着重实现第二种聚类方法，第一种其实同理。</p>
<p>首先产生一组随机数：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">N = <span class="number">1000</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># concatenate 用来组合两种数据，第一组数据均值0方差1，数量占 30% </span></span><br><span class="line"><span class="comment"># 第二组数据均值 5 方差1 数量占 70%</span></span><br><span class="line"><span class="comment"># [:, np.newaxis] 把数据维度更新为二维一列的数据</span></span><br><span class="line">X = np.concatenate((np.random.normal(<span class="number">0</span>, <span class="number">1</span>, int(<span class="number">0.3</span> * N)), np.random.normal(<span class="number">5</span>, <span class="number">1</span>, int(<span class="number">0.7</span> * N))))[:, np.newaxis]</span><br></pre></td></tr></table></figure>
<p>其次调用sklearn这个库实现核密度估计即可：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">X_plot = np.linspace(<span class="number">-5</span>, <span class="number">10</span>, <span class="number">1000</span>)[:, np.newaxis]</span><br><span class="line"></span><br><span class="line">colors = [<span class="string">'blue'</span>]</span><br><span class="line">kernels = [<span class="string">'gaussian'</span>]</span><br><span class="line">lw = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> color, kernel <span class="keyword">in</span> zip(colors, kernels):</span><br><span class="line">    <span class="comment"># Fit the Kernel Density model on the data.</span></span><br><span class="line">    kde = KernelDensity(kernel=kernel, bandwidth=<span class="number">0.5</span>).fit(X)</span><br><span class="line">    <span class="comment"># Evaluate the log density model on the data. </span></span><br><span class="line">    log_dens = kde.score_samples(X_plot)</span><br><span class="line">    plt.plot(X_plot[:, <span class="number">0</span>], np.exp(log_dens), color=color, lw=lw,</span><br><span class="line">            linestyle=<span class="string">'-'</span>, label=<span class="string">"kernel = '&#123;0&#125;'"</span>.format(kernel))</span><br><span class="line">    arr = np.exp(log_dens)</span><br><span class="line">    np.save(<span class="string">'data.npy'</span>, arr)</span><br></pre></td></tr></table></figure>
<ul>
<li>X_plot ：An array of points to query；</li>
<li>kde = KernelDensity(kernel=kernel, bandwidth=0.5).fit(X) 完成训练工作，计算核密度；</li>
<li>log_dens = kde.score_samples(X_plot) 评估这点的概率值该是多少。画图是连续的曲线，曲线上的点不一定在样本中，所以要弥补一些缺失的点；</li>
<li>np.exp 是因为kde.score_samples反馈结果的概率值取了ln(可参看源码实现)，所以计算真实概率值要exp一下；</li>
<li>保存数据用于后期聚类处理。</li>
</ul>
<p>完整代码如下：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KernelDensity</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> norm</span><br><span class="line"></span><br><span class="line">N = <span class="number">1000</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">X = np.concatenate((np.random.normal(<span class="number">0</span>, <span class="number">1</span>, int(<span class="number">0.3</span> * N)), np.random.normal(<span class="number">5</span>, <span class="number">1</span>, int(<span class="number">0.7</span> * N))))[:, np.newaxis]</span><br><span class="line"></span><br><span class="line">X_plot = np.linspace(<span class="number">-5</span>, <span class="number">10</span>, <span class="number">1000</span>)[:, np.newaxis]</span><br><span class="line"></span><br><span class="line">colors = [<span class="string">'blue'</span>]</span><br><span class="line">kernels = [<span class="string">'gaussian'</span>]</span><br><span class="line">lw = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> color, kernel <span class="keyword">in</span> zip(colors, kernels):</span><br><span class="line">    kde = KernelDensity(kernel=kernel, bandwidth=<span class="number">0.5</span>).fit(X)</span><br><span class="line">    log_dens = kde.score_samples(X_plot)</span><br><span class="line">    plt.plot(X_plot[:, <span class="number">0</span>], np.exp(log_dens), color=color, lw=lw,</span><br><span class="line">            linestyle=<span class="string">'-'</span>, label=<span class="string">"kernel = '&#123;0&#125;'"</span>.format(kernel))</span><br><span class="line">    arr = np.exp(log_dens)</span><br><span class="line">    np.save(<span class="string">'data.npy'</span>, arr)</span><br><span class="line"></span><br><span class="line">plt.legend(loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.hist(X, <span class="number">70</span>, normed = <span class="number">1</span>, histtype=<span class="string">'bar'</span>, facecolor=<span class="string">'salmon'</span>, rwidth=<span class="number">0.9</span>)  </span><br><span class="line"><span class="comment"># plt.set_xlim(-4, 9)</span></span><br><span class="line"><span class="comment"># plt.set_ylim(-0.02, 0.4)</span></span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">"$N$ = 1000 points"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Data"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Density Function"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.savefig(<span class="string">'test.png'</span>, dpi=<span class="number">300</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="求极值以聚类"><a href="#求极值以聚类" class="headerlink" title="求极值以聚类"></a>求极值以聚类</h2><p>之后借助scipy求出核密度估计的点中的几个极大值和极小值（极值并不唯一）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> argrelextrema</span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">data = np.load(<span class="string">'data.npy'</span>)</span><br><span class="line"><span class="comment"># 求极大值</span></span><br><span class="line">maxn = argrelextrema(data, np.greater)</span><br><span class="line"><span class="comment"># 求极小值</span></span><br><span class="line">minn = argrelextrema(data, np.less)</span><br><span class="line"><span class="comment"># 打印极大值的索引</span></span><br><span class="line">print(maxn)</span><br><span class="line"><span class="comment"># 打印极小值的索引</span></span><br><span class="line">print(minn)</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(array([<span class="number">340</span>, <span class="number">667</span>], dtype=int64),)</span><br><span class="line">(array([<span class="number">480</span>], dtype=int64),)</span><br></pre></td></tr></table></figure>
<p>得到的结果显示有两个极大值两个极小值，与概率密度估计图象相吻合。按照返回的极值索引访问极值即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(data[minn])</span><br></pre></td></tr></table></figure>
<p>进而按照极值划分数据，即可完成聚类。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>站在巨人的肩膀上，我们能更好的前行：</p>
<ol>
<li><a href="https://lotabout.me/2018/kernel-density-estimation/" target="_blank" rel="noopener">https://lotabout.me/2018/kernel-density-estimation/</a></li>
<li><a href="https://spaces.ac.cn/archives/3785" target="_blank" rel="noopener">https://spaces.ac.cn/archives/3785</a></li>
<li><a href="https://scikit-learn.org/stable/auto_examples/neighbors/plot_kde_1d.html" target="_blank" rel="noopener">https://scikit-learn.org/stable/auto_examples/neighbors/plot_kde_1d.html</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KernelDensity.html" target="_blank" rel="noopener">https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KernelDensity.html</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/referenc/generated/scipy.signal.argrelextrema.html" target="_blank" rel="noopener">https://docs.scipy.org/doc/scipy/referenc/generated/scipy.signal.argrelextrema.html</a></li>
<li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html" target="_blank" rel="noopener">https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html</a></li>
<li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.expand_dims.html" target="_blank" rel="noopener">https://docs.scipy.org/doc/numpy/reference/generated/numpy.expand_dims.html</a></li>
</ol>
<p>你也可以看到我查看翻阅了大量的官方文档，其实对于这种技术东西，官方文档的解释往往是最好的，不懂的问题就多动动手多思考嘛，哪能不懂就问。</p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX补充:矩阵外加描述元素</title>
    <url>/2018/11/17/LaTeX-supplement/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写这个的主要目的是，整理那些年写 LaTeX中遇到的坑，有些东西在教科书里面没有，遇到就记下来。毕竟这玩意，见过就是会，没见过就是不会。</p>
<a id="more"></a>
<p>如果对本文有疑问或者想找男朋友，可以联系我，<a href="https://muyuuuu.github.io/about/">点击此处有我联系方式。</a></p>
<h1 id="矩阵外加描述元素"><a href="#矩阵外加描述元素" class="headerlink" title="矩阵外加描述元素"></a>矩阵外加描述元素</h1><p><img data-src="/2018/11/17/LaTeX-supplement/1.png" alt></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;blkarray&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;blockarray&#125;</span><span class="string">&#123;ccccccc&#125;</span></span></span><br><span class="line">  &amp; 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5<span class="tag">\<span class="name">\</span></span></span><br><span class="line">  <span class="tag">\<span class="name">begin</span><span class="string">&#123;block&#125;</span><span class="string">&#123;c[cccccc]&#125;</span></span></span><br><span class="line">    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0<span class="tag">\<span class="name">\</span></span></span><br><span class="line">    1 &amp; 0.6 &amp; 0 &amp; 0.4 &amp; 0 &amp; 0 &amp; 0<span class="tag">\<span class="name">\</span></span></span><br><span class="line">    2 &amp; 0 &amp; 0.6 &amp; 0 &amp; 0.4 &amp; 0 &amp; 0<span class="tag">\<span class="name">\</span></span></span><br><span class="line">    3 &amp; 0 &amp; 0 &amp; 0.6 &amp; 0 &amp; 0.4 &amp; 0<span class="tag">\<span class="name">\</span></span></span><br><span class="line">    4 &amp; 0 &amp; 0 &amp; 0 &amp; 0.6 &amp; 0 &amp; 0.4<span class="tag">\<span class="name">\</span></span></span><br><span class="line">    5 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1<span class="tag">\<span class="name">\</span></span></span><br><span class="line">  <span class="tag">\<span class="name">end</span><span class="string">&#123;block&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;blockarray&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>此处感谢福州的一位网友的帮助，可惜无法引用一下。。。</p>
<hr>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>美赛论文LaTeX模板</title>
    <url>/2019/01/15/MCM-template/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里是我自己维护的美赛模板5.0，应用在了2018和2019的竞赛中（2020年摘要也做出变动，但已经修改）。<strong>2018年二等奖，2019年一等奖</strong>。其他人也用过我的模板，一等、二等、三等都有。虽然很遗憾到头来也没能拿个Outstanding Winner。如果作者不是很忙，会<code>持续跟进</code>每年的美赛模板的变化，并修改发布。</p>
<p>最后一次更新的时候，我已经两年不建模了。大一（2016年）进的建模协会，一晃都四年过去了，当初一起比赛一起刷夜一起机房吵架的小伙伴早已去各大高校深造或入海工作，还真是有点时过境迁的感慨。</p>
<p>纯手工打造，没用texlive中自带的包，因为去年用自带的模板出了点问题：</p>
<ul>
<li>比如摘要页太少</li>
<li>比如参考文献出了BUG(安神他们组出BUG了，时间仓促直到后来也没去看那个BUG)，估计是被别人推荐使用CTeX套装导致的不良后果</li>
</ul>
<p>文章主体内容：给出MCM的模板代码，使用说明和最终结果。</p>
<p>既然你能检索到这个网站，说明你的搜索能力不一般，可能有良好的计算机使用习惯。祝你比赛顺利and文末有论文和模板的代码。</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>介绍我的模板，目前个人维护版本version5.0，基于texlive2019发行版。</li>
<li>字体palatino，大小13pt。Times New Roman实在太难看，而且我看别人的Outstanding论文基本都是palatino字体，2020年要求了摘要页必须用Times New Roman，2021年又没有这个要求了。</li>
<li>使用ctexart文档方便翻译，xelatex编译文档，bibtex编译参考文献，在Windows、Mac OS、linux均测试通过。</li>
<li>模板内有各种参数，如果模板不符合自己口味随意修改。(中文字体的间距可能有点挤，换成英文就OK啦)。我也尽力写了人性化的注释。</li>
<li>至于英文首段缩进与否(英文排版习惯是不缩进，我的习惯是缩进)，我预留了缩进的代码，自己随意修改。</li>
<li>众所周知美赛没有固定模板，美赛官网无任何模板要求，建模比赛也不是排版比赛。</li>
<li><strong>美赛官网只要求了：字体不小于12pt，页眉格式，页数限制，没有其他要求</strong></li>
<li>以曾经我们组的实力而言，是不用在乎排版的细节的，如：几号字体，字体多少，行距多少，缩进不缩进，没必要。</li>
</ul>
<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>另外，在我写代码报错的时候，十分感谢各位大佬对我耐心的帮助和支持，在此表示十分的感谢。特别鸣谢，排名不分先后：</p>
<ul>
<li><a href="https://github.com/OsbertWang" target="_blank" rel="noopener">啸行</a>：帮助我调页眉，文章字体等。</li>
<li><a href="https://github.com/stone-zeng" target="_blank" rel="noopener">Stone-Zeng</a>：帮助我修改论文中代码字体，指出了我的错误。此外我从他身上学到最重要的东西：眼界要长远。</li>
<li><a href="https://github.com/zepinglee" target="_blank" rel="noopener">zepinglee</a>：曾深夜12点对我的代码进行挑刺，感谢修改意见。</li>
<li><a href="https://liam.page/" target="_blank" rel="noopener">Liam Huang</a>：帮助我修改论文中代码字体，参考文献格式，插入eps文件的指导，有关浮动体过多导致不良后果的讨论。</li>
<li><a href="https://github.com/RuixiZhang42" target="_blank" rel="noopener">RuixiZhang</a>：对我论文中的代码字体提供了详细的指导意见。</li>
</ul>
<h1 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h1><ul>
<li>最重要的建议：模板是给有 $\LaTeX$ 基础的人用的，小白驾驭不了，着急参赛请用word。</li>
<li>最终的 $\LaTeX$ 代码会很长，请保证代码规范。这不是为了考试，所以请书写人性化的可读性很强的代码。</li>
<li>我致力于开源可分享，所以把我自己写的模板放到了网站上，后面会把我一等奖的论文放上来供大家参考使用。我发誓不收费，还免费提供后期服务。你参加美赛我肯定支持，当然也希望你取得好成绩。</li>
<li>代码没有所谓的版权，如果想使用随便copy。但是希望你一定要精通 $\LaTeX$ 的常用命令，会基本的排版，读过入门文档，不然出错了神仙难救。</li>
<li>当然，如果使用我的模板出现问题，请及时联系我，我一定会尽力维护。</li>
<li>还有希望引用请注明出处，尤其是那些无良的教育机构，活生生的把别人的模板说成是自己写的，希望你有点良心。</li>
<li>如果你没良心我也不介意，随意山寨随意copy，只要能推广$\LaTeX$就行，至于是说成谁写的，谁推广的，我无所谓。这点胸怀还是有的。如果你用来收费就很恶心了。</li>
</ul>
<h1 id="摘要页"><a href="#摘要页" class="headerlink" title="摘要页"></a>摘要页</h1><p>是不是比之前的能写上好多内容。</p>
<p><img data-src="/2019/01/15/MCM-template/1.jpg" alt></p>
<h1 id="一封信"><a href="#一封信" class="headerlink" title="一封信"></a>一封信</h1><p><img data-src="/2019/01/15/MCM-template/2.png" alt></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><img data-src="/2019/01/15/MCM-template/4.png" alt></p>
<h1 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h1><p><img data-src="/2019/01/15/MCM-template/3.png" alt></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><img data-src="/2019/01/15/MCM-template/5.png" alt></p>
<h1 id="附录代码"><a href="#附录代码" class="headerlink" title="附录代码"></a>附录代码</h1><p><img data-src="/2019/01/15/MCM-template/6.png" alt></p>
<h1 id="插图"><a href="#插图" class="headerlink" title="插图"></a>插图</h1><p><img data-src="/2019/01/15/MCM-template/8.png" alt></p>
<h1 id="页眉页脚"><a href="#页眉页脚" class="headerlink" title="页眉页脚"></a>页眉页脚</h1><p><img data-src="/2019/01/15/MCM-template/13.png" alt></p>
<h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p>代码就不在这里展示了，太长。真心的请你一定读过一本入门文档。</p>
<p><del>Github传送门（我在不会ZZ的去用百度云~）</del></p>
<p><img data-src="/2019/01/15/MCM-template/14.jpg" alt></p>
<p>因本人太穷，<del><code>Github</code>免费代码已经关闭</del>。欢迎来这里下载，顺便给这个网站引流。下载一次我能挣一毛钱，我就是穷，没啥，代码还是原来的代码。两个下载链接：</p>
<ul>
<li><a href="https://github.com/muyuuuu/A-customized-MCM-LaTeX-template-based-on-ctexart" target="_blank" rel="noopener">github</a></li>
<li><a href="https://latexstudio.net/index/details/index/mid/841.html" target="_blank" rel="noopener">LaTeXStudio</a></li>
</ul>
<h1 id="修改日志"><a href="#修改日志" class="headerlink" title="修改日志"></a>修改日志</h1><p>如果你用了这份模板，且取得了不错的成绩，且想公布你的论文。欢迎联系我，我会注明作者、学校等，做到这个模板的可持续发展。如果你想把比赛论文改成期刊投出去，期刊等级低的没意思，等级高的，恕我直言中不了。</p>
<h2 id="2020年修改"><a href="#2020年修改" class="headerlink" title="2020年修改"></a>2020年修改</h2><ul>
<li>根据官网给的新摘要页，重新修改。</li>
<li>English-version-2019-MCM-C和中文版-2018-MCM-C这两个版本的代码太烂了，烂到不想承认是我写的。</li>
<li>综上：2020-Summary-change改进了那两份不好的代码，并修改了摘要页，建议使用这个版本的（附论文）。</li>
</ul>
<h2 id="2021年修改"><a href="#2021年修改" class="headerlink" title="2021年修改"></a>2021年修改</h2><ul>
<li>官方没给出任何修改。</li>
</ul>
]]></content>
      <tags>
        <tag>LaTeX</tag>
        <tag>Modeling</tag>
      </tags>
  </entry>
  <entry>
    <title>GCN的通俗理解，无复杂公式</title>
    <url>/2020/06/16/GCN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近期在鼓捣图神经网络，发现直接读state-of-art的论文基本读不懂，于是先决定搞懂图神经网络的最基本概念，即工作原理、处理数据流程等。因网上的众多文章（包括原论文）都有复杂的数学公式，我不是否认数学公式不好，而是胡乱的堆公式对讲明白原理没有丝毫帮助。于是决定做一篇GCN的简单阐述，意在用最简单的语言，表达最清晰的思路。</p>
<a id="more"></a>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>图的表示为$G=(V,E)$，将图的节点表示和邻接矩阵作为网络的输入：</p>
<ul>
<li>对于每一个节点$i$的特征描述$x_i$，组成一个$N\times D$的矩阵$X$，$N$是节点的数量，$D$是特征的维度；</li>
<li>图的邻接矩阵为$A$；</li>
<li>网络的输出是$Z$，维度是$N\times F$，$F$是输出维度的特征。</li>
</ul>
<p>每一层神经网络可以定义为非线性函数：</p>
<p>\begin{equation}<br>H^{l+1}=f(H^l, A)<br>\end{equation}</p>
<p>其中，$H^0=X,H^l=Z$，$l$是网络的层数，$f$是选择的网络模型，就这样一层一层的输出。</p>
<h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><p>首先定义逐层之间的传播规则：</p>
<p>\begin{equation}f(H^l,A)=\sigma (AH^lW^l)\end{equation}</p>
<p>其中，$W^l$是第$l$层的网络权重，$\sigma$是非线性的激活函数，这是最简单的定义。对这个最简单的定义添加两个限制：</p>
<ul>
<li>$A\times H^l$意味着对于图中的每一个节点，将它所有的邻居节点的全部特征向量求和，但没有考虑自己（除非有链接到自己的环），所以要对矩阵$A$增加单位矩阵$I$，这样矩阵的每一个节点就具有链接到自己的回路；</li>
<li>考虑到邻接矩阵$A$的同时，也要考虑到节点的度，度越大，表明该节点和其他节点的关系越大，如果直接提取度数很大节点和周围节点的联系，即将邻居节点的全部特征向量求和，势必会导致数据分布的不均衡。此时标准化的方式为：要取该节点的周围节点特征值的平均值。通俗点说，就是一个节点和四个节点挨着，那么对这四个节点，取每个节点特征值的$1/4$在求和就行了。而实现这种方式只需要一个矩阵变换：方式为$D^{-1}A$/其中，$D$是对角矩阵，矩阵元素是节点的度。论文中使用了对称标准化$D^{-\frac{1}{2}}AD^{-\frac{1}{2}}$的方式，这不再严格等于相邻节点的平均。</li>
<li><del>（只是这么一种处理方式，不必太在意）</del>，还是要在意一下，我之前认为傅立叶变换等数学推导可以忽略，结果发现这是傅立叶变换和逆变换的两个过程，如果想要看懂这个过程，可以参考：李宏毅机器学习课程 <code>GNN</code> 的第二章节的课程。</li>
</ul>
<p>此时，传播规则为：</p>
<p>\begin{equation}f(H^l,A)=\sigma (\hat{D}^{-\frac{1}{2}}\hat{A}\hat{D}^{-\frac{1}{2}}H^lW^l)\end{equation}</p>
<p>其中，$\hat{A}=A+I$，$\hat{D}$是$\hat{A}$的节点度的矩阵。</p>
<h1 id="模型操作"><a href="#模型操作" class="headerlink" title="模型操作"></a>模型操作</h1><p>如果你看到这里还不是很懂，那我很建议去看它的代码，一目了然。值得注意的是，模型产生了这些节点的嵌入，它们非常类似于图的社区结构。</p>
<h2 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h2><p>只对有标签的数据训练，没有标签的数据在损失函数中不考虑。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>恕我直言，上古时期的<code>tensorflow</code>代码没有看懂，<code>keras</code>的代码还能看懂，但没有调通，看源代码的众多<code>issue</code>就知道了。</p>
<ol>
<li>第一步加载数据，<code>X, A, y = load_data(dataset=DATASET)</code>，其中X是特征矩阵，即节点的向量表示，A是临界矩阵，y是标签；</li>
<li>然后得到训练数据<code>graph</code>，由<code>X</code>和<code>A_</code>（处理后的矩阵，包括增加单位矩阵和对称标准化）组成；</li>
<li>之后数据经过<code>doupout</code>，传入<code>GraphConvolution</code>层；</li>
</ol>
<h2 id="GraphConvolution-解析"><a href="#GraphConvolution-解析" class="headerlink" title="GraphConvolution 解析"></a><code>GraphConvolution</code> 解析</h2><p>重要的一点是，图卷积网络和卷积核无关。而是直接矩阵相乘，在得到节点的嵌入表示后，再去划分就很容易了。可以参看原文的代码（我删除了一部分无关紧要的代码）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphConvolution</span><span class="params">(Layer)</span>:</span></span><br><span class="line">    <span class="string">"""Basic graph convolution layer as in https://arxiv.org/abs/1609.02907"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_output_shape</span><span class="params">(self, input_shapes)</span>:</span></span><br><span class="line">        features_shape = input_shapes[<span class="number">0</span>]</span><br><span class="line">        output_shape = (features_shape[<span class="number">0</span>], self.units)</span><br><span class="line">        <span class="keyword">return</span> output_shape  <span class="comment"># (batch_size, output_dim)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self, input_shapes)</span>:</span></span><br><span class="line">        features_shape = input_shapes[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">assert</span> len(features_shape) == <span class="number">2</span></span><br><span class="line">        input_dim = features_shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        self.kernel = self.add_weight(shape=(input_dim * self.support,</span><br><span class="line">                                             self.units),</span><br><span class="line">                                      initializer=self.kernel_initializer,</span><br><span class="line">                                      name=<span class="string">'kernel'</span>,</span><br><span class="line">                                      regularizer=self.kernel_regularizer,</span><br><span class="line">                                      constraint=self.kernel_constraint)</span><br><span class="line"></span><br><span class="line">        self.bias = self.add_weight(shape=(self.units,),</span><br><span class="line">                                        initializer=self.bias_initializer,</span><br><span class="line">                                        name=<span class="string">'bias'</span>,</span><br><span class="line">                                        regularizer=self.bias_regularizer,</span><br><span class="line">                                        constraint=self.bias_constraint)</span><br><span class="line"></span><br><span class="line">        self.built = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs, mask=None)</span>:</span></span><br><span class="line">        features = inputs[<span class="number">0</span>]</span><br><span class="line">        basis = inputs[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        supports = list()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.support):</span><br><span class="line">            supports.append(K.dot(basis[i], features))</span><br><span class="line">        supports = K.concatenate(supports, axis=<span class="number">1</span>)</span><br><span class="line">        output = K.dot(supports, self.kernel)</span><br><span class="line"></span><br><span class="line">        output += self.bias</span><br><span class="line">        <span class="keyword">return</span> self.activation(output)</span><br></pre></td></tr></table></figure>
<p>如上，我么很容易看出 <code>GCN</code> 的工作就是矩阵相乘，将输出的维度不断的压缩，得到节点的嵌入表示。也许你会很疑惑？众多科普文章中的拉普拉斯算子什么的呢？关于这一点，原作者也做出了解释：</p>
<p><code>spectral graph convolution</code>（我不知道该怎么翻译了）：定义为信号与图的傅立叶空间中的滤波器相乘。说人话的意思是：矩阵$X$要和矩阵$U$相乘，矩阵$U$是图灵拉普拉斯矩阵$L$的特征向量矩阵，$L$的计算方式是：$L=I-\hat{A}$，但是具有高昂的计算代价。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>也许你会疑问，图网络是用来干什么的？正如作者所说，GCN仅仅是一个开始。据我个人的粗俗分析，可以用来：</p>
<ol>
<li>借助GCN学习得到的节点表示，来进行大规模图划分；</li>
<li>如果GCN的标签是自己本身，那是不是可以用类似 autoencoder 的形式来进行链接预测？</li>
<li>能否学习节点之间的隐藏联系，推断序列数据的结构？</li>
<li>能否与周围环境交互，对已有的模型进行调整，主动构建关系、对象等？</li>
</ol>
<p>当然，距离实现以上这些还有很长的路要走。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>站在巨人的肩膀上，我们能更好的前行：</p>
<ol>
<li>参考论文: <a href="https://arxiv.org/pdf/1609.02907.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1609.02907.pdf</a></li>
<li>参考博客(原文讲的很好): <a href="http://tkipf.github.io/graph-convolutional-networks/" target="_blank" rel="noopener">http://tkipf.github.io/graph-convolutional-networks/</a></li>
<li>数据集(cora): <a href="http://www.cs.umd.edu/~sen/lbc-proj/LBC.html" target="_blank" rel="noopener">http://www.cs.umd.edu/~sen/lbc-proj/LBC.html</a></li>
<li>代码参考(tensorflow): <a href="https://github.com/tkipf/gcn" target="_blank" rel="noopener">https://github.com/tkipf/gcn</a></li>
<li>代码参考(keras): <a href="https://github.com/tkipf/keras-gcn" target="_blank" rel="noopener">https://github.com/tkipf/keras-gcn</a></li>
</ol>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>对抗训练篇：MART 防御算法论文笔记</title>
    <url>/2021/06/22/MART/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MART(Misclassification Aware adveRsarial Training) 是 2020 年提出的最好的对抗防御算法。传统对抗训练算法中 min-max 时不会考虑当前样本是否被正确分类，统一制作对抗样本。而作者抓住了这一点，发现对于 max 制作对抗样本期间没有被网络正确分类的样本，对结果的影响很大。换句话说，<strong>网络连干净样本都不认识，何谈认识它的对抗样本？</strong> MART 算法的创新点在于区别对待错分类和正确分类的样本。</p>
<a id="more"></a>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>MART 防御的仍然是微小扰动的图像，也就是人眼察觉不出来的那种。论文用$p$ 范数满足这一限制：$\Vert x’-x \Vert_p \leq \epsilon$。对抗训练可以视为使用对抗样本进行数据增强，解决的是以下优化问题：</p>
<p>\begin{equation}<br>\min_\theta \frac{1}{n} \sum_{i=1}^{n} \max_{\Vert x’-x \Vert_p \leq \epsilon} L(h_\theta(x_i’), y_i)<br>\end{equation}</p>
<p>$n$ 是一个 batch 的大小，$L$ 是分类的损失函数。内部通过最大化损生成对抗样本，外部最小化对抗样本的分类损失来训练更好的 DNN，如 <a href="https://muyuuuu.github.io/2021/04/26/DNN-safe-basic/">PGD</a> 就是使用的这种方案。</p>
<p>而本文的关注点在对抗训练的对抗样本上，其实许多对抗训练算法忽略了一点，有些样本被正确分类，有些样本被错误分类，但无论哪种样本，都在 min-max 中直接制作对抗样本。因此本文也就抛出例如下疑问：</p>
<blockquote>
<p>由错分类样本和正确分类的样本产生的对抗样本，对模型的鲁棒性贡献程度是一样的吗？如果不是，如何利用这个差异，来提升模型的鲁棒性？</p>
</blockquote>
<p>本文针对这个被忽略的一点做了一些探索，发现被错分类和正确分类的样本对最终模型的鲁棒性的确有不同的影响。</p>
<p>本文做了这样的实验，在 CIFAR-10 数据集上做白盒攻击，扰动值 $\epsilon=8/255$。使用 PGD-10 算法制作对抗样本，以对抗训练的形式训练得到的网络的准确率是 87%。然后选择被错分类的样本记为 $S^-$，在选择被正确分类的样本记为 $S^+$。之后使用这两类样本，用不同的方式训练上述网络，最后用 PGD-20 算法制作的对抗样本评估最终模型的鲁棒性。结果如下图所示：</p>
<p><img data-src="https://z3.ax1x.com/2021/06/22/RmVckj.png" alt></p>
<p>在图 a 中：错分类样本对鲁棒性有明显影响。</p>
<ol>
<li>蓝色的线是标准对抗训练的对抗鲁棒性</li>
<li>绿色的线表示没有对 $S^-$ 制作对抗样本，其它样本仍然是对抗样本，鲁棒性降低很大；</li>
<li>橙色的线表示没有对 $S^+$ 制作对抗样本，其它样本仍然是对抗样本，鲁棒性变换其实不大。</li>
</ol>
<p>图 b 中：为了更深理解『错分类样本和其它样本』的影响是不同的，外部 min 采用交叉熵，内部 max 采用攻击强度很弱的 <a href="https://muyuuuu.github.io/2021/04/26/DNN-safe-basic/">FGSM</a> 算法：</p>
<ol>
<li>蓝色的线是标准对抗训练的对抗鲁棒性</li>
<li>绿色的线表示在 $S^-$ 上产生的对抗样本对鲁棒性几乎没有提升。这可以说明不同的 max 方法在 $S^-$ 上会对模型鲁棒性有不同程度的影响。然而，</li>
<li>橙色的线表示，低强度的攻击算法在 $S^+$ 上制作的对抗样本会使鲁棒性退化。</li>
</ol>
<p>图 c 中，内部 max 选择 PGD-10 算法，外部 min 尝试不同的函数。发现对错分类的样本使用不同的 min 方法，对最终鲁棒性的结果影响也很大。</p>
<ol>
<li>蓝色的线是，对传统对抗训练，外部 min 使用交叉熵函数</li>
<li>绿色的线是，对错分类样本添加额外的 KL 散度作为正则化项，鲁棒性有明显的提升</li>
<li>绿色的线是，将同样的 KL 散度作为正则化项添加到正确分类的样本上，鲁棒性也有提升，但不如绿色的线明显。</li>
</ol>
<p>基于以上实验发现，论文考虑了错分类样本对鲁棒性的影响，提出了一个新的防御算法，以一种动态的方式实现对抗训练。主要贡献是：</p>
<ul>
<li>研究了错分类和正确分类的样本对『对抗训练』最终鲁棒性的影响，结果表明，在 min-max 框架下，对错分类样本的处理对模型最终鲁棒性的影响佷大，且 min 方法比 max 方法更为关键。</li>
<li>提出一种正则化的对抗风险，将错误分类的样本做显式区分，作为正则化项添加到损失函数中。</li>
</ul>
<h1 id="MART-算法"><a href="#MART-算法" class="headerlink" title="MART 算法"></a>MART 算法</h1><p>临时通知一周后期末考试，去准备期末考试了，考完了回来填坑。其实这个算法的缺陷显而易见，可以尝试往 GAN 那边走一走。考完了，回来填坑。</p>
<h2 id="前期定义"><a href="#前期定义" class="headerlink" title="前期定义"></a>前期定义</h2><p>对于一个 $K$ 分类问题，给定数据集 $(x_i,y_i)$，深度模型 $h_\theta$，对于每个样本而言，网络的输出如下：</p>
<p>\begin{equation}<br>\begin{aligned}<br>h_\theta(x_i) &amp;= \arg \max p_k(x_i, \theta) \\<br>p_k(x_i, \theta) &amp;= \exp(z_k(x_i,\theta)) / \sum_{j=1}^K \exp(z_j(x_i,\theta))<br>\end{aligned}<br>\end{equation}</p>
<p>其中，$z_k(x_i,\theta)$ 是网络的逻辑输出，<code>softmax</code> 后获得类别标签。对抗风险定义为：一个 batch 中被分类错误的样本数除以 batch 数。对抗样本的制作为：</p>
<p>\begin{equation}<br>\hat{x} = \arg\max \mathbb{I}(h_\theta(x_i) \neq y_i)<br>\end{equation}</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote>
<p>注，原文第二章写了一些0-1损失，后面又说不用这个，所以我没有写0-1损失</p>
</blockquote>
<p>首先将训练样本分为正样本 $S^+_{h\theta}$ 和错样本 $S^-_{h\theta}$，即能被网络正确识别的样本和不能被正确识别的样本。</p>
<ul>
<li>对于 $S^-_{h\theta}$ 而言，添加正则化项，使得网络能稳定的防御错分类对抗样本。因为对抗样本的分类需要更强的分类器和更光滑的决策边界，损失函数定义为 $\mathbb{I}(h_\theta(\hat{x_i}) \neq y_i) + \mathbb{I}(h_\theta(x_i) \neq h_\theta(\hat{x_i}))$，意思是，第一项优化的目标是，使对抗样本被分类正确；第二项优化的目标是，使网络认识原始样本和对抗样本。</li>
<li>对于 $S^+_{h\theta}$ 而言，正则化不会明显提升网络鲁棒性。在这种情况下，已经有 $h_\theta(x_i)=y_i$，因此此时的优化目标是 $\mathbb{I}(h_\theta(x_i) \neq h_\theta(\hat{x}))=\mathbb{I}(h_\theta(\hat{x_i})\neq y_i)$，也就是说，网络将干净样本和对抗样本视为两个类别且对抗样本分类错误的概率。</li>
<li>其中 $\mathbb{I}$ 是指示函数，意思是，错了损失值为1，正确损失值为0。</li>
</ul>
<p>但是这个指示函数难以优化，本文提出 BCE(boosted cross entropy) 损失函数，用于代替 $\mathbb{I}(h(\hat{x} \neq y))$，定义如下：</p>
<p>\begin{equation}<br>\begin{aligned}<br>\text{BCE}(p(\hat{x}, \theta), y_i) &amp;= -\log(p_{y_i}(\hat{x},\theta)) - \log (1-\max_{k\neq y_i}p_k(\hat{x}, \theta))<br>\end{aligned}<br>\end{equation}</p>
<p>第一项是普通的交叉熵损失函数，第二项用于提升模型决策边界的间隙。</p>
<p>使用 $KL$ 散度代替 $\mathbb{I}(h_\theta(x) \neq h_\theta(\hat{x}))$，定义如下：</p>
<p>\begin{equation}<br>\text{KL}(p(x_i,\theta)||p(\hat{x}, \theta))=\sum_{k=1}^K p_k{(x_i,\theta)} \log \frac{p_k(x_i,\theta)}{p_k(\hat{x_i},\theta)}<br>\end{equation}</p>
<p>对于制作对抗样本使用的指示函数 $\mathbb{I}(h_\theta(x_i) \neq y_i)$，通过 $1-p_{y_i}(x_i, \theta)$ 的形式选择对抗样本。因此，内部最大化的损失定义如下，攻击方式选择 PGD。</p>
<p>\begin{equation}<br>\hat{x} = \arg \max \text{CE} (p(x_i, \theta), y_i)<br>\end{equation}</p>
<p>将两中损失结合起来到对抗训练的框架中，最终的损失函数为：</p>
<p>\begin{equation}<br>L = \text{BCE}(p(\hat{x}, \theta), y_i) + \lambda \text{KL} (p(x_i,\theta)||p(\hat{x}, \theta))(1-p_{y_i}(x_i, \theta))<br>\end{equation}</p>
<p>$\lambda$ 参数用于平衡两个损失。</p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>美赛进坑须知</title>
    <url>/2019/01/20/MCM-notice/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是去年做的E题，和别人做了对比，又重新阅读了美赛的<strong>官方说明</strong>。</p>
<p>也包括阅读评委评审意见的收获，整理如下。</p>
<a id="more"></a>
<p>如果对本文有疑问或者想找男朋友，可以联系我，<a href="https://muyuuuu.github.io/about/">点击此处有我联系方式</a>。</p>
<p>2019 Contest changes/updates can be found in below:</p>
<p>MCM/ICM is an all electronic submission!</p>
<p>You are <strong>not required</strong> to mail a print copy of your signed Control Sheet.</p>
<p>We have added 3 hours to the contest start time to allow for teams to download, read, discuss, and choose a problem.</p>
<p>The contest problems will become available precisely at 4:50PM EST on Thursday January 24, 2019 on the following mirror sites:</p>
<ul>
<li><p><a href="http://www.comap-math.com/mcm/index.html" target="_blank" rel="noopener">http://www.comap-math.com/mcm/index.html</a></p>
</li>
<li><p><a href="http://www.mathismore.net/mcm/index.html" target="_blank" rel="noopener">http://www.mathismore.net/mcm/index.html</a></p>
</li>
<li><p><a href="http://www.mathportals.com/mcm/index.html" target="_blank" rel="noopener">http://www.mathportals.com/mcm/index.html</a></p>
</li>
<li><p><a href="http://www.immchallenge.org/mcm/index.html" target="_blank" rel="noopener">http://www.immchallenge.org/mcm/index.html</a></p>
</li>
</ul>
<hr>
<h2 id="In-competition-some-tips"><a href="#In-competition-some-tips" class="headerlink" title="In competition, some tips:"></a>In competition, some tips:</h2><p>Partial solutions are acceptable. There is no passing or failing cut-off score, and numerical scores will not be assigned. The MCM/ICM contest judges are primarily interested in the team’s approach and methods.</p>
<p>The summary is an essential part of your MCM/ICM paper. The judges place considerable weight on the summary, and winning papers are often distinguished from other papers based on the quality of the summary.</p>
<p>Restatement and clarification of the problem: State in your own words what you are going to do.</p>
<p>Explain assumptions and rationale/justification: Emphasize the assumptions that bear on the problem. Clearly list all variables used in your model.</p>
<p>Include your model design and justification for type model used or developed.</p>
<p>Describe model testing and sensitivity analysis, including error analysis, etc.</p>
<p>Discuss the strengths and weaknesses of your model or approach.</p>
<hr>
<h2 id="The-judges-will-evaluate-the-quality-of-your-writing-in-the-Solution-Paper"><a href="#The-judges-will-evaluate-the-quality-of-your-writing-in-the-Solution-Paper" class="headerlink" title="The judges will evaluate the quality of your writing in the Solution Paper:"></a>The judges will evaluate the quality of your writing in the Solution Paper:</h2><ul>
<li>Conciseness and organization are extremely important.</li>
<li>Key statements should present major ideas and results.</li>
<li>Present a clarification or restatement of the problem, as appropriate.</li>
<li>Present a clear exposition of all variables, assumptions, and hypotheses.</li>
<li>Present an analysis of the problem, including the motivation or justification for the model that is used.</li>
<li>Include a design of the model.</li>
<li>Discuss how the model could be tested, including error analysis and stability (conditioning, sensitivity, etc.).</li>
<li>Discuss any apparent strengths or weaknesses in your model or approach.</li>
</ul>
<hr>
<h2 id="About-MCM-competition-template"><a href="#About-MCM-competition-template" class="headerlink" title="About MCM competition template:"></a>About MCM competition template:</h2><p>Papers must be typed in English, with a readable font of at least 12 point type.</p>
<p>The solution must consist entirely of written text, and possibly figures, charts, or other written material only. No non-paper support materials such as computer files or software will be accepted.</p>
<p>The Solution Paper must display the team control number and the page number at the top of every page; for example, use the following page header on each page:</p>
<p>The names of the students, advisor, or institution should NOT appear on any page of the electronic solution. The solution should not contain any identifying information other than the team control number.</p>
<p>Print/Download one copy of the Control Sheet.</p>
<p>Download or copy the team Summary Sheet. (This should be used as the first page of your electronic email submission.</p>
<p>COMAP will accept only a Adobe PDF of your solution. DO NOT include your Control Sheet, programs or software with your email as they will not be used in the judging process. </p>
<p>Limit one solution per email.</p>
<p> The names of the students, advisor, or institution should NOT appear on any page of the electronic solution. Your team’s summary should be included as the first page of your file. Note: The attachment must be less than 17MB.</p>
<hr>
<h2 id="About-MCM-competition-time"><a href="#About-MCM-competition-time" class="headerlink" title="About MCM competition time:"></a>About MCM competition time:</h2><p>Each team is required to submit an electronic copy of its solution paper by email to solutions@comap.com. Any team member or the advisor may submit this email.</p>
<p>Send the signed Control Sheet by email to COMAP:After the signed control sheet is prepared, email it to: forms@comap.com.</p>
<p>In the subject line of your email write: your team’s control number. For example: 1900000.</p>
<hr>
<h2 id="Some-Thinking-About-Reading-UMAP"><a href="#Some-Thinking-About-Reading-UMAP" class="headerlink" title="Some Thinking About Reading UMAP"></a>Some Thinking About Reading UMAP</h2><p>论文中的某些部分可以简写，但是考虑因素要全面。符号说明简明清晰的包含所有要素。摘要写一页，包括使用的方法和对结果的总结,传达模型的意义(有所限制的展示基本的模型和潜在的假设)。包含你的结果，结果做到量化。</p>
<p>有关模型(必须有优缺点)：网络发展的今天，很多参赛队都能在网上搜到差不多的模型进行改进，然后解决问题。但是更希望建立连续(具有凝聚力)的模型，并且在足够的细节上进行描述推导来解释结果之间潜在的联系。</p>
<p>论文简洁有组织。在符号说明中定义所有变量，但是论文中不能定义太多，及解释每个变量的意义甚至单位，以变量的单位保证方程的相等性。官方没说层次分析法遗传算法不好，放开了去使用，但是不要写推导过程，可以提供附件代码。</p>
<p>对于因子、常数、系数，确保有详细的解释说明。记录搜集数据的工作，列出数据缺失而产生的假设和简化问题而做出的假设，以数学方程表达变量之间的关系，使用合理的方法分析变量之间的关系来支持你的结论。</p>
<p>做只与模型相关的假设，包括理由以及如何影响模型。重点是阐述假设如何应用到模型中，甚至做模型假设的灵敏性分析检验假设，模型假设可以啊，但这种假设会对模型的精确行产生多少影响呢？需要灵敏行分析。并进行敏感性分析以解决所做的任何假设，或估计所用相关变量的预期变化。只对最最最重要的变量进行灵敏性分析。</p>
<p>描述模型建立的原因和动机。(数据分析详细的描述如何使用的数据)，如果行业内有相关的制定标准，一定要引用进来。搜寻可靠的数据，并记录数据来源。不希望有广阔的数据来源和精细复杂的模型，只希望看到在模型建立过程中的分析，不强行规定解决问题的方向。</p>
<p>成功的团队提供了解释模拟结果的统计显着性。然而最成功的团队详细解释了他们的模拟过程；一些甚至包括流程图。结果是不重要的，重点是对结果的分析。为了问题而建模，而不是为了建模而建模(最好的论文考虑通过模型而测量指标，而其他论文为了测量指标而建立模型)。</p>
<p>然而，最成功的团队将他们的敏感性分析集中在他们在建模过程中所做的假设上。这提供了敏感性分析和建模过程之间的一致性，并且提高了团队建议的可信度（如果模型结果对所做的假设不敏感）或建议的进一步分析区域。对模型假设的参数的检验，懂得灵敏性分析的目的，为什么做灵敏性分析。</p>
<p>明确设定的相关变量的单位（保证方程两边单位相等），做出的假设要么是为了弥补数据的不足，要么是为了解释相关变量之间的数学关系。引用别人的方法并不可耻(shame)，如果引用请做好标注，会详细的检查<strong>参考文献</strong>。适当的数学技术或方法来分析数学关系并形成建议，写出来的信件包含所有因素，使用简单的英语描述非技术性元素。</p>
<hr>
]]></content>
      <tags>
        <tag>Modeling</tag>
      </tags>
  </entry>
  <entry>
    <title>聚会的说～</title>
    <url>/2018/10/13/MMA-Party-2018/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>建模聚会的说，大概是第三次在这里了，很开心。重要的是这里的风格很自由，很``没大没小”；有很多很多很好的人，很舒服，就酱。</p>
<a id="more"></a>
<p>每次建模聚会都能很巧的赶上我的生日，也不想说，毕竟20岁的人了，猥琐在角落里默默祝福自己，和自己干一杯，突然发现，我还挺能喝。(这次聚会后又又又发现了个跟我同年同月同日生的孩子)。希望在奔三的路中，一切顺心就好。</p>
<p>也许没尽到自己的职责，我更适合当一个员工，告诉我干什么，然后我赶出来，很符合计算机程序员的工作模式：提要求——解决掉。</p>
<p>还看到了学长学姐，在奔向各自的前程中优秀着。我不善于表达但还是要送去祝福，自己最擅长的祝福套路就是：``被岁月温柔以待，在彼此看不见的岁月里熠熠生辉”。</p>
<p>自己还没有一个大三学生的样子，可笑，也许在折腾一会儿也该去考研了。老的真快，真快。</p>
<p>还想说一句：好久不见，近来可好。</p>
<p>两年前的现在：</p>
<p><img data-src="/2018/10/13/MMA-Party-2018/mma-20161.jpg" alt></p>
<p>一年前的现在：</p>
<p><img data-src="/2018/10/13/MMA-Party-2018/mma-20171.jpeg" alt></p>
<p><img data-src="/2018/10/13/MMA-Party-2018/mma-20173.jpeg" alt></p>
<p>现在：</p>
<p>某小畜生不配合，外加忘拍照，只搜集到了这一章，嗯：中间马赛克的是那个小畜生。</p>
<p><img data-src="/2018/10/13/MMA-Party-2018/mma-2018.jpg" alt></p>
<p>补上：</p>
<p><img data-src="/2018/10/13/MMA-Party-2018/mma-20182.jpg" alt></p>
<hr>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测篇：自定义 MMDetection 的 Pipeline</title>
    <url>/2021/05/20/MMdetection-pipeline/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>经过几天连续的开坑和读源代码，对 mmdetection 的配置流程了解的差不多了。考虑一个实例应用，尝试着将 <code>FGSM</code> 攻击算法的制作的对抗样本植入目标检测中，企图增加网络的鲁棒性，也就是一个自定义输出处理 <code>Pipeline</code> 的实际流程。之后会尝试自定义损失函数，支持简单的对抗训练，如 MART 算法等 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p>
<a id="more"></a>
<h1 id="对抗攻击之植入-mmdetection"><a href="#对抗攻击之植入-mmdetection" class="headerlink" title="对抗攻击之植入 mmdetection"></a>对抗攻击之植入 mmdetection</h1><p>众所周知，攻击算法基于原始样本制作一种含有梯度的扰动信息，将扰动信息叠加至原始样本，就得到了对抗样本。因此，对抗样本应该添加在数据处理的 pipeline 中，而不是网络层。首先实现最简单的对抗训练：</p>
<p>\begin{equation}<br>\min_\theta \biggl( \max \Bigl( l \bigl(T_\theta(x’), y_i \bigl) \Bigr) \biggr)<br>\end{equation}</p>
<p>内部的对抗样本 $x’$ 企图最大化模型的分类误差，外部的训练企图最小化对抗样本带来的误差。查看训练数据的 pipeline，我们发现是在最后一步转为 tensor，而攻击算法是在tensor上进行操作的。所以，对抗攻击应该加在最后一步之后或之前。我们查看返回 tensor 的源代码。此部分代码在 <code>mmdet/datasets/pipelines</code> 目录下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, results)</span>:</span></span><br><span class="line">    <span class="string">"""Call function to transform and format common fields in results.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        results (dict): Result dict contains the data to convert.</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        dict: The result dict contains the data that is formatted with \</span></span><br><span class="line"><span class="string">            default bundle.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'img'</span> <span class="keyword">in</span> results:</span><br><span class="line">        img = results[<span class="string">'img'</span>]</span><br><span class="line">        <span class="comment"># add default meta keys</span></span><br><span class="line">        results = self._add_default_meta_keys(results)</span><br><span class="line">        <span class="keyword">if</span> len(img.shape) &lt; <span class="number">3</span>:</span><br><span class="line">            img = np.expand_dims(img, <span class="number">-1</span>)</span><br><span class="line">        img = np.ascontiguousarray(img.transpose(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        results[<span class="string">'img'</span>] = DC(to_tensor(img), stack=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> [<span class="string">'proposals'</span>, <span class="string">'gt_bboxes'</span>, <span class="string">'gt_bboxes_ignore'</span>, <span class="string">'gt_labels'</span>]:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> results:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        results[key] = DC(to_tensor(results[key]))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'gt_masks'</span> <span class="keyword">in</span> results:</span><br><span class="line">        results[<span class="string">'gt_masks'</span>] = DC(results[<span class="string">'gt_masks'</span>], cpu_only=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'gt_semantic_seg'</span> <span class="keyword">in</span> results:</span><br><span class="line">        results[<span class="string">'gt_semantic_seg'</span>] = DC(</span><br><span class="line">            to_tensor(results[<span class="string">'gt_semantic_seg'</span>][<span class="literal">None</span>, ...]), stack=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>
<p>而对抗攻击只关注图像与标签，所以，只关注图像与标签，而这部分一目了然。所以，开始写自己的对抗样本：</p>
<ul>
<li>黑盒攻击，基于 resnet18 制作攻击样本，插入到 pipeline 中</li>
<li>我暂时的想法是只攻击目标区域，所以筛选出目标区域的位置与标签，按照梯度上升的方向制作对抗样本。</li>
</ul>
<h1 id="自定义-backbone"><a href="#自定义-backbone" class="headerlink" title="自定义 backbone"></a>自定义 backbone</h1><p><strong>注意这步不做也行</strong>。可以直接模改原有的 <code>backbone</code>，只是不推荐。而为了方便调试，我们使用自己定义的网络，网络只打印输入观察数据是否修改成功。因此，自定义的网络如下，并放在 <code>mmdet/models/backbones/mybackbone</code>下，</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> ..builder <span class="keyword">import</span> BACKBONES</span><br><span class="line"></span><br><span class="line"><span class="meta">@BACKBONES.register_module()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mynet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(x)</span><br></pre></td></tr></table></figure>
<p>而后为了导入模块，在 <code>mmdet/models/backbones/__init__.py</code> 中添加 <code>from .mybackbone import mynet</code>。为了适配 faster rcnn 的其它参数，我这里的 backbone 直接使用了 ResNet 里面的内容，只是打印了 x，这里是为了方便观察结果。这里需要注意，那些 <code>super</code> 初始化也要改，防止重名，因为不具备普适性，所以这里就不演示了。而后配置文件中指定以下就可以自由使用，我的配置文件是 <code>adv_faster_rcnn.py</code>：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">model = dict(</span><br><span class="line">    ...</span><br><span class="line">    backbone=dict(</span><br><span class="line">        type=<span class="string">'mynet'</span>,</span><br><span class="line">        arg1=xxx,</span><br><span class="line">        arg2=xxx),</span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># 测试用，跑一轮就停</span></span><br><span class="line">runner = dict(type=<span class="string">'EpochBasedRunner'</span>, max_epochs=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>而后执行一下，成功的看到输入被打印了出来。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mmdet.apis <span class="keyword">import</span> init_detector, inference_detector</span><br><span class="line"><span class="comment"># 目标检测配置文件</span></span><br><span class="line">config_file = <span class="string">'mmdetection/configs/faster_rcnn/adv_faster_rcnn.py'</span></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">checkpoint_file = <span class="string">'mmdetection/checkpoints/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置模型</span></span><br><span class="line">model = init_detector(config=config_file,</span><br><span class="line">                      checkpoint=checkpoint_file,</span><br><span class="line">                      device=<span class="string">'cuda:0'</span>)</span><br><span class="line"></span><br><span class="line">img = <span class="string">'a.png'</span></span><br><span class="line"><span class="comment">#  推理实际调用语句</span></span><br><span class="line"><span class="comment"># results = model(return_loss=False, rescale=True, **data)</span></span><br><span class="line">result = inference_detector(model=model, imgs=img)</span><br></pre></td></tr></table></figure>
<h1 id="对抗样本代码思想"><a href="#对抗样本代码思想" class="headerlink" title="对抗样本代码思想"></a>对抗样本代码思想</h1><p>首先在 <code>pipeline</code> 文件夹下创建自己的 <code>my_pipeline</code>，而后定义自己的处理流程，比如我就看看处理的数据都有哪些：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mmdet.datasets <span class="keyword">import</span> PIPELINES</span><br><span class="line"></span><br><span class="line"><span class="meta">@PIPELINES.register_module()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, results)</span>:</span></span><br><span class="line">        print(type(results))</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> results:</span><br><span class="line">            print(key, type(results[key]))</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>
<p>最后在 <code>__init__.py</code> 中导入自己的东西，<code>from .my_pipeline import MyTransform</code>。综上发现，在 <code>DefaultFormatBundle</code> 和 <code>Collect</code> 处理后，数据类型不是我能驾驭的常见数据类型： <code>mmcv.parallel.data_container.DataContainer</code>。</p>
<p>所以选择在 <code>Normalize</code> 后加入对抗攻击，因为常见的攻击算法也都是在标准化之后，此外那里还是 <code>ndarray</code> 等常见类型，我能把握住这些基本的类似那个。<code>Normalize</code> 后的数据类型：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">img_prefix      &lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">seg_prefix</span>      &lt;<span class="title">class</span> '<span class="title">NoneType</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">proposal_file</span>   &lt;<span class="title">class</span> '<span class="title">NoneType</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">bbox_fields</span>     &lt;<span class="title">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">mask_fields</span>     &lt;<span class="title">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">seg_fields</span>      &lt;<span class="title">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">filename</span>        &lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">ori_filename</span>    &lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">img</span>             &lt;<span class="title">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">img_shape</span>       &lt;<span class="title">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">ori_shape</span>       &lt;<span class="title">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">img_fields</span>      &lt;<span class="title">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">gt_bboxes</span>       &lt;<span class="title">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">gt_bboxes_ignore</span>        &lt;<span class="title">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">gt_labels</span>       &lt;<span class="title">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">flip</span>            &lt;<span class="title">class</span> '<span class="title">bool</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">flip_direction</span>  &lt;<span class="title">class</span> '<span class="title">NoneType</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">img_norm_cfg</span>    &lt;<span class="title">class</span> '<span class="title">dict</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>我利用的信息只有 <code>img</code>，<code>gt_labels</code> 和 <code>gt_bboxes</code>。其实我也不知道以上字段是啥，源码和文档的信息很少，所以我只能自己都打印了一下。所以此时的任务就是，按照 <code>gt_bboxes</code>，截取 <code>img</code>，根据 <code>gt_labels</code>，制作对抗样本。但对抗样本返回的是 tensor，所以最后要转回到 numpy，在覆盖原来的数据。而 PGD、CW 等攻击算法过程会很慢，所以选用攻击强度大且快捷的 <code>FGSM</code> 单步算法。</p>
<p>而为了防止对抗样本带来的过大负担，所以添加了两个额外参数 $p_1$ 和 $p_2$。</p>
<ul>
<li>如果概率小于 $p_1$，在目标区域叠加高斯噪音</li>
<li>如果概率在 $p_1$ 到 $p_2$ 之间，在目标区域制作对抗样本</li>
<li>如果概率大于 $p_2$，使用原图，不做任何处理</li>
</ul>
<p>综上，此时的配置文件应该为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">adv_para = dict(mu=<span class="number">0</span>, std=<span class="number">0.1</span>, epsilon=<span class="number">0.1</span>, pro1=<span class="number">0.3</span>, pro2=<span class="number">0.6</span>, adv=<span class="string">'fgsm'</span>)</span><br><span class="line"></span><br><span class="line">train_pipeline = [</span><br><span class="line">    dict(type=<span class="string">'LoadImageFromFile'</span>),</span><br><span class="line">    dict(type=<span class="string">'LoadAnnotations'</span>, with_bbox=<span class="literal">True</span>),</span><br><span class="line">    dict(type=<span class="string">'Resize'</span>, img_scale=(<span class="number">1333</span>, <span class="number">800</span>), keep_ratio=<span class="literal">True</span>),</span><br><span class="line">    dict(type=<span class="string">'RandomFlip'</span>, flip_ratio=<span class="number">0.0001</span>),</span><br><span class="line">    dict(type=<span class="string">'Normalize'</span>, **img_norm_cfg_trian),</span><br><span class="line">    <span class="comment"># 自己的 pipeline</span></span><br><span class="line">    dict(type=<span class="string">'advTransform'</span>, **adv_para),</span><br><span class="line">    dict(type=<span class="string">'Pad'</span>, size_divisor=<span class="number">32</span>),</span><br><span class="line">    dict(type=<span class="string">'DefaultFormatBundle'</span>),</span><br><span class="line">    dict(type=<span class="string">'Collect'</span>, keys=[<span class="string">'img'</span>, <span class="string">'gt_bboxes'</span>, <span class="string">'gt_labels'</span>]),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="开始制作"><a href="#开始制作" class="headerlink" title="开始制作"></a>开始制作</h1><p>为了使代码易于维护和扩展，我尽力使额外添加的程序符合设计模式，对扩展开放，对修改封闭，针对接口编程。</p>
<ul>
<li>在 <code>mmdet/datasets/pipelines/</code> 目录下增加 <code>adv_example</code> pipeline，生成对抗样本。</li>
<li>至于攻击算法，依据设计模式，应使用额外的类来实现。位于 <code>datasets/</code> 目录下，命名为 attack 文件夹。</li>
</ul>
<h2 id="对抗样本-pipeline"><a href="#对抗样本-pipeline" class="headerlink" title="对抗样本 pipeline"></a>对抗样本 pipeline</h2><p>这里有几个点需要注意下：</p>
<ul>
<li>通过获得的 <code>results</code>，图像的维度是：高、宽、通道</li>
<li><code>bboxes</code> 中的信息是 <code>x1,x2,y1,y2</code> </li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mmdet.datasets <span class="keyword">import</span> PIPELINES</span><br><span class="line"><span class="comment"># 导入攻击算法</span></span><br><span class="line"><span class="keyword">from</span> mmdet.datasets <span class="keyword">import</span> attack</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@PIPELINES.register_module()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">advTransform</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">                 mu=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 std=<span class="number">0.1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 epsilon=<span class="number">0.1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 pro1=<span class="number">0.3</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 pro2=<span class="number">0.6</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 adv=<span class="string">'fgsm'</span>)</span>:</span></span><br><span class="line">        <span class="comment"># 高斯噪音的均值和方差</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(mu, int) <span class="keyword">or</span> isinstance(mu, float):</span><br><span class="line">            self.mu = mu</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.mu = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isinstance(mu, int) <span class="keyword">or</span> isinstance(mu, float):</span><br><span class="line">            self.std = std</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.std = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对抗扰动值</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(mu, int) <span class="keyword">or</span> isinstance(mu, float):</span><br><span class="line">            self.epsilon = epsilon</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.epsilon = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 概率 p1 和 p2</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(pro1, float):</span><br><span class="line">            self.pro1 = pro1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.pro1 = <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isinstance(pro2, float):</span><br><span class="line">            self.pro2 = pro2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.pro2 = <span class="number">0.6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用的攻击算法</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(adv, str):</span><br><span class="line">            self.adv = adv</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.adv = <span class="string">'fgsm'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 产生一个随机数</span></span><br><span class="line">        <span class="comment"># 如果位于区间 [0, pro1), 目标区域添加噪音</span></span><br><span class="line">        <span class="comment"># 如果位于区间 [pro1, pro2), 目标区域用 adv 算法攻击</span></span><br><span class="line">        <span class="comment"># 如果区间位于 [pro2, 1) 不做任何操作，返回原图</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0</span> &lt; pro1 &lt; pro2 &lt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        self.pro1 = pro1</span><br><span class="line">        self.pro2 = pro2</span><br><span class="line"></span><br><span class="line">        self.rand_ = random.random()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 复写这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, results)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(len(results['gt_bboxes']))</span></span><br><span class="line">        <span class="comment"># print(len(results['gt_labels']))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回原图</span></span><br><span class="line">        <span class="keyword">if</span> self.rand_ &gt; self.pro2:</span><br><span class="line">            <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 目标区域叠加高斯噪音</span></span><br><span class="line">        <span class="keyword">elif</span> self.rand_ &lt; self.pro1:</span><br><span class="line">            <span class="comment"># 可能有好几个盒子</span></span><br><span class="line">            bboxes = results[<span class="string">'gt_bboxes'</span>]</span><br><span class="line">            img = results[<span class="string">'img'</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> box <span class="keyword">in</span> bboxes:</span><br><span class="line">                box = box.tolist()</span><br><span class="line">                box = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> box]</span><br><span class="line">                x1, y1, x2, y2 = box[<span class="number">0</span>], box[<span class="number">1</span>], box[<span class="number">2</span>], box[<span class="number">3</span>]</span><br><span class="line">                noise = np.random.normal(</span><br><span class="line">                    self.mu, self.std, size=(y2 - y1, x2 - x1, <span class="number">3</span>))</span><br><span class="line">                img[y1:y2, x1:x2] += noise</span><br><span class="line"></span><br><span class="line">            results[<span class="string">'img'</span>] = img</span><br><span class="line">            <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对抗攻击</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># labels = results['ann_info']['labels']</span></span><br><span class="line">            <span class="comment"># bboxes = results['ann_info']['bboxes']</span></span><br><span class="line">            labels = results[<span class="string">'gt_labels'</span>]</span><br><span class="line">            bboxes = results[<span class="string">'gt_bboxes'</span>]</span><br><span class="line">            img = results[<span class="string">'img'</span>]</span><br><span class="line">            <span class="comment"># 针对接口编程，只需要给攻击算法提供 图像、位置、标签和扰动值</span></span><br><span class="line">            img = attack.fgsm.fgsm_attack(img, bboxes, labels, self.epsilon)</span><br><span class="line">            results[<span class="string">'img'</span>] = img</span><br><span class="line">            <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>
<h2 id="攻击算法"><a href="#攻击算法" class="headerlink" title="攻击算法"></a>攻击算法</h2><p>攻击算法位于 <code>datasets/attack/</code> 文件夹下。此外，为了导入包，需要添加 <code>__init__.py</code>，并按以下格式添加内容：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .fgsm <span class="keyword">import</span> fgsm_attack</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">'fgsm_attack'</span>]</span><br></pre></td></tr></table></figure>
<p>同样这里也有一些需要注意的地方：</p>
<ul>
<li>针对接口编程，只需要给攻击算法提供图像、目标区域、标签和扰动值，至于内部自己如何实现，不重要</li>
<li>攻击算法返回的就是图像，内部如何实现，不重要，减少两个模块的耦合</li>
</ul>
<p><code>fgsm.py</code> 的内容为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fgsm_attack</span><span class="params">(img, bboxes, labels, epsilon)</span>:</span></span><br><span class="line">    <span class="comment"># data_grad 转 tensor</span></span><br><span class="line">    <span class="keyword">import</span> torch</span><br><span class="line">    <span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line">    model = torch.hub.load(</span><br><span class="line">        <span class="string">'pytorch/vision:v0.9.0'</span>, <span class="string">'resnet18'</span>, pretrained=<span class="literal">True</span>)</span><br><span class="line">    model.eval()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 增加 batch 维度，然后 channel first</span></span><br><span class="line">    tmp_img = torch.from_numpy(img).clone().unsqueeze(dim=<span class="number">0</span>).transpose(</span><br><span class="line">        <span class="number">1</span>, <span class="number">3</span>).transpose(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tenor 转 numpy</span></span><br><span class="line">    <span class="keyword">for</span> box, target <span class="keyword">in</span> zip(bboxes, labels):</span><br><span class="line">        <span class="comment"># numpy 2 list</span></span><br><span class="line">        box = box.tolist()</span><br><span class="line">        box = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> box]</span><br><span class="line">        <span class="comment"># print(box, target)</span></span><br><span class="line">        x1, y1, x2, y2 = box[<span class="number">0</span>], box[<span class="number">1</span>], box[<span class="number">2</span>], box[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># deep copy</span></span><br><span class="line">        input_ = tmp_img[:, :, y1:y2, x1:x2].clone()</span><br><span class="line">        input_.requires_grad = <span class="literal">True</span></span><br><span class="line">        label = torch.tensor([int(target)])</span><br><span class="line"></span><br><span class="line">        output = model(input_)</span><br><span class="line"></span><br><span class="line">        loss = F.nll_loss(output, label)</span><br><span class="line">        <span class="comment"># model.zero_grad()</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        sign_data = input_.grad.data.sign()</span><br><span class="line">        <span class="comment"># 脱离计算图</span></span><br><span class="line">        perturbed_image = input_.detach() + epsilon * sign_data</span><br><span class="line">        <span class="comment"># 指定区域生成对抗样本</span></span><br><span class="line">        tmp_img[:, :, y1:y2, x1:x2] += perturbed_image</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除 batch 维度</span></span><br><span class="line">    tmp_img = tmp_img.squeeze().detach().cpu().numpy().transpose(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp_img</span><br></pre></td></tr></table></figure>
<h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><ul>
<li>也许你看过一些对抗攻击的算法，知道最后的对抗样本应该 <code>torch.clamp</code> 到 $[0,1]$。可那是论文里用的玩具数据集才会做的事情，那些数据集知道均值和方差。现实世界的真实数据，又怎么会知道均值和方差，怎么去标准化到 $[0,1]$ 之间呢？</li>
<li>我遇到了一个佷头疼的 bug，是多线程导致的反向传播异常，大概错误信息是：terminate called after throwing an instance of ‘c10::Error what():  CUDA error: initialization error。网上翻阅了无数 bug issue，才找到一篇有用的，也不知道那些 github 仓库的作者咋想的，问题还没解决就 close 掉，冲业绩还是图仓库 bug 少？这里把每个 GPU 的线程数量设为 0 就可以了 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 。而至于写多线程下的梯度反向传播，我貌似还没这个本事。<strong>但是，我服务器上没发现有这个 bug，应该是版本问题。</strong></li>
</ul>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>官方的程序如何使用，我的就怎么使用，毕竟是直接 <code>fork</code> 过来的，从安装一步步来就行。此外，为了方便使用，我把配置文件放到了 <code>configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py</code> 文件中，可以进去参观下。</p>
<p><a href="https://github.com/muyuuuu/mmdetection" target="_blank" rel="noopener">https://github.com/muyuuuu/mmdetection</a></p>
<p>此外，我在 colab 也创建了一份能用的，在不会用就真没救了。</p>
<p><a href="https://github.com/muyuuuu/open-mmlab-colab/blob/main/Detection/mmdet_adv.ipynb" target="_blank" rel="noopener">https://github.com/muyuuuu/open-mmlab-colab/blob/main/Detection/mmdet_adv.ipynb</a></p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">https://openreview.net/forum?id=rklOg6EFwS</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">https://github.com/pytorch/pytorch/issues/1355#issuecomment-299094286</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>MPI基础，以 mpi4py 为例（操作系统番外篇）</title>
    <url>/2021/02/23/MPI-basics/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以python为例，多线程由于GIL的存在，所以有multiprocessing来缓解；但它不能面向多个计算节点编程，所以MPI来了。当面向多个计算节点编程时，程序的各部分之间通过来回传递消息的方式通信。要使得消息传递方式可移植，就需要采用标准的消息传递库。这就促成消息传递接口(Message Passing Interface, MPI)的面世，MPI是一种被广泛采用的消息传递标准，所以MPI并不是一种语言。</p>
<a id="more"></a>
<p>在程序中，不同的进程需要相互的数据交换，特别是在科学计算中，需要大规模的计算与数据交换，集群可以很好解决单节点计算力不足的问题，但在集群中大规模的数据交换是很耗费时间的，因此需要一种在多节点的情况下能快速进行数据交流的标准，这就是MPI。所以MPI是一组用于多节点数据通信的标准，而非一种语言或者接口。具体的使用方法需要依赖它的具体实现(mpich or openmpi等)。对于 python 的 MPI 标准而言，可以使用 <code>mpi4py</code> 这个库。实现了点到点通信和集群通信等功能。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>博客简明的介绍 <code>mpi4py</code> 的使用，本博客翻译自瑞典皇家理工PDC高性能计算中心发布的文章，已经过原作者同意。原文写的很好，英文水平够建议阅读原文。</p>
<ol>
<li><a href="https://www.kth.se/blogs/pdc/2019/08/parallel-programming-in-python-mpi4py-part-1/" target="_blank" rel="noopener">https://www.kth.se/blogs/pdc/2019/08/parallel-programming-in-python-mpi4py-part-1/</a></li>
<li><a href="https://www.kth.se/blogs/pdc/2019/11/parallel-programming-in-python-mpi4py-part-2/" target="_blank" rel="noopener">https://www.kth.se/blogs/pdc/2019/11/parallel-programming-in-python-mpi4py-part-2/</a></li>
</ol>
<p>需要注意的是：</p>
<ul>
<li>里面所有的代码我都执行过，没问题</li>
<li>并非原封不动的翻译。为了更好的理解和适配国内的阅读风格，做了些许修改。并加了点自己的东西，照搬原文不是我的习惯。</li>
<li>MPI 中没有主进程的概念，结合代码中变量的作用，将原文的 <code>master process</code>在这里翻译为<strong>管理者进程</strong>或领导者进程。任何进程都可以作为管理者进程，所以这里不能翻译为主进程。另外一点是，会与 multiprocess 中的主进程有歧义。</li>
</ul>
<h1 id="环境与运行方式"><a href="#环境与运行方式" class="headerlink" title="环境与运行方式"></a>环境与运行方式</h1><p>我在windows下安装最新版的<code>mpi4py</code>，但是包导入不进来，关于 windows 对代码很不友好这一点我领略很多次了。我也懒的细查是什么原因，反正我有linux操作系统。所以，本文的代码都是在 <code>Arch</code> 这款系统下跑通的。</p>
<p>运行一般MPI程序的方法是：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">mpirun -n <span class="number">4</span> python3 filename.py // <span class="number">4</span> 表示启动 <span class="number">4</span> 个进程</span><br></pre></td></tr></table></figure></p>
<p>因linux的mpi4py禁止系统创建大量进程，否则会报错。因此在项目根目录下创建<code>hostfile</code>文件，写入<code>localhost slots=25</code>，表示最大允许创建的进程数量是25。创建20个进程时，程序执行方式：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">mpirun --hostfile hostfile -np <span class="number">20</span> python filename.py</span><br></pre></td></tr></table></figure>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>在使用 MPI 并行编程时，需要一种叫『通信器』的东西，它是由多个能相互通信的进程组成的一个群组。为了确定进程是群组中的哪一个，每个进程都会被分配唯一的ID号，称为 rank。所以，能通过 rank 得知群组中有多少进程。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"></span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">rank = comm.Get_rank()</span><br><span class="line">size = comm.Get_size()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Hello from process &#123;&#125; out of &#123;&#125;'</span>.format(rank, size))</span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>comm</code>变量是定义的默认『通信器』，能通过 <code>Get_rank</code> 方法取回通信器中每个进程的 rank ，通过 <code>Get_size</code> 方法获取通信器内进程的数量。启动四个进程，运行的输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello from process 3 out of 4</span><br><span class="line">Hello from process 0 out of 4</span><br><span class="line">Hello from process 1 out of 4</span><br><span class="line">Hello from process 2 out of 4</span><br></pre></td></tr></table></figure>
<h1 id="简单类型通信"><a href="#简单类型通信" class="headerlink" title="简单类型通信"></a>简单类型通信</h1><h2 id="点到点通信"><a href="#点到点通信" class="headerlink" title="点到点通信"></a>点到点通信</h2><p>点到点通信时，<code>mpi4py</code> 提供了和MPI中类似的 <code>send</code> 和 <code>recv</code> 方法，用于传递简单的python对象。一个典型的例子，管理者进程和其他工作进程的通信，管理者进程发送一个python的字典到工作者进程中。通信模型与代码如下：</p>
<p><img data-src="https://s3.ax1x.com/2021/02/23/yLnavV.png" alt></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"></span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">rank = comm.Get_rank()</span><br><span class="line">size = comm.Get_size()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主进程</span></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2.0</span>&#125;</span><br><span class="line">    <span class="comment"># 主进程发送字典到所有的子进程</span></span><br><span class="line">    print(<span class="string">'Process &#123;&#125; sent data:'</span>.format(rank), data)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">        comm.send(data, dest=i, tag=i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程收到主进程的数据</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    data = comm.recv(source=<span class="number">0</span>, tag=rank)</span><br><span class="line">    print(<span class="string">'Process &#123;&#125; received data:'</span>.format(rank), data)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process 0 sent data: &#123;&apos;x&apos;: 1, &apos;y&apos;: 2.0&#125;</span><br><span class="line">Process 0 sent data: &#123;&apos;x&apos;: 1, &apos;y&apos;: 2.0&#125;</span><br><span class="line">Process 0 sent data: &#123;&apos;x&apos;: 1, &apos;y&apos;: 2.0&#125;</span><br><span class="line">Process 1 received data: &#123;&apos;x&apos;: 1, &apos;y&apos;: 2.0&#125;</span><br><span class="line">Process 2 received data: &#123;&apos;x&apos;: 1, &apos;y&apos;: 2.0&#125;</span><br><span class="line">Process 3 received data: &#123;&apos;x&apos;: 1, &apos;y&apos;: 2.0&#125;</span><br></pre></td></tr></table></figure>
<p>dest表示发送的目标进程的 rank，tag表示消息的 ID，source 表示源头进程的 rank，tag表示信息的 ID。两个 ID 对不上，消息则无法接收。通过 rank 号来设置主进程，在这里，指定的 rank=0 的就是『管理者进程』。然后通过一个 for 循环给其他进程发送数据。当通信的内容很多时，可以使用 tag 来区分不同的消息。</p>
<p>然而上述代码的通信方式是<a href="https://muyuuuu.github.io/2021/02/18/simple-multithread/">阻塞</a>通信，意思是，通信不结束，代码无法继续往下执行。记录下时间，大概 1.44秒。</p>
<p>阻塞的行为在并行编程中不可取，所以我们要使用非阻塞通信的方法，<code>isend</code>和<code>irecv</code>。会立即返回请求对象，并使用<code>wait</code>方法来管理这些进程完成通信。大约 0.34 秒。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2.0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">        req = comm.isend(data, dest=i, tag=i)</span><br><span class="line">        req.wait()</span><br><span class="line">        print(<span class="string">'Process &#123;&#125; sent data:'</span>.format(rank), data)</span><br><span class="line"></span><br><span class="line">        tmp = comm.irecv(source=i, tag=i)</span><br><span class="line">        time_ += tmp.wait()</span><br><span class="line">    print(time_)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    since = time.time()</span><br><span class="line">    req = comm.irecv(source=<span class="number">0</span>, tag=rank)</span><br><span class="line">    data = req.wait()</span><br><span class="line">    end = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将消耗的时间发送回去</span></span><br><span class="line">    comm.send(end-since, dest=<span class="number">0</span>, tag=rank)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Process &#123;&#125; received data:'</span>.format(rank), data)</span><br></pre></td></tr></table></figure>
<h2 id="集体通信"><a href="#集体通信" class="headerlink" title="集体通信"></a>集体通信</h2><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p><img data-src="https://s3.ax1x.com/2021/02/23/yLulxx.png" alt></p>
<p>广播通信的意思是，一个节点给其他所有的节点发送信息。以发送 numpy 数组为例，root 表示广播节点的 rank 号。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">rank = comm.Get_rank()</span><br><span class="line">size = comm.Get_size()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = np.arange(<span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    data = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">msg = comm.bcast(data, root=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'Process &#123;&#125; broadcast data:'</span>.format(rank), msg)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Process &#123;&#125; received data:'</span>.format(rank), msg)</span><br></pre></td></tr></table></figure>
<p>输出为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process 0 broadcast data: [0. 1. 2. 3.]</span><br><span class="line">Process 1 received data: [0. 1. 2. 3.]</span><br><span class="line">Process 2 received data: [0. 1. 2. 3.]</span><br><span class="line">Process 3 received data: [0. 1. 2. 3.]</span><br></pre></td></tr></table></figure></p>
<h3 id="scatter"><a href="#scatter" class="headerlink" title="scatter"></a>scatter</h3><p>在面对大规模任务时，尤其是面对巨大的数组、列表数据，可以先对数据进行划分，分成不同的子任务。将子任务交给各个工作者进程去执行，这时候可以使用<code>scatter</code>方法，但分配的数量不能超过处理器的数量。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">rank = comm.Get_rank()</span><br><span class="line">nprocs = comm.Get_size()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = np.arange(<span class="number">17.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ave 除数，res 余数</span></span><br><span class="line">    ave, res = divmod(data.size, nprocs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 余数是多出来的，加到前面 防止划分不均</span></span><br><span class="line">    counts = [ave + <span class="number">1</span> <span class="keyword">if</span> p &lt; res <span class="keyword">else</span> ave <span class="keyword">for</span> p <span class="keyword">in</span> range(nprocs)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 子任务的起始点与结束点 个数求和 表示下标</span></span><br><span class="line">    starts = [sum(counts[:p]) <span class="keyword">for</span> p <span class="keyword">in</span> range(nprocs)]</span><br><span class="line">    ends = [sum(counts[:p+<span class="number">1</span>]) <span class="keyword">for</span> p <span class="keyword">in</span> range(nprocs)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 切片</span></span><br><span class="line">    data = [data[starts[p]:ends[p]] <span class="keyword">for</span> p <span class="keyword">in</span> range(nprocs)]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    data = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">data = comm.scatter(data, root=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Process &#123;&#125; has data:'</span>.format(rank), data)</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process 0 has data: [0. 1. 2. 3. 4.]</span><br><span class="line">Process 1 has data: [5. 6. 7. 8.]</span><br><span class="line">Process 3 has data: [13. 14. 15. 16.]</span><br><span class="line">Process 2 has data: [ 9. 10. 11. 12.]</span><br></pre></td></tr></table></figure>
<h3 id="gather"><a href="#gather" class="headerlink" title="gather"></a>gather</h3><p>与 <code>scatter</code> 相反的是 <code>gather</code>，用于收集每个进程中指定的变量，这个方法收集每个进程的元素会汇集到一个列表中。一个<a href="https://muyuuuu.github.io/2021/02/18/simple-multithread/">实例</a>，两者同时使用来计算 $\pi$。</p>
<p><img data-src="https://s3.ax1x.com/2021/02/23/yLK2nK.png" alt></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">t0 = time.time()</span><br><span class="line"></span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">rank = comm.Get_rank()</span><br><span class="line">nprocs = comm.Get_size()</span><br><span class="line"></span><br><span class="line">nsteps = <span class="number">10000000</span></span><br><span class="line">dx = <span class="number">1.0</span> / nsteps</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    ave, res = divmod(nsteps, nprocs)</span><br><span class="line">    counts = [ave + <span class="number">1</span> <span class="keyword">if</span> p &lt; res <span class="keyword">else</span> ave <span class="keyword">for</span> p <span class="keyword">in</span> range(nprocs)]</span><br><span class="line"></span><br><span class="line">    starts = [sum(counts[:p]) <span class="keyword">for</span> p <span class="keyword">in</span> range(nprocs)]</span><br><span class="line">    ends = [sum(counts[:p+<span class="number">1</span>]) <span class="keyword">for</span> p <span class="keyword">in</span> range(nprocs)]</span><br><span class="line"> </span><br><span class="line">    data = [(starts[p], ends[p]) <span class="keyword">for</span> p <span class="keyword">in</span> range(nprocs)]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    data = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">data = comm.scatter(data, root=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">partial_pi = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(data[<span class="number">0</span>], data[<span class="number">1</span>]):</span><br><span class="line">    x = (i + <span class="number">0.5</span>) * dx</span><br><span class="line">    partial_pi += <span class="number">4.0</span> / (<span class="number">1.0</span> + x * x)</span><br><span class="line">partial_pi *= dx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 收集每个进程的 partial_pi 到 0号进程中</span></span><br><span class="line">partial_pi = comm.gather(partial_pi, root=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'pi computed in &#123;:.3f&#125; sec'</span>.format(time.time() - t0))</span><br><span class="line">    print(<span class="string">'error is &#123;&#125;'</span>.format(abs(sum(partial_pi) - math.pi)))</span><br></pre></td></tr></table></figure>
<p>输出为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pi computed in 0.546 sec</span><br><span class="line">error is 1.234568003383174e-13</span><br></pre></td></tr></table></figure></p>
<p>同样，也可以直接使用 <code>reduce</code> 收集结果，在收集的时候就能进行求和等操作。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 收集每个进程的 partial_pi</span></span><br><span class="line">partial_pi = comm.reduce(partial_pi, root=<span class="number">0</span>, op=MPI.SUM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'pi computed in &#123;:.3f&#125; sec'</span>.format(time.time() - t0))</span><br><span class="line">    print(<span class="string">'error is &#123;&#125;'</span>.format(abs(partial_pi) - math.pi))</span><br></pre></td></tr></table></figure>
<h1 id="类缓冲区对象通信"><a href="#类缓冲区对象通信" class="headerlink" title="类缓冲区对象通信"></a>类缓冲区对象通信</h1><p><code>mpi4py</code> 提供了一些方法来直接发送和接收类缓冲区对象。优点是通信快，缺点是需要程序员要显式的声明所需分配的内存空间。在接收数据之前就需要显式的分配内存空间，且发送数据的大小不能超过缓冲区。同样需要注意的是，类缓冲区对象在物理地址上应该是连续的。好巧不巧，numpy 恰好符合这一点。所以在科学计算中，numpy 数组常用于类缓冲区对象。所以接下来使用用 numpy 来演示类缓冲区对象的发送与接受。</p>
<p>与之前python普通对象通信不同的是，这里的类缓冲区对象的方法首字母都是大写的。</p>
<h2 id="点到点通信-1"><a href="#点到点通信-1" class="headerlink" title="点到点通信"></a>点到点通信</h2><p>与之前不同的时，接收数据的进程需要提前初始化缓冲区，也就是在 recv 被调用之前。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">rank = comm.Get_rank()</span><br><span class="line">size = comm.Get_size()</span><br><span class="line">num = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># master process</span></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = np.arange(float(num))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">        comm.Send(data, dest=i, tag=i)</span><br><span class="line">        print(<span class="string">'Process &#123;&#125; sent data:'</span>.format(rank), data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># worker processes</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    data = np.zeros(num)</span><br><span class="line">    <span class="comment"># 接收</span></span><br><span class="line">    comm.Recv(data, source=<span class="number">0</span>, tag=rank)</span><br><span class="line">    print(<span class="string">'Process &#123;&#125; received data:'</span>.format(rank), data)</span><br></pre></td></tr></table></figure>
<p>data作为第一个参数，被写入接收的数据。输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process 0 sent data: [0. 1. 2. 3.]</span><br><span class="line">Process 0 sent data: [0. 1. 2. 3.]</span><br><span class="line">Process 2 received data: [0. 1. 2. 3.]</span><br><span class="line">Process 0 sent data: [0. 1. 2. 3.]</span><br><span class="line">Process 3 received data: [0. 1. 2. 3.]</span><br><span class="line">Process 1 received data: [0. 1. 2. 3.]</span><br></pre></td></tr></table></figure>
<p>再使用 <code>Send</code> 和 <code>Recv</code> 的时候需要注意的是发送数据大小和接收的数据大小应该匹配。</p>
<ul>
<li>如果发送的数据大小大于接收区的缓存大小，将会报错；</li>
<li>缓冲区的数据大小大于发送区的数据大小是没关系的。</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = np.arange(<span class="number">4.</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">        comm.Send(data, dest=i, tag=i)</span><br><span class="line">        print(<span class="string">'Process &#123;&#125; sent data:'</span>.format(rank), data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    data = np.zeros(<span class="number">6</span>)</span><br><span class="line">    comm.Recv(data, source=<span class="number">0</span>, tag=rank)</span><br><span class="line">    print(<span class="string">'Process &#123;&#125; has data:'</span>.format(rank), data)</span><br></pre></td></tr></table></figure>
<p>上述程序中，发送4个大小的数据，缓冲区用6个大小的数据块去接收，只有前4个数据被覆盖了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process 0 sent data: [0. 1. 2. 3.]</span><br><span class="line">Process 0 sent data: [0. 1. 2. 3.]</span><br><span class="line">Process 0 sent data: [0. 1. 2. 3.]</span><br><span class="line">Process 1 has data: [0. 1. 2. 3. 0. 0.]</span><br><span class="line">Process 2 has data: [0. 1. 2. 3. 0. 0.]</span><br><span class="line">Process 3 has data: [0. 1. 2. 3. 0. 0.]</span><br></pre></td></tr></table></figure>
<p>同样，也有对应的阻塞版本和非阻塞版本。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = np.arange(<span class="number">4.</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">        req = comm.Isend(data, dest=i, tag=i)</span><br><span class="line">        req.Wait()</span><br><span class="line">        print(<span class="string">'Process &#123;&#125; sent data:'</span>.format(rank), data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    data = np.zeros(<span class="number">4</span>)</span><br><span class="line">    req = comm.Irecv(data, source=<span class="number">0</span>, tag=rank)</span><br><span class="line">    req.wait()</span><br><span class="line">    print(<span class="string">'Process &#123;&#125; received data:'</span>.format(rank), data)</span><br></pre></td></tr></table></figure>
<h2 id="集体通信-1"><a href="#集体通信-1" class="headerlink" title="集体通信"></a>集体通信</h2><p><del>其实这里的内容基本和之前的类似了。</del></p>
<h3 id="广播-1"><a href="#广播-1" class="headerlink" title="广播"></a>广播</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">rank = comm.Get_rank()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = np.arange(<span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    data = np.zeros(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">comm.Bcast(data, root=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Process &#123;&#125; has data:'</span>.format(rank), data)</span><br></pre></td></tr></table></figure>
<p>输出是：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Process <span class="number">0</span> has data: [<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span>]</span><br><span class="line">Process <span class="number">1</span> has data: [<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span>]</span><br><span class="line">Process <span class="number">3</span> has data: [<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span>]</span><br><span class="line">Process <span class="number">2</span> has data: [<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span>]</span><br></pre></td></tr></table></figure>
<h3 id="Scatter"><a href="#Scatter" class="headerlink" title="Scatter"></a>Scatter</h3><p>另一种集群通信是 Scatter，将一个大型的数组进行切片。之前演示过 scatter，但是 Scatter 不像 scatter 一样容易使用，因为它需要提前知道数组的大小。问题是，实际中往往无法提前获知数组的大小，因此任务的划分也成了问题。更推荐去使用 Scatterv，这是 Scatter 的向量版本，提供了很多灵活的方法来分配数组。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">rank = comm.Get_rank()</span><br><span class="line">nprocs = comm.Get_size()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    sendbuf = np.arange(<span class="number">15.0</span>)</span><br><span class="line"></span><br><span class="line">    ave, res = divmod(sendbuf.size, nprocs)</span><br><span class="line">    <span class="comment"># 每个进程的元素数量</span></span><br><span class="line">    count = [ave + <span class="number">1</span> <span class="keyword">if</span> p &lt; res <span class="keyword">else</span> ave <span class="keyword">for</span> p <span class="keyword">in</span> range(nprocs)]</span><br><span class="line">    count = np.array(count)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个进程的起始位置</span></span><br><span class="line">    displ = [sum(count[:p]) <span class="keyword">for</span> p <span class="keyword">in</span> range(nprocs)]</span><br><span class="line">    displ = np.array(displ)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sendbuf = <span class="literal">None</span></span><br><span class="line">    count = np.zeros(nprocs, dtype=np.int)</span><br><span class="line">    displ = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">comm.Bcast(count, root=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">recvbuf = np.zeros(count[rank])</span><br><span class="line"></span><br><span class="line">comm.Scatterv([sendbuf, count, displ, MPI.DOUBLE], recvbuf, root=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'After Scatterv, process &#123;&#125; has data:'</span>.format(rank), recvbuf)</span><br></pre></td></tr></table></figure>
<p>通过<code>[sendbuf, count, displ, MPI.DOUBLE]</code>来指定类缓冲区对象，count表示发送给每个进程的数量，displ表示子任务的起始切片。所以这里是对 sendbuf 进行切分，并保存到 recvbuf 中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">After Scatterv, process 0 has data: [0. 1. 2. 3.]</span><br><span class="line">After Scatterv, process 1 has data: [4. 5. 6. 7.]</span><br><span class="line">After Scatterv, process 2 has data: [8. 9. 10. 11.]</span><br><span class="line">After Scatterv, process 3 has data: [12. 13. 14.]</span><br></pre></td></tr></table></figure>
<h3 id="Gatherv"><a href="#Gatherv" class="headerlink" title="Gatherv"></a>Gatherv</h3><p>Gatherv 的行为和 Scatterv 相反，所以，在使用 Gatherv 的时候，需要指定接收缓存的形式为：<code>[recvbuf2, count, displ, MPI.DOUBLE]</code>。管理者进程中，sendbuf2会被收集到一个更大的recvbuf2中。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sendbuf2 = recvbuf</span><br><span class="line">recvbuf2 = np.zeros(sum(count))</span><br><span class="line"><span class="comment"># sendbuf2 按照指定的规则汇总</span></span><br><span class="line">comm.Gatherv(sendbuf2, [recvbuf2, count, displ, MPI.DOUBLE], root=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> comm.Get_rank() == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'After Gatherv, process 0 has data:'</span>, recvbuf2)</span><br></pre></td></tr></table></figure>
<p>输出的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">After Gatherv, process 0 has data: </span><br><span class="line">[ 0.  1.  2.  3.  4.  5.  6.  7.  8.  9. 10. 11. 12. 13. 14.]</span><br></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>在另一个角度而言，reduce 可以对每个进程所收集的数据进行求和，也就是计算每个进程 recvbuf 的和，并汇总到管理者进程中。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">partial_sum = np.zeros(<span class="number">1</span>)</span><br><span class="line">partial_sum[<span class="number">0</span>] = sum(recvbuf)</span><br><span class="line">print(<span class="string">'Partial sum on process &#123;&#125; is:'</span>.format(rank), partial_sum[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">total_sum = np.zeros(<span class="number">1</span>)</span><br><span class="line">comm.Reduce(partial_sum, total_sum, op=MPI.SUM, root=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> comm.Get_rank() == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'After Reduce, total sum on process 0 is:'</span>, total_sum[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Partial sum on process 0 is: 6.0</span><br><span class="line">Partial sum on process 1 is: 22.0</span><br><span class="line">Partial sum on process 2 is: 38.0</span><br><span class="line">Partial sum on process 3 is: 39.0</span><br><span class="line">After Reduce, total sum on process 0 is: 105.0</span><br></pre></td></tr></table></figure>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>这里的实例是一百万维的向量加法串行计算和并行计算的性能对比。<del>因为Scatterv只支持一维向量的通信，矩阵乘法还得从二维转一维，我懒的费尽了。</del></p>
<h2 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h2><p>大概 0.35 秒左右。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">2</span>)</span><br><span class="line">size = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">x1 = np.random.random(size)</span><br><span class="line">x2 = np.random.random(size)</span><br><span class="line">result = np.zeros(size, dtype=float)</span><br><span class="line"></span><br><span class="line">since = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">    result[i] = x1[i] + x2[i]</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line">print(end - since)</span><br></pre></td></tr></table></figure>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>我开了 5 个进程，大概 0.083 秒左右。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">rank = comm.Get_rank()</span><br><span class="line">nprocs = comm.Get_size()</span><br><span class="line"></span><br><span class="line">size = <span class="number">1000000</span></span><br><span class="line">x1 = np.random.random(size)</span><br><span class="line">x2 = np.random.random(size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">    ave, res = divmod(size, nprocs)</span><br><span class="line"></span><br><span class="line">    count = [ave + <span class="number">1</span> <span class="keyword">if</span> p &lt; res <span class="keyword">else</span> ave <span class="keyword">for</span> p <span class="keyword">in</span> range(nprocs)]</span><br><span class="line">    count = np.array(count)</span><br><span class="line"></span><br><span class="line">    displ = [sum(count[:p]) <span class="keyword">for</span> p <span class="keyword">in</span> range(nprocs)]</span><br><span class="line">    displ = np.array(displ)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sendbuf = <span class="literal">None</span></span><br><span class="line">    count = np.zeros(nprocs, dtype=np.int)</span><br><span class="line">    displ = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">t0 = time.time()</span><br><span class="line">comm.Bcast(count, root=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">recvbuf1 = np.zeros(count[rank])</span><br><span class="line">recvbuf2 = np.zeros(count[rank])</span><br><span class="line"></span><br><span class="line">comm.Scatterv([x1, count, displ, MPI.DOUBLE], recvbuf1, root=<span class="number">0</span>)</span><br><span class="line">comm.Scatterv([x2, count, displ, MPI.DOUBLE], recvbuf2, root=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'After Scatterv, process &#123;&#125; has data:'</span>.format(rank), recvbuf1)</span><br><span class="line">print(<span class="string">'After Scatterv, process &#123;&#125; has data:'</span>.format(rank), recvbuf2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(recvbuf1.shape[<span class="number">0</span>]):</span><br><span class="line">    recvbuf1[i] += recvbuf2[i]</span><br><span class="line"></span><br><span class="line">sendbuf2 = recvbuf1</span><br><span class="line">recvbuf2 = np.zeros(sum(count))</span><br><span class="line">comm.Gatherv(sendbuf2, [recvbuf2, count, displ, MPI.DOUBLE], root=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> comm.Get_rank() == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'pi computed in &#123;:.3f&#125; sec'</span>.format(time.time() - t0))</span><br><span class="line">    print(<span class="string">'After Gatherv, process 0 has data:'</span>, recvbuf2)</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>并行计算的坑大概是开完了，这里写点结语吧。我大一上学期寒假的时候，有个叫 CCF 的组织来我校讲过一次并行计算。我那会儿还小，对一切未知事物都感到好奇。那会他们讲的我也实在听不懂，毕竟没学过多少计算机课程，还去问老师有没有什么相关资料，那会儿可真是傻啊，这有啥可问的。</p>
<p>时至上学期的『高性能计算实验课』，又再次接触到了这个东西。今时不同往日，进程、线程、系统、编程这些概念我都学过了，所以入门并行计算也是很一蹴而就的事情，就相当于把课程内容and所学的操作系统之类的知识整理一下。</p>
<p>掏出之前用 MPI 写过的一点并行计算的任务，加速比还是很明显的。<del>代码太烂就不放了</del><br><img data-src="https://s3.ax1x.com/2021/02/23/yL8vNT.png" alt><br><img data-src="https://s3.ax1x.com/2021/02/23/yLGSCF.png" alt></p>
]]></content>
      <tags>
        <tag>Computer</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测篇：MMDetection 推理使用与详细踩坑记录</title>
    <url>/2021/05/11/MMDetection-use/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近喜欢上了听音乐，B 站关注了个 UP 主叫『<strong>咻咻满</strong>』，长得好看，戏腔唱『<strong>青花瓷</strong>』入坑了，也听了其它的『星辰大海』和『白月光和朱砂痣』，都挺好听。以后得关注点女 UP 了，看着多可爱，生活又不是只有代码。卧艹不对说回正题。</p>
<p>MMDetection 是一个基于 PyTorch 的目标检测开源工具箱 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，支持了众多主流的和最新的检测算法，例如 Faster R-CNN，Mask R-CNN，RetinaNet 等，官网也给出了详细的教程。既然如此，生命不息，开坑不止。前前后后被各种事情打断，大概花了一周搞懂了如何使用 <code>MMdetection</code> 去做检测的任务。本文收录：</p>
<ul>
<li>安装</li>
<li>修改配置文件</li>
<li>调用模型与训练好的参数，进行推理</li>
<li>自定义训练</li>
<li>数据处理流程</li>
</ul>
<p>注意，本文更多像是记录学习过程，这也是我第一次用这个工具，遇到问题一步一步的 debug 与记录，并不是直接的教程。且，本文程序大多能直接复制运行，需要对应到自己的路径。我希望读者看完本文后具有解决问题的能力，而不只是会解决问题。</p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>MMDetection 检测框架包括 mmdetection 和 mmcv，两者是不可分割的。首先安装 mmcv，掏出官方文档 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，发现有两个版本可供安装，支持 <code>CUDA</code> 操作的 mmcv-full 和不支持 <code>CUDA</code> 的 mmcv，而图片处理显然需要 <code>GPU</code>。所以知道了要安装的是 mmcv-full，之后就是确定安装版本。</p>
<p>首先查看自己的 <code>CUDA</code> 和 <code>pytorch</code> 版本，然后查阅官方提供的表格，找到对应的安装命令。综上，我本地服务器的安装指令就是（我现在写代码都默认 Linux 系统了，本教程不知道适不适合 windows）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pip install mmcv-full -f https://download.openmmlab.com/mmcv/dist/cu92/torch1<span class="number">.7</span><span class="number">.0</span>/index.html</span><br></pre></td></tr></table></figure>
<p>而后安装 mmdetection，继续掏出官方文档 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>，按着步骤一步一步来：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/open-mmlab/mmdetection.git</span><br><span class="line">cd mmdetection</span><br><span class="line">pip install -r requirements/build.txt</span><br><span class="line">pip install -v -e .</span><br></pre></td></tr></table></figure>
<p>也就是安装完成后，当前目录会保留一个 <code>mmdetection</code> 的文件夹，一些模型的配置文件都在里面，不要删除这个文件夹。在安装完成后，执行一段代码查看是否安装成功</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mmdet.apis <span class="keyword">import</span> init_detector, inference_detector</span><br></pre></td></tr></table></figure>
<h1 id="简单推理"><a href="#简单推理" class="headerlink" title="简单推理"></a>简单推理</h1><p>在网上查阅相关用法时，发现绝大多数教程<strong>已经过时</strong>，软件迭代重构、接口更新很正常。即使某一天本文被骂陈旧过时，我也不会感觉到任何意外。接口问题多查阅官方文档，其余问题可以多用谷歌搜索。但官方文档 <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> 写的实在是烂，甚至连返回类型都没写，是 tensor，还是 list。不仅没写类型，输出是什么也没写，是得分，是窗口还是类别，一个字都不肯多说，<strong>以上结论仅限博客发布的日期</strong>。所以只能自己一个一个打印了，然后自己分析了下，结果的形式是多个列表，因为有多个目标。每个列表的形式是盒子 <code>xmin, ymin, xmax, ymax</code> 以及得分。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mmdet.apis <span class="keyword">import</span> init_detector, inference_detector</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标检测配置文件</span></span><br><span class="line">config_file = <span class="string">'mmdetection/configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py'</span></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">checkpoint_file = <span class="string">'mmdetection/checkpoints/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置模型</span></span><br><span class="line">model = init_detector(config=config_file,</span><br><span class="line">                      checkpoint=checkpoint_file,</span><br><span class="line">                      device=<span class="string">'cuda:0'</span>)</span><br><span class="line"></span><br><span class="line">img = <span class="string">'woman-3377839_1920.jpg'</span></span><br><span class="line"><span class="comment">#  推理实际调用语句</span></span><br><span class="line"><span class="comment"># results = model(return_loss=False, rescale=True, **data)</span></span><br><span class="line">result = inference_detector(model=model, imgs=img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>在我打印 result 后，发现了一个震惊的消息，只有盒子、概率，没有类别，也就时说代码只能预测当前目标在哪，目标的概率，但不能预测目标是什么 <sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>，没有类别输出。来看一下官方的回答。我当时属实没看懂，数据集有类别信息？既然有了类别信息还推理干啥…</p>
<p><img data-src="https://z3.ax1x.com/2021/05/13/gBkChn.png" alt></p>
<p>没办法接着去翻 github，自己提了个问 <sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>。才知道 <code>result</code> 的长度就是类别长度，而 <code>print(model.CLASSES)</code> 可以打印类别。比如 <code>model.ClASSES</code> 的长度是 80，那么 <code>result</code> 的长度也就是 80，<code>result[0]</code> 就对应 <code>model.CLASSES</code> 的第一个类别，表示第一个类别的盒子、概率。这样一切就解释通了。</p>
<ul>
<li>如果一个图片里只有一个目标，那么 <code>result</code> 类别索引对应的元素中，只有一组数据。</li>
<li>如果一个图片里有多个目标，那么 <code>result</code> 类别索引对应的元素中，就有多组数据。</li>
</ul>
<p>因为我的服务器没有 GUI，而官方画图程序需要调用 matplotlib 和 tkiner，所以无法显示图片，只能读取结果信息，自己用 PIL 画一下了。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw</span><br><span class="line"><span class="comment"># 打开原图</span></span><br><span class="line">img = Image.open(<span class="string">'Hippopx.jpg'</span>).convert(<span class="string">'RGB'</span>)</span><br><span class="line"><span class="comment"># 画出目标框，因为一个类别可能对应多个目标</span></span><br><span class="line"><span class="keyword">for</span> rec <span class="keyword">in</span> result[<span class="number">0</span>]:</span><br><span class="line">    x, y, w, h = rec[<span class="number">0</span>], rec[<span class="number">1</span>], rec[<span class="number">2</span>], rec[<span class="number">3</span>]</span><br><span class="line">    draw = ImageDraw.Draw(img)</span><br><span class="line">    draw.rectangle((x, y, w, h), width=<span class="number">2</span>, outline=<span class="string">'#41fc59'</span>)</span><br><span class="line"><span class="comment"># 保存结果图片</span></span><br><span class="line">img.save(<span class="string">'result.png'</span>)</span><br></pre></td></tr></table></figure>
<p>一个类对应一个目标：<img data-src="https://z3.ax1x.com/2021/05/13/gBksu8.jpg" alt> 一个类有多个目标：<img data-src="https://z3.ax1x.com/2021/05/13/gBAUqU.jpg" alt></p>
<h1 id="自定义推理"><a href="#自定义推理" class="headerlink" title="自定义推理"></a>自定义推理</h1><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>将数据的软链接挂到 <code>mmdetection</code> 文件夹下，目录结构如下。 <code>ln -s minidata /mmdetection/data/</code>，创建软链时需要注意，使用绝对路径。因为之后会沿着软链访问数据，相对路径可能找不到数据。此时的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mmdetection</span><br><span class="line">├── mmdet</span><br><span class="line">├── tools</span><br><span class="line">├── configs</span><br><span class="line">├── data</span><br><span class="line">│   ├── minidata</span><br><span class="line">│   │   ├── annotations/</span><br><span class="line">│   │   ├── test_data/</span><br></pre></td></tr></table></figure>
<p><code>annotations</code> 是对图片信息的说明，<code>test_data</code> 就是要推理的图片。其实这里的结构也不太重要，重点是后面的配置文件要把路径给指对了。而后下载预训练的模型，对目标数据集进行推理。模型都可以在官方文档的 <code>Model Zoo</code> 中下载到。</p>
<h3 id="修改配置文件-不建议"><a href="#修改配置文件-不建议" class="headerlink" title="修改配置文件(不建议)"></a>修改配置文件(不建议)</h3><p>因为源代码中指定的配置文件是 <code>configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py</code>，而打开这个文件，我们会发现以下几行信息：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">_base_ = [</span><br><span class="line">    <span class="string">'../_base_/models/faster_rcnn_r50_fpn.py'</span>,</span><br><span class="line">    <span class="string">'../_base_/datasets/coco_detection.py'</span>,</span><br><span class="line">    <span class="string">'../_base_/schedules/schedule_1x.py'</span>, <span class="string">'../_base_/default_runtime.py'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>也就是，配置文件是继承自 <code>_base_</code> 文件夹下面的模型、数据、学习率、运行时设置这四个文件。所以要按照自己想要的方式运行，就需要修改这四个配置文件。</p>
<p>比如以数据为例，因为目标数据集位于 <code>data/mini_data</code> 下，所以要修改配置文件，使配置文件找到正确的数据路径。打开 <code>configs/_base_/datasets/coco_detection.py</code>，修改 <code>data</code> 字典中的 <code>test</code>。<strong>类别数量修改同理，在models文件夹下。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">test=dict(</span><br><span class="line">    type=dataset_type,</span><br><span class="line">    <span class="comment"># 找到自己的 json</span></span><br><span class="line">    ann_file=data_root + <span class="string">'annotations/openbrand_train.json'</span>,</span><br><span class="line">    <span class="comment"># 找到自己的图片路径</span></span><br><span class="line">    img_prefix=data_root + <span class="string">'test_data/'</span>,</span><br><span class="line">    pipeline=test_pipeline)</span><br></pre></td></tr></table></figure>
<ul>
<li>而后在 <code>mmdetection/mmdet/core/evaluation/classes_names</code> 中的 <code>coco_classes</code> 函数中修改类别名称信息。（这个我没找到如何在配置文件中修改，只能在源文件中修改了）</li>
<li>也在<code>mmdetection/mmdet/datasets/coco.py</code> 中的 <code>class CocoDataset(CustomDataset):</code> 类中的 <code>CLASSES</code> 字段修改为自己需要的类别信息。</li>
</ul>
<h2 id="开始推理"><a href="#开始推理" class="headerlink" title="开始推理"></a>开始推理</h2><p>而最后执行推理的代码如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python tools/test.py \</span><br><span class="line">    <span class="variable">$&#123;CONFIG_FILE&#125;</span> \</span><br><span class="line">    <span class="variable">$&#123;CHECKPOINT_FILE&#125;</span> \</span><br><span class="line">    [--out <span class="variable">$&#123;RESULT_FILE&#125;</span>] \</span><br><span class="line">    [--<span class="built_in">eval</span> <span class="variable">$&#123;EVAL_METRICS&#125;</span>] \</span><br></pre></td></tr></table></figure>
<ul>
<li><code>RESULT_FILE</code> 结果序列化输出到指定文件中，必须是 <code>.pkl</code> 文件</li>
<li><code>EVAL_METRICS</code> 结果要评估的项目，结果会打印到屏幕，对于 COCO 数据接而言，有 <code>proposal, bbox, segm</code> 等。但是需要注意的是，faster rcnn 没有 segm，mask rcnn 才有。</li>
</ul>
<p>比如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mmdetection 文件夹下执行</span></span><br><span class="line">python tools/test.py \</span><br><span class="line">    <span class="comment"># 配置文件</span></span><br><span class="line">    configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \</span><br><span class="line">    <span class="comment"># 模型</span></span><br><span class="line">    checkpoints/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth \</span><br><span class="line">    <span class="comment"># 输出</span></span><br><span class="line">    --out /mmnet/out.pkl \</span><br><span class="line">    --<span class="built_in">eval</span> bbox proposal \</span><br><span class="line">    --show-score-thr 0.5 <span class="comment"># 概率低于 0.5 的预测结果都要被删除</span></span><br></pre></td></tr></table></figure>
<p>打开 <code>test.py</code>，一步步追踪源码，发现推理时调用的东西和 <code>inference_detector</code> 接口调用的一样，所以推理阶段不输出类别，类别需要自己从 <code>model.CLASSES</code> 中获取。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    result = model(return_loss=<span class="literal">False</span>, rescale=<span class="literal">True</span>, **data)</span><br></pre></td></tr></table></figure>
<p>因为最后输出的结果保存到了 <code>out.pkl</code> 文件中，所以给一份精简代码，关于如何读取序列化数据。<del>其实跟 json 的读取挺像的。</del></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">data = <span class="literal">None</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'out.pkl'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = pickle.load(f)</span><br><span class="line">process(data)</span><br></pre></td></tr></table></figure>
<p>推理结束后可以删除数据的软链，以备下次使用。删除软件时需要注意，可能一不小心删除原始数据。正确的删除软链方式是 <code>rm minidata</code>，注意不要加斜杠。</p>
<p>理论上应该是按着上面描述的那样执行，但其实我这里报错了：<code>KeyError: &quot;CocoDataset: &#39;categories&#39;&quot;</code>。定位到报错代码，发现是因为使用 <code>pycocotools</code> 读取 json 文件时，没有读到分类这个属性。<strong>所以这里需要注意的是，推理要用的 json，自己要添加一下类别的信息。</strong></p>
<h2 id="通过配置文件推理"><a href="#通过配置文件推理" class="headerlink" title="通过配置文件推理"></a>通过配置文件推理</h2><p>当我本能的以为又要修改源代码时，我意识到一个问题。以任何学过『设计模式』而言的人来说，初衷绝对不是让用户去修改源代码，每次修改来修改去，程序到最后可能都没法用了。而是应该通过添加额外配置文件，来达到用户想要的目的。<strong>对修改封闭，对扩展开放。</strong>所以以上修改我又还原了，决定自己写脚本进行推理。</p>
<h3 id="自定义脚本推理"><a href="#自定义脚本推理" class="headerlink" title="自定义脚本推理"></a>自定义脚本推理</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> mmdet.apis <span class="keyword">import</span> init_detector, inference_detector</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pycocotools.coco <span class="keyword">import</span> COCO</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交要求</span></span><br><span class="line"><span class="comment"># [&#123;</span></span><br><span class="line"><span class="comment">#     "image_id": int,</span></span><br><span class="line"><span class="comment">#     "category_id": int,</span></span><br><span class="line"><span class="comment">#     "bbox": [x_min,y_min,width,height],</span></span><br><span class="line"><span class="comment">#     "score": float,</span></span><br><span class="line"><span class="comment"># &#125;]</span></span><br><span class="line"></span><br><span class="line">anno_path = <span class="string">'test.json'</span></span><br><span class="line">coco = COCO(anno_path)</span><br><span class="line">ids = list(coco.imgs.keys())</span><br><span class="line"></span><br><span class="line">filename_id = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文件名与对应的 ID</span></span><br><span class="line"><span class="comment"># 如 &#123;'000000.jpg': 12&#125;</span></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> tqdm(range(len(ids))):</span><br><span class="line">    img_id = ids[idx]</span><br><span class="line">    img_ids = coco.getImgIds(imgIds=img_id)</span><br><span class="line">    image = coco.loadImgs(img_ids)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> image:</span><br><span class="line">        filename_id[i[<span class="string">'file_name'</span>]] = i[<span class="string">'id'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标检测配置文件</span></span><br><span class="line">config_file = <span class="string">'mmnet/mmdetection/configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py'</span></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">checkpoint_file = <span class="string">'mmnet/mmdetection/checkpoints/faster_rcnn_r50_fpn_1x.pth'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置模型</span></span><br><span class="line">model = init_detector(config=config_file,</span><br><span class="line">                      checkpoint=checkpoint_file,</span><br><span class="line">                      device=<span class="string">'cuda:0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要推理的图片的路径</span></span><br><span class="line">root = <span class="string">'val_data/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储结果，并生成 json</span></span><br><span class="line">results = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始推理</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> tqdm(os.listdir(root)):</span><br><span class="line">    result = inference_detector(model=model, imgs=root + file)</span><br><span class="line">    <span class="keyword">for</span> cate, items <span class="keyword">in</span> enumerate(result, <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 同一类别的有很多结果</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            item = item.tolist()</span><br><span class="line">            x, y, w, h, s = item[<span class="number">0</span>], item[<span class="number">1</span>], item[<span class="number">2</span>], item[<span class="number">3</span>], item[<span class="number">4</span>]</span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            d[<span class="string">'image_id'</span>] = filename_id[file]</span><br><span class="line">            d[<span class="string">'category_id'</span>] = cate</span><br><span class="line">            d[<span class="string">'bbox'</span>] = [x, y, w, h]</span><br><span class="line">            d[<span class="string">'score'</span>] = s</span><br><span class="line">            results.append(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'result.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(results, f, indent=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h3 id="配置文件推理"><a href="#配置文件推理" class="headerlink" title="配置文件推理"></a>配置文件推理</h3><p>之前说过，配置文件继承自以下四个文件：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">_base_ = [</span><br><span class="line">    <span class="string">'../_base_/models/faster_rcnn_r50_fpn.py'</span>,</span><br><span class="line">    <span class="string">'../_base_/datasets/coco_detection.py'</span>,</span><br><span class="line">    <span class="string">'../_base_/schedules/schedule_1x.py'</span>, <span class="string">'../_base_/default_runtime.py'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>所以我们自己定义一个配置文件，称为 <code>mynet.py</code>，位于 <code>mmdetection/configs/faster_rcnn/</code> 文件夹下，把以上四个文件的内容全部拷贝到 <code>mynet.py</code> 中，并修改自己需要改的地方即可。<code>mynet.py</code> 文件如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">_base_ = [</span><br><span class="line">    <span class="string">'../_base_/models/faster_rcnn_r50_fpn.py'</span>,</span><br><span class="line">    <span class="string">'../_base_/datasets/coco_detection.py'</span>,</span><br><span class="line">    <span class="string">'../_base_/schedules/schedule_1x.py'</span>, <span class="string">'../_base_/default_runtime.py'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># model settings</span></span><br><span class="line">model = dict(</span><br><span class="line">    type=<span class="string">'FasterRCNN'</span>,</span><br><span class="line">    pretrained=<span class="string">'torchvision://resnet50'</span>,</span><br><span class="line">    backbone=dict(</span><br><span class="line">        type=<span class="string">'ResNet'</span>,</span><br><span class="line">        depth=<span class="number">50</span>,</span><br><span class="line">        num_stages=<span class="number">4</span>,</span><br><span class="line">        out_indices=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        frozen_stages=<span class="number">1</span>,</span><br><span class="line">        norm_cfg=dict(type=<span class="string">'BN'</span>, requires_grad=<span class="literal">True</span>),</span><br><span class="line">        norm_eval=<span class="literal">True</span>,</span><br><span class="line">        style=<span class="string">'pytorch'</span>),</span><br><span class="line">    neck=dict(</span><br><span class="line">        type=<span class="string">'FPN'</span>,</span><br><span class="line">        in_channels=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>],</span><br><span class="line">        out_channels=<span class="number">256</span>,</span><br><span class="line">        num_outs=<span class="number">5</span>),</span><br><span class="line">    rpn_head=dict(</span><br><span class="line">        type=<span class="string">'RPNHead'</span>,</span><br><span class="line">        in_channels=<span class="number">256</span>,</span><br><span class="line">        feat_channels=<span class="number">256</span>,</span><br><span class="line">        anchor_generator=dict(</span><br><span class="line">            type=<span class="string">'AnchorGenerator'</span>,</span><br><span class="line">            scales=[<span class="number">8</span>],</span><br><span class="line">            ratios=[<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>],</span><br><span class="line">            strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>]),</span><br><span class="line">        bbox_coder=dict(</span><br><span class="line">            type=<span class="string">'DeltaXYWHBBoxCoder'</span>,</span><br><span class="line">            target_means=[<span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>, <span class="number">.0</span>],</span><br><span class="line">            target_stds=[<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>]),</span><br><span class="line">        loss_cls=dict(</span><br><span class="line">            type=<span class="string">'CrossEntropyLoss'</span>, use_sigmoid=<span class="literal">True</span>, loss_weight=<span class="number">1.0</span>),</span><br><span class="line">        loss_bbox=dict(type=<span class="string">'L1Loss'</span>, loss_weight=<span class="number">1.0</span>)),</span><br><span class="line">    roi_head=dict(</span><br><span class="line">        type=<span class="string">'StandardRoIHead'</span>,</span><br><span class="line">        bbox_roi_extractor=dict(</span><br><span class="line">            type=<span class="string">'SingleRoIExtractor'</span>,</span><br><span class="line">            roi_layer=dict(type=<span class="string">'RoIAlign'</span>, output_size=<span class="number">7</span>, sampling_ratio=<span class="number">0</span>),</span><br><span class="line">            out_channels=<span class="number">256</span>,</span><br><span class="line">            featmap_strides=[<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>]),</span><br><span class="line">        bbox_head=dict(</span><br><span class="line">            type=<span class="string">'Shared2FCBBoxHead'</span>,</span><br><span class="line">            in_channels=<span class="number">256</span>,</span><br><span class="line">            fc_out_channels=<span class="number">1024</span>,</span><br><span class="line">            roi_feat_size=<span class="number">7</span>,</span><br><span class="line">            <span class="comment"># 修改类别</span></span><br><span class="line">            num_classes=<span class="number">515</span>,</span><br><span class="line">            bbox_coder=dict(</span><br><span class="line">                type=<span class="string">'DeltaXYWHBBoxCoder'</span>,</span><br><span class="line">                target_means=[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">                target_stds=[<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>]),</span><br><span class="line">            reg_class_agnostic=<span class="literal">False</span>,</span><br><span class="line">            loss_cls=dict(</span><br><span class="line">                type=<span class="string">'CrossEntropyLoss'</span>, use_sigmoid=<span class="literal">False</span>, loss_weight=<span class="number">1.0</span>),</span><br><span class="line">            loss_bbox=dict(type=<span class="string">'L1Loss'</span>, loss_weight=<span class="number">1.0</span>))),</span><br><span class="line">    <span class="comment"># model training and testing settings</span></span><br><span class="line">    train_cfg=dict(</span><br><span class="line">        rpn=dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.7</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.3</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.3</span>,</span><br><span class="line">                match_low_quality=<span class="literal">True</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">256</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.5</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">False</span>),</span><br><span class="line">            allowed_border=<span class="number">-1</span>,</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>),</span><br><span class="line">        rpn_proposal=dict(</span><br><span class="line">            nms_pre=<span class="number">2000</span>,</span><br><span class="line">            max_per_img=<span class="number">1000</span>,</span><br><span class="line">            nms=dict(type=<span class="string">'nms'</span>, iou_threshold=<span class="number">0.7</span>),</span><br><span class="line">            min_bbox_size=<span class="number">0</span>),</span><br><span class="line">        rcnn=dict(</span><br><span class="line">            assigner=dict(</span><br><span class="line">                type=<span class="string">'MaxIoUAssigner'</span>,</span><br><span class="line">                pos_iou_thr=<span class="number">0.5</span>,</span><br><span class="line">                neg_iou_thr=<span class="number">0.5</span>,</span><br><span class="line">                min_pos_iou=<span class="number">0.5</span>,</span><br><span class="line">                match_low_quality=<span class="literal">False</span>,</span><br><span class="line">                ignore_iof_thr=<span class="number">-1</span>),</span><br><span class="line">            sampler=dict(</span><br><span class="line">                type=<span class="string">'RandomSampler'</span>,</span><br><span class="line">                num=<span class="number">512</span>,</span><br><span class="line">                pos_fraction=<span class="number">0.25</span>,</span><br><span class="line">                neg_pos_ub=<span class="number">-1</span>,</span><br><span class="line">                add_gt_as_proposals=<span class="literal">True</span>),</span><br><span class="line">            pos_weight=<span class="number">-1</span>,</span><br><span class="line">            debug=<span class="literal">False</span>)),</span><br><span class="line">    test_cfg=dict(</span><br><span class="line">        rpn=dict(</span><br><span class="line">            nms_pre=<span class="number">1000</span>,</span><br><span class="line">            max_per_img=<span class="number">1000</span>,</span><br><span class="line">            nms=dict(type=<span class="string">'nms'</span>, iou_threshold=<span class="number">0.7</span>),</span><br><span class="line">            min_bbox_size=<span class="number">0</span>),</span><br><span class="line">        rcnn=dict(</span><br><span class="line">            score_thr=<span class="number">0.05</span>,</span><br><span class="line">            nms=dict(type=<span class="string">'nms'</span>, iou_threshold=<span class="number">0.3</span>),</span><br><span class="line">            max_per_img=<span class="number">100</span>)</span><br><span class="line">        <span class="comment"># soft-nms is also supported for rcnn testing</span></span><br><span class="line">        <span class="comment"># e.g., nms=dict(type='soft_nms', iou_threshold=0.5, min_score=0.05)</span></span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># dataset settings</span></span><br><span class="line">dataset_type = <span class="string">'CocoDataset'</span></span><br><span class="line">data_root = <span class="string">'mmnet/mmdetection/data/ljw/'</span></span><br><span class="line">img_norm_cfg = dict(</span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>], std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>], to_rgb=<span class="literal">True</span>)</span><br><span class="line">train_pipeline = [</span><br><span class="line">    dict(type=<span class="string">'LoadImageFromFile'</span>),</span><br><span class="line">    dict(type=<span class="string">'LoadAnnotations'</span>, with_bbox=<span class="literal">True</span>),</span><br><span class="line">    dict(type=<span class="string">'Resize'</span>, img_scale=(<span class="number">1333</span>, <span class="number">800</span>), keep_ratio=<span class="literal">True</span>),</span><br><span class="line">    dict(type=<span class="string">'RandomFlip'</span>, flip_ratio=<span class="number">0.5</span>),</span><br><span class="line">    dict(type=<span class="string">'Normalize'</span>, **img_norm_cfg),</span><br><span class="line">    dict(type=<span class="string">'Pad'</span>, size_divisor=<span class="number">32</span>),</span><br><span class="line">    dict(type=<span class="string">'DefaultFormatBundle'</span>),</span><br><span class="line">    dict(type=<span class="string">'Collect'</span>, keys=[<span class="string">'img'</span>, <span class="string">'gt_bboxes'</span>, <span class="string">'gt_labels'</span>]),</span><br><span class="line">]</span><br><span class="line">test_pipeline = [</span><br><span class="line">    dict(type=<span class="string">'LoadImageFromFile'</span>),</span><br><span class="line">    dict(</span><br><span class="line">        type=<span class="string">'MultiScaleFlipAug'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        flip=<span class="literal">False</span>,</span><br><span class="line">        transforms=[</span><br><span class="line">            dict(type=<span class="string">'Resize'</span>, keep_ratio=<span class="literal">True</span>),</span><br><span class="line">            dict(type=<span class="string">'RandomFlip'</span>),</span><br><span class="line">            dict(type=<span class="string">'Normalize'</span>, **img_norm_cfg),</span><br><span class="line">            dict(type=<span class="string">'Pad'</span>, size_divisor=<span class="number">32</span>),</span><br><span class="line">            dict(type=<span class="string">'ImageToTensor'</span>, keys=[<span class="string">'img'</span>]),</span><br><span class="line">            dict(type=<span class="string">'Collect'</span>, keys=[<span class="string">'img'</span>]),</span><br><span class="line">        ])</span><br><span class="line">]</span><br><span class="line">data = dict(</span><br><span class="line">    samples_per_gpu=<span class="number">2</span>,</span><br><span class="line">    workers_per_gpu=<span class="number">2</span>,</span><br><span class="line">    train=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_train2017.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'train2017/'</span>,</span><br><span class="line">        pipeline=train_pipeline),</span><br><span class="line">    val=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'annotations/instances_val2017.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'val2017/'</span>,</span><br><span class="line">        pipeline=test_pipeline),</span><br><span class="line">    test=dict(</span><br><span class="line">        type=dataset_type,</span><br><span class="line">        ann_file=data_root + <span class="string">'test.json'</span>,</span><br><span class="line">        img_prefix=data_root + <span class="string">'val_data/'</span>,</span><br><span class="line">        pipeline=test_pipeline))</span><br><span class="line">evaluation = dict(interval=<span class="number">1</span>, metric=<span class="string">'bbox'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># optimizer</span></span><br><span class="line">optimizer = dict(type=<span class="string">'SGD'</span>, lr=<span class="number">0.02</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.0001</span>)</span><br><span class="line">optimizer_config = dict(grad_clip=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># learning policy</span></span><br><span class="line">lr_config = dict(</span><br><span class="line">    policy=<span class="string">'step'</span>,</span><br><span class="line">    warmup=<span class="string">'linear'</span>,</span><br><span class="line">    warmup_iters=<span class="number">500</span>,</span><br><span class="line">    warmup_ratio=<span class="number">0.001</span>,</span><br><span class="line">    step=[<span class="number">8</span>, <span class="number">11</span>])</span><br><span class="line">runner = dict(type=<span class="string">'EpochBasedRunner'</span>, max_epochs=<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p>最终，<code>python tools/test.py configs/faster_rcnn/mynet.py ......</code> 就可以运行自己的配置文件，完成推理。尽量避免了破坏原有的代码结构。如果想加速执行，就需要多显卡，而 <code>mmdetection</code> 对这方面支持的很好：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">bash tools/dist_test.sh \</span><br><span class="line">    configs/faster_rcnn/my_faster_rcnn.py \</span><br><span class="line">    checkpoints/faster_rcnn_r50_fpn_1x.pth \</span><br><span class="line">    <span class="comment"># 4 个 GPU</span></span><br><span class="line">    <span class="number">4</span> \</span><br><span class="line">    --format-only \</span><br><span class="line">    <span class="comment"># 输出推理得到的 json 文件</span></span><br><span class="line">    --options <span class="string">"jsonfile_prefix=results6"</span></span><br></pre></td></tr></table></figure>
<h1 id="推理程序"><a href="#推理程序" class="headerlink" title="推理程序"></a>推理程序</h1><p>然后，我把一些简单的程序传到 <code>colab</code> 了，可以<a href="https://github.com/muyuuuu/open-mmlab-colab" target="_blank" rel="noopener">打开</a>去实际执行一下，虽然也有一些分类的任务，但思想是一样的。</p>
<h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><h2 id="Finetune"><a href="#Finetune" class="headerlink" title="Finetune"></a>Finetune</h2><p>这个恐怕是最简单但也是最常用的一种方案，和前文一样，也是基于配置文件、命令行启动的方式进行训练。修改类别同前文。同样以 Faster RCNN 为例，先写好自己的配置文件，执行方式为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python tools/train.py \</span><br><span class="line">    $&#123;CONFIG_FILE&#125; \</span><br><span class="line">    [optional arguments]</span><br></pre></td></tr></table></figure>
<p>optional arguments 是可选参数，这里需要加上模型的 log 输出文件目录和预加载模型的地址：</p>
<ul>
<li><code>--work-dir work_dirs/</code>，将日志、模型输出到 <code>work_dirs</code> 文件夹下</li>
<li><code>--load-from model.pth</code>，只加载模型参数，从第 0 个 epoch 开始训练，但是我试了一下，这个参数不太行</li>
<li><code>--resume-from model.pth</code>，加载模型参数与优化器状态，继承上次的 epoch，通常用于恢复意外中断的训练过程</li>
</ul>
<p>当然如果想在多个 GPU 上训练也是可以的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash ./tools/dist_train.sh \</span><br><span class="line">    <span class="variable">$&#123;CONFIG_FILE&#125;</span> \</span><br><span class="line">    <span class="variable">$&#123;GPU_NUM&#125;</span> \</span><br><span class="line">    [optional arguments]</span><br></pre></td></tr></table></figure>
<h2 id="配置文件训练"><a href="#配置文件训练" class="headerlink" title="配置文件训练"></a>配置文件训练</h2><p>官方文档给出了两种修改配置的方案 <sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>：</p>
<ul>
<li>一种是通过 <code>python tools/train.py</code> 时添加 <code>--cfg-options</code> 参数，例如 <code>--cfg-options model.backbone.norm_eval=False</code> 会将模型的 BN 层调为运行时 <sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> 状态。但是这样参数会很多，且很容易出错，个人不建议这么修改。</li>
<li>第二种方案就是自定义配置文件，并继承 <code>_base_</code>，具体操作可以见上文。模型、数据、学习率等都可以轻松设置。官网也给出了 Mask RCNN 的具体配置文件与解释 <sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>。因为官方支持可以只在配置文件中写入修改部分，不修改的部分可以不必声明。而在子文件中修改配置文件时，如果重新定义了自己的变量，一定记得传入，否则默认还是原来的配置。如下：</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新的修改</span></span><br><span class="line">test_pipeline = [</span><br><span class="line">    dict(type=<span class="string">'LoadImageFromFile'</span>),</span><br><span class="line">    dict(</span><br><span class="line">        type=<span class="string">'MultiScaleFlipAug'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        flip=<span class="literal">False</span>,</span><br><span class="line">        transforms=[</span><br><span class="line">            dict(type=<span class="string">'Resize'</span>, keep_ratio=<span class="literal">True</span>),</span><br><span class="line">            dict(type=<span class="string">'RandomFlip'</span>),</span><br><span class="line">            dict(type=<span class="string">'Normalize'</span>, **img_norm_cfg),</span><br><span class="line">            dict(type=<span class="string">'Pad'</span>, size_divisor=<span class="number">32</span>),</span><br><span class="line">            dict(type=<span class="string">'ImageToTensor'</span>, keys=[<span class="string">'img'</span>]),</span><br><span class="line">            dict(type=<span class="string">'Collect'</span>, keys=[<span class="string">'img'</span>]),</span><br><span class="line">        ])</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 传入自己的修改，其它不用写，用默认的</span></span><br><span class="line">data = dict(</span><br><span class="line">    test=dict(pipeline=test_pipeline))</span><br></pre></td></tr></table></figure>
<h1 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h1><p>这个在程序中的字段是 <code>pipeline</code>，也就是数据处理的一个管道。来看默认配置文件中的内容：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">img_norm_cfg = dict(</span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>], std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>], to_rgb=<span class="literal">True</span>)</span><br><span class="line">train_pipeline = [</span><br><span class="line">    <span class="comment"># 从文件加载图片</span></span><br><span class="line">    dict(type=<span class="string">'LoadImageFromFile'</span>),</span><br><span class="line">    <span class="comment"># 加载 boxes，boxes_ignore，label 等信息</span></span><br><span class="line">    dict(type=<span class="string">'LoadAnnotations'</span>, with_bbox=<span class="literal">True</span>),</span><br><span class="line">    <span class="comment"># 重新定义图像大小、bbox 等区域的大小也会变换</span></span><br><span class="line">    dict(type=<span class="string">'Resize'</span>, img_scale=(<span class="number">1333</span>, <span class="number">800</span>), keep_ratio=<span class="literal">True</span>),</span><br><span class="line">    <span class="comment"># 随机翻转，bbox 等内容也会变化</span></span><br><span class="line">    dict(type=<span class="string">'RandomFlip'</span>, flip_ratio=<span class="number">0.5</span>),</span><br><span class="line">    <span class="comment"># 数据标准化</span></span><br><span class="line">    dict(type=<span class="string">'Normalize'</span>, **img_norm_cfg),</span><br><span class="line">    <span class="comment"># https://github.com/open-mmlab/mmdetection/blob/master/mmdet/datasets/pipelines/transforms.py</span></span><br><span class="line">    <span class="comment"># https://mmcv.readthedocs.io/en/latest/api.html</span></span><br><span class="line">    <span class="comment"># 填充除数，追踪源代码到 mmcv，意思是，填充后的图像边，是 32 的倍数</span></span><br><span class="line">    dict(type=<span class="string">'Pad'</span>, size_divisor=<span class="number">32</span>),</span><br><span class="line">    <span class="comment"># https://github.com/open-mmlab/mmdetection/blob/master/mmdet/datasets/pipelines/formating.py</span></span><br><span class="line">    <span class="comment"># 开始批处理。对于图片，处理、转为向量、收集到 batchsize。bbox，label 同理</span></span><br><span class="line">    dict(type=<span class="string">'DefaultFormatBundle'</span>),</span><br><span class="line">    dict(type=<span class="string">'Collect'</span>, keys=[<span class="string">'img'</span>, <span class="string">'gt_bboxes'</span>, <span class="string">'gt_labels'</span>]),</span><br><span class="line">]</span><br><span class="line">test_pipeline = [</span><br><span class="line">    dict(type=<span class="string">'LoadImageFromFile'</span>),</span><br><span class="line">    dict(</span><br><span class="line">        type=<span class="string">'MultiScaleFlipAug'</span>,</span><br><span class="line">        img_scale=(<span class="number">1333</span>, <span class="number">800</span>),</span><br><span class="line">        <span class="comment"># 禁止翻转</span></span><br><span class="line">        flip=<span class="literal">False</span>,</span><br><span class="line">        transforms=[</span><br><span class="line">            dict(type=<span class="string">'Resize'</span>, keep_ratio=<span class="literal">True</span>),</span><br><span class="line">            dict(type=<span class="string">'RandomFlip'</span>),</span><br><span class="line">            dict(type=<span class="string">'Normalize'</span>, **img_norm_cfg),</span><br><span class="line">            dict(type=<span class="string">'Pad'</span>, size_divisor=<span class="number">32</span>),</span><br><span class="line">            dict(type=<span class="string">'ImageToTensor'</span>, keys=[<span class="string">'img'</span>]),</span><br><span class="line">            dict(type=<span class="string">'Collect'</span>, keys=[<span class="string">'img'</span>]),</span><br><span class="line">        ])</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>而如果想扩展自己的数据处理流程 <sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup> ，先自己定义一个数据处理的类，然后导入进来，加入到 <code>train_pipeline</code> 即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mmdet.datasets <span class="keyword">import</span> PIPELINES</span><br><span class="line"></span><br><span class="line"><span class="meta">@PIPELINES.register_module()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, results)</span>:</span></span><br><span class="line">        results[<span class="string">'dummy'</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .my_pipeline <span class="keyword">import</span> MyTransform</span><br><span class="line"></span><br><span class="line">train_pipeline = [</span><br><span class="line">    dict(type=<span class="string">'LoadImageFromFile'</span>),</span><br><span class="line">    dict(type=<span class="string">'LoadAnnotations'</span>, with_bbox=<span class="literal">True</span>),</span><br><span class="line">    dict(type=<span class="string">'Resize'</span>, img_scale=(<span class="number">1333</span>, <span class="number">800</span>), keep_ratio=<span class="literal">True</span>),</span><br><span class="line">    dict(type=<span class="string">'RandomFlip'</span>, flip_ratio=<span class="number">0.5</span>),</span><br><span class="line">    dict(type=<span class="string">'Normalize'</span>, **img_norm_cfg),</span><br><span class="line">    dict(type=<span class="string">'Pad'</span>, size_divisor=<span class="number">32</span>),</span><br><span class="line">    <span class="comment"># 添加自己的</span></span><br><span class="line">    dict(type=<span class="string">'MyTransform'</span>),</span><br><span class="line">    dict(type=<span class="string">'DefaultFormatBundle'</span>),</span><br><span class="line">    dict(type=<span class="string">'Collect'</span>, keys=[<span class="string">'img'</span>, <span class="string">'gt_bboxes'</span>, <span class="string">'gt_labels'</span>]),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>而至于自定义模型的 backbone，neck，head <sup id="fnref:11"><a href="#fn:11" rel="footnote">11</a></sup> 、学习率和优化方案 <sup id="fnref:12"><a href="#fn:12" rel="footnote">12</a></sup>、自定义损失函数 <sup id="fnref:13"><a href="#fn:13" rel="footnote">13</a></sup> 等，官网也给出了详细的解决方案。</p>
<h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/open-mmlab/mmdetection/blob/master/README_zh-CN.md" target="_blank" rel="noopener">MMDetection 介绍</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/open-mmlab/mmcv#install-with-pip" target="_blank" rel="noopener">mmcv-full 安装文档</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://mmdetection.readthedocs.io/en/latest/get_started.html#installation" target="_blank" rel="noopener">mmdetection 安装文档</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://mmdetection.readthedocs.io/en/latest/api.html#mmdet.apis.init_detector" target="_blank" rel="noopener">mmdetection 官方文档</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/open-mmlab/mmdetection/issues/3755" target="_blank" rel="noopener">inference_detector 无法输出每个盒子的所属类别</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/open-mmlab/mmdetection/issues/3755#issuecomment-840228347" target="_blank" rel="noopener">inference_detector 获取类别</a></span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;"><a href="https://mmdetection.readthedocs.io/en/latest/tutorials/config.html" target="_blank" rel="noopener">MMdetection 配置文件修改</a></span><a href="#fnref:7" rev="footnote"> ↩</a></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">8.</span><span style="display: inline-block; vertical-align: top;"><a href="https://muyuuuu.github.io/2021/05/07/DNN-data-normal/">BN 层在运行时状态</a></span><a href="#fnref:8" rev="footnote"> ↩</a></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">9.</span><span style="display: inline-block; vertical-align: top;"><a href="https://mmdetection.readthedocs.io/en/latest/tutorials/config.html" target="_blank" rel="noopener">Mask RCNN 配置文件说明</a></span><a href="#fnref:9" rev="footnote"> ↩</a></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">10.</span><span style="display: inline-block; vertical-align: top;"><a href="https://mmdetection.readthedocs.io/en/latest/tutorials/data_pipeline.html" target="_blank" rel="noopener">扩展数据处理流程</a></span><a href="#fnref:10" rev="footnote"> ↩</a></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">11.</span><span style="display: inline-block; vertical-align: top;"><a href="https://mmdetection.readthedocs.io/en/latest/tutorials/customize_models.html" target="_blank" rel="noopener">自定义模型</a></span><a href="#fnref:11" rev="footnote"> ↩</a></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">12.</span><span style="display: inline-block; vertical-align: top;"><a href="https://mmdetection.readthedocs.io/en/latest/tutorials/customize_runtime.html" target="_blank" rel="noopener">自定义学习率和优化方案</a></span><a href="#fnref:12" rev="footnote"> ↩</a></li><li id="fn:13"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">13.</span><span style="display: inline-block; vertical-align: top;"><a href="https://mmdetection.readthedocs.io/en/latest/tutorials/customize_losses.html" target="_blank" rel="noopener">自定义损失函数</a></span><a href="#fnref:13" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记：Multi-Task Learning as Multi-Objective Optimization</title>
    <url>/2020/12/05/MTL-to-MOO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自从学了『工程优化』这门课程，也意识到优化是一潭很深的水。只是简单的将几个目标线性加权优化，或优化完一个目标在优化另一个目标是很愚蠢的做法，<strong>亲身试验后的确发现这是最差的解法，解会出现不收敛、随机性、震荡等各种情况</strong>。如果在神经网络中恰好遇到了多任务学习的问题，且两个问题相互制约，那么可以考虑将多任务学习转换为多目标优化，融合成最终的一个loss函数，这会比线性加权好上很多。本论文发表在2018年的NIPS上，个人认为具有借鉴意义和开创性工作，所以记录于此。</p>
<a id="more"></a>
<p>论文地址：<a href="https://papers.nips.cc/paper/2018/file/432aca3a1e345e339f35a30c8f65edce-Paper.pdf" target="_blank" rel="noopener">https://papers.nips.cc/paper/2018/file/432aca3a1e345e339f35a30c8f65edce-Paper.pdf</a><br>代码地址：<a href="https://github.com/intel-isl/MultiObjectiveOptimization" target="_blank" rel="noopener">https://github.com/intel-isl/MultiObjectiveOptimization</a></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在这篇论文中，明确的将神经网络的多任务学习转换为多目标优化问题。将文章提出的方法用到多任务的深度学习场景中，如图像分类，语义分割、实体分割识别等、多标签分类等。<strong>和其他多任务学习或单任务逐步训练的方法相比</strong>，能获得性能更好的模型。</p>
<p>在多任务学习中，通常情况是在约束情况下分别解决每一个任务企图获取每个任务的优化解，但这很大程度上并不可行，因为多任务学习本质是一个多目标问题。多目标优化问题中，需要权衡多个目标之间可能存在的冲突。对每个优化目标进行线性加权得到一个代理目标，最小化每个目标的加权后的损失这种方案仅仅适用于目标之间不冲突的情况，目标之间相互冲突时就超出了线性组合的范畴。</p>
<p>多任务学习MTL(multi-task learning)的潜在优势是，即使是看起来毫不相关的任务，也由于共享输入数据而具有很强的依赖性。在神经网络学习时，将多个任务视为<strong>归纳偏见</strong>(inductive bias)成为了一种解决问题可行的方案。个人理解归纳偏见的意思就是：将各个任务中数据信息所包含的偏差去除，得到所有任务的最优解。</p>
<p>一种这样的方法是多梯度下降算法（MGDA，multi-gradient descent algorithm），该算法基于梯度下降的方法，通过更新每个任务的梯度并解决优化问题，并可证明可以收敛到优化解。所以MGDA非常适合在神经网络进行多任务学习。但是，有两个因素限制了MGDA在大规模任务中的应用： </p>
<ul>
<li>该算法需要计算每个任务的梯度，从而导致反向传播时也需要多次计算，即每个任务对应一次反向传播，训练期间非常耗时。</li>
<li>在多目标优化中，传统的梯度下降算法不能直接应用到大量任务的学习中，因为随着任务数量和梯度维度的增加，模型的扩展性很差。</li>
</ul>
<p>在文章中提出了一种基于Frank-Wolfe的优化方法，<strong>能适应大规模问题</strong>。此外，文章为优化目标提供了一个上限，通过优化上限可以<strong>通过单次反向传播来更新梯度</strong>，而无需单独更新特定任务的梯度，减小了MGDA的计算开销。文章也证明了在现实条件的假设下，算法可以使得神经网络找到多目标优化任务的<strong>Pareto最优解</strong>。</p>
<h1 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h1><p>设数据的输入空间为$X$，任务的集合为$Y_t,t\in [T]$，$T$是任务数量，$N$表示数据集的数量，$y_i^t$表示第$t$个任务的第$i$个数据的标签，数据集可以写为$[x_i,y_i^1,\cdots,y_i^T]$。对每一个任务，可以用参数表示为：$f^t(x;\theta^{sh},\theta^t):X\to Y^t$。$\theta^{sh}$是所有任务共享的参数，$\theta^t$是每个任务独有的参数，每一个任务的损失值为$L^t$。通常的论文会将损失函数设计为：</p>
<p>\begin{equation}<br>\min_{\theta^{sh},\theta^1\cdots\theta^T}=\sum_{i=1}^Tc^tL^t<br>\end{equation}</p>
<p>$c^t$表示每个任务的权重。公式很直观，当网络层数和任务逐步增多时，它通常需要在成比例缩放的空间中进行搜索，要么使用启发式算法，要么很难在多任务学习中找到最优解。但是对于两个参数$\theta,\bar{\theta}$，很可能会有 $L^1(\theta^{sh},\theta^{t_1})&lt;L^2(\bar{\theta}^{sh},\bar{\theta}^{t_1})$，此时$\theta$在任务$t_1$中更好；</p>
<p>但 $L^2(\theta^{sh},\theta^{t_2})&gt;L^2(\bar{\theta}^{sh},\bar{\theta}^{t_2})$ 也可能发生，$\bar{\theta}$在任务$t_2$中更好。如果不知道两个任务的重要性，那么就无法比较$\theta$和$\bar{\theta}$哪个更好。</p>
<p>因此<strong>将多任务学习写成多目标优化问题</strong>，选用的方式是使用一个向量$L$来表示多目标的损失：</p>
<p>\begin{equation}<br>\min_{\theta^{sh},\theta^1\cdots\theta^T}L(\theta^{sh},\theta^1\cdots\theta^T)=\min_{\theta^{sh},\theta^1\cdots\theta^T}\Bigl(L^1(\theta^{sh},\theta^1),\cdots,L^T(\theta^{sh},\theta^T)\Bigr)<br>\end{equation}</p>
<p>同样，本文使用梯度下降法来优化多目标任务，对于多目标优化问题的最优解，有以下两个定义：</p>
<ol>
<li>对于所有的任务$t$，如果$L^T(\theta^{sh},\theta^T)&lt;L^T(\bar\theta^{sh},\bar\theta^T)$，那么$\theta$优于$\bar\theta$。</li>
<li>如果没有$\theta$优于$\theta^{\star}$，那么称$\theta^{\star}$是最优解。</li>
</ol>
<h2 id="多梯度下降算法"><a href="#多梯度下降算法" class="headerlink" title="多梯度下降算法"></a>多梯度下降算法</h2><p>文章提出的方法在multiple gradient descent algorithm (MGDA)的基础上，假设对于每一个任务，有KKT(Karush-Huhn-Tucker，是非线性规划最优解的必要条件)条件成立：</p>
<ul>
<li>存在$\alpha_1\cdots,\alpha_T\geq 0$存在，使得$\sum_{i=1}^T\alpha_i=1$，$\sum_{i=1}^T\alpha_i\nabla_{\theta^{sh}}L^i(\theta^{sh},\theta^i)=0$，公式的含义是：在共享层，没有可行的下降方向，即处于全局最优点，达到了所有任务的最优解。<del>优化课程应该都讲过这些</del></li>
<li>对于任意任务$t$，$\nabla_{\theta^t}L^t(\theta^{sh},\theta^t)=0$</li>
</ul>
<p>任意解满足以上条件就是Pareto平稳点，每一个优化解都是平稳点，反之不成立。优化问题改写为：</p>
<p>\begin{equation}<br>\min_{\alpha_1\cdots,\alpha_T}\Bigl(  \Bigl| \sum_{i=1}^T\alpha^i\nabla_{\theta^{sh}}L^t(\theta^{sh},\theta^i) \Bigr|^2 \Bigl| \sum_{i=1}^T\alpha_i=1,\alpha_i\geq0 \forall i\Bigr)<br>\label{KKT}<br>\end{equation}</p>
<p>这个优化问题已经被证明任何一个优化解取值都是0且结果满足KKT条件；或者当前解能提供一个下降的方向来优化所有的任务。于是MTL算法将计算式\eqref{KKT}得到每一个任务的梯度，并使用$\sum_{i=1}^T\alpha^i\nabla_{\theta^{sh}}$来更新共享参数的梯度。</p>
<h2 id="算法应用到大规模任务中"><a href="#算法应用到大规模任务中" class="headerlink" title="算法应用到大规模任务中"></a>算法应用到大规模任务中</h2><p>\eqref{KKT}中定义的优化问题等价于在<strong>输入空间的凸组合中找到最小范数</strong>。因此使用基于凸优化的一种方法来求解。</p>
<p>在处理一般情况之前，先处理只有两个优化目标的一般情况。此时的优化目标是一个一元二次函数：$min_{\alpha\in [0,1]}||\alpha\nabla_{\theta^{sh}} L^1+(1-\alpha)\nabla_{\theta^{sh}}L^2||_2^2$，$\alpha$的解为：</p>
<p>\begin{equation}<br>\hat\alpha=\biggl( \frac{\nabla_{\theta^{sh}}L^2-\nabla_{\theta^{sh}}L^1}{||\nabla_{\theta^{sh}}L^1-\nabla_{\theta^{sh}}L^2||^2}\nabla_{\theta^{sh}}L^2 \biggr)_+<br>\label{two}<br>\end{equation}</p>
<p>$[a]_+$表示$\max(\min(a,1),0)$。以\eqref{two}作为优化求解的示例，在算法2中给出了Frank-Wolfe求解大规模问题的一般化算法(见算法2)：</p>
<p><img data-src="https://static01.imgkr.com/temp/20a8a63f1da840e08fdda5ae5a314ae4.png" alt="example-image"></p>
<p><img data-src="https://static01.imgkr.com/temp/3fd47e446a944c3bad7af6bc4ca8c543.png" alt="example-image"></p>
<h2 id="在Encoder和Decoder结构中优化"><a href="#在Encoder和Decoder结构中优化" class="headerlink" title="在Encoder和Decoder结构中优化"></a>在Encoder和Decoder结构中优化</h2><p>算法2可以应用到任何基于梯度下降的优化问题中。但是对于每一个任务$t$，都需要计算$\nabla_{\theta^{sh}}L^t(\theta^{sh},\theta^t)$，而参数$\theta^{sh}$在反向传播阶段恰好是多任务共享的参数，所以在反向传播阶段需要计算$T$次。</p>
<p>为降低计算复杂度，提出了一种有效的方法来确定优化目标的上界，且此时的模型只需要一次反向传播。将模型的结构分为：<strong>共享的表示层函数与特定任务的决策函数。</strong>此类架构涵盖了大多数现有的MTL模型，定义为：</p>
<p>\begin{equation}<br>    f^t(x;\theta^{sh},\theta^t)=f^t(g(x;\theta^{sh});\theta^t)<br>\end{equation}</p>
<p>$g$是共享的多任务表示层函数，$f^t$是第$t$个任务的决策函数，且输入为$g$的输出。如果表示层的函数输出为$[z_1,z_2,\cdots,z_n]$，$z_i=g(x_i;\theta^{sh})$，则优化问题的上界为：</p>
<p>\begin{equation}<br>    \Bigl| \sum_{i=1}^T\alpha_i\nabla_{\theta^{sh}}L^t \Bigr|^2 \leq \Bigl| \frac{\partial Z}{\partial \theta^{sh}} \Bigl|^2 \Bigl| \sum_{i=1}^T\alpha_i\nabla_{Z}L^t \Bigr|_2^2<br>\end{equation}</p>
<p>$\nabla_{Z}L^t$能够在单向反向传播中计算得出，$\frac{\partial Z}{\partial \theta^{sh}}$与$\alpha$无关，不会影响到优化过程，所以在优化过程中会被移除。因此使用上界来代替优化目标：</p>
<p>\begin{equation}<br>    \min_{\alpha_1,\cdots,\alpha^T}\biggl( \Big| \sum_{i=1}^T\alpha^i\nabla_{Z}L^t(\theta^{sh},\theta^i) \Big|^2  \Big| \sum_{i=1}^T\alpha_i=1,\alpha_i\geq0 \forall i \biggr)<br>\end{equation}</p>
<p>改进的模型称为<strong>MGDA-UB:Multiple Gradient Descent Algorithm – Upper Bound</strong>。使用共享表示层来代替共享参数后，模型计算复杂度将大大降低。虽然MGDA-UB是原始优化问题的一个估计，文末给出了仍然能产生Pareto最优解的证明。此时网络结构为：</p>
<p><img data-src="https://static01.imgkr.com/temp/39ef45740d8b404bbbf4b4a3a0311aba.png" alt></p>
<p>能将网络结构和公式推导结合到一起，这个想法是真的可以。还是说：先想出了网络结构，而后给出了数学公式的推导和证明。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这篇文章依靠数学证明等公式推导，给出了一种如何将神经网络的多任务学习转换为多目标优化的方案，读起来赏心悦目。</p>
<p><strong>知识使人睿智，工程使人成长。</strong> 无论是遗传算法等启发式算法，还是牛顿迭代法、变尺度法等靠数学证明推导而来的公式，都只是求解问题的工具，但需要结合具体问题来判断哪种工具更为合适。但无论如何，知识会让人有更多的选择方案，而不是没有任何理论依据的胡乱求解，这更像是打开了新世界的大门。但想要更好的掌握优化这门学科，还需要不断的学习和阅读文献，同时必须要注重实际工程的练习，否则无法领会优化的作用与奥妙。<del>这段很突兀的原因是，我这是直接从课程报告里面摘出来的。</del></p>
]]></content>
      <tags>
        <tag>PaperNote</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测篇：Python使用PIL库制作mask数据时，JPG与PNG的异同</title>
    <url>/2021/01/19/Mask-PIL-jpg-and-png/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>生命不息，开坑不止。最近在开『目标检测』领域的坑，<del>真坑。</del>众所周知，<a href="https://arxiv.org/abs/1703.06870" target="_blank" rel="noopener"><code>Mask R-CNN</code></a> 是领域内比较强大的方法。仿照<code>Pytorch</code>官方文档，企图搭建自己的模型，制作自己的 <code>mask</code> 数据。</p>
<a id="more"></a>
<p><code>mask</code> 数据长成下图这样，背景一个颜色，每个目标的颜色是不相同的。</p>
<p><img data-src="https://pytorch.org/tutorials/_static/img/tv_tutorial/tv_image01.png" alt><img data-src="https://pytorch.org/tutorials/_static/img/tv_tutorial/tv_image02.png" alt></p>
<h1 id="制作数据"><a href="#制作数据" class="headerlink" title="制作数据"></a>制作数据</h1><p>按照题目中给出的 <code>json</code> 数据：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"name": "223_89_t20201125085855802_CAM3.jpg",</span><br><span class="line">"image_height": 3500,</span><br><span class="line">"image_width": 4096,</span><br><span class="line">"category": 4,</span><br><span class="line">"bbox": [</span><br><span class="line">    1702.79,</span><br><span class="line">    2826.53,</span><br><span class="line">    1730.79,</span><br><span class="line">    <span class="number">2844.53</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>按照 <code>json</code> 数据读取图片，在按照 <code>category</code> 字段使得不同颜色对应不同类别，按照 <code>bbox</code> 字段生成矩形区域，直接一生成，完美。核心代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不同的类使用不同的颜色</span></span><br><span class="line">colors = &#123;</span><br><span class="line">    <span class="string">'background'</span>: <span class="string">'#000000'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'#110000'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'#002200'</span>,</span><br><span class="line">    <span class="string">'3'</span>: <span class="string">'#000033'</span>,</span><br><span class="line">    <span class="string">'4'</span>: <span class="string">'#445500'</span>,</span><br><span class="line">    <span class="string">'5'</span>: <span class="string">'#660077'</span>,</span><br><span class="line">    <span class="string">'6'</span>: <span class="string">'#008899'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 先创建一个图片对象，扩大数据作用域</span></span><br><span class="line">im = Image.new(<span class="string">'RGB'</span>, (<span class="number">10</span>, <span class="number">10</span>), colors[<span class="string">'background'</span>])</span><br><span class="line"><span class="comment"># 一个图片有好几个坏点 box 区域，所以循环遍历所有坏点</span></span><br><span class="line"><span class="keyword">for</span> pic <span class="keyword">in</span> items:</span><br><span class="line">    <span class="comment"># 第一次遍历，按图片大小生成mask图片大小</span></span><br><span class="line">    <span class="keyword">if</span> height <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> width <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        height, width = pic[<span class="string">'image_height'</span>], pic[<span class="string">'image_width'</span>]</span><br><span class="line">        im = Image.new(<span class="string">'RGB'</span>, (height, width), colors[<span class="string">'background'</span>])</span><br><span class="line">    <span class="comment"># 按照 size 创建背景颜色的图片</span></span><br><span class="line">    x0, y0 = int(pic[<span class="string">'bbox'</span>][<span class="number">0</span>]), int(pic[<span class="string">'bbox'</span>][<span class="number">1</span>])</span><br><span class="line">    x1, y1 = int(pic[<span class="string">'bbox'</span>][<span class="number">2</span>]), int(pic[<span class="string">'bbox'</span>][<span class="number">3</span>])</span><br><span class="line">    <span class="comment"># 对异常区域创建矩形 作为掩码</span></span><br><span class="line">    im1 = Image.new(<span class="string">'RGB'</span>, (x1-x0, y1-y0), colors[str(pic[<span class="string">'category'</span>])])</span><br><span class="line">    <span class="comment"># 添加掩码区域</span></span><br><span class="line">    im.paste(im1, (x0, y0))</span><br><span class="line"><span class="comment"># 保存图片</span></span><br><span class="line">im.save(save_path + <span class="string">'Mask_'</span> + name[:<span class="number">-4</span>] + <span class="string">'.jpg'</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><p>到这里会发现程序很简单，一帆风顺。<strong>但是，坑来了。</strong>按照如上 <code>mask</code> 生成方法，每个图片上最多有 10 种 <code>RGB</code> 的颜色存在。这里我们写一份小代码复现一下，不能说完全一致，但思想一模一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">im = Image.new(<span class="string">'RGB'</span>, (<span class="number">10</span>, <span class="number">10</span>), <span class="string">'#000000'</span>)</span><br><span class="line">im1 = Image.new(<span class="string">'RGB'</span>, (<span class="number">5</span>, <span class="number">5</span>), <span class="string">'#006677'</span>)</span><br><span class="line">im.paste(im1, (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">im.save(<span class="string">'1.jpg'</span>)</span><br></pre></td></tr></table></figure>
<p>这里在检测下生成的<code>1.jpg</code>中有多少颜色：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">im = Image.new(<span class="string">'RGB'</span>, (<span class="number">10</span>, <span class="number">10</span>), <span class="string">'#000000'</span>)</span><br><span class="line">im1 = Image.new(<span class="string">'RGB'</span>, (<span class="number">5</span>, <span class="number">5</span>), <span class="string">'#006677'</span>)</span><br><span class="line">im.paste(im1, (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">im.save(<span class="string">'1.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一定要重新打开在读取</span></span><br><span class="line">im2 = Image.open(<span class="string">'1.jpg'</span>).convert(<span class="string">'RGB'</span>)</span><br><span class="line">a = np.array(im2)</span><br><span class="line">print(np.unique(a))</span><br></pre></td></tr></table></figure>
<p>输出是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[  <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span>  <span class="number">16</span>  <span class="number">17</span></span><br><span class="line">  <span class="number">18</span>  <span class="number">19</span>  <span class="number">21</span>  <span class="number">22</span>  <span class="number">23</span>  <span class="number">24</span>  <span class="number">25</span>  <span class="number">26</span>  <span class="number">29</span>  <span class="number">30</span>  <span class="number">31</span>  <span class="number">33</span>  <span class="number">35</span>  <span class="number">38</span>  <span class="number">40</span>  <span class="number">41</span>  <span class="number">42</span>  <span class="number">43</span></span><br><span class="line">  <span class="number">76</span>  <span class="number">85</span>  <span class="number">87</span>  <span class="number">88</span>  <span class="number">89</span>  <span class="number">90</span>  <span class="number">91</span>  <span class="number">92</span>  <span class="number">93</span>  <span class="number">94</span>  <span class="number">95</span>  <span class="number">96</span>  <span class="number">97</span>  <span class="number">98</span>  <span class="number">99</span> <span class="number">101</span> <span class="number">102</span> <span class="number">103</span></span><br><span class="line"> <span class="number">105</span> <span class="number">107</span> <span class="number">108</span> <span class="number">109</span> <span class="number">110</span> <span class="number">111</span> <span class="number">115</span> <span class="number">116</span> <span class="number">118</span> <span class="number">122</span> <span class="number">129</span> <span class="number">130</span>]</span><br></pre></td></tr></table></figure>
<p><strong>平白无故多出来这么多颜色</strong>，当场人就傻了。再来试试把图片保存为 <code>png</code> 格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">im = Image.new(<span class="string">'RGB'</span>, (<span class="number">10</span>, <span class="number">10</span>), <span class="string">'#000000'</span>)</span><br><span class="line">im1 = Image.new(<span class="string">'RGB'</span>, (<span class="number">5</span>, <span class="number">5</span>), <span class="string">'#006677'</span>)</span><br><span class="line">im.paste(im1, (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">im.save(<span class="string">'1.png'</span>)</span><br><span class="line"></span><br><span class="line">im2 = Image.open(<span class="string">'1.png'</span>).convert(<span class="string">'RGB'</span>)</span><br><span class="line">a = np.array(im2)</span><br><span class="line">print(np.unique(a))</span><br></pre></td></tr></table></figure>
<p>此时的输出是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[  <span class="number">0</span> <span class="number">102</span> <span class="number">119</span>]</span><br><span class="line"><span class="comment"># 16 进制的 66 在 10 进制中是 102</span></span><br><span class="line"><span class="comment"># 16 进制的 77 在 10 进制中是 119</span></span><br></pre></td></tr></table></figure>
<p>瞬间正常了，看来的确是文件格式导致的原因。</p>
<h1 id="踩坑分析"><a href="#踩坑分析" class="headerlink" title="踩坑分析"></a>踩坑分析</h1><p>虽然很无能为力的生气，数据集大小是 <code>10GB</code> 大小，重做一次数据都得两个小时左右，<del>好在不是自己的CPU和硬盘。</del>此时打开搜索引擎，查找<code>jpg</code>和<code>png</code>的区别：</p>
<ul>
<li><code>jpg</code> 是由 <code>CCITT&amp;ISO</code> 的一群人员，在1987年提出的一种工业压缩标准。此类格式的文件，通过压缩算法将图片大小压缩，会产生图像失真的情况。即在压缩过程中图像的品质会遭受到可见的破坏。</li>
<li><code>png</code> 格式是无损数据压缩的，还有透明的选择。</li>
</ul>
<p>看到这里就可以了，原来是数据格式的问题。<del>是我文盲了，正在去重新做数据的路上。</del></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://mingwang0824.pixnet.net/blog/post/27833076" target="_blank" rel="noopener">https://mingwang0824.pixnet.net/blog/post/27833076</a></li>
<li><a href="https://www.zhihu.com/question/29758228" target="_blank" rel="noopener">https://www.zhihu.com/question/29758228</a></li>
</ol>
]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>分割篇：Mask R-CNN</title>
    <url>/2021/05/25/Mask-R-CNN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不同于 FCN 的语义分割，Mask R-CNN 是用于实体分割的。借鉴 FCN 的思想，通过在 Faster R-CNN 的用于边界框识别分支上添加了一个并行的用于预测目标掩码的分支 Mask，在实现目标检测的同时，实现实例分割（object instance segmentation），即把每个目标像素分割出来。而 Faster R-CNN 和 FCN 在之前介绍过，所以本文的重点将会放在损失函数的设计和 ROI-Align 上。</p>
<p>实体分割不同于语义分割的是，不仅要检测出所属类别，还要区分同一类别下的不同实例。</p>
<p><img data-src="https://z3.ax1x.com/2021/05/25/gxXEss.png" alt></p>
<a id="more"></a>
<p>按着前文描述，网络结构如下，蓝色分支是 Faster R-CNN 中用于预测类别和回归框的分支，红色分支是新加入的预测掩码的分支。</p>
<p><img data-src="https://z3.ax1x.com/2021/05/25/gxOoa6.png" alt></p>
<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>语义分割问题只需要在语义上对像素点进行区分即可。而实例分割问题不仅需要正确地检测出所有的目标，还需要在单个目标的基础上对每一个实例进行准确的分割。而作者基于 Faster R-CNN 目标检测的框架和 FCN 的语义分割提出了 Mask R-CNN。所以流程就是：</p>
<ol>
<li>输入一副图片，将图片输入到特征提取层 backbone，也可以融合 FPN 机制，最终获得对应的 feature map。下图中，左图是 Mask R-CNN 和 Faster R-CNN 结合的方式，右图是 Mask R-CNN 和 FPN 结合的方式。</li>
<li>对 feature map 中获得多个候选 ROI，候选的 ROI 送入 RPN 网络进行二值分类和 bbox 回归，截止到这一步，Mask R-CNN 和 Faster R-CNN 完全相同</li>
<li>Mask R-CNN 中，取消 ROI pooling，替换为 ROI-Align</li>
<li>对这些 ROI 进行分类、box 回归和 MASK 生成</li>
</ol>
<p><del>如果看不懂建议重新看 Faster R-CNN 和 FCN</del></p>
<p><img data-src="https://z3.ax1x.com/2021/05/25/gxvu2F.png" alt></p>
<h1 id="ROI-Align"><a href="#ROI-Align" class="headerlink" title="ROI-Align"></a>ROI-Align</h1><p>对于传统的 ROI pooling 而言，难免会有精度损失。比如 <code>20X20</code> 的特征图 pool 到 <code>7X7</code>，自然无法整除，就需要对像素点进行取舍，带来精度上的损失。RoI 对应至特征图和 ROI 进行划分这两步取整量化操作会导致 ROI 与抽取出的特征图在空间位置上不匹配。这一问题不会对目标的分类造成大的影响，但会对 mask 预测造成极大的负面影响。如下图所示 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> ，并非均匀划分：</p>
<p><img data-src="https://z3.ax1x.com/2021/05/25/gzSIZd.gif" alt></p>
<p>对于 ROI-Align 而言，不在对 ROI 边界进行取整。假设 pool 到 <code>3X3</code> 的格子，那么计算每个格子中心四个点的坐标。对于每个点而言，对每个周围的四个点进行采样，使用双线性插值计算当前点的取值，而后 max pool 获取当前格子里面的值。无论采样点的多少与采样方式，结果都不会很差。如果使用的量化取整，结果就会很差。如下图，作者也只使用了这一张图介绍了 ROI-Align。</p>
<p><img data-src="https://z3.ax1x.com/2021/05/25/gzptwd.png" alt></p>
<p>这个过程佷繁琐不易理解，但其实并不难，可以来这篇博客看下动图。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
<p><img data-src="https://z3.ax1x.com/2021/05/25/gziG9I.gif" alt></p>
<h1 id="Mask-损失"><a href="#Mask-损失" class="headerlink" title="Mask 损失"></a>Mask 损失</h1><p>Mask R-CNN 的分支由三部分组成，其中 $L_{\text{cls}}$ 和 $L_{\text{box}}$ 与 Faster R-CNN 没有本质区别，所以重点是 $ L_{\text{mask}}$，它是平均二分类交叉熵损失。</p>
<p>\begin{equation}<br>L = L_{\text{cls}} + L_{\text{box}} + L_{\text{mask}}<br>\end{equation}</p>
<p>假设一共有 $K$ 个类别，则 Mask 分割分支的输出维度是 $K m m$。所以对于 $m\times m$ 中的每个点，都会输出 $K$ 个二值 Mask（每个类别使用 <code>sigmoid</code> 输出）。这里与 FCN 的做法不同，FCN 在每个像素点上应用 softmax 函数，整体采用多任务交叉熵，这样会导致类间竞争（class competition），最终导致分割效果差。其实上文也能看到，分割效果的确很差。</p>
<p><img data-src="https://z3.ax1x.com/2021/05/25/gzgnb9.png" alt></p>
<blockquote>
<p>在 Faster RCNN 做 object detection 的时候，已经把某一块 RoI 识别为汽车，但这个 RoI 内可能存在其他物体的一部分，因此分割的 mask 中，除了要将汽车分割出来外，还要把另外那个物体也分割出来。这就导致这样的情况，在 object detection 的分支中，这块 RoI 整体被识别为汽车，但在 segmentation 的时候，这块 RoI 一部分被识别为汽车，一部分又要当作其他物体。如此一来，这两个分支回传到前面的梯度多少存在冲突，而前面的特征提取网络可是共享的，结果网络在学习的时候就可能出现左右为难的情况。</p>
</blockquote>
<p>那么来考虑二分类。To this we apply a per-pixel sigmoid, and define $L_{\text{mask}}$ as the average binary cross-entropy loss. For an RoI associated with ground-truth class $k$, $L_{\text{mask}}$ is only defined on the $k$-th mask (other mask outputs do not contribute to the loss). 也就是，只考虑一种类别，如果 ground truth 中标记了这个 bounding box 中是个人的话，那我们就只针对人的 mask 进行分割，而对这个 bounding box 中其他可能存在的物体一律忽视。如下图所示。这里画图的思想参考了这篇文章 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</p>
<p><img data-src="https://z3.ax1x.com/2021/05/25/gzRBjS.png" alt></p>
<p>在测试阶段，通过分类分支预测的类别来选择相应的 Mask 预测。这样，Mask 预测和分类预测就彻底解耦了。</p>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><ol>
<li><a href="https://pytorch.org/tutorials/intermediate/torchvision_tutorial.html" target="_blank" rel="noopener">torchvision</a> 上有现成的示例。</li>
<li>等我以后用到语义分割的时候再回来补冲这里的程序，那时候肯定是 open-mmlab 系列的东西了。</li>
</ol>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://en.wikipedia.org/wiki/File:RoI_pooling_animated.gif" target="_blank" rel="noopener">ROI pooling 动图</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://towardsdatascience.com/understanding-region-of-interest-part-2-roi-align-and-roi-warp-f795196fc193" target="_blank" rel="noopener">ROI Align 动图</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zhuanlan.zhihu.com/p/65321082" target="_blank" rel="noopener">二分类损失代替多分类损失</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>敦煌莫高窟</title>
    <url>/2020/01/17/MoGaoGrottoes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>小学以为学莫高窟就是为了学说明文这种文体，这里有多少窟，每个窟多大，有多少佛像，每个佛像多高，有多少壁画，壁画是哪个朝代的，无聊得很，除了考试别无他用。</p>
<p>但是，直到看见了莫高窟，被眼前的景象深深折服，工匠之心，精益求精，此间雕刻举世无双，不愧是世界奇迹，中华文化的瑰宝。中午吃了敦煌榆钱，太香了。</p>
<p>因为文化保护，不能拍照，但绝不虚此行。虽然你会感觉看完了本文的相册毫无感觉，因为：洞窟里面才是世间奇迹，不过那里禁止拍照。</p>
<p><img data-src="/2020/01/17/MoGaoGrottoes/61.jpg" alt></p>
<a id="more"></a>
<p><img data-src="/2020/01/17/MoGaoGrottoes/62.jpg" alt><br><img data-src="/2020/01/17/MoGaoGrottoes/64.jpg" alt><br><img data-src="/2020/01/17/MoGaoGrottoes/67.jpg" alt><br><img data-src="/2020/01/17/MoGaoGrottoes/70.jpg" alt><br><img data-src="/2020/01/17/MoGaoGrottoes/71.jpg" alt><br><img data-src="/2020/01/17/MoGaoGrottoes/73.jpg" alt><br><img data-src="/2020/01/17/MoGaoGrottoes/74.jpg" alt><br><img data-src="/2020/01/17/MoGaoGrottoes/75.jpg" alt></p>
]]></content>
      <categories>
        <category>塞上西北行</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Metis的大规模图融合算法实现</title>
    <url>/2020/11/20/Metis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是我第一次开发如此大规模的程序，论文的作者也提供了算法的<code>C</code>语言还是<code>C++</code>版本的软件来？我记不清了。但对于我们来说，<code>Metis</code>只是图划分的上游任务，且不需要完整的<code>Metis</code>算法，只是需要它融合图的一部分，而不需要它的图划分阶段。下游任务必须要用<code>python</code>来处理，考虑到数据结构和数据类型对接的方便性，因此我们考虑使用<code>python</code>来复现<code>Metis</code>算法。还有一点，使用别人的软件，万一结果不好怎么办？万一自己想改算法怎么办？现存的库都是直接返回划分结果，但我们只想融合，自己开发还是灵活。</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>还有一点是，<code>python</code>第三方库的<code>Metis</code>模块是使用<code>networkx</code>开发的，它的底层是<code>python</code>，在处理超大规模图数据时肯定效率不够高，因此我们选用底层为<code>C++</code>的<code>graph-tool</code>重新开发。</p>
<ul>
<li>考虑到看官体验，没有结合代码一起写。但建议结合代码一起看，不然各种数据结构用来用去、调来调去很容易眩晕。</li>
<li>开发程序的过程中，使用了大量数据结构的使用和程序的设计技巧，经过精心打磨，使用了桶排序、哈系、队列、列表、字典等结构的花式操作来降低算法时间和空间复杂度，一点点的将$O(n^2)$的程序降低到$O(n\log n)$在降到$O(n)$。如果不是非要用<code>Metis</code>算法来融合图和抱着必死的决心一定要读懂代码，请谨慎观看本文。</li>
<li>这不是我一个人的功劳，还要感谢我聪明的<a href="https://github.com/dajiaozhu" target="_blank" rel="noopener">师姐</a>和我一起开发。整体而言，对开发出来的程序表示满意。</li>
<li>文末给出我对大规模图划分的一点想法，欢迎探讨。</li>
</ul>
<p>程序地址：<a href="https://github.com/muyuuuu/Metis" target="_blank" rel="noopener">https://github.com/muyuuuu/Metis</a><br>论文地址：<a href="http://glaros.dtc.umn.edu/gkhome/node/1186" target="_blank" rel="noopener">http://glaros.dtc.umn.edu/gkhome/node/1186</a></p>
<p>最后，将我们的算法和目前的第三方库<code>metis</code>与<code>pymetis</code>进行对比，我们实现的性能能吊打<code>metis</code>包，与<code>pymetis</code>还有些差距，文末给出性能对比。</p>
<h1 id="第一次协作开发"><a href="#第一次协作开发" class="headerlink" title="第一次协作开发"></a>第一次协作开发</h1><p><img data-src="https://static01.imgkr.com/temp/8a98d8ea24b243f1bf8d1ecfbecb27ad.png" alt></p>
<h1 id="图融合思想"><a href="#图融合思想" class="headerlink" title="图融合思想"></a>图融合思想</h1><p>原始的图记为$G_0$，融合一次得到一个规模相对较小的图$G_1$，一直融合到$G_n$为止。停止融合的条件由自己设定，比如我设置的是，当图节点的数量少于$\sqrt{n}$时停止迭代，$n$为$G_0$中节点的数量。一个两万节点的图，融合结果如下：</p>
<p>99个节点：<img data-src="https://static01.imgkr.com/temp/8d753700aee54a61939d2051ac7050c2.jpg" alt><br>7个节点：<img data-src="https://static01.imgkr.com/temp/773434f99e384f57aac8cb4ba1c35650.jpg" alt></p>
<h1 id="参数约定与注意事项"><a href="#参数约定与注意事项" class="headerlink" title="参数约定与注意事项"></a>参数约定与注意事项</h1><ul>
<li>在原图中，每个节点的权重$\eta$为1，此处不考虑赋权图。</li>
<li>$m$表示原始图中边的数量，$n$表示原始图中节点的数量。</li>
<li>注意：本次处理大规模图数据，切勿使用复杂度很高的程序，千万不要暴力破解。合理使用数据结构降低复杂度，以及善用迭代器和生成器，写出来的程序也要防止炸内存。</li>
</ul>
<h1 id="边处理"><a href="#边处理" class="headerlink" title="边处理"></a>边处理</h1><p>边融合：如果两个节点只通过一条边相邻，那么将这两个节点融合在一起，时间复杂度为$O(m)$。</p>
<p>实现思路：此时创建一个向量<code>M</code>和<code>visited</code>（python用列表实现），如果两个节点$u$和$v$相互匹配，则<code>M[u]=v, M[v]=u</code>。如果没有匹配的节点，则$M(u)=u$。融合后的每一个点赋予权重$\eta$，如$u,v$权重为1，融合成了$a$，那么$a$的权重就是2。记录权重的原因是：防止所有节点融合到一个节点，导致后期的图中某个节点的权重过大，划分不均衡。</p>
<p><code>visited</code>长度为$n$，全部初始化为<code>False</code>，如果一个节点被融合，那么值为<code>True</code>。</p>
<p>返回参数为向量<code>M</code>和<code>visited</code>，用于表示节点的融合关系以及点是否被融合。使用列表的原因是：字典浪费内存，且本次任务中，没有节点的插入、删除和查找，列表性能更高一些。</p>
<h1 id="防止划分不均"><a href="#防止划分不均" class="headerlink" title="防止划分不均"></a>防止划分不均</h1><p>为防止融合后的图出现节点分布不均匀的现象，即出现幂律图（有的节点权重$\eta$很大，有的节点权重$\eta$很小），所以放宽了融合的约束条件。并不是只有相邻节点才能融合到一起，考虑使用节点的二跳信息来融合节点，尽管节点间并没有直接相邻。</p>
<h1 id="叶子节点处理"><a href="#叶子节点处理" class="headerlink" title="叶子节点处理"></a>叶子节点处理</h1><p>将度为1的节点视为叶子节点，融合根节点相同的叶子节点，实现的时间复杂度为$O(n)$。根据边融合返回的<code>visited</code>参数，遍历节点，只访问度为1且没有被匹配的节点，将他们放到一个列表中，并将每个节点的父节点添加到字典中，字典的<code>key</code>为父节点，<code>value</code>为孩子节点。</p>
<p>之后遍历字典，如果字典某个<code>key</code>对应的值的数量大于2，说明这个根节点有大于等于两个以上的叶子节点，那么对这个<code>key</code>中对应的叶子节点进行两两融合，将融合关系记录到<code>M</code>中，且更改<code>visited</code>。</p>
<h1 id="双胞胎节点处理"><a href="#双胞胎节点处理" class="headerlink" title="双胞胎节点处理"></a>双胞胎节点处理</h1><p>双胞胎节点的定义是：如果节点的度相同，且节点的邻接列表相同，则为双胞胎节点。融合双胞胎节点是最难实现的一个功能，结果看到论文中提示用<code>hash</code>来简化计算，简直神来之笔，实现的时间复杂度为$O(n\log n)$。</p>
<p>这个函数仍然需要读入<code>visited</code>参数，只处理还没有被融合的节点。为降低复杂度，按照度进行桶排序，即将不同度的节点放到对应的桶中，桶的取值范围是$[2,64]$。创建一个字典，<code>key</code>为邻接列表（<strong>转为字符串，可哈系</strong>），值为这个邻接列表对应的节点，<strong>这种结构会大大降低复杂度</strong>；相反，<code>key</code>为节点，值为邻接列表的数据结构，程序复杂度会达到$O(n^2)$。在每个桶内，遍历节点，并填充到上述字典中。填充完毕后，遍历字典的值，进行两两融合，将融合关系记录到<code>M</code>中，并更改<code>visited</code>。</p>
<p>如果考虑加速执行，可以考虑多进程（python多线程不适合密集计算）来遍历每个桶，毕竟桶里面的处理都一样。<del>利用到字典、哈系、桶排序来降低复杂度，能想出来的一定有很深的程序设计功底。</del></p>
<h1 id="亲戚节点处理"><a href="#亲戚节点处理" class="headerlink" title="亲戚节点处理"></a>亲戚节点处理</h1><p>亲戚节点的定义与双胞胎节点类似，如果节点的度相同，则视为亲戚节点，进行融合。实现的时间复杂度为$O(n)$。</p>
<p>这个函数也需要读入<code>visited</code>参数，只处理还没有被融合的节点。遍历<code>visited</code>列表，记录没有被访问的节点的度，将节点的度作为<code>key</code>，值为节点。融合方法和上面的就一样了，将融合关系记录到<code>M</code>中。</p>
<h1 id="图收缩"><a href="#图收缩" class="headerlink" title="图收缩"></a>图收缩</h1><p>在利用二跳信息对节点处理后，可以达到70%到90%的匹配率。</p>
<p>在得到融合关系的列表<code>M</code>后，则开始收缩图的规模，实现的时间复杂度为$O(n)$。创建辅助列表<code>C</code>，如果两个节点$u$和$v$融合到一起，那么<code>C[u]=C[v]</code>，且，在列表<code>C</code>中，只有融合到一起的节点的值相等，不融合到一起的值不相等。</p>
<p>生成<code>C</code>后，按照<code>C</code>中数值的关系，开始获取图的邻接列表。因为值相等表示这些节点融合到一起，所以很容易得到融合后的图的邻接列表<code>adj</code>。比如<code>a,b,c,d,e,f</code>邻接到一起，那么<code>adj[key]={a,b,c,d,e,f}</code>，<code>key</code>是一个自增的变量，表示新图的节点编号，即新图中的<code>key</code>节点由旧图中的<code>a,b,c,d,e,f</code>这几个节点组成。至此，得到了新图和旧图之间的点的对应关系。可以将这个字典保存为<code>json</code>，方便后续处理。</p>
<h1 id="图融合"><a href="#图融合" class="headerlink" title="图融合"></a>图融合</h1><p>遍历图收缩返回的数据结构<code>adj</code>，<code>adj</code>中的值对应的所有节点都将视为新图中的一个点，<code>len(adj)</code>就表示新图中节点的数量。</p>
<p>创建一个字典，字典的<code>key</code>是一个元组类型。元组包含两个元素，分别为新图中两个节点的索引，含义是新图中这两个节点之间有边。遍历原始图的边，判断当前边两个点是否进行融合：</p>
<ul>
<li>如果两个点进行融合，那么这两个顶点在新图上的映射节点相同，则对应边不用考虑，即这两个节点在新图中没有连接边；</li>
<li>若当前边的两个顶点没有进行融合，则按照新旧图的映射关系，将旧图中边上的两个顶点换成映射中新图上顶点，以此作为<code>key</code>，并将边填入字典。这里太绕了，添加部分伪代码进行说明：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据原始图和融合后的图节点的映射关系，求出原始图每一个点与新图的映射关系</span></span><br><span class="line"><span class="comment"># index表示原始图节点索引，old_mapping_new[index]表示原图中index节点在新图的索引</span></span><br><span class="line"><span class="keyword">for</span> new_ver, old_vers <span class="keyword">in</span> adj.items():</span><br><span class="line">    <span class="keyword">for</span> old_ver <span class="keyword">in</span> old_vers:</span><br><span class="line">        old_mapping_new[old_ver] = new_ver</span><br><span class="line"><span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">    source, target = edge</span><br><span class="line">    <span class="comment"># 取节点的索引</span></span><br><span class="line">    s_index = graph.vertex_index[source]</span><br><span class="line">    t_index = graph.vertex_index[target]</span><br><span class="line">    <span class="comment"># 若当前边的两个顶点没有进行融合</span></span><br><span class="line">    <span class="keyword">if</span> old_mapping_new[s_index] != old_mapping_new[t_index]:</span><br><span class="line">        <span class="keyword">if</span> old_mapping_new[s_index] &lt; old_mapping_new[t_index]:</span><br><span class="line">            new_edges[(old_mapping_new[s_index], old_mapping_new[t_index])] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_edges[(old_mapping_new[t_index], old_mapping_new[s_index])] += <span class="number">1</span></span><br><span class="line"><span class="comment"># 按照字典中的`key`，将边添加到节点中。</span></span><br><span class="line"><span class="keyword">for</span> edge <span class="keyword">in</span> new_edges.keys():</span><br><span class="line">    new_graph.add_edge(edge[<span class="number">0</span>], edge[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>之后创建新图的节点，按照字典中的<code>key</code>，将边添加到节点中，就完成了所有工作。</p>
<p>所以整体流程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 边融合</span></span><br><span class="line">M, visited = aggregate.edge_merge(graph, constrain, loop, ver_q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 叶子融合</span></span><br><span class="line">M, visited = aggregate.leaf_merge(graph, M, visited)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双胞胎融合</span></span><br><span class="line">M, visited = aggregate.twin_merge(graph, M, visited)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 亲戚节点融合</span></span><br><span class="line">M, visited = aggregate.relative_merge(graph, M, visited)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始收缩</span></span><br><span class="line">graph, adj = contraction.contract(graph, M)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存旧图与新图之间的映射关系</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'map/real_data_'</span> + str(loop) + <span class="string">'.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">    json.dump(adj, outfile, indent=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始产生新图</span></span><br><span class="line">graph = contraction.get_new_graph(graph, adj, M)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取新图的规模</span></span><br><span class="line">ver_size = utils.get_graph_vertex_num(graph)</span><br><span class="line">edge_size = utils.get_graph_edge_num(graph)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"当前图节点数是&#123;&#125;，边数是&#123;&#125;"</span>.format(ver_size, edge_size), end=<span class="string">', '</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小到一定规模就可视化</span></span><br><span class="line"><span class="keyword">if</span> ver_size &lt; <span class="number">200</span>:</span><br><span class="line">    gt.graph_draw(graph, vertex_text=graph.vertex_index, output=<span class="string">"output/real_graph_"</span>+str(loop)+<span class="string">".png"</span>)</span><br></pre></td></tr></table></figure>
<h1 id="后期处理"><a href="#后期处理" class="headerlink" title="后期处理"></a>后期处理</h1><p>别急着走，还没完。在<code>utils.py</code>中写了一个装饰器和<code>log</code>函数，记录每种处理所消耗的时间，以此来检查哪里的程序写的不好；此外，<code>M</code>中<code>True</code>元素的个数除以<code>M</code>的长度，就会得当当前方法的融合率：<code>visited.count(True) / len(visited)</code>。</p>
<p>图融合的重点是：节点是否分不均衡（即一个节点的权重是不是太大，而其他节点权重很小），边割率是不是太高（相邻节点没融合到一起，反而切割了大量的边）。</p>
<ul>
<li>点平衡率计算：分区中节点最大值 × 分区数 / 原图节点数</li>
<li>边平衡率计算：切割边 / 总边数</li>
</ul>
<p>本次代码中也进行了相关处理和计算。伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取新图的一个节点代表旧图的几个节点，是数量</span></span><br><span class="line">ver_q = performance.get_vertex_map_number(ver_q, adj)</span><br><span class="line"><span class="comment"># 获取新图的一个结点代表旧图的哪些节点，是列表</span></span><br><span class="line">edge_q = performance.get_vertex_map_relation(edge_q, adj)</span><br><span class="line"><span class="comment"># 节点平衡率</span></span><br><span class="line">performance.print_vertex_balance(ver_q, ver_size_list)</span><br><span class="line"><span class="comment"># 边割率</span></span><br><span class="line">performance.print_edge_cut(edge_q, edge_size_list, origin_graph)</span><br></pre></td></tr></table></figure>
<p>我尽力了，但本处的描述过于模糊，建议对照代码进行观看。</p>
<p>在点平衡率的计算中，为降低空间复杂度，使用了队列这种数据结构。设置队列的长度为1，队列中的元素为字典，<code>key</code>为图节点的索引，<code>value</code>为节点权重，是节点的个数。含义是：上次融合图和原图之间节点的对应关系。当本次图融合完成时，传入的<code>adj</code>表示本次图和上次融合图的对应关系。取出队列元素值，即上次融合图和原始图的节点对应关系，按照本次图和上次融合图节点的关系，<strong>进行一次套娃，得到本次图中每个节点的权重</strong>，并压入队列并<code>return</code>，这样就可以计算点平衡率。</p>
<p>而边平衡率的计算同理，仍然使用队列。<strong>每次融合进行一次套娃</strong>，得到新图的一个结点(<code>key</code>)代表旧图的哪些节点(<code>value</code>)，(<code>value</code>)是一个列表。然后反转一下这个字典，以原始图节点的索引为<code>key</code>，如果这些点在新图中是一个节点，那么他们的<code>value</code>相同。之后按着边遍历原始图，相邻节点的<code>value</code>不同，则边割率++。</p>
<p><del>所以我当时是怎么想出来各种结构和算法来实现这些的，感觉好难。</del></p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>经过测试，能发现<code>Metis</code>算法的优缺点：</p>
<ul>
<li>优势：能保留节点的中心性。</li>
<li>劣势：节点权重不平衡，边割率太高。</li>
</ul>
<p>可以看到到处是缺点，这里只给出一种解决方案，毕竟这只是上游任务，没必要太精细。</p>
<p>在融合的时候，点和边的选择顺序是随机的。所以，我们可以限制融合顺序，先融合节点度小的点，在融合度大的点。目前，此方案仅增加在<strong>边处理</strong>中，其他合并没有增加，但是一个道理。</p>
<p>结论：节点平衡率能下降，比之前好多了，如果还觉得高，其他融合函数也进行融合限制即可。边割率一如既往的高，毕竟初试划分很随机，不能纵观全局，这是导致边割率过高的原因。但降低边割率并不是粗划分的重点。</p>
<h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><h2 id="与metis包的性能对比"><a href="#与metis包的性能对比" class="headerlink" title="与metis包的性能对比"></a>与metis包的性能对比</h2><p><code>pip install metis</code>即可。测试数据为一个<a href="https://snap.stanford.edu/data/email-Eu-core.html" target="_blank" rel="noopener">很小规模的图数据</a>，<strong>需要注意的是：我们的算法是图融合的，metis是用来图划分的。</strong> 严格意义上来讲没有可比性，但<code>metis</code>这个包的执行结果太让人失望了。</p>
<h3 id="我们的"><a href="#我们的" class="headerlink" title="我们的"></a>我们的</h3><p><strong>我们程序的融合部分耗时为0.57秒。</strong></p>
<p><img data-src="https://static01.imgkr.com/temp/fabdcb8a0ca845ccabcd3d74bbb6df71.png" alt></p>
<h3 id="目前第三方的"><a href="#目前第三方的" class="headerlink" title="目前第三方的"></a>目前第三方的</h3><p><code>metis</code>包的官网：<br><a href="https://metis.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://metis.readthedocs.io/en/latest/</a></p>
<p><code>pip install metis netowrkx==2.3</code>后，实现了两种读取数据的方式，结果直接爆炸，且<code>networkx</code>已经更新到<code>2.5</code>版本，但<code>metis</code>只支持到了<code>2.3</code>。目前第三方支持了两种读取数据的方式，第一种是读入邻接列表，第二种是通过<code>networkx</code>读入数据并转为<code>metis</code>能处理的类型。</p>
<p>首先是<code>networkx</code>读入图数据并转换类型，我按照官方的说明实现了一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = nx.read_adjlist(<span class="string">"email-Eu-core.txt"</span>, nodetype=int)</span><br><span class="line">metis.networkx_to_metis(g)</span><br><span class="line">(edgecuts, parts) = metis.part_graph(g, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>然后直接内存溢出：</p>
<p><img data-src="https://static01.imgkr.com/temp/7007c6a1045a46858658a3df37367ab5.png" alt></p>
<p>我放心不下，就试试手动读入图数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createGraph</span><span class="params">(filename)</span> :</span></span><br><span class="line">    G = nx.Graph()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> open(filename) :</span><br><span class="line">        strlist = line.split()</span><br><span class="line">        n1 = int(strlist[<span class="number">0</span>])</span><br><span class="line">        n2 = int(strlist[<span class="number">1</span>])</span><br><span class="line">        G.add_edges_from([(n1, n2)])</span><br><span class="line">    <span class="keyword">return</span> G</span><br><span class="line"></span><br><span class="line">g = createGraph(<span class="string">"email-Eu-core.txt"</span>)</span><br><span class="line">metis.networkx_to_metis(g)</span><br><span class="line">(edgecuts, parts) = metis.part_graph(g, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>直接段错误：</p>
<p><img data-src="https://static01.imgkr.com/temp/a530f15ef32348e1816c5654ebb7a89f.png" alt></p>
<p>官方还支持读入邻接列表，然后我又实现了一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">(filename)</span>:</span></span><br><span class="line">    adj_list = []</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            temp = line.split(<span class="string">' '</span>)</span><br><span class="line">            adj_list.append((int(temp[<span class="number">0</span>]), int(temp[<span class="number">1</span>])))</span><br><span class="line">    <span class="keyword">return</span> adj_list</span><br><span class="line"></span><br><span class="line">adjlist = read_data(<span class="string">'email-Eu-core.txt'</span>)</span><br><span class="line">g = metis.adjlist_to_metis(adjlist)</span><br><span class="line">(edgecuts, parts) = metis.part_graph(g, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>然后还是段错误：</p>
<p><img data-src="https://static01.imgkr.com/temp/a530f15ef32348e1816c5654ebb7a89f.png" alt></p>
<p>这种东西就没法比了，对面都执行不出来，对比的代码也会放到<code>github</code>上。</p>
<h2 id="与pymetis的对比"><a href="#与pymetis的对比" class="headerlink" title="与pymetis的对比"></a>与pymetis的对比</h2><p>按照<a href="https://github.com/inducer/pymetis" target="_blank" rel="noopener">官网</a>实现一下<code>pymetis</code>(版本：2020.1)的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pymetis</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">(filename)</span>:</span></span><br><span class="line">    adjacency_list = []</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            temp = line.split(<span class="string">' '</span>)</span><br><span class="line">            adjacency_list.append(np.array([int(temp[<span class="number">0</span>]), int(temp[<span class="number">1</span>])]))</span><br><span class="line">    <span class="keyword">return</span> adjacency_list</span><br><span class="line"></span><br><span class="line">adjacency_list = read_data(<span class="string">'email-Eu-core.txt'</span>)</span><br><span class="line">print(len(adjacency_list))</span><br><span class="line"></span><br><span class="line">since = time.time()</span><br><span class="line">n_cuts, membership = pymetis.part_graph(<span class="number">100</span>, adjacency=adjacency_list)</span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line">print(end - since)</span><br></pre></td></tr></table></figure>
<p>程序执行时间在0.35秒到0.5秒之间。虽然我们在叶子节点处理中加入了额外的信息处理，但<code>pymetis</code>执行的时间还包括反粗划分与图划分，所以我们的程序还有较大的改进空间。比如多进程、使用numpy代替list等等，<strong>前路漫漫，还需努力</strong>。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>个人还是比较喜欢这类论文的，将程序设计和理论分析完美融合。<del>不会写程序只会发论文的计算机人我通常认为是在耍流氓，不去写代码而只是高高在上的提所谓的idea，其实根本不知道底层发生了什么。</del></p>
<p>最后感谢我的<a href="https://github.com/dajiaozhu" target="_blank" rel="noopener">师姐</a>，在双胞胎处理、亲戚节点处理、图融合上提出了关键性想法，使得程序圆满开发成功。（她在写代码这方面真的很聪明的！！！）</p>
<p>也许有读者能看出来，这部分代码是为了图划分做准备，但图融合只是图划分的上游任务。关于<strong>大规模图划分</strong>我想说的：</p>
<ul>
<li>如果使用传统启发式算法，图融合，图划分，最后反粗划分，这种思路和算法大概率已经烂大街了，<strong>无非是一丢丢可有可无的改进</strong>。所以边割率、平衡率和速度要<strong>远远好于目前的成果</strong>才算可以。即使发了论文也不一定有人看，毕竟大家都知道是那套东西。或者说，图划分的算法复杂度更多的取决于分割的算法，融合只是上游任务。</li>
<li>如果使用图神经网络去划分，用哪种图网络是一个问题，GraphSAGE？GAT？此外损失函数如何设计又是一个问题，如何把边割率和平衡率融入到一个函数里，这更像是多目标优化。而且也会牵扯到其他问题，图的节点、边该如何用数字去表示。假设这几个问题都解决了，那么，网络训练又是一个问题，能否收敛？收敛的快不快？图神经网络便无法再用时间复杂度$O(n)$去衡量，毕竟要迭代好几次呢，每次迭代可能也要很久。</li>
<li>我看了近几年论文，在大规模图划分上并没有发现有做的很好的。<strong>如果取得了很好的结果或有突破性思路</strong>，时间慢一点应该可以被接受。如果效果只是好了一点点但付出了巨大的时间、计算资源的代价，个人认为只具备学术论文价值，但不具备工程实际应用的价值，所以我个人不看好这个方向。</li>
<li>图分割很大程度上是为下游任务提供支持，如生物、化学、交通网络等。<strong>其效率比起效果更应该受到重视</strong>。但神经网络的训练代价太大，程序消耗过多时间在图分割上，<strong>甚至需要GPU</strong>反而是本末倒置。传统算法用着CPU都划分完了，且结果也不是很差，神经网络还在那用着2080反向传播，loss还很大，这说不过去。</li>
<li>图的节点、边该如何用数字去表示？关于这一点，已经有不少图嵌入表示的论文了。但那些表示是否适合图划分却不得而知，或者说，需不需要为了图划分而单独的去设计一种图嵌入表示算法。</li>
<li>loss的收敛问题。关于这一点，<del>我认为是个坑</del>，或者需要一些数学工具去优化。我尝试过简单的将边割率、平衡率的损失直接相加，结果震荡的很严重。且边割率会受到平衡率的影响，即总体loss在下降，平衡率loss在下降，但边割率的loss却在上升，所以整体loss下降只是因为平衡率loss下降了。我也尝试过分批训练，即前200个epoch训练平衡率，后200个epoch训练边割率，如此轮回，但损失还是震荡或者回升。关于这一点，<del>我并没有很好的想法</del>。学完《工程优化》这门课程后发现这是多目标优化的问题，需要将神经网络的多任务学习变成多目标优化，这个在顶会上已经有不少的论文了，可以借鉴下他人的思路。</li>
<li>如果说使用神经网络算法去完成图划分，<strong>时间比启发式算法快，且效果比它还要好</strong>。今年的顶会就是您的，这也许会颠覆目前图划分的思想和现有的图划分软件，可惜我目前并没有这个实力和突破性的想法。</li>
</ul>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>黄山自由行攻略</title>
    <url>/2019/05/01/Mount-Huang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>江南烟雨下的青石古木</li>
<li>古巷里的袅袅炊烟</li>
<li>天青色等烟雨下的黑白风徽州style</li>
<li>小桥流水人家的无言守护</li>
<li>云海翻腾的婉约黄山</li>
</ul>
<p><img data-src="/2019/05/01/Mount-Huang/10.jpg" alt></p>
<a id="more"></a>
<!-- <div class="note default"><p> -->
<p>一直想看的南方，终于见到了！！！</p>
<h1 id="旅行计划"><a href="#旅行计划" class="headerlink" title="旅行计划"></a>旅行计划</h1><h2 id="必携带"><a href="#必携带" class="headerlink" title="必携带"></a>必携带</h2><ul>
<li>身份证</li>
<li>学生证</li>
<li>车票</li>
</ul>
<h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><ul>
<li>从北京出发（4.26）</li>
<li>宏村（4.27上午）</li>
<li>九龙瀑，翡翠谷（4.27下午）</li>
<li>黄山（4.28）</li>
<li>返程（4.29）</li>
<li>返校（4.30）</li>
</ul>
<h2 id="携带物品"><a href="#携带物品" class="headerlink" title="携带物品"></a>携带物品</h2><ul>
<li>登山杖可有可无。</li>
<li>手套没必要。</li>
<li>雨披不管用，一定要有雨裤和鞋套，不然裤子和鞋子湿透的感觉很爽。</li>
<li>山区不要打伞，自己被雷击不要紧，关键是很窄的山路你打伞影响其他人。</li>
<li>某些景点比较陡峭，鞋子一定防滑。</li>
<li>耐磨，大容量，舒适的书包（山顶一盘青菜80块，一瓶水20块，土豪随意）。</li>
<li>带够水，爬山过程如果遭遇艳阳高照还是很渴的。</li>
<li>护膝，很多地方是笔直的几百米的下楼梯，很消耗膝盖。</li>
<li>衣服不要纯棉，要速干的。</li>
</ul>
<h1 id="旅行攻略"><a href="#旅行攻略" class="headerlink" title="旅行攻略"></a>旅行攻略</h1><h2 id="自由行还是报团"><a href="#自由行还是报团" class="headerlink" title="自由行还是报团"></a>自由行还是报团</h2><p>&emsp;&emsp;当然是自由行，黄山景区的交通、路线、超市等已经开发的相当方便（山底的超市正常物价，山顶的物价 so so so expensive），不用担心没有车的问题。另外山顶4G满格没问题。只要到了黄山，公交、住宿十分方便，开着导航一切OK。以我上山所见的旅游团，走的慢慢悠悠还挡路，到了景点把地方一占开始拍照，挺烦的。重点是跟团不自由，有的景点就给几分钟然后集合，有的景点去不了。</p>
<p><img data-src="/2019/05/01/Mount-Huang/1.jpg" alt></p>
<h2 id="黄山路线"><a href="#黄山路线" class="headerlink" title="黄山路线"></a>黄山路线</h2><p>&emsp;&emsp;到黄山站（黄山北也行），出站就有公交站点，扫描公交站牌上的二维码，就有黄山公交的电子卡了，很方便。</p>
<ul>
<li>在火车站坐公交前往屯溪的游客集散中心，到市区的时候被甜甜的空气迷倒了，可能是在华北地区吸雾霾太多了（到了屯溪就能准备出发去黄山）</li>
<li>从屯溪到汤口（黄山山底），屯溪的黑车太多，还伪装工作人员，搞得我差点就信了。</li>
<li>在黄山山底买公交票和景区门票到景区（黄山山底到景区入口有16公里，还是坐车好点，另外含29块钱的保险和15块钱的免费导游，就是山上的导游免费为你服务，而且还可以不跟着导游走），一波S型环山公路后到达景区门口。景区入口可以买小黄帽的上山索道票，进去再买太挤了。</li>
<li>黄山景区入口在云谷寺，坐索道上去（没必要把体力浪费在没有风景的7.5公里的上山路程（这里需要爬2.5小时的上坡山路，没必要），后期几十公里的山路更累），而且从山底的大雾到山顶的云海，坐索道看的这一切很梦幻，看到云海的那一刻感觉所有的一路颠簸都值了，所以推荐索道上山。</li>
<li>可以在山脚的某个地方拿个地图。关于地图上景区，最好用BFS算法遍历地图，上山转3/4的景区，我每天操场五圈的体力看3/4的景区，耗费的时间是从上午八点到下午四点。剩下的1/4景区下山看，如果一天看完全部景区能累死。</li>
<li>关于景区，最好要挑阴雨天去，在阴雨来临之前上山（山底阴天，山顶晴天），下雨来临前云层聚集，这样就能看到传说中特别美的云海。但是阴雨天的云层加厚上升，大部分的山，日落，星空，日出是看不见的。不过无所谓，山这种东西可以在别的地方看，云海是真的美，美到极品。通常大家运气都不好，因为南方的雨下起来基本没完没了，不像北方下雨劈里啪啦的快速了事。看到云海就看不见山，看见山就看不到云海。另外，黄山一年只有50天有云海，机不可失。</li>
<li>下山在玉屏景区索道下车，我是懒得跟这十公里的山路费劲了。（因为我有幸看到了云海，雨越下越大遭遇了暴雨，距离只有400米的迎客松都懒得去看）</li>
<li>返回时，景区出口买门票到屯溪，屯溪买票到火车站。</li>
</ul>
<p><img data-src="/2019/05/01/Mount-Huang/3.jpg" alt></p>
<h2 id="宏村路线"><a href="#宏村路线" class="headerlink" title="宏村路线"></a>宏村路线</h2><p>&emsp;&emsp;屯溪到宏村就行了，买官方人员的票，屯溪车站黑车太多，还装工作人员，我差点信了。宏村民风很好，拦着我送吃的给我（免费，当时我是拒绝的，小姐姐说“你别绕着我走啊~”）。但是说实话，宏村的风景也有点失望，村子入口、月沼、水圳、古巷看完了基本就没了，一个半小时足够。我是逛完宏村后直接在宏村买的到汤口的票准备登山了。</p>
<p><img data-src="/2019/05/01/Mount-Huang/7.jpg" alt></p>
<h2 id="九龙瀑和翡翠谷"><a href="#九龙瀑和翡翠谷" class="headerlink" title="九龙瀑和翡翠谷"></a>九龙瀑和翡翠谷</h2><p>&emsp;&emsp;在汤口出发，滴滴（10-20块）或者公交（5块），虽然公交的官方人员长的像票贩子。说实话这两个景区的广告做的不错，但是是真的不值票价（还有个安徽的学校的学生冒充学生证被工作人员拦下，后面那个学生打电话说再给我来四个学生证，虽然是个好学校，但是学生不诚信也能表示这个学校育人很垃圾了），九龙瀑是一个细的不行的瀑布，翡翠谷是一个绿池子就没了。电影《卧虎藏龙》在九龙瀑和宏村取景，所以宏村和九龙瀑借助电影使劲的吹，其实这个电影拍的好是因为剧本写得好演员到位，跟取景没有关系，在哪取景都一样的。而且这两个景区存在坑钱的行为，刚开始说免费拍照，觉得不错，后来发现拍出来的照片需要购买。就是拍照是免费的，取照片收费，10块钱一张照片。其实我感觉一个照片5毛就可以了，我说送给你们景区当纪念了，我不要了扭头就走。走到一半阿姨说10块两张，我没搭理她，走到门口她说10块3张，然后我还是走了。对待不诚信的人就得这样，反正我不买他是白折腾。如果时间紧，这两个景区就别看了。</p>
<p><img data-src="/2019/05/01/Mount-Huang/2.jpg" alt></p>
<h2 id="老街路线"><a href="#老街路线" class="headerlink" title="老街路线"></a>老街路线</h2><p>&emsp;&emsp;我是最后一天去的老街，在看完黄山之后返回火车站，距离火车出发还早，于是坐公交（前文提到的公家卡）去老街溜了圈，在18楼俯瞰整个黄山市是黑白色的建筑，正好赶上天青色的烟雨。古朴的建筑和淳朴的民风，一条街好多东西都免费吃。买了个书签和特产就回来了，反正不贵。</p>
<p><img data-src="/2019/05/01/Mount-Huang/4.jpg" alt></p>
<h1 id="饮食住宿"><a href="#饮食住宿" class="headerlink" title="饮食住宿"></a>饮食住宿</h1><h2 id="屯溪"><a href="#屯溪" class="headerlink" title="屯溪"></a>屯溪</h2><p>&emsp;&emsp;在屯溪就随便找酒店住了，我住的骏怡，标间有异味，可能都这样。自从上次去长白山住了一次万达度假区后，感觉其他的酒店住宿真的脏。食物的话去满园春吃的，还行，特产是毛豆腐和竹笋（新鲜，比我学校的新鲜多了）。购物的话去的避风港，应有尽有，老板还不错。</p>
<h2 id="汤口"><a href="#汤口" class="headerlink" title="汤口"></a>汤口</h2><p>&emsp;&emsp;到达汤口后，就在车站下车那里吃，特别便宜。我以为车站是贵的，就往里面走，越走越发现，里面的东西越来越贵。我住的云崖泉，反正是有点坑。饭菜贵不说，住宿的地方沐浴液和洗发水是别人用一半剩下的，Are you kidding me? 即使没有洁癖，还是感觉不爽。听了一夜的雨，早上出发去登山了。</p>
<h2 id="山顶"><a href="#山顶" class="headerlink" title="山顶"></a>山顶</h2><p>&emsp;&emsp;山顶的食物和住宿不要想了，80一盘青菜，20一瓶水，1000块钱一个标间，土豪随意。我这种穷学生呢，自己背的食物和水，阴天是5瓶水，晴天可能得多带。食物是中午一个面包，三根火腿，一个士力架；晚上是5个达利园，一袋酸奶，一个火腿，第二天的早饭他们提供，不用担心。住宿的话住的光明顶山庄（是观看日出的最高点）的招待所，7张上下铺，好几个人每人一百多凑齐1000块233333，不过不如自己搭帐篷，晚上别人的呼噜声太大了233333。而且我睡觉的时候他看电影开外放，声音贼大的那种。没人想听你那破电影，TM不知道带个耳机吗。</p>
<p><img data-src="/2019/05/01/Mount-Huang/6.jpg" alt></p>
<h1 id="杂事记录"><a href="#杂事记录" class="headerlink" title="杂事记录"></a>杂事记录</h1><p>&emsp;&emsp;不要在人多的地方挤，后面的风景更美（很多人体力不好走不到那里），黄山美不美，全靠两条腿。</p>
<p>&emsp;&emsp;汤口有个叫好再来的饭店，价格可以而且饭菜还行；有个叫好又多的超市，有两个老外登山直接买的啤酒，老板娘看了他们一眼，说“together, twenty”，原来开超市还需要如此深厚的英语功底，不厚道的笑了出来。后面看到工作人员也用流利的英语和老外交流，说的内容我没听出来，可能本科毕业也找不到工作了吧。</p>
<p>&emsp;&emsp;民风还可以，没给我瞎指路。（反正我有导航）</p>
<p>&emsp;&emsp;爬山还看到了俄罗斯的小姐姐，真他娘的好看，肤白貌美前凸后翘，身材匀称优美，一看就是健康饮食，不像国内的众多女生以瘦为美，正长身体和发育的年纪减什么肥，该吃吃该喝喝~。还有个外国小姐姐穿着校服去的。</p>
<p><img data-src="/2019/05/01/Mount-Huang/5.jpg" alt></p>
<p>&emsp;&emsp;还碰到了一个学计算机的大哥，十年前大学毕业。别人问电视怎么接通的，他随口一说铜轴电缆，我感觉就是同行，后来还真是。出生湖北在深圳工作，一路结伴走了下来，在世界上最大的半导体公司ASM上班，还有头发，看来不错。因为我遭遇了暴雨，去他的宾馆吹干了我的鞋子和衣服，后来一起吃了顿饭就告别了，似乎能理解到古人离别的心情和不爽。此去经年，有缘再见。</p>
<p><img data-src="/2019/05/01/Mount-Huang/8.jpg" alt></p>
<hr>
]]></content>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>华北理工大学数学建模协会竞赛信息管理软件</title>
    <url>/2020/02/01/NCSTModel/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>耗时4个月<del>主要是我懒老拖着</del>，终于大概算写完了这款软件吧，也是我第一次写这么大的软件。从入门学习GUI，到自己写，到数据库，到部署，到处都是知识盲区，<del>主要是自己太垃圾了</del>。</p>
<p><img data-src="/2020/02/01/NCSTModel/1.jpg" alt></p>
<p>部署服务器，反向代理，防火墙开放端口，数据库操作，自动化测试，系统日志等等等等，一切对我来说都是茫然的，自己还很菜，要走的路还很长。事实证明，参加比赛之后，还是要回归工程，学以致用，大学专业课的知识还是有用的啊。如计算机网络，如数据库等，很遗憾我学的并不好，都是后期现学现查。</p>
<p>此项目的代码都在github上，是我的私人仓库，如果你想继续本软件的开发(<code>pyqt5+sqlalchemy+alembic</code>)，可以联系我，到时候在邀请你。</p>
<a id="more"></a>
<p>当然，如果你只是本博客的游客，只是单纯的想问下我这个软件的某些功能如何实现，留言或邮箱均可，我也可以告诉你。实在不便开源代码，望理解。</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>同样，本软件也存在缺点，如下：</p>
<p><img data-src="/2020/02/01/NCSTModel/2.jpg" alt></p>
<p>可以集成<code>Matplotlib, pyqtgraph, pyecharts</code>等可视化工具在软件中进行简单的分析，奈何我太菜，写不出来。</p>
<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>这里是华北理工大学数学建模协会制作的竞赛信息管理软件version 1.0。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="确认身份界面"><a href="#确认身份界面" class="headerlink" title="确认身份界面"></a>确认身份界面</h2><p>选择自己是管理员还是游客，只能二选一，且选择管理员后，需要账号和密码登录。</p>
<p><img data-src="/2020/02/01/NCSTModel/3.jpg" alt></p>
<h2 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h2><p>输入账号和密码进行登录，超级管理员解锁信息管理和录入信息两个界面，普通管理员解锁录入信息界面，外来游客不可进行信息管理和信息录入。当然，胡乱的输入肯定不行：</p>
<p><img data-src="/2020/02/01/NCSTModel/4.jpg" alt></p>
<h2 id="信息管理界面"><a href="#信息管理界面" class="headerlink" title="信息管理界面"></a>信息管理界面</h2><p>由超级管理员负责管理，负责维护竞赛信息等。超级管理员的账号以<code>@admin</code>结尾，解锁所有权限，可删除除<code>wuyuhang@admin</code>外的所有账号。</p>
<p><img data-src="/2020/02/01/NCSTModel/5.jpg" alt></p>
<p>普通管理员只解锁录入信息界面，不解锁信息管理界面。</p>
<p><img data-src="/2020/02/01/NCSTModel/6.jpg" alt></p>
<p>所以在注册普通管理员时，不要以此结尾，进行普通注册即可，如账号：<code>201614420112</code>，密码：<code>123456</code>。</p>
<ul>
<li>账号管理：超级管理员的账号最长为20位，管理员帐号最长20位，密码最长20位，账号不能重复。</li>
<li>教师管理：工号唯一，不能重复。</li>
<li>学院专业管理：输入专业时，左侧一定要有学院名，否则会报错，因为不知道该专业是哪个学院的。</li>
<li>竞赛管理：竞赛名称唯一，不能重复。</li>
</ul>
<p><img data-src="/2020/02/01/NCSTModel/7.jpg" alt></p>
<h2 id="录入信息界面"><a href="#录入信息界面" class="headerlink" title="录入信息界面"></a>录入信息界面</h2><p>负责录入学生比赛记录、删除记录等。</p>
<ul>
<li>建模博客：录入后会展示在建模博客界面。</li>
<li>录入比赛：录入单条学生信息。</li>
<li>删除信息：输入学生的学号，得到要删除的记录号，输入要删除的记录号即可删除。（因一个学生会参加多个比赛，学号会重复，所以不能按学号进行删除）。</li>
<li>快速录入：待完成。</li>
</ul>
<p>删除比赛场景：</p>
<p><img data-src="/2020/02/01/NCSTModel/8.jpg" alt></p>
<p>录入单条比赛，你是谁，学号，专业，性别，教师，获奖名，获奖级别，何时参赛，何时获奖都会录入。</p>
<p><img data-src="/2020/02/01/NCSTModel/9.jpg" alt></p>
<h2 id="查询信息界面"><a href="#查询信息界面" class="headerlink" title="查询信息界面"></a>查询信息界面</h2><ul>
<li>导出数据：超级管理员可以按时间、比赛为索引，选择全部比赛或部分比赛，导出<code>csv</code>格式的文件。</li>
<li>其他所有人员可按教师查询和按学生查询。</li>
</ul>
<p>导出CSV文件：</p>
<p><img data-src="/2020/02/01/NCSTModel/10.jpg" alt></p>
<p>按教师查询：</p>
<p><img data-src="/2020/02/01/NCSTModel/11.jpg" alt></p>
<h2 id="建模博客界面"><a href="#建模博客界面" class="headerlink" title="建模博客界面"></a>建模博客界面</h2><p>收录建模学子自己手动搭建的博客，不收录CSDN、知乎、博客园、简书等依赖第三方平台搭建的博客，无技术门槛，不值得收录。</p>
<p>点击后调用系统浏览器打开，建议使用<code>chrome</code>或<code>firefox</code>。</p>
<p><img data-src="/2020/02/01/NCSTModel/12.jpg" alt></p>
<h2 id="个人空间界面"><a href="#个人空间界面" class="headerlink" title="个人空间界面"></a>个人空间界面</h2><p>预留的组队信息、个人展示接口，暂时未开放。</p>
<h2 id="退出界面"><a href="#退出界面" class="headerlink" title="退出界面"></a>退出界面</h2><p>退出软件。</p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>由<code>pyinstaller</code>打包，暂时只支持windows系统64位。</p>
<p><a href="https://github.com/muyuuuu/NCST-MMA-Contest-Management-System-Public/releases" target="_blank" rel="noopener">NCSTModel软件下载</a></p>
<p>先准备测试，第一次开发软件，没有人带也没有公司开发的经验。不知道怎么配置合适，也不知道如何妥善的收尾，不知道需要生成哪些配置文件，不知道需要记录哪些日志文件，也不知道怎么优化体验等等等等，有问题请及时提供有效的反馈，毕业之前有时间的话，我会修改的。</p>
]]></content>
      <tags>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>C++数据结构篇『三』关联容器：映射与集合</title>
    <url>/2019/06/02/OJ-Cpp-cumulative/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>工欲善其事，必先利其器，使用恰当的数据结构去解决问题能事半功倍。因本人没有任何C++的基础，但在刷题的过程中遇到了一些数据结构的经典应用，且能借助STL中的容器很好的实现并解决任务。因此总结常用容器的用法，以供下次使用。</p>
<a id="more"></a>
<p>关联容器包括: map 和 set，字面意思的理解就是，map是字典，有键有对应的值；set是数学上的那个集合，元素无序，且没有重复元素。</p>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>常用的调用如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;&gt;里的第一个参数表示 key 的类型, 第二个参数表示 value 的类型</span></span><br><span class="line"><span class="comment">// 模板的实例化</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m1; </span><br><span class="line">m1[<span class="string">"Kobe"</span>] = <span class="number">100</span>;</span><br><span class="line">m1[<span class="string">"James"</span>] = <span class="number">99</span>;</span><br><span class="line">m1[<span class="string">"Curry"</span>] = <span class="number">98</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"Jordan"</span>)</span></span>;</span><br><span class="line">m1[s] = <span class="number">90</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m1[<span class="string">"Kobe"</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m1[<span class="string">"Jordan"</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//不存在这个 key，就显示 0</span></span><br><span class="line"><span class="comment">// 所以若存在有值为 0 的时候就需要格外注意</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m1[<span class="string">"Durant"</span>] &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="comment">//通过关键字来删除</span></span><br><span class="line">m1.erase(<span class="string">"Curry"</span>);</span><br><span class="line"><span class="comment">// 输出 map 的键和值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m1-&gt;first;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m1-&gt;second;</span><br><span class="line"><span class="comment">// pair 的意思是将两个数据组合成一个数据</span></span><br><span class="line"><span class="comment">//也可以通过insert函数来实现增加元素</span></span><br><span class="line">m1.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(<span class="string">"Harris"</span>, <span class="number">89</span>));</span><br><span class="line"><span class="comment">// 域分隔符 value_type 函数</span></span><br><span class="line">m1.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">100</span>, <span class="string">"zhangsan"</span>));</span><br><span class="line"><span class="comment">// 全部元素的遍历</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator itr;</span><br><span class="line"><span class="comment">// 按 key 升序</span></span><br><span class="line"><span class="keyword">for</span> (itr = m1.begin(); itr != m1.end(); itr++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="string">" : "</span> &lt;&lt; itr-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空全部</span></span><br><span class="line">m1.clear();</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。</p>
<p><strong>输入格式：</strong></p>
<p>输入第一行给出一个正整数 $N（≤ 50 000）$，是已知夫妻/伴侣的对数；随后 $N$ 行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 $M（≤ 10 000）$，为参加派对的总人数；随后一行给出这 $M$ 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。</p>
<p><strong>输出格式：</strong></p>
<p>首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。</p>
<p><strong>输入样例：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">11111 22222</span><br><span class="line">33333 44444</span><br><span class="line">55555 66666</span><br><span class="line">7</span><br><span class="line">55555 44444 10000 88888 22222 11111 23333</span><br></pre></td></tr></table></figure></p>
<p><strong>输出样例：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">10000 23333 44444 55555 88888</span><br></pre></td></tr></table></figure></p>
<h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>使用 map 这种数据结构，将夫妻关系进行映射即可，单身狗即为在映射中查找不到的人。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; couple;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">100002</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v, v1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> str1, str2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">        <span class="keyword">if</span> (str1 == <span class="number">0</span>) str1 = <span class="number">100001</span>;</span><br><span class="line">        <span class="keyword">if</span> (str2 == <span class="number">0</span>) str2 = <span class="number">100001</span>;</span><br><span class="line">        couple[str1] = str2;</span><br><span class="line">        couple[str2] = str1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    v.resize(m);</span><br><span class="line">    v1.resize(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 有人可能是夫妻 但另一方不参加聚会 也是单身狗</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>) temp = <span class="number">100001</span>;</span><br><span class="line">        arr[temp] = <span class="number">1</span>;</span><br><span class="line">        v[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 map 中存在，且 数组两端均为 1 表示不单身（两人都在）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (couple[v[i]] != <span class="number">0</span> &amp;&amp; arr[v[i]] == <span class="number">1</span> &amp;&amp; arr[couple[v[i]]] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            v1.push_back(v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sort(v1.begin(), v1.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d"</span>, v1[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %05d"</span>, v1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><h2 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">showset</span>(<span class="title">set</span>&lt;T&gt; <span class="title">v</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">typename</span> <span class="built_in">set</span>&lt;T&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动排序，从小到大，剔除相同项</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1&#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span> &#125;; </span><br><span class="line">showset(s1);</span><br><span class="line"><span class="comment">// 字典序 排序</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s2&#123; <span class="string">"hello"</span>,<span class="string">"sysy"</span>,<span class="string">"school"</span>,<span class="string">"hello"</span> &#125;; </span><br><span class="line">showset(s2);</span><br><span class="line"><span class="comment">// 有这个值了，do nothing</span></span><br><span class="line">s1.insert(<span class="number">9</span>);</span><br><span class="line">showset(s1);</span><br><span class="line"><span class="comment">// 没有这个字符串，添加并且排序</span></span><br><span class="line">s2.insert(<span class="string">"aaa"</span>); </span><br><span class="line">showset(s2);</span><br></pre></td></tr></table></figure>
<p>同样，若在集合中插入结构体等数据，我们可以重载 <code>&lt;, &gt;</code> 等运算符，实现集合内元素的自动排序。</p>
<h2 id="其他常见调用"><a href="#其他常见调用" class="headerlink" title="其他常见调用"></a>其他常见调用</h2><p>在使用 <code>multiset</code> 时，也只需引用头文件 <code>set</code> 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> values[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(values, values + <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator p;</span><br><span class="line"><span class="keyword">for</span> (p = s.<span class="built_in">begin</span>(); p != s.<span class="built_in">end</span>(); p++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">s.insert(<span class="number">12</span>);</span><br><span class="line">s.insert(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认降序</span></span><br><span class="line"><span class="comment">// multiset&lt;int, greater&lt;int&gt; &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找 2 第一次出现</span></span><br><span class="line">p = s.lower_bound(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 查找 2 最后一次出现</span></span><br><span class="line">p = s.upper_bound(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line">p = s.<span class="built_in">find</span>(<span class="number">13</span>);</span><br><span class="line"><span class="keyword">if</span> (p == s.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.count(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有的 2</span></span><br><span class="line">s.erase(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (p = s.<span class="built_in">begin</span>(); p != s.<span class="built_in">end</span>(); p++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记</title>
    <url>/2019/09/04/PAT/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关于上次说的失眠，又莫名其妙的好了，和失眠和解了。</p>
<p>当初脑门一热报名了PAT的考试，现在是还债的时候了。大概这几天整理了常见的题型和操作，当然距离大佬还差的很远，都后悔报名了，就当去写代码玩一玩。毕竟算法还是计算机的看家本事。中途也问了问已经工作的算法工程师，得到了如下的回答，不过努力都不会白费的。不知何时能有柳神一半强。</p>
<p><img data-src="/2019/09/04/PAT/1.png" alt></p>
<p>大量代码摘抄自这里：<a href="https://github.com/liuchuo/PAT/tree/master/AdvancedLevel_C%2B%2B" target="_blank" rel="noopener">https://github.com/liuchuo/PAT/tree/master/AdvancedLevel_C%2B%2B</a></p>
<p>有的代码人家写出来了，不过我实在看不懂。</p>
<a id="more"></a>
<h1 id="杂项整理"><a href="#杂项整理" class="headerlink" title="杂项整理"></a>杂项整理</h1><ul>
<li>多项式相乘有$x$。</li>
<li>Each case contains a positive integer $N$, followed by $N$ positive numbers. All the numbers in the input are less than 100。读题错误，意思是，$N$后面的$N$个数才是要处理的。</li>
<li>int 的取值范围很大，大于$2^{31}$，小于$10^7$。实在不行再去long long，虽然不知道哪里不对。</li>
</ul>
<h2 id="读输入"><a href="#读输入" class="headerlink" title="读输入"></a>读输入</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3.2</span><span class="number">.1</span> <span class="number">10.16</span><span class="number">.27</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld.%lld.%lld %lld.%lld.%lld"</span>, &amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span>/<span class="number">5</span> <span class="number">4</span>/<span class="number">15</span> <span class="number">1</span>/<span class="number">30</span> <span class="number">-2</span>/<span class="number">60</span> <span class="number">8</span>/<span class="number">3</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) 	</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld/%lld"</span>, &amp;a, &amp;b);</span><br></pre></td></tr></table></figure>
<h2 id="判断是否为数字"><a href="#判断是否为数字" class="headerlink" title="判断是否为数字"></a>判断是否为数字</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> n, <span class="keyword">long</span> <span class="keyword">long</span> radix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = n.rbegin(); it != n.rend(); it++) &#123;</span><br><span class="line">        temp = <span class="built_in">isdigit</span>(*it) ? *it - <span class="string">'0'</span> : *it - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">        sum += temp * <span class="built_in">pow</span>(radix, index++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断是否为素数"><a href="#判断是否为素数" class="headerlink" title="判断是否为素数"></a>判断是否为素数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= (<span class="keyword">int</span>) <span class="built_in">sqrt</span>((<span class="keyword">double</span>) n); i++) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大公约最小公倍"><a href="#最大公约最小公倍" class="headerlink" title="最大公约最小公倍"></a>最大公约最小公倍</h2><h2 id="最大公约"><a href="#最大公约" class="headerlink" title="最大公约"></a>最大公约</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小公倍"><a href="#最小公倍" class="headerlink" title="最小公倍"></a>最小公倍</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>, b = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = a &gt; b ? a : b; </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">max</span> % a == <span class="number">0</span> &amp;&amp; <span class="built_in">max</span> % b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"LCM = "</span> &lt;&lt; <span class="built_in">max</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ++<span class="built_in">max</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// str中存储的是逆序的，在逆序输出即可</span></span><br><span class="line"><span class="keyword">while</span>(num != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    str += to_string(num % radix);</span><br><span class="line">    num = num / radix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果转的是13进制，需要考虑字母：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (num != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">13</span> &gt;= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a.push_back((<span class="keyword">char</span>)(<span class="string">'A'</span> + num % <span class="number">13</span> - <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a += to_string(num % <span class="number">13</span>);</span><br><span class="line">    num = num / <span class="number">13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尽量不要三层循环"><a href="#尽量不要三层循环" class="headerlink" title="尽量不要三层循环"></a>尽量不要三层循环</h2><p>容易超时。如甲级 1104 。Given a sequence of positive numbers, a segment is defined to be a consecutive subsequence. For example, given the sequence { 0.1, 0.2, 0.3, 0.4 }, we have 10 segments: (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) and (0.4)。Now given a sequence, you are supposed to find the sum of all the numbers in all the segments. For the previous example, the sum of all the 10 segments is 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三层循环超时代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key; i++)</span><br><span class="line">&#123;</span><br><span class="line">    b[i] = b[i] / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> temp1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; key; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp1 += b[k];</span><br><span class="line">        &#125;</span><br><span class="line">        temp1 += b[j];</span><br><span class="line">    &#125;</span><br><span class="line">    sum += temp1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2f"</span>, sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正解代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">    <span class="comment">// i * (n - i + 1) 是temp的出现次数</span></span><br><span class="line">    sum = sum + temp * i * (n - i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2f"</span>, sum);</span><br></pre></td></tr></table></figure>
<h2 id="截取子串转数字"><a href="#截取子串转数字" class="headerlink" title="截取子串转数字"></a>截取子串转数字</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int num = stoi(t);</span><br><span class="line">string t = s.substr(i, k);</span><br></pre></td></tr></table></figure>
<h2 id="级数展开"><a href="#级数展开" class="headerlink" title="级数展开"></a>级数展开</h2><p>$\sum_{i=0}^ka_ib^i$,若以$b$为base，系数$a_i$是<code>a%b</code>，然后逆序。</p>
<h2 id="集合使用"><a href="#集合使用" class="headerlink" title="集合使用"></a>集合使用</h2><p>​        集合与数学中的集合同一个概念，无重复项。初始化集合的时候还会自动升序。集合的交集、并集、对称差是很常见的操作，但小心超时。集合的算术运算在C++中的体现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前四个参数为两个集合的开始和结束位置迭代器，最后一个迭代器为结果集合的插入迭代器</span></span><br><span class="line"><span class="comment">// 均需要#inlcude&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line">set_intersection(x1.<span class="built_in">begin</span>(),x1.<span class="built_in">end</span>(),x2.<span class="built_in">begin</span>(),x2.<span class="built_in">end</span>(),inserter(x,x.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line">set_union(x1.<span class="built_in">begin</span>(),x1.<span class="built_in">end</span>(),x2.<span class="built_in">begin</span>(),x2.<span class="built_in">end</span>(),inserter(x,x.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line">set_difference(x1.<span class="built_in">begin</span>(),x1.<span class="built_in">end</span>(),x2.<span class="built_in">begin</span>(),x2.<span class="built_in">end</span>(),inserter(x,x.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure>
<p>​        甲级1063。<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805409175420928" target="_blank" rel="noopener">Set Similarity</a> 。如果使用了差集和交集的话，最后一个测试点超时。</p>
<p>​        超时代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_query</span><span class="params">(<span class="keyword">int</span> query1, <span class="keyword">int</span> query2, <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//交集</span></span><br><span class="line">    set_intersection(v[query1].<span class="built_in">begin</span>(), v[query1].<span class="built_in">end</span>(), v[query2].<span class="built_in">begin</span>(), v[query2].<span class="built_in">end</span>(), inserter(common, common.<span class="built_in">begin</span>()));</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = common.<span class="built_in">begin</span>(); it != common.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 差集</span></span><br><span class="line">    <span class="keyword">float</span> b = v[query2].<span class="built_in">size</span>();</span><br><span class="line">    set_difference(v[query1].<span class="built_in">begin</span>(), v[query1].<span class="built_in">end</span>(), common.<span class="built_in">begin</span>(), common.<span class="built_in">end</span>(), inserter(diff, diff.<span class="built_in">begin</span>()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = diff.<span class="built_in">begin</span>(); it != diff.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line">    diff.<span class="built_in">clear</span>();</span><br><span class="line">    common.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// cout &lt;&lt; b &lt;&lt; "  ";</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, a/b*<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"%"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, a/b*<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"%"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        后来发现，题上并没有说明确的求出差集和并集，不如直接遍历集合，对并集和差集的数量直接计数即可，没必要真的去求。正常代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_query</span><span class="params">(<span class="keyword">int</span> query1, <span class="keyword">int</span> query2, <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> b = v[query2].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = v[query1].<span class="built_in">begin</span>(); it != v[query1].<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查询内容时要 *it</span></span><br><span class="line">        <span class="keyword">if</span> (v[query2].<span class="built_in">find</span>(*it) == v[query2].<span class="built_in">end</span>())</span><br><span class="line">            b++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, a/b*<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"%"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, a/b*<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"%"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="链表处理"><a href="#链表处理" class="headerlink" title="链表处理"></a><strong>链表处理</strong></h1><h2 id="链表删除（空间换时间）"><a href="#链表删除（空间换时间）" class="headerlink" title="链表删除（空间换时间）"></a><strong>链表删除（空间换时间）</strong></h2><p>​        <strong>甲级1097。<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805369774129152" target="_blank" rel="noopener">Deduplication on a Linked List</a>  。问题：删除链表中重复的元素或者绝对值相等的元素。</strong></p>
<p>​        <strong>错误思路会面临超时危险：时间复杂度为$O(n^2)$。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = add; i != <span class="number">-1</span>; i = node[i].next)</span><br><span class="line">&#123;</span><br><span class="line">    temp = node[i].key;</span><br><span class="line">    <span class="comment">// 从 i+1 的后面遍历链表，时间复杂度O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = node[i].next; j != <span class="number">-1</span>; j = node[j].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果值相等，或者是绝对值，并且还没有被删除</span></span><br><span class="line">        <span class="keyword">if</span> ( ((node[j].key == temp ) || (node[j].key == -temp &amp;&amp; temp &lt;= <span class="number">0</span>)) &amp;&amp; (node[j].flag == <span class="literal">true</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// false表示被删除</span></span><br><span class="line">            node[j].flag = <span class="literal">false</span>;</span><br><span class="line">            node2[cnt2] = node[j];</span><br><span class="line">            cnt2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上一层for循环没有波及到，即不存在值相同，就赋值到另一个链表内</span></span><br><span class="line">    <span class="keyword">if</span> (node[i].flag == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node1[cnt1] = node[i];</span><br><span class="line">        cnt1++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        <strong>超时的原因并不是每次都需要计算<code>node[i].next</code>或者<code>j=node[i].next</code>，我自己又重新写了一份，用空间换取时间，即使用<code>i</code>自增的形式访问，每次用计算，但还是超时，主要原因是算法复杂度过高。</strong></p>
<p>​        <strong>错误的空间换取时间的例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 额外创建空间，but没用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = add; i != <span class="number">-1</span>; i = node[i].next)</span><br><span class="line">&#123;</span><br><span class="line">    node[i].flag = <span class="literal">true</span>;</span><br><span class="line">    node3[cnt] = node[i];</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 算法时间复杂度没有改变，只是以i自增的形式访问，并没有快多少</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">&#123;</span><br><span class="line">    temp = node3[i].key;</span><br><span class="line">    <span class="comment">// j 自增的形式访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; cnt; j ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ((node3[j].key == temp ) || (node3[j].key == -temp &amp;&amp; temp &lt;= <span class="number">0</span>)) &amp;&amp; (node3[j].flag == <span class="literal">true</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            node3[j].flag = <span class="literal">false</span>;</span><br><span class="line">            node2[cnt2] = node3[j];</span><br><span class="line">            cnt2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node3[i].flag == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node1[cnt1] = node3[i];</span><br><span class="line">        cnt1++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        <strong>正确的空间换取时间的例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 额外创建这么多数组</span></span><br><span class="line"><span class="keyword">bool</span> exist[maxn];  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(NODE a, NODE b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num &lt; b.num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">begin</span>; i != <span class="number">-1</span>; i = node[i].next) &#123;</span><br><span class="line">    <span class="comment">// 没有访问直接添加进来</span></span><br><span class="line">    <span class="keyword">if</span>(exist[<span class="built_in">abs</span>(node[i].key)] == <span class="literal">false</span>) &#123;</span><br><span class="line">        exist[<span class="built_in">abs</span>(node[i].key)] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// cnt 是 num 的值，也表明了先后的访问顺序</span></span><br><span class="line">        <span class="comment">// 根据num排序，就是确定了链表的顺序</span></span><br><span class="line">        node[i].num = cnt1;</span><br><span class="line">        cnt1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        node[i].num = maxn + cnt2;</span><br><span class="line">        cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(node, node + maxn, cmp1);</span><br><span class="line"><span class="comment">// 最后输出 cnt1 + cnt2 个节点就可以了</span></span><br></pre></td></tr></table></figure>
<h2 id="部分子链表反序（物理不相邻改为逻辑相邻）"><a href="#部分子链表反序（物理不相邻改为逻辑相邻）" class="headerlink" title="部分子链表反序（物理不相邻改为逻辑相邻）"></a><strong>部分子链表反序（物理不相邻改为逻辑相邻）</strong></h2><p>​        <strong>甲级 1074。<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805394512134144" target="_blank" rel="noopener">Reversing Linked List</a> 。题目要求，把链表穿起来，然后对数值反序，此时开始位置跟着反序，指向的下一个位置开始变化指向下一节点。</strong></p>
<p>​        <strong>思路：创建两个结构体。第一个结构体的索引是起始位置，第一个值也是起始位置，访问，穿起来，并赋值给第二个结构体，第二个结构体的索引是自增的$i$，只需要对第二个结构体反序就可以了。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> add, key, next;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">&#125; node[<span class="number">100005</span>], node1[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">line</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;k, &amp;n);</span><br><span class="line">    <span class="comment">// 结构体下标是起始地址的原因是便于访问</span></span><br><span class="line">    node[a] = &#123;a, k, n, <span class="literal">false</span>&#125;;            </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 避免暴力破解</span></span><br><span class="line"><span class="comment">// 对于逻辑不相邻的链表直接逆序 是很复杂的</span></span><br><span class="line"><span class="comment">// 因此需要创建新链表，根据原来链表的物理位置使得新链表逻辑相邻，逆序就简单了</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = add; i != <span class="number">-1</span>; i = node[i].next) &#123;   </span><br><span class="line">    <span class="comment">// node[i] 直接索引到具体结构体</span></span><br><span class="line">    node[i].flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 赋值进来，cnt计数，用于后期逆序</span></span><br><span class="line">    node1[cnt] = node[i];                       </span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i += re)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i + re &gt; cnt)       <span class="comment">// 后半部分无法逆转</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(node1 + i, node1 + i + re);   <span class="comment">// 逆序子链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链表调整完毕，输出即可</span></span><br></pre></td></tr></table></figure>
<h2 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a><strong>链表排序</strong></h2><p>​        <strong>甲级 1052 。 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805425780670464" target="_blank" rel="noopener">Linked List Sorting</a> 。面临的问题是，对两列数组进行排序，如何使得一列的顺序跟随另一列的顺序变化？答案是使用结构体。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> address, key, next;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">&#125;node[<span class="number">100000</span>];</span><br><span class="line"><span class="comment">// 如果a,b都没有被访问过，a.flag==b.flag==0，按a.flag &gt; b.flag排列会被放到最后面</span></span><br><span class="line"><span class="comment">// 如果a,b被访问过，就按 a.key &lt; b.key 从小到大排列，数组的两个数一起变化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(NODE a, NODE b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !a.flag || !b.flag ? a.flag &gt; b.flag : a.key &lt; b.key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, cnt = <span class="number">0</span>, s, a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        node[a] = &#123;a, b, c, <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s; i != <span class="number">-1</span>; i = node[i].next) &#123;</span><br><span class="line">        node[i].flag = <span class="literal">true</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 -1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对数组整体进行排序</span></span><br><span class="line">        sort(node, node + <span class="number">100000</span>, cmp1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %05d\n"</span>, cnt, node[<span class="number">0</span>].address);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d %d "</span>, node[i].address, node[i].key);</span><br><span class="line">            <span class="keyword">if</span>(i != cnt - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%05d\n"</span>, node[i + <span class="number">1</span>].address);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求最大后缀"><a href="#求最大后缀" class="headerlink" title="求最大后缀"></a><strong>求最大后缀</strong></h2><p>​        <strong>甲级 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805460652113920" target="_blank" rel="noopener">Sharing</a> 1032 暴力破解超时的危险。</strong></p>
<p>​        <strong>题目：给定$N\times 3$的数组，第一列起始地址，第二列数值，第三列是下一个字母的起始地址。按照地址拼接成两个单词，求这两个单词后缀相同部分的起始地址。</strong></p>
<p><strong><code>Sample Input :</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11111 22222 9</span><br><span class="line">67890 i 00002</span><br><span class="line">00010 a 12345</span><br><span class="line">00003 g -1</span><br><span class="line">12345 D 67890</span><br><span class="line">00002 n 00003</span><br><span class="line">22222 B 23456</span><br><span class="line">11111 L 00001</span><br><span class="line">23456 e 67890</span><br><span class="line">00001 o 00010</span><br></pre></td></tr></table></figure>
<p><strong><code>Sample Output :</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">67890</span><br><span class="line">（注：LoaDing 和 Being 的最大后缀是ing，i的起始位置为67890）</span><br></pre></td></tr></table></figure>
<p>​        <strong>我的错误思路：一次for循环，按地址顺序找到两个单词并存储。从两个单词的后面开始遍历，如果相等，就count+1，直到不相等为止，记录位置的字母，暴力循环找到这个字母的起始位置然后然后输出。因为暴力破解次数过多，结果直接完美 RunTime Error  和 Time Limit Exceeded。</strong></p>
<p>​        <strong>错误代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按输入地址的顺序，找到两个单词</span></span><br><span class="line"><span class="comment">// i =- 1 是因为 i 赋值后进入下一轮for循环的第一件事就是i++</span></span><br><span class="line"><span class="comment">// 会错过 i = 0 的情况</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (add[i][<span class="number">0</span>] == add1)</span><br><span class="line">    &#123;</span><br><span class="line">        word1.push_back(value[i]);</span><br><span class="line">        add1 = add[i][<span class="number">1</span>];</span><br><span class="line">        i = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (add[i][<span class="number">0</span>] == add2)</span><br><span class="line">    &#123;</span><br><span class="line">        word2.push_back(value[i]);</span><br><span class="line">        add2 = add[i][<span class="number">1</span>];</span><br><span class="line">        i = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 两个单词，从后向前，寻找相等部分的长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">110</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (word1.substr(word1.length()-i) == word2.substr(word2.length()-i))</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再次遍历数组，找到和最大后缀第一个字母value[i]相等的，add[i][0]就是起始地址</span></span><br><span class="line"><span class="keyword">if</span> (count &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    count ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (value[i] == word1[word1.length() - count])</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; add[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        <strong>正解思路：</strong></p>
<p>​        <strong>用结构体数组存储，node[i]表示地址为i的结点，key表示值，next为下一个结点的地址，flag表示第一条链表有没有该结点。</strong><br><strong>​        遍历第一条链表，将访问过的结点的flag都标记为true，当遍历第二条结点的时候，如果遇到了true的结点就输出并结束程序。因为一旦相同，都会接到同一个起始地址。就是没有遇到就输出-1。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> key;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">&#125;node[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s1, s2, n, a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;s1, &amp;s2, &amp;n);</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %c %d"</span>, &amp;a, &amp;data, &amp;b);</span><br><span class="line">        node[a] = &#123;data, b, <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s1; i != <span class="number">-1</span>; i = node[i].next)</span><br><span class="line">        node[i].flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s2; i != <span class="number">-1</span>; i = node[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[i].flag == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d"</span>, i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="大数处理"><a href="#大数处理" class="headerlink" title="大数处理"></a><strong>大数处理</strong></h1><h2 id="大数加法"><a href="#大数加法" class="headerlink" title="大数加法"></a><strong>大数加法</strong></h2><p><strong><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805478658260992" target="_blank" rel="noopener">        Have Fun with Numbers</a> 甲级1023。注意是原来数据的排列组合，不是出现就行。此类大数计算题目可以用python强行爆破，我测试了一下，python空间和时间是C++的10倍，谨慎使用。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k = int(input())</span><br><span class="line">a = k * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">k = str(k)</span><br><span class="line">a = str(a)</span><br><span class="line">c = a</span><br><span class="line"></span><br><span class="line">a = list(a)</span><br><span class="line">k = list(k)</span><br><span class="line"></span><br><span class="line">a.sort()</span><br><span class="line">k.sort()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == k):</span><br><span class="line">    print(<span class="string">'Yes\n'</span> + c, end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'No\n'</span> + c, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>​        <strong>学习思路：使用char数组存储这个数，每个数的数位乘以2 + 进位，同时设立book来标记数位出现的情况。只有最后book的每个元素都是0的时候才说明这两个数字是相等的一个排列结果。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> num[<span class="number">22</span>];</span><br><span class="line"><span class="comment">// 输入那个大数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, num);</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>, len = <span class="built_in">strlen</span>(num);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = num[i] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="comment">// 原始序列中出现的数值都保留下来</span></span><br><span class="line">    book[temp]++;</span><br><span class="line">    <span class="comment">// 乘以2 加上进位</span></span><br><span class="line">    temp = temp * <span class="number">2</span> + flag;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        temp = temp - <span class="number">10</span>;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num[i] = (temp + <span class="string">'0'</span>);</span><br><span class="line">    <span class="comment">// 2倍序列后出现的数字就--</span></span><br><span class="line">    <span class="comment">// 可以应对不同的排列顺序</span></span><br><span class="line">    book[temp]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(book[i] != <span class="number">0</span>)</span><br><span class="line">        flag1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数字、字符、逆序"><a href="#数字、字符、逆序" class="headerlink" title="数字、字符、逆序"></a><strong>数字、字符、逆序</strong></h2><p>​        <strong>甲级1024。<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805476473028608" target="_blank" rel="noopener">Palindromic Number</a> 存在较多的数字转字符，字符逆序转数字，C++不易操作，不如直接开python。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = input()</span><br><span class="line"></span><br><span class="line">n, k = a.split()</span><br><span class="line"></span><br><span class="line">n, k = int(n), int(k)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge_pal</span><span class="params">(pal)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> (pal == pal[::<span class="number">-1</span>]):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, k):</span><br><span class="line">    x = judge_pal(str(n))</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>):</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        print(str(n) + <span class="string">'\n'</span> + str(i), end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        n = n + int(str(n)[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">    print(str(n) + <span class="string">'\n'</span> + str(k), end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<h1 id="图专题"><a href="#图专题" class="headerlink" title="图专题"></a>图专题</h1><h2 id="连通分量计数"><a href="#连通分量计数" class="headerlink" title="连通分量计数"></a>连通分量计数</h2><p>​        甲级 1013 。<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840" target="_blank" rel="noopener">Battle Over Cities</a> 。给出n个城市之间有相互连接的m条道路，当删除一个城市和其连接的道路的时候，问其他几个剩余的城市至少要添加多少个路线才能让它们重新变为连通图。</p>
<p>​        分析：添加的最少的路线，就是他们的连通分量数-1，因为当a个互相分立的连通分量需要变为连通图的时候，只需要添加a-1个路线，就能让他们相连。所以这道题就是求去除了某个结点之后其他的图所拥有的连通分量数。</p>
<p>​        使用邻接矩阵存储，对于每一个被占领的城市，去除这个城市结点，就是把它标记为已经访问过，这样在深度优先遍历的时候，对于所有未访问的结点进行遍历，就能求到所有的连通分量的个数～记得因为有很多个要判断的数据，每一次输入被占领的城市之前要把visit数组置为false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> adj[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    visit[node] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//  == 1 确保有这个节点</span></span><br><span class="line">        <span class="keyword">if</span>(visit[i] == <span class="literal">false</span> &amp;&amp; adj[node][i] == <span class="number">1</span>)</span><br><span class="line">            dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  m, k, a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> city1, city2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; city1 &gt;&gt; city2;</span><br><span class="line">        adj[city1][city2] = adj[city2][city1] = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// k 个需要计算的城市</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 所有节点设置为false，要求的节点设为 true</span></span><br><span class="line">        <span class="comment">// 孤立这个节点，看看有几个连通分量</span></span><br><span class="line">        <span class="built_in">fill</span>(visit, visit + <span class="number">1010</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        visit[a] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果一个节点没有被访问，就遍历</span></span><br><span class="line">        <span class="comment">// 然后和这个节点相邻的节点都为true，免得重复遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[j] == <span class="literal">false</span>) &#123;</span><br><span class="line">                dfs(j);</span><br><span class="line">                <span class="comment">// 记录连通子图的数量</span></span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连通分量 - 1，就是要修建的路数，变为连通图 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连通分量遍历（DFS）"><a href="#连通分量遍历（DFS）" class="headerlink" title="连通分量遍历（DFS）"></a>连通分量遍历（DFS）</h2><p>​        给出n个结点之间的n条边，问是否能构成一棵树，如果不能构成则输出它有的连通分量个数。如果能构成一棵树，如何遍历才会使得这个树的深度最高？求此时的根结点。如果有多个，按照从小到大输出。</p>
<p>​        如果只有一个连通分量，就两次深度优先搜索，先从一个结点<strong>DFS</strong>后保留最高高度拥有的结点们，然后从这些结点中的其中任意一个开始<strong>DFS</strong>得到最高高度的结点们，这两个结点集合的并集就是所求。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> adj[<span class="number">10004</span>][<span class="number">10004</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">10004</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> max_height = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> <span class="built_in">height</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visit[node] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">height</span> &gt; max_height)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        max_height = <span class="built_in">height</span>;</span><br><span class="line">        v.push_back(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">height</span> == max_height)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (adj[node][i] == <span class="number">1</span> &amp;&amp; visit[i] == <span class="literal">false</span>)</span><br><span class="line">            dfs(i, <span class="built_in">height</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        adj[a][b] = adj[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill</span>(visit, visit + <span class="number">10004</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visit[i] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(i, <span class="number">1</span>);</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="comment">// 如果是一个树，i == 1已经加入所有的最长路径</span></span><br><span class="line">            &#123;   <span class="comment">// 如果不是，集合s到后面反正也没用</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v.<span class="built_in">size</span>(); j++)</span><br><span class="line">                    s.insert(v[j]); <span class="comment">// 不重复，升序的保留最高节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: "</span> &lt;&lt; cnt &lt;&lt; <span class="string">" components"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> root = v[<span class="number">0</span>]; <span class="comment">// 选取一个最为遍历的开始</span></span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        max_height = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">fill</span>(visit, visit + <span class="number">10004</span>, <span class="literal">false</span>);</span><br><span class="line">        dfs(root, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">        s.insert(v[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *it);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连通分量遍历求最大权值-DFS"><a href="#连通分量遍历求最大权值-DFS" class="headerlink" title="连通分量遍历求最大权值(DFS)"></a>连通分量遍历求最大权值(DFS)</h2><p>甲级 1034 。 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805456881434624" target="_blank" rel="noopener">Head of a Gang</a> 。 </p>
<p>首先要根据字符串来标记节点，因此，设立map映射，对于给定字符串就有一个确定值，以此来设立邻接矩阵的下标。同时map也会自动排序字符的顺序。思路比较经典，可以多读代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; stringToInt;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; intToString;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">int</span> idNumber = <span class="number">1</span>, k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ID号记录人数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoifunc</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stringToInt[s] == <span class="number">0</span>) &#123;</span><br><span class="line">        stringToInt[s] = idNumber;</span><br><span class="line">        intToString[idNumber] = s;</span><br><span class="line">        <span class="keyword">return</span> idNumber++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stringToInt[s];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[<span class="number">2010</span>][<span class="number">2010</span>], weight[<span class="number">2010</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参改变取值，在上次遍历基础上继续 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> &amp;head, <span class="keyword">int</span> &amp;numMember, <span class="keyword">int</span> &amp;totalweight)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    numMember++;</span><br><span class="line">    <span class="keyword">if</span>(weight[u] &gt; weight[head])</span><br><span class="line">        head = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt; idNumber; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(G[u][v] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            totalweight += G[u][v];</span><br><span class="line">            <span class="comment">// 走过一次防止下次还走 </span></span><br><span class="line">            G[u][v] = G[v][u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[v] == <span class="literal">false</span>)</span><br><span class="line">                dfs(v, head, numMember, totalweight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 自动排序映射 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsTrave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; idNumber; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> head = i, numMember = <span class="number">0</span>, totalweight = <span class="number">0</span>;</span><br><span class="line">            dfs(i, head, numMember, totalweight);</span><br><span class="line">            <span class="keyword">if</span>(numMember &gt; <span class="number">2</span> &amp;&amp; totalweight &gt; k)</span><br><span class="line">                ans[intToString[head]] = numMember;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; w;</span><br><span class="line">        <span class="keyword">int</span> id1 = stoifunc(s1);</span><br><span class="line">        <span class="keyword">int</span> id2 = stoifunc(s2);</span><br><span class="line">        <span class="comment">// 有了这么多人 </span></span><br><span class="line">        weight[id1] += w;</span><br><span class="line">        weight[id2] += w;</span><br><span class="line">        <span class="comment">// 两人的权重 += w </span></span><br><span class="line">        G[id1][id2] += w;</span><br><span class="line">        G[id2][id1] += w;</span><br><span class="line">    &#125;</span><br><span class="line">    dfsTrave();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = ans.<span class="built_in">begin</span>(); it != ans.<span class="built_in">end</span>(); it++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="到某点的路径最多-BFS"><a href="#到某点的路径最多-BFS" class="headerlink" title="到某点的路径最多(BFS)"></a>到某点的路径最多(BFS)</h2><p>甲级 1076 。 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805392092020736" target="_blank" rel="noopener">Forwards on Weibo</a> 。 </p>
<p>题目大意：给出每个用户关注的人的id，和转发最多的层数，求一个id发了条微博最多会有多少个人转发.</p>
<p>分析：带层数的广度优先，因为一个用户只能转发一次，所以用inq判断当前结点是否入队过了，如果入队过了就不能重复入队（重复转发消息），inq 邻接表v 都可以使用int只存储id，queue的数据类型必须为node，同时保存它的id和layer层数，控制不超过L层～.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, l, m, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, layer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(node tnode)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 第二次可能继续访问，可以重复 </span></span><br><span class="line">    <span class="keyword">bool</span> inq[<span class="number">1010</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">    q.push(tnode);</span><br><span class="line">    inq[tnode.id] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        node top = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> topid = top.id;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[topid].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextid = v[topid][i];</span><br><span class="line">            <span class="comment">// 没有超出层数限制 ，防止循环访问自己，导致数量偏多 </span></span><br><span class="line">            <span class="keyword">if</span>(inq[nextid] == <span class="literal">false</span> &amp;&amp; top.layer &lt; l) &#123;</span><br><span class="line">                node next = &#123;nextid, top.layer + <span class="number">1</span>&#125;;</span><br><span class="line">                q.push(next);</span><br><span class="line">                inq[next.id] = <span class="literal">true</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;l);</span><br><span class="line">    v.resize(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">            <span class="comment">// 压入跟随者 </span></span><br><span class="line">            v[temp].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">int</span> tid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tid);</span><br><span class="line">        node tnode = &#123;tid, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 将查询编号视为结构体bfs </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bfs(tnode));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="Dijsktra算法"><a href="#Dijsktra算法" class="headerlink" title="Dijsktra算法"></a>Dijsktra算法</h2><p>此处参考：<a href="https://www.liuchuo.net/archives/tag/dijkstra" target="_blank" rel="noopener">https://www.liuchuo.net/archives/tag/dijkstra</a></p>
<h3 id="求最短路径的距离"><a href="#求最短路径的距离" class="headerlink" title="求最短路径的距离"></a>求最短路径的距离</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> n, e[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> dis[maxv], pre[maxv];<span class="comment">// pre用来标注当前结点的前一个结点</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;  <span class="comment">// S 是出发点</span></span><br><span class="line">  <span class="built_in">fill</span>(dis, dis + maxv, inf);</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) pre[i] = i; <span class="comment">//初始状态设每个点的前驱为自身</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">-1</span>, minn = inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(visit[j] == <span class="literal">false</span> &amp;&amp; dis[j] &lt; minn) &#123;</span><br><span class="line">        u = j;</span><br><span class="line">        minn = dis[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>; <span class="comment">// u 没有更新，到处都是无穷距离</span></span><br><span class="line">    visit[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(visit[v] == <span class="literal">false</span> &amp;&amp; e[u][v] != inf &amp;&amp; dis[u] + e[u][v] &lt; dis[v]) &#123;</span><br><span class="line">        dis[v] = dis[u] + e[u][v];</span><br><span class="line">        pre[v] = u; <span class="comment">// pre用来标注当前结点的前一个结点</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出最短路径经过的节点"><a href="#输出最短路径经过的节点" class="headerlink" title="输出最短路径经过的节点"></a>输出最短路径经过的节点</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(v == s) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(s, pre[v]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新增边权"><a href="#新增边权" class="headerlink" title="新增边权"></a>新增边权</h3><p>要求在最短路径有多条时要求路径上的花费之和最小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123; <span class="comment">//重写v的for循环</span></span><br><span class="line">  <span class="keyword">if</span>(visit[v] == <span class="literal">false</span> &amp;&amp; e[u][v] != inf) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[u] + e[u][v] &lt; dis[v]) &#123;</span><br><span class="line">      dis[v] = dis[u] + e[u][v];</span><br><span class="line">      c[v] = c[u] + cost[u][v];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dis[u] + e[u][v] == dis[v] &amp;&amp; c[u] + cost[u][v] &lt; c[v]) &#123;</span><br><span class="line">      c[v] = c[u] + cost[u][v];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新增点权"><a href="#新增点权" class="headerlink" title="新增点权"></a>新增点权</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(visit[v] == <span class="literal">false</span> &amp;&amp; e[u][v] != inf) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[u] + e[u][v] &lt; dis[v]) &#123;</span><br><span class="line">      dis[v] = dis[u] + e[u][v];</span><br><span class="line">      w[v] = w[u] + weight[v];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dis[u] + e[u][v] == dis[v] &amp;&amp; w[u] + weight[v] &gt; w[v]) &#123;</span><br><span class="line">      w[v] = w[u] + weight[v];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问有多少条最短路径"><a href="#问有多少条最短路径" class="headerlink" title="问有多少条最短路径"></a>问有多少条最短路径</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(visit[v] == <span class="literal">false</span> &amp;&amp; e[u][v] != inf) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[u] + e[u][v] &lt; dis[v]) &#123;</span><br><span class="line">      dis[v] = dis[u] + e[u][v];</span><br><span class="line">      num[v] = num[u];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dis[u] + e[u][v] == dis[v]) &#123;</span><br><span class="line">      num[v] = num[v] + num[u];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h3><p>甲级1003 。  <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">Emergency</a> 。 题目大意：n个城市m条路，每个城市有救援小组，所有的边的边权已知。给定起点和终点，求从起点到终点的最短路径条数以及最短路径上的救援小组数目之和。如果有多条就输出点权（城市救援小组数目）最大的那个～</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, c1, c2;</span><br><span class="line"><span class="keyword">int</span> e[<span class="number">510</span>][<span class="number">510</span>], weight[<span class="number">510</span>], dis[<span class="number">510</span>], num[<span class="number">510</span>], w[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">99999999</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;c1, &amp;c2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;weight[i]);</span><br><span class="line">    <span class="built_in">fill</span>(e[<span class="number">0</span>], e[<span class="number">0</span>] + <span class="number">510</span> * <span class="number">510</span>, inf);</span><br><span class="line">    <span class="built_in">fill</span>(dis, dis + <span class="number">510</span>, inf);</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        e[a][b] = e[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[c1] = <span class="number">0</span>;</span><br><span class="line">    w[c1] = weight[c1];</span><br><span class="line">    num[c1] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minn = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[j] == <span class="literal">false</span> &amp;&amp; dis[j] &lt; minn) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minn = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        visit[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[v] == <span class="literal">false</span> &amp;&amp; e[u][v] != inf) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[u] + e[u][v] &lt; dis[v]) &#123;</span><br><span class="line">                    dis[v] = dis[u] + e[u][v];</span><br><span class="line">                    num[v] = num[u]; <span class="comment">// 救援队的数量</span></span><br><span class="line">                    w[v] = w[u] + weight[v]; <span class="comment">// 点权</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dis[u] + e[u][v] == dis[v]) &#123;</span><br><span class="line">                    num[v] = num[v] + num[u];</span><br><span class="line">                    <span class="keyword">if</span>(w[u] + weight[v] &gt; w[v]) <span class="comment">// 点权大也要更新</span></span><br><span class="line">                        w[v] = w[u] + weight[v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, num[c2], w[c2]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>一个简单的例子。懒到不想画图。</p>
<p><img data-src="/2019/09/04/PAT/2.jpg" alt></p>
<p>简单的应用：</p>
<p>甲级 1118 。 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805354108403712" target="_blank" rel="noopener">Birds in Forest</a> .一幅画里面的鸟为同一棵树上的，问有多少棵树和多少只鸟，以及对于两只鸟判断是否在同一个树上～如果这个算法难以理解，那么就手动模拟一下，我当时手动模拟程序执行了两页A4纸才搞明白。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bird[<span class="number">10001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father, isRoot;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="comment">// 查找树根的特定写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = x;</span><br><span class="line">	<span class="keyword">while</span> (x != father[x])</span><br><span class="line">		x = father[x];</span><br><span class="line">	<span class="keyword">while</span>(a != father[a])&#123;</span><br><span class="line">		<span class="keyword">int</span> z = a;</span><br><span class="line">		a = father[a]; </span><br><span class="line">		father[z] = x;<span class="comment">// 经过的节点的根节点都是x	</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 归并的固定写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="keyword">int</span> faB = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(faA != faB) father[faA] = faB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	father.resize(n + <span class="number">1</span>);</span><br><span class="line">	isRoot.resize(n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		father[i] = i;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a; j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b);</span><br><span class="line">			<span class="keyword">if</span> (bird[b] == <span class="number">0</span>)&#123;</span><br><span class="line">				s.insert(b);</span><br><span class="line">				bird[b] = i;</span><br><span class="line">			&#125; <span class="comment">// i 是新的，find(bird[b])是旧的，两集合合并</span></span><br><span class="line">			Union(i, <span class="built_in">find</span>(bird[b]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 判断有几个根节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        isRoot[<span class="built_in">find</span>(i)]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isRoot[i] != <span class="number">0</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">" "</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> n1; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)&#123;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">    	<span class="keyword">if</span> (<span class="built_in">find</span>(bird[a]) == <span class="built_in">find</span>(bird[b]))</span><br><span class="line">    		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">    		<span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个复杂的并查集：</p>
<p>甲级 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805356599820288" target="_blank" rel="noopener">Family Property</a> . 就是统计的时候有点复杂，读入一次数据就需要合并，最后记录到解里面统一处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DATA</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, fid, mid, num, area;</span><br><span class="line">    <span class="keyword">int</span> cid[<span class="number">10</span>];</span><br><span class="line">&#125;data[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, people;</span><br><span class="line">    <span class="keyword">double</span> num, area;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">&#125;ans[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = x;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x])</span><br><span class="line">        x = father[x];</span><br><span class="line">    <span class="keyword">while</span>(a != father[a])&#123;</span><br><span class="line">    	<span class="keyword">int</span> z = a;</span><br><span class="line">    	a = father[a];</span><br><span class="line">    	father[z] = x;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并规则是：输出最小的ID </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="keyword">int</span> faB = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(faA &gt; faB)</span><br><span class="line">        father[faA] = faB;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(faA &lt; faB)</span><br><span class="line">        father[faB] = faA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.area != b.area)</span><br><span class="line">        <span class="keyword">return</span> a.area &gt; b.area;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        father[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;data[i].id, &amp;data[i].fid, &amp;data[i].mid, &amp;k);</span><br><span class="line">        visit[data[i].id] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[i].fid != <span class="number">-1</span>) &#123;</span><br><span class="line">            visit[data[i].fid] = <span class="literal">true</span>;</span><br><span class="line">            Union(data[i].fid, data[i].id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data[i].mid != <span class="number">-1</span>) &#123;</span><br><span class="line">            visit[data[i].mid] = <span class="literal">true</span>;</span><br><span class="line">            Union(data[i].mid, data[i].id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data[i].cid[j]);</span><br><span class="line">            visit[data[i].cid[j]] = <span class="literal">true</span>;</span><br><span class="line">            Union(data[i].cid[j], data[i].id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;data[i].num, &amp;data[i].area);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每个根节点代表的家庭开始计算 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="built_in">find</span>(data[i].id);</span><br><span class="line">        ans[id].id = id;</span><br><span class="line">        ans[id].num += data[i].num;</span><br><span class="line">        ans[id].area += data[i].area;</span><br><span class="line">        ans[id].flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i])</span><br><span class="line">            ans[<span class="built_in">find</span>(i)].people++;</span><br><span class="line">        <span class="comment">// 计算根节点数量 </span></span><br><span class="line">        <span class="keyword">if</span>(ans[i].flag)</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i].flag) &#123;</span><br><span class="line">            ans[i].num = (<span class="keyword">double</span>)(ans[i].num * <span class="number">1.0</span> / ans[i].people);</span><br><span class="line">            ans[i].area = (<span class="keyword">double</span>)(ans[i].area * <span class="number">1.0</span> / ans[i].people);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans, ans + <span class="number">10000</span>, cmp1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%04d %d %.3f %.3f\n"</span>, ans[i].id, ans[i].people, ans[i].num, ans[i].area);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数学计算类"><a href="#数学计算类" class="headerlink" title="数学计算类"></a>数学计算类</h1><p>待整理。</p>
<p>1059，1019，1010，1103，1085，1061。 </p>
<p>明天背背常见的语法、工具和函数写法，希望接下来的日子一切顺利吧。</p>
<h1 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h1><p>等开个新的专题吧。还差的很远。</p>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT甲级整理</title>
    <url>/2020/09/07/PAT-advanced/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对我会做的甲级题目进行了分类整理，仅代表我个人的分类，不是很严谨。如有的题可以哈希，也可以 <code>map</code>；有的题是字符串的处理，但也涉及到了素数什么的。</p>
<p>此外，甲级以字符串处理、数组使用、数据精度为简单题目；借助结构体实现多条件排序，通常难度适中，就是排序规则有点复杂；而树、图涉及到的数据结构为中等难度的题，这类题目建议按类型刷，能够举一反三；30分的题为难度大的题目，涉及到动态规划和一些算法等，以我目前对算法的接触而言，我不太会那些。</p>
<ul>
<li>20分：稍微复杂的编程应用，逻辑复杂，但不涉及数据结构；</li>
<li>25分：常见数据结构的应用，如树、图、链表等；</li>
<li>30分：有的会，大部分我不会，就放过了。</li>
</ul>
<p>整体而言，不适合刚入门 OJ 的同学进行练手，用来熟练编程和掌握基本数据结构还是可以的。</p>
<a id="more"></a>
<h1 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h1><p>整理的题目是我会的，没整理在内的是我不会的。能力一般，智商有限，有的题目看答案并仔细钻研是能看懂的，剩下的是看答案都看不懂的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>题目类型</th>
<th>题目</th>
</tr>
</thead>
<tbody>
<tr>
<td>素数</td>
<td>1015</td>
</tr>
<tr>
<td>数据精度</td>
<td>1058，1065，1081</td>
</tr>
<tr>
<td>数组应用</td>
<td>1046，1042，1029(选择中位数)，1117，1067，1113，1128(N皇后判断)，1125，1082(极度繁琐，我抄的)，1002，1008，1009(与1002类似)，1011，1019，1041，1045，1046，1048，1054，1085，1109，1148</td>
</tr>
<tr>
<td>字符串处理</td>
<td>1035(<code>vector</code>应用)，1073，1069(字符串转数字)，1077(最大公共后缀子串)，1140，1136，1108，1120，1001，1005，1006，1023，1024，1027，1031，1035，1042，1061，1069，1073，1084，1092，1093(子串匹配)，1100，1108，1112，1116，1120，1132</td>
</tr>
<tr>
<td>数学计算</td>
<td>1096，1104，1113，1117</td>
</tr>
<tr>
<td><code>map</code>应用</td>
<td>1041(可哈希)，1144(不可哈希)，1124，1112，1121，1149，1022，1071</td>
</tr>
<tr>
<td>哈希算法</td>
<td>1041(可<code>map</code>)，1121，1145(正宗哈希)，1050，1078(正宗哈希)</td>
</tr>
<tr>
<td>数据精度</td>
<td>1088，1136(写字符串加法)</td>
</tr>
<tr>
<td><code>vector</code>应用</td>
<td>1048</td>
</tr>
<tr>
<td>借助结构体的多条件排序</td>
<td>1025，1012，1028，1047，1055，1062，1075，1083，1070，1036，1141，1137，1153，1070</td>
</tr>
<tr>
<td>排序算法</td>
<td>1089(插入与归并)，1101(快速排序)</td>
</tr>
<tr>
<td>栈的应用</td>
<td>1051</td>
</tr>
<tr>
<td>树状数组</td>
<td>1057(无序数据的中位数)</td>
</tr>
<tr>
<td><code>set</code>应用</td>
<td>1129(操作符重载)，1063</td>
</tr>
<tr>
<td>动态规划</td>
<td>1040(最长对称子串)，1044，1045，1007(子序列和最大)</td>
</tr>
<tr>
<td>队列应用</td>
<td>1017</td>
</tr>
<tr>
<td>链表处理</td>
<td>1028，1032，1133，1052，1074，1097</td>
</tr>
<tr>
<td>树的应用</td>
<td>1004(层次遍历二叉树，输出叶子节点)，1102(层次、右根左遍历，反转二叉树)，1043(查找树、镜像查找树、先序、后序)，1064(完全查找树)，1099(按指定结构建立二叉查找树)，1110(判断完全二叉树，第六个测试点测评机器有问题)，1123(AVL树的层序遍历与判断是否是完全二叉树)，1066(寻找AVL树的根)，1130(中缀表达式)，1020(前序后序转层序)，1053(遍历树，求权重相等的路径)，1076(宽度优先遍历)，1079(深优遍历叶子节点)，1090(叶子节点数量)，1094(树中最长路径)，1106(树中最长路径与叶子数量)，1115(建立二叉查找树)</td>
</tr>
<tr>
<td>图的应用</td>
<td>1154(相邻顶点颜色是否相同)，1146(有向图的拓扑序列)，1122(哈密顿图的判断)，1134(无向图的顶点覆盖)，1142(极大团问题)，1126(欧拉回路)，1013(连通分量计数)，1021(计数图内最长路径，连通子图计数)</td>
</tr>
<tr>
<td>最短路径</td>
<td>1030(借助遍历)，1003(最短路径数量与点权求和)，</td>
</tr>
<tr>
<td>进制转换</td>
<td>1010</td>
</tr>
<tr>
<td>三维遍历</td>
<td>1091(dfs算法遍历三维数据)</td>
</tr>
<tr>
<td>旋转矩阵</td>
<td>1105</td>
</tr>
<tr>
<td>并查集</td>
<td>1107，1114，1118</td>
</tr>
</tbody>
</table>
</div>
<h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><ol>
<li><code>vector&lt;int&gt; a(10, 1)</code>的含义为声明一个长度为10的不定长数组且全部初始化为 1 。</li>
<li>当借助结构体的多条件排序需要比较的条件比较多时，可以考虑结构体中放数组。甲级1012。</li>
<li>求两个递增序列的中位数，直接<code>sort</code>会超时，且有更好的算法，提前计算中位数的位置即可。甲级1029。</li>
<li>运算的括号可能会加长运算时间而超时，也可考虑更换<code>cin</code>为<code>scanf</code>，<code>cout</code>为<code>printf</code>。甲级1055。</li>
<li>在使用<code>map</code>时，查找无效表示为0，所以在设立映射时的初始值应该为1而不是0。甲级1137。</li>
<li>简易判断完全二叉树的方法。甲级<code>1110-1.cpp</code>。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是<a href="https://muyuuuu.github.io/2020/08/21/PAT-basic/">乙级</a>整理的结果，可能接下来要去整理归纳一些算法题目了，刷完就忘还是相当于不会。或者说，<strong>追求做题数量是没有意义的。</strong></p>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级整理</title>
    <url>/2020/08/21/PAT-basic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对乙级题目进行了分类整理，仅代表我个人的分类，不是很严谨。如1087可以集合，也可以哈希；1079也有数字计算和进制转换，但核心问题是字符串处理；1094是判断素数，但也有求字符串子串的使用。</p>
<p>此外，乙级以字符串处理为简单题目，其中涉及：求子串、字符串查找、替换等多个考点，借助结构体实现多条件排序，通常难度适中，且需要借助<code>vector</code>等数据结构方能实现。建议按类型刷题。</p>
<ul>
<li>15分：简单的编程应用，涉及数组、分支、循环、判断等；</li>
<li>20分：比较复杂的编程应用，逻辑复杂，但不涉及数据结构；</li>
<li>25分：涉及简单的数据结构的使用，如<code>vector, map</code>等，不涉及算法，但涉及一些算法库的使用，如<code>algorithm</code>里的<code>sort</code>函数，同样需要合理设计逻辑，如哈希等，不然很容易出错。</li>
</ul>
<p>整体而言，适合刚入门 OJ 的同学进行练手，就当熟悉常见操作了。</p>
<a id="more"></a>
<h1 id="题目整理"><a href="#题目整理" class="headerlink" title="题目整理"></a>题目整理</h1><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>题目</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据精度与范围</td>
<td>1011，1034</td>
</tr>
<tr>
<td>进制转换</td>
<td>1022，1074</td>
</tr>
<tr>
<td>数组应用</td>
<td>1008，1061，1066，1092</td>
</tr>
<tr>
<td>素数判断</td>
<td>1007，1013，1094</td>
</tr>
<tr>
<td>哈希</td>
<td>1004，1005，1032， 1038，1047，1064，1072，1083</td>
</tr>
<tr>
<td>字符串处理</td>
<td>1002，1003，1006，1009，1014，1017，1018，1021，1023，1024，1027，1028，1029，1031，1033，1036，1039，1042，1043，1044，1048，1052，1056，1057，1067，1076，1078，1079，1081，1084，1086， 1091，1093</td>
</tr>
<tr>
<td>数学计算</td>
<td>1001，1010，1012，1016，1019，1020，1026，1030，1037，1046，1049，1051，1053，1054，1060，1062，1063，1070，1071，1077，1082，1088，1089</td>
</tr>
<tr>
<td>借助结构体的多条件排序</td>
<td>1015，1041，1055，1058，1073，1080，1085，1095</td>
</tr>
<tr>
<td>map映射</td>
<td>1059，1065，1069，1090</td>
</tr>
<tr>
<td>集合</td>
<td>1087</td>
</tr>
<tr>
<td>链表类</td>
<td>1025，1075</td>
</tr>
<tr>
<td>排序算法</td>
<td>1035，1045</td>
</tr>
<tr>
<td>子串匹配</td>
<td>1040</td>
</tr>
<tr>
<td>螺旋矩阵</td>
<td>1050</td>
</tr>
<tr>
<td>递归查找</td>
<td>1068</td>
</tr>
</tbody>
</table>
</div>
<h1 id="不知为何出错的题目"><a href="#不知为何出错的题目" class="headerlink" title="不知为何出错的题目"></a>不知为何出错的题目</h1><ul>
<li>1030 5分，看不懂题</li>
<li>1044 看不懂题在说什么，仿佛是为了考试而考试，没意思。</li>
<li>1088 18分，一个点没过</li>
<li>1033 19分，一个点没过</li>
<li>1073 14分，两个点没过，猜测算法设计的不好</li>
</ul>
<h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><p>本人没学过C++，第一次接触，记录的东西可能有点low。1003，1030看不懂题，不知道他在说什么。1005题目的描述实在花了很长时间才看懂。对于这些题目没有做的兴趣。</p>
<ol>
<li><code>scanf</code> 代替 <code>cin</code> 可在某种程度上避免超时。</li>
<li>快速排序前后，主元位置不变，否则常规思路会超时。乙级 1045。</li>
<li><code>stof</code>, <code>stoi</code> 完成字符串转数字。乙级 1054。</li>
<li><code>isdigital</code> 传入的变量是<code>char</code>类型。</li>
<li><code>if</code> <code>if</code> <code>else</code> 和 <code>if</code> <code>else if</code> <code>else</code> 对代码的执行结果影响不一样。</li>
<li><a href="https://blog.csdn.net/FX677588/article/details/52708813" target="_blank" rel="noopener">二维数组的定义</a>：传入常量不能传入参数。乙级1066。</li>
<li>输出<code>3</code>位数，高位补0：<code>printf(&quot;%03d &quot;, arr[i][j]);</code>。</li>
<li>哈希时要考虑空间大小，<code>int a[99999][99999]</code> 太大了，可以考虑使用 Map。乙级1090。</li>
<li><code>map</code>键对应的值不止一个时，值可以考虑用 <code>vector</code> 载入。</li>
<li>数字转字符串：<code>to_string()</code>，字符串逆序(algorithm)：<code>reverse(s.begin(), s.end());</code>，乙级1086。</li>
<li>虽然链表可以考虑顺序结构和链式结构实现，但巧妙的软换会比两者都好。乙级1075。</li>
<li><code>map</code>配合<code>hash</code>能有效提升程序的效率。乙级1065。</li>
<li>在不知数据量多少的情况下，读取所有输入 <code>while(cin &gt;&gt; temp)</code>。乙级1009。</li>
<li>尽量避免批量的命名数组，重复的操作很容易超时，同一种思维也能换一种写法。乙级1015。</li>
<li>虽然我不知道我的哪里错了，但学习到了<code>abs(j - i) * 1.0 / x != abs(j - i) / x</code>。乙级1088。</li>
<li><code>cin</code>时注意输入的与声明的数据类型是否有差异。乙级1053。</li>
<li>尽量不要操作一次删除一次，很容易超时，尽量以下标移动去解决问题。乙级1055。</li>
<li>乙级1085，差 <code>20ms</code> 超时。<code>if else</code>写法比三元运算符写法耗时。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node1 a, node1 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score != b.score)</span><br><span class="line">        <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.num != b.num)</span><br><span class="line">            <span class="keyword">return</span> a.num &lt; b.num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不如<code>return a.score != b.score ? a.score &gt; b.score : a.num != b.num ? a.num &lt; b.num : a.id &lt; b.id;</code></p>
<h1 id="Bug记录"><a href="#Bug记录" class="headerlink" title="Bug记录"></a>Bug记录</h1><p>自己发现了一个 <code>bug</code>，联系了官方，到现在也没个消息，但还是要提醒后来者。（发现时间是2020年2月份，如果它现在改了当我没说）。</p>
<p>在乙级1081题目中，我通过测试代码：虽然代码通过了测试，但仍然有 <code>BUG</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">int</span> digit = <span class="number">0</span>, alpha = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(<span class="built_in">cin</span> , temp);</span><br><span class="line">        <span class="keyword">if</span> (temp.length() &lt; <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Your password is tai duan le."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.length(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isdigit</span>(temp[j]) || <span class="built_in">isalpha</span>(temp[j]) || temp[j] == <span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(temp[j]))</span><br><span class="line">                        digit = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isalpha</span>(temp[j]))</span><br><span class="line">                        alpha = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Your password is tai luan le."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// break;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (digit == <span class="number">0</span> &amp;&amp; alpha == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Your password is tai luan le."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (digit == <span class="number">0</span> &amp;&amp; alpha == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Your password needs shu zi."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (alpha == <span class="number">0</span> &amp;&amp; digit == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Your password needs zi mu."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; alpha == <span class="number">1</span> &amp;&amp; digit == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Your password is wan mei."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">0</span>; digit = <span class="number">0</span>; alpha = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="太乱了测试点出错"><a href="#太乱了测试点出错" class="headerlink" title="太乱了测试点出错"></a>太乱了测试点出错</h2><p>上面代码虽然通过了它的测试，但有的测试点并没有正确工作。</p>
<p><img data-src="/2020/08/21/PAT-basic/bug.png" alt></p>
<h3 id="错误测试点"><a href="#错误测试点" class="headerlink" title="错误测试点"></a>错误测试点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">[[[[[[[[[[[[</span><br><span class="line">aaaaaaaaaaaaaa</span><br></pre></td></tr></table></figure>
<h1 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h1><p><a href="https://github.com/muyuuuu/OnlineJudgeSolutions/tree/master/PAT/乙级" target="_blank" rel="noopener">https://github.com/muyuuuu/OnlineJudgeSolutions/tree/master/PAT/%E4%B9%99%E7%BA%A7</a></p>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5通过信号实现MVC</title>
    <url>/2021/02/03/PyQt5-MVC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>众所周知MVC是个好东西。前阵子网上搜了下，但关于用<code>PyQt5</code>实现MVC的中文文档缺少之又少，优质的文档只搜到了一篇。既然这样，来，开个坑，学习新知识，<del>吸引流量。</del>话说，关于<code>PyQt5</code>，布局那里需要好好看看，容器类控件需要好好看看，还有多线程和自动化测试那块。但要写出完美GUI需要大量的代码经验和文档查询的能力。然后，嗯，这部分坑就填完了。</p>
<p>扯回正题：假设此时面临的场景是，一个软件涉及好几个页面，每个页面是单独的代码。且每个页面需要有自己的<code>controller</code>，最终所有的<code>controller</code>汇总到一起，统一管理。</p>
<p>本文中，文字只是辅助理解，务必读懂代码。</p>
<a id="more"></a>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>众所周知，GUI中当一个控件的状态改变时需要通知另一个控件，也就是实现了对象间的通信。当事件发生或状态改变时，就会发出信号，信号会触发与这个事件相关联的函数，我们这个函数为槽。信号与槽可以是多对多的关系。信号在类创建时定义，即需要在初始化的前面定义。</p>
<h2 id="自定义信号与槽"><a href="#自定义信号与槽" class="headerlink" title="自定义信号与槽"></a>自定义信号与槽</h2><p>别问，静静感受以下代码。以下的代码中，已经包含了信号的定义、指定参数的类型、发射、绑定槽函数等一系列过程。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QObject, pyqtSignal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 信号对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QSignal</span><span class="params">(QObject)</span>:</span></span><br><span class="line">    <span class="comment"># 定义信号</span></span><br><span class="line">    <span class="comment"># 在类创建时定义，不能在类创建后作为类的属性而添加</span></span><br><span class="line">    <span class="comment"># 指定信号传递参数的数量，类型等</span></span><br><span class="line">    send_msg = pyqtSignal(str, str)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(QSignal, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 信号发射</span></span><br><span class="line">        self.send_msg.emit(<span class="string">'First arg'</span>, <span class="string">'Second arg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 槽对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QSlot</span><span class="params">(QObject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(QSlot, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="comment"># 信号接收</span></span><br><span class="line">        print(<span class="string">"Get message =&gt;"</span> + args[<span class="number">0</span>], args[<span class="number">1</span>], sep=<span class="string">', '</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    send = QSignal()</span><br><span class="line">    slot = QSlot()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将信号与槽函数绑定</span></span><br><span class="line">    send.send_msg.connect(slot.get)</span><br><span class="line">    <span class="comment"># 外部调用 发射信号</span></span><br><span class="line">    send.run()</span><br><span class="line">    <span class="comment"># 信号与槽解除关联</span></span><br><span class="line">    send.send_msg.disconnect(slot.get)</span><br><span class="line">    send.run()</span><br></pre></td></tr></table></figure>
<h2 id="内置信号绑定自定义槽"><a href="#内置信号绑定自定义槽" class="headerlink" title="内置信号绑定自定义槽"></a>内置信号绑定自定义槽</h2><p>这样，再来看一个和窗口结合的实例。窗口中有一个按钮，点击按钮就退出窗口。虽然这个例子很简单，不用信号和槽也能实现。但这里给个例子静心感受下：信号连接、发射、接收的全逻辑。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> pyqtSignal</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QMainWindow, QApplication, QPushButton, QWidget, </span><br><span class="line">                             QHBoxLayout)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    btn_signal = pyqtSignal()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MainWindow, self).__init__()</span><br><span class="line"></span><br><span class="line">        a = QPushButton(<span class="string">"退出"</span>)</span><br><span class="line">        <span class="comment"># 给绑定的槽函数增加额外信息</span></span><br><span class="line">        a.clicked.connect(partial(self.btn_clicked, <span class="number">1</span>))</span><br><span class="line">        self.btn_signal.connect(self.close)</span><br><span class="line"></span><br><span class="line">        self.setWindowTitle(<span class="string">"演示"</span>)</span><br><span class="line"></span><br><span class="line">        main_widget = QWidget()</span><br><span class="line">        layout = QHBoxLayout()</span><br><span class="line">        layout.addWidget(a)</span><br><span class="line">        main_widget.setLayout(layout)</span><br><span class="line">        <span class="comment"># QMainWindow 不能设置布局</span></span><br><span class="line">        self.setCentralWidget(main_widget)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">btn_clicked</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        print(n)</span><br><span class="line">        self.btn_signal.emit()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        app = QApplication.instance()</span><br><span class="line">        app.quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 在shell中执行</span></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    mywin = MainWindow()</span><br><span class="line">    mywin.show()</span><br><span class="line">    <span class="comment"># 开始主循环，直到退出</span></span><br><span class="line">    sys.exit(app.exec())</span><br></pre></td></tr></table></figure>
<p>这里，想给绑定的槽函数<code>btn_clicked</code>传递额外参数，但信号绑定时不能添加额外参数。对应到上述例子中，<code>close()</code>可以通过指定信号的参数和类型来增加参数，但<code>btn_clicked()</code>不能。一种解决方案是掏出万能的<code>partial</code>函数，将函数和参数绑定在一起。</p>
<p>至此，应该了解了信号的工作方式和原理。而关于信号更多的内容，如重载、装饰器等，这里不做更多介绍，详情参考官方文档。话说，也佩服当年的学习方式：『把所有代码敲一遍』。时至今日也忘记了大多控件的含义和各种样式的代码，变成了：到时候去查API。<del>一边谈技术一边谈没用的，不愧是我的博客。</del></p>
<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>MVC的大名应该都听说过，model, view 和 control，即数据库、页面和处理逻辑相分离，这样写出来的代码更加专一化。这里给份代码感受下，三个内容用三个类所实现，个人不建议这样写，建议将文件放到三个文件夹下，而不是扔进一份代码里：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtCore</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QWidget, QHBoxLayout, QPushButton, QMessageBox, </span><br><span class="line">                             QLineEdit, QApplication)</span><br><span class="line"></span><br><span class="line"><span class="comment"># View</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">    verifySignal = QtCore.pyqtSignal()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super(MainWindow, self).__init__(*args, **kwargs)</span><br><span class="line">        self.id_line = QLineEdit()</span><br><span class="line">        self.id_line.setPlaceholderText(<span class="string">"请输入账号"</span>)</span><br><span class="line">        self.psd_line = QLineEdit()</span><br><span class="line">        self.psd_line.setPlaceholderText(<span class="string">"请输入密码"</span>)</span><br><span class="line"></span><br><span class="line">        self.init()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        layout = QHBoxLayout()</span><br><span class="line">        self.setLayout(layout)</span><br><span class="line"></span><br><span class="line">        self.button = QPushButton(<span class="string">"登录"</span>)</span><br><span class="line">        layout.addWidget(self.button)</span><br><span class="line"></span><br><span class="line">        layout.addWidget(self.id_line)</span><br><span class="line">        layout.addWidget(self.psd_line)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 连接定义的信号</span></span><br><span class="line">        self.button.clicked.connect(self.verify_emit)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_emit</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.verifySignal.emit()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_ok</span><span class="params">(self)</span>:</span></span><br><span class="line">        QMessageBox.about(self, <span class="string">"密码正确"</span>, <span class="string">"已经登录"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_no</span><span class="params">(self)</span>:</span></span><br><span class="line">        QMessageBox.about(self, <span class="string">"你犯了一个粗误"</span>, <span class="string">"请重新检查输入"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># model</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"aaa"</span></span><br><span class="line">        self.password = <span class="string">"aaa"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># control</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginControll</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 不需要从命令行输入参数</span></span><br><span class="line">        self._app = QApplication([])</span><br><span class="line">        self._model = Student()</span><br><span class="line">        self._view = MainWindow()</span><br><span class="line">        self.init()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._view.verifySignal.connect(self.verify_user)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_user</span><span class="params">(self)</span>:</span></span><br><span class="line">        id_ = self._view.id_line.text()</span><br><span class="line">        psd_ = self._view.psd_line.text()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> id_ == self._model.name <span class="keyword">and</span> psd_ == self._model.password:</span><br><span class="line">            self._view.verify_ok()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._view.verify_no()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._view.show()</span><br><span class="line">        <span class="comment"># 事件循环，直到应用退出</span></span><br><span class="line">        <span class="keyword">return</span> self._app.exec_()</span><br><span class="line"></span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    login_control_ = LoginControll()</span><br><span class="line">    <span class="comment"># 退出主程序</span></span><br><span class="line">    sys.exit(login_control_.run())</span><br></pre></td></tr></table></figure>
<p>在这个例子里需要注意的是，将model，view和controller分成了三个类。在view中定义信号以及信号何时发射，在controller中定义信号发射后连接的槽函数，即触发何种的响应。这样，通过信号的发射与连接，就将view和controller绑定在了一起。view负责页面展示与信号定义，controller负责信号的连接与功能的实现，完美。</p>
<h1 id="MVC实现"><a href="#MVC实现" class="headerlink" title="MVC实现"></a>MVC实现</h1><h2 id="单页面"><a href="#单页面" class="headerlink" title="单页面"></a>单页面</h2><p>如果读懂以上内容，那么应该可以实战了。首先给出一个demo，就是将上面最简单的MVC的例子拆分为三个文件。这里不便代码展示，请移步到我的github进行观看，这是<a href="https://github.com/muyuuuu/PyQt5-learn/tree/master/GUI/Basic-train/MVC-single-page" target="_blank" rel="noopener">文件结构</a>，这是<a href="https://github.com/muyuuuu/PyQt5-learn/blob/master/GUI/Basic-train/MVC-single-page/main.py" target="_blank" rel="noopener">主文件</a>。</p>
<h2 id="多页面"><a href="#多页面" class="headerlink" title="多页面"></a>多页面</h2><p>在实现个复杂点的逻辑，多个页面，多个<code>controller</code>，文件结构如下所示，一个主文件，配三个文件夹，完美。这里命名时尽量规范，文件名、类名、函数名，不然容易把自己搞晕了。<code>python main.py</code>执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MVC-demo</span><br><span class="line">├─ main.py</span><br><span class="line">├─ UI</span><br><span class="line">│    ├─ leftbtn_ui.py</span><br><span class="line">│    ├─ login_ui.py</span><br><span class="line">│    ├─ main_window_ui.py</span><br><span class="line">│    └─ verify_ui.py</span><br><span class="line">├─ control</span><br><span class="line">│    ├─ controller.py</span><br><span class="line">│    ├─ leftbtn_control.py</span><br><span class="line">│    ├─ login_control.py</span><br><span class="line">│    └─ verify_control.py</span><br><span class="line">└─ model</span><br><span class="line">       └─ model.py</span><br></pre></td></tr></table></figure>
<p>调用关系如下：</p>
<p><img data-src="https://static01.imgkr.com/temp/5fcf0ccbb7b94c89ba5b42f8f3605432.png" alt></p>
<p>这里需要注意的是<strong>变量的生存周期</strong>，main调用controller，controller调用其它的子controller，很容易在声明一个类后局部变量消失，导致信号无法连接。如在<code>controller.py</code>中，典型错误的写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controll</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        self._app = QApplication([])</span><br><span class="line"></span><br><span class="line">        self._stu = Student()</span><br><span class="line"></span><br><span class="line">        self._view = MainWindow()</span><br><span class="line">        self.init()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 子 controller 作为局部变量，调用完后立刻消失，所以无法连接信号和槽</span></span><br><span class="line">        <span class="comment"># 这个问题困扰了我三天，可真是滑稽</span></span><br><span class="line">        login_controller = login_control.Controller(self._view, self._stu.name, self._stu.password)</span><br></pre></td></tr></table></figure>
<p>因为代码文件实在太多且混乱，就不在这里展示了，不然读者会更容易感到乱。这里只展示一个效果，完整代码见我的<a href="https://github.com/muyuuuu/PyQt5-learn/tree/master/GUI/Basic-train/MVC/MVC-demo" target="_blank" rel="noopener">github</a>。其实看一个例子，就啥都懂了。</p>
<p><img data-src="https://static01.imgkr.com/temp/5b351da806dd4c9c888d0215fd7ec703.gif" alt></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>有篇很好的MVC实现找不到了，具有启蒙意义，看这篇吧：<a href="https://www.pythonf.cn/read/11042" target="_blank" rel="noopener">https://www.pythonf.cn/read/11042</a></li>
<li>那个困扰我三天的问题，stackoverflow太伟大了：<br><a href="https://stackoverflow.com/questions/66026582/in-pyqt5-why-signal-cant-connect-a-slot-in-a-external-class?" target="_blank" rel="noopener">https://stackoverflow.com/questions/66026582/in-pyqt5-why-signal-cant-connect-a-slot-in-a-external-class?</a></li>
</ol>
]]></content>
      <tags>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>CV 领域的自监督</title>
    <url>/2021/12/28/SSL-intro/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>还是要认真的学习一会儿，降低多巴胺的分泌。在使用 triplet loss 学表示的时候，出现了模型坍塌的情况，也就是说，模型对任何输入的输出都是一样的，损失恒定的现象。在网上搜了一些解决方案后，需要用户去花精力构造正负样本，我不喜欢这样的东西，所以开始看了自监督的论文，毕竟都是学表示。也发现自监督会在一段时间内成为未来的视觉领域的主流，正好我做的东西和自监督也算相关，做一个论文整理。包括了 MoCo，SimCLR，SimSiam 和 Barlow Twins。</p>
<blockquote>
<p>模型崩塌，也就是模型为了偷懒，无论什么图片都会输出同样表示，这样结果 loss 很小，然后却没学到任何东西。</p>
</blockquote>
<a id="more"></a>
<p>图像领域的自监督主要由两部分组成，对比损失和数据增强，而那四篇论文也是基于这两个东西去做的，无非是如何对比。</p>
<h1 id="MoCo"><a href="#MoCo" class="headerlink" title="MoCo"></a>MoCo</h1><p>首先是 <code>MoCo</code>，简单的看一下模型的结构</p>
<p><img data-src="https://s4.ax1x.com/2021/12/28/TsYsxS.png" alt="TsYsxS.png"></p>
<p>对同一个样本做两次数据增强，会得到两个样本 $x_q$ 和 $x_k$，创建两个 <code>encoder</code>，左边那个 <code>encoder</code> 接入 $x_q$，右边的 <code>encoder</code> 接入 $x_k$，使得这两个的相似性越高越好，与此同时，期望 $x_q$ 与负样本的相似性越低越好。那么如何衡量相似性呢？使用的是 <code>InfoNCE</code> 这个损失函数。</p>
<p>\begin{aligned}<br>{L}_{InfoNCE} =-{E}_X\left[\log \frac{f_{k}\left(x_{t+k}, c_{t}\right)}{\sum_{x_{j} \in X} f_{k}\left(x_{j}, c_{t}\right)}\right] \\<br>\end{aligned}</p>
<p>分子是正样本的相似度，分母是负样本的相似度，这个比值越大，log 就越大，对应的损失函数就越小。<code>MoCo</code> 的改动如下，用点积来衡量 $x_q$ 和正负样本的距离。也就是说，使用对比损失来区分图像的高维特征。</p>
<p>\begin{equation}<br>{L}_q = -\log \frac{ \exp(q\cdot k_{+}/\tau) }{\sum_{i=0}^K \exp(q\cdot k_{i}/\tau)}<br>\end{equation}</p>
<p>那么与众不同的地方呢？换句话说，负样本从哪里来呢？模型会设计一个队列，队列负责维护将刚进入的样本视为负样本放入队列（最开始没负样本的话，用的是随机数），并弹出之前的负样本，这就需要很大的显存以及代码编写的难度，我不是很喜欢这两点。不信你来看他们官方的<a href="https://github.com/facebookresearch/moco" target="_blank" rel="noopener">程序</a>。</p>
<p>此外需要注意的是，作者提出了动量的更新方式，来更新右侧的网络：</p>
<p>\begin{equation}<br>\theta_k \leftarrow m\theta_k + (1-m)\theta_q , m\in[0,1)<br>\end{equation}</p>
<p>也许你会有疑问，都计算好梯度了，更新左侧的网络就没事，更新右侧的网络就有事，莫非在耍流氓？这个梯度给谁不是给，为什么不用梯度更新两个网络？论文上写的是：由于样本很多，右侧网络不容易更新。很多网上的论文解析也是人云亦云，看了代码就知道存储负样本的队列和右侧的网络没半毛钱关系，队列在计算梯度的时候已经 <code>detach</code> 了。所以，论文写的更新困难并不是梯度回传困难，那么为什么不能用梯度更新右侧的网络呢？</p>
<p>先来解释为什么不把左侧网络的参数拷贝给右侧网络的参数。这么做的目的是因为不同 <code>epoch</code> 之间数据分布差异可能很大，<code>encoder</code> 的参数有可能会发生突变，不能将多个 <code>epoch</code> 的数据特征近似成一个静止的大 <code>batch</code> 数据特征，因此就使用了这么一个类似于滑动平均的方法来更新右侧网络。</p>
<p>再来回答为什么不用梯度更新右侧的网络。$x_k$ 经过右侧网络后，然后我们就得到了它们相对应的表示。而对于这个表示，它们不光包含了这个 <code>mini-batch</code> 的表示，也包含了一些之前处理过的 <code>mini-batch</code> 中的表示。换句极端的话说，右侧的网络掌握了全部数据的表示，来调控左侧网络该学到什么样的表示。这些表示通过右侧网络后放入队列中，相对于只在本 <code>mini-batch</code> 内做比较的方法而言，<code>moco</code> 能用较小的管理开销来获得更多的负样本。如果只用一个 <code>mini-batch</code> 的梯度更新右侧网络，或者说右侧网络只掌握一个 <code>mini-batch</code> 的表示，那右侧网络直接输出和左侧网络一样的东西不就行了，这样损失很小，但什么也没学到。因此，不能用一个 <code>mini-batch</code> 的梯度去更新右侧网络。</p>
<h2 id="损失函数解析"><a href="#损失函数解析" class="headerlink" title="损失函数解析"></a>损失函数解析</h2><p>此外是本文较为迷惑的损失函数，文章写的没啥迷惑，迷惑的是代码。我第一眼过去，直接理解为不管是正样本还是负样本，都和 0 去接近，正样本明明越大越好，应该和 1 去接近，这么写肯定不对呀。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">l_pos = torch.einsum(<span class="string">'nc,nc-&gt;n'</span>, [q, k]).unsqueeze(<span class="number">-1</span>)</span><br><span class="line">l_neg = torch.einsum(<span class="string">'nc,ck-&gt;nk'</span>, [q, self.queue.clone().detach()])</span><br><span class="line">logits = torch.cat([l_pos, l_neg], dim=<span class="number">1</span>)</span><br><span class="line">labels = torch.zeros(logits.shape[<span class="number">0</span>], dtype=torch.long)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">loss = criterion(logits, target)</span><br></pre></td></tr></table></figure>
<p>后来仔细抠的代码才理解，<code>torch</code> 的交叉熵损失函数由 <code>logsoftmax</code> 和 <code>nllloss</code> 组成，前者完成 <code>logsoftmax</code> 的计算，后者 <code>nllloss</code> 取出对应的标签，在 <code>nllloss</code> 的时候，标签为 0 的意思是取出 <code>batch</code> 中的第一列，而这一列正好是正样本，<code>nlloss</code> 期望这列的值越小越好，那么回退到 <code>logsoftmax</code>，就是期望这列的值越大越好，也就是，正样本的相似度很高。<strong>并不是像网上那种垃圾博客说的，无监督任务都分成 0 类即可。</strong> 这里还是建议理解一下，因为自监督的损失大多是这么设计的。</p>
<h1 id="SimCLR"><a href="#SimCLR" class="headerlink" title="SimCLR"></a>SimCLR</h1><p>推荐一个比较好的<a href="https://github.com/Spijkervet/SimCLR" target="_blank" rel="noopener">实现</a>。因为反感 <code>MoCo</code> 那种开显存的操作，毕竟不是所有人都有  <code>facebook</code> 的财力，所以继续去读了其他自监督的论文，较为相似的一篇论文是 <code>SimCLR</code>。还是先来看模型结构图：</p>
<p><img data-src="https://s4.ax1x.com/2021/12/28/TsYr28.png" alt="TsYr28.png"></p>
<p>注意，左右两边的网络都是相同的，也就不存在梯度该传给谁的问题。一个 <code>batch</code> 的样本，经过数据增强得到两个 <code>batch</code> 的样本，这两个 <code>batch</code> 的样本进入网络会得到两个 <code>batch</code> 的表示，期待这两组表示中，同一数据的表示很接近，放大不同数据的差异。损失同样是用的类似 <code>InfoNCE</code> 的损失函数。不过论文中有比较奇怪的点，放一段原文：</p>
<blockquote>
<p>We randomly sample a minibatch of N examples, augmented examples derived from the minibatch, resulting in 2N data points. We treat the other 2(N-1) augmented examples within a minibatch as negative examples.The final loss is computed across all positive pairs.</p>
</blockquote>
<p>问题来了，一共 $2N$ 个样本，$2(N-1)$ 都视为负样本，哪来的 positive pairs？还是直接看代码吧，其实 <code>MoCo</code> 的论文写的也够晕的。看了代码损失函数的设计后发现，就是自己和自己是正样本，自己和其他的样本的关系是负样本。严格来说，对于一个样本而言，有 <code>2(N-2)</code> 个负样本。损失函数和 <code>MoCo</code> 的保持一致，都是用交叉熵损失函数实现的。推荐去看这个损失函数的实现，代码写的还是比较有意思的。但是计算量会大一些。</p>
<h1 id="SimSiam"><a href="#SimSiam" class="headerlink" title="SimSiam"></a>SimSiam</h1><p>在 <code>MoCo</code> 之后，提出了更简单的网络结构：</p>
<p><img data-src="https://s4.ax1x.com/2021/12/28/TsYD8f.png" alt="TsYD8f.png"></p>
<p>提前声明，相似度用的是余弦函数，因为余弦函数相似性越高数值越大，因此损失函数取了负数，最后的损失值也是负的。思路很简单，对同一个图像做两次增强得到俩个正样本，$x_1$ 和 $x_2$，$x_1$ 经过 <code>encoder</code> 得到表示 $z1$，$z1$ 经过 <code>predictor</code> 得到 $p_1$，同理得到 $p_2$ 和 $z_2$，计算 $p_1$ 和 $z_2$ 以及 $p_2$ 和 $z_1$ 的相似度，然后就没了。</p>
<p>简单吗？简单。有坑吗？有。我当时在想，如果 <code>predictor</code> 的权重全部是 1，那么相似度不就会很小了，但仍然是模型坍塌的情况。然后带着疑问去看代码，结果人家直接冻结了 <code>predictor</code> 某一层的权重，是我大意了。后来我以抄袭的形式复现的时候，没有冻结权重，效果比 SimCLR 要好一些。</p>
<h1 id="Barlow-Twins"><a href="#Barlow-Twins" class="headerlink" title="Barlow Twins"></a>Barlow Twins</h1><p>到这篇论文，思路更加简单，东西和 SimCLR 比较类似，损失函数用的是大二学过的协方差矩阵，对角线越大越好，其余位置越小越好。它虽然很简洁，但我感觉他比 SimSiam 更令人喜欢。</p>
<p>\begin{equation}<br>L=\sum_{i}(1-C_{ii})^2 + \lambda \sum_i \sum_{j\neq i} C_{ij}^2<br>\end{equation}</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://kakack.github.io/2021/05/Moco-%E5%9F%BA%E4%BA%8E%E5%8A%BF%E8%83%BD%E6%9B%B4%E6%96%B0%E7%9A%84%E8%87%AA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">MoCo 参考</a></li>
<li><a href="https://blog.csdn.net/qq_22210253/article/details/85229988" target="_blank" rel="noopener">NLLLoss 解析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/357088620" target="_blank" rel="noopener">SimSiam 为什么 stop grad</a></li>
</ol>
]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>迟暮的丞相：遂许先帝以驱驰，尔来二十又一年</title>
    <url>/2019/03/28/Prime-minister-music/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;之前同学(某仙女)给我推荐过一首轻音乐——《武侯祠》，今日忽然之间又偶然刷到了这首音乐，好听的不得了，又忽然想背诵《出师表》，特来发布至博客。越是稀缺的情感，越感人至深。</p>
<p><img data-src="/2019/03/28/Prime-minister-music/1.jpg" alt><br><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>三顾频烦天下计，两朝开济老臣心。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote></p>
<p><div class="note danger"><p><audio src="http://music.163.com/song/media/outer/url?id=477841196.mp3" style="max-height :100%; max-width: 800%; display: block; margin-left: auto; margin-right: auto;" controls="controls" loop="loop" preload="meta">Your browser does not support the audio tag.</audio></p></div><br><a id="more"></a></p>
<p>&emsp;&emsp; 当时的聊天记录如下：</p>
<p><img data-src="/2019/03/28/Prime-minister-music/1.png" alt></p>
<p>可能当时也是这么多感受吧，今日有幸在此刷到了这首音乐，新的感触，毕竟是天朝元素——<code>Chinese Element</code>，思绪回到那个战火纷飞的年代。</p>
<p>其实说起轻音乐，不只是外国的钢琴、吉他、鼓点等，中国也有好的好听的轻音乐，比如二胡、古琴、琵琶，声音一想起，将仿佛进入到了张艺谋的电影——《英雄》的场景中，很浓厚的中国元素，江山如画下的多少豪杰，比如水墨画，比如兰亭唱晚，比如江南婉约，比如江上清风，比如明月照离人，很美的画面，古典与朴素，淡雅与高尚，很有情怀的feel。</p>
<p>那么回到《三国演义》，小时候很爱看这些古代小说，当时读到诸葛亮的时候，也确实佩服他的聪明才智，献策隆中，火烧新野，舌战群儒，巧算华容道，复取荆州，以天下舍我其谁的气势踏入战火连天的三国舞台，就算到了晚年，也是亲征南蛮，六出祁山…</p>
<p>后来看了一些为了吸引眼球的网文，没有任何科学依据的在那里一本正经的胡说八道：三国演义中最聪明的不是诸葛亮，是周瑜郭嘉荀彧戏志才贾诩，是司马懿，是这些鬼才，他们把一个国家从零到有的带到繁荣了吗？没有。也许诸葛亮不聪明，但他做到了，跟了47岁未有寸土之地的创业者，尽忠职守，兢兢业业，他不是神，但值得每一个人敬仰。后来知道了为什么一本正经的胡说八道来贬低诸葛亮，网文通常都在以这种形式吸引眼球，获取流量挣钱。而现实生活中一些人还是这么说的话，通常是为了“标新立异”来显示自己的与众不同(显示自己智商的下线)，不必理会。</p>
<p>如果不能理解上文，我在举个例子：假设『马谡』死于生病，而不是死于失街亭。那么网文会不会写：其实三国智商最高的是马谡，马谡不死，司马懿不出，马谡不死，邓艾不动，只可惜天妒英才，不然必能顶替诸葛北伐中原统一大业，而后三国杀马谡技能：天妒。而后网络小说家：马谡不死，三国尽归蜀汉。网友：诸葛亮根本不入流，三国最厉害的军师是马谡。诸葛亮用马谡之计平南蛮易如反掌，马谡死后诸葛亮北伐寸步难行，可以看到马谡死后，蜀汉开始走下坡路。我也会编，有意思么。</p>
<p>当时的刘备还是相当弱鸡，北有曹操东有孙权，而自己毫无立足之地，或者说有了立足之地而无力防守。于是在徐庶的建议下去请诸葛亮出山。于是有了后来的故事，这个故事的记录者也是诸葛亮，记录在了千古绝唱《出师表》中：</p>
<blockquote class="colorquote success"><p> 臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。</p></blockquote>

<p>二十一年的时光也很短，从意气风发到白发苍苍而迟暮，从最开始的隆中对，开始接手烂摊子，出山前对书童说：“三五年后我会回来的”。到最后的败军之际而奉命，没想到一走二十一年，最终搭上了自己的性命，后来大将军姜维自刎殉国，蜀国走向了下坡路。</p>
<p>鞠躬尽瘁死而后已，中国历史需要这样的骨气，来撑起中国五千年的历史而绵延不绝，我相信也是中国人具备这样的品质和骨气，华夏文明才传承了五千年不止，即使被外族入侵，还有岳飞、文天祥、闻一多这样的人不是吗？“先天下之忧而忧 后天下之乐而乐”，这是气节，是撑起中华民族脊梁的气节。乱入一段：</p>
<ul>
<li>如果能唤醒中国几万万人的觉醒，我很乐意付出我的生命。</li>
<li>我的恋人，是这个国家。</li>
</ul>
<p>读罢《出师表》，掩卷深思，一位为国为民鞠躬尽瘁、死而后已的诸葛亮仿佛就站在面前，更加深切地体会到，唯心中装着国家和人民的人，历史才不会忘记。</p>
<p>《出师表》的历史评价也很高，至少，我相信这些古人的眼光也不会差，至少不是把诸葛亮评论的一无是处。也许诸葛亮没那么神话智商500+，鲁迅的评价是“状诸葛多智而近妖”，可至少他凭一己之力把没落的一批人带到了前所未有的高度，至少三国时代没有第二个这样的人，司马一族也很大程度上收了曹魏的人头，如果说近代中国史也有个这么伟大的人，那么是周恩来吧。</p>
<ul>
<li>文天祥：天下皆传清献节，人心自有武侯碑。</li>
<li>陆游：出师一表真名世，千载谁堪伯仲间！</li>
<li>杜甫：三顾频烦天下计，两朝开济老臣心。</li>
</ul>
<p>在赤壁之战的时候，关乎生死的一场战斗，蜀国代表是诸葛亮，吴国代表是周瑜，共五万军队，魏国代表是曹操和一群谋士，共七万军队(我没经历过这个时代，可能不严谨)，诸葛亮和周瑜以二十几岁年纪的经验，打赢了五十多岁的曹操，像苏东坡写的那样：羽扇纶巾，谈笑间樯橹灰飞烟灭，还是到最后的人生如梦，一尊还酹江月，可这终究是一段传奇，诸葛亮保住了蜀国，创造了历史。</p>
<blockquote class="colorquote success"><p> 先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐托付不效，以伤先帝之明。故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。</p></blockquote>


<p>从岐山到西安的路程只有几个小时的高铁，诸葛亮走了一辈子，只是为了挽救奄奄一息的汉朝和当初的承诺。七擒孟获，六次北伐，把他从一个意气风发的俊朗少年变成了一个心力交瘁事事操劳的“老臣”。</p>
<p>丞相踏上漫漫的北伐之路，以报答先主当年的三顾之恩，二十一年的风风雨雨不曾磨灭的是那份初出茅庐的诺言，或许丞相知道兴复汉室是明知不可为而为之，在尽人事听天命之后，丞相也只能感叹，吾再不能临阵讨贼，今当远离，临表涕零，不知所言。可如今千载已过，卧龙岗的繁花开了几载又几载，小桥流水仍如旧日，而那个赏花赋诗，流觞曲水的白衣先生却众未归来。</p>
<p>当时很讨厌背诵《出师表》，至少现在不是，读完了《出师表》也就读懂了“遂许先帝以驱驰二十一年”。即便是两千年来，回顾中国历史，诸葛亮也是人臣之典范，无愧鞠躬尽瘁，死而后已这八个字。</p>
<p>越是稀缺的情感，越感人至深。</p>
<ul>
<li>读诸葛孔明《出师表》而不堕泪者，其人必不忠。</li>
<li>读李令伯《陈情表》而不堕泪者，其人必不孝。</li>
<li>读韩退之《祭十二郎文》而不堕泪者，其人必不友。</li>
</ul>
<p>就像：“庭有枇杷树，吾妻死之年所手植也，今已亭亭如盖矣。” 这里没有悲哀、悲伤的字，但悲伤眷恋之情溢于言表，</p>
<p>也许总有一天，会明白一些内容其中的深意，让我成为不同的人。</p>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5多线程</title>
    <url>/2021/02/05/PyQt5-QThread/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开完一坑又一坑，这应该是<code>GUI</code>系列的完结稿了。时至今日，很多方法和函数已经忘记，一部分整理到了仓库，用时查阅；一部分学会了查官方文档。比如布局中的<code>addSpacing</code>和<code>addStretch</code>填充，以及不同空间该如何<code>Qt.Align</code>，需要大量的经验。用过一次就会知道功能，所以，官方文档永远的神。</p>
<a id="more"></a>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在之前的<a href="https://muyuuuu.github.io/2020/05/12/reverse-radar-multi-thread/">制作倒车雷达</a>中，已经说过了多线程的应用背景。那会儿是项目驱动，现在来彻底了结。一个软件中，如果制作一个计数功能。那么主进程进入计数函数，没有进程负责界面的显示，就会导致软件卡死。如下代码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QMainWindow, QWidget, QHBoxLayout, QApplication, </span><br><span class="line">                             QPushButton)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mainwindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(mainwindow, self).__init__()</span><br><span class="line"></span><br><span class="line">        layout = QHBoxLayout()</span><br><span class="line">        w = QWidget()</span><br><span class="line">        w.setLayout(layout)</span><br><span class="line">        self.setCentralWidget(w)</span><br><span class="line"></span><br><span class="line">        btn = QPushButton(<span class="string">"点击"</span>)</span><br><span class="line">        layout.addWidget(btn)</span><br><span class="line">        btn.clicked.connect(self.count)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self)</span>:</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> num &lt;= <span class="number">12000</span>:</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QApplication([])</span><br><span class="line">    m = mainwindow()</span><br><span class="line">    m.show()</span><br><span class="line">    sys.exit(app.exec())</span><br></pre></td></tr></table></figure>
<p>需要额外注意的是，在Qt的开发中，一定不能使用time.sleep()这种方法。Qt是框架是基于事件循环的，<code>time.sleep()</code>因为它会阻塞事件的循环，导致窗口冻结，直接跳到<code>sleep</code>后的程序，从而阻止了GUI的重新绘制，并没有中间的过程。所以在Qt中，可以考虑使用多线程来解决这些问题，如：分为显示线程和工作线程，显示事件负责GUI的显示，工作事件负责刷新物体的位置。</p>
<h1 id="QTimer"><a href="#QTimer" class="headerlink" title="QTimer()"></a>QTimer()</h1><p>这是一个实现多线程的最简单的工具，通常用于周期性检测，比<code>sleep()</code>这种强行停止窗口事件的循环要好上很多。它有常用的两个函数：</p>
<ul>
<li><code>start(int n)</code>，表示n毫秒后，定时器会发出信号。我们只需要把发出的信号绑定到对应函数就可以工作了</li>
<li><code>timeout</code>就是发出的信号，将它绑定到槽函数上</li>
<li><code>stop</code>，停止计时器</li>
</ul>
<p>我们来写一个最简单却常用的功能。当软件卡顿时，一般会出现转圈圈的图标，表示正在加载。假设就让它转5秒，5秒后通过另一个线程让它消失，不影响主窗口的显示。如果直接<code>time.sleep(5)</code>，那么圆圈不会转动的，界面会直接到在这5秒内静止，然后一步跳到5秒后。所以以下程序是错误的：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">self.move()    <span class="comment"># 开始转动</span></span><br><span class="line">time.sleep(<span class="number">5</span>)  <span class="comment"># 转 5 秒</span></span><br><span class="line">self.stop()    <span class="comment"># 停止转动</span></span><br></pre></td></tr></table></figure>
<p>Qt是循环的框架，所以应该考虑用 QTimer 代替 sleep 正确姿势如下，图片文件自己去下载一个吧：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QApplication, QLabel, QMainWindow, QWidget, </span><br><span class="line">                             QHBoxLayout)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QMovie</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> Qt, QTimer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWidget</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span></span><br><span class="line">        super(MainWidget, self).__init__(parent)</span><br><span class="line">        self.setAttribute(Qt.WA_StyledBackground, <span class="literal">True</span>)</span><br><span class="line">        self.setStyleSheet(<span class="string">'background-color: white'</span>)</span><br><span class="line"></span><br><span class="line">        self.label = QLabel()</span><br><span class="line">        <span class="comment"># 居中对齐</span></span><br><span class="line">        self.label.setAlignment(Qt.AlignCenter | Qt.AlignVCenter)</span><br><span class="line">        self.loading = QMovie(<span class="string">"images/loading.gif"</span>)</span><br><span class="line">        self.label.setMovie(self.loading)</span><br><span class="line">        self.layout = QHBoxLayout()</span><br><span class="line">        self.layout.addWidget(self.label)</span><br><span class="line">        self.loading_start()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定时器</span></span><br><span class="line">        self.t = QTimer()</span><br><span class="line">        self.t.start(<span class="number">5000</span>)</span><br><span class="line">        self.t.timeout.connect(self.loading_end)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loading_end</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.t.stop()</span><br><span class="line">        self.loading.stop()</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        self.label.clear()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loading_start</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.loading.start()</span><br><span class="line">        <span class="comment"># self.loading.stop()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MainWindow, self).__init__()</span><br><span class="line"></span><br><span class="line">        W = MainWidget()</span><br><span class="line">        self.setCentralWidget(W)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QApplication([])</span><br><span class="line">    window = MainWindow()</span><br><span class="line">    window.show()</span><br><span class="line">    sys.exit(app.exec())</span><br></pre></td></tr></table></figure>
<p>效果展示，你看多好，嘿嘿：</p>
<p><img data-src="https://s3.ax1x.com/2021/02/06/yJd5Rg.gif" alt></p>
<h1 id="QThread"><a href="#QThread" class="headerlink" title="QThread()"></a>QThread()</h1><p>这个实现多线程就比较强大了，可以完成更为复杂的业务。只需要继承这个类，并重写<code>run()</code>函数就可以了。外部实例化这个类，并调用<code>start()</code>函数，会启动线程；线程启动后，会自动调用实现的 <code>run()</code> 函数。</p>
<ul>
<li>此外还有started, finised等信号来完成资源的加载与释放；</li>
<li>isRunning(), isfinished()来检测线程是否还在执行；</li>
<li>同样，也可以定义自己的信号；</li>
<li>线程执行完毕后，可以调用quit(), exit()来退出线程；</li>
<li>如果不是十分有把握，请不要使用<code>terminate</code>来终止线程，因为它不是线程安全的，会导致资源、锁紊乱。</li>
</ul>
<p>给个例子，包含以上所有提到的常用方法。主窗口启动一个子线程，线程每隔一秒发送数据给主窗口，主窗口显示数据。发送到一定量后，停止子线程。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QMainWindow, QTextEdit, QWidget, QApplication, </span><br><span class="line">                             QHBoxLayout)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QThread, pyqtSignal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span><span class="params">(QThread)</span>:</span></span><br><span class="line">    <span class="comment"># 自定义信号</span></span><br><span class="line">    signal_out = pyqtSignal(str)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, working)</span>:</span></span><br><span class="line">        super(Worker, self).__init__()</span><br><span class="line">        self.working = working</span><br><span class="line">        self.num = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 结束信号的触发</span></span><br><span class="line">        self.finished.connect(self.finish)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 在这里释放资源</span></span><br><span class="line">        print(<span class="string">'finish'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># while 持续发送</span></span><br><span class="line">        <span class="keyword">while</span> self.working == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.num != <span class="number">0</span> <span class="keyword">and</span> self.num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                self.signal_out.emit(<span class="string">"stop"</span>)</span><br><span class="line">            string = <span class="string">"Index "</span> + str(self.num)</span><br><span class="line">            self.num += <span class="number">1</span></span><br><span class="line">            self.signal_out.emit(string)</span><br><span class="line">            self.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MainWindow, self).__init__()</span><br><span class="line">        self.text = QTextEdit()</span><br><span class="line">        layout = QHBoxLayout()</span><br><span class="line">        layout.addWidget(self.text)</span><br><span class="line">        w = QWidget()</span><br><span class="line">        w.setLayout(layout)</span><br><span class="line">        self.setCentralWidget(w)</span><br><span class="line">        self.worker = Worker(working=<span class="literal">True</span>)</span><br><span class="line">        self.start()</span><br><span class="line">        self.worker.signal_out.connect(self.display)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self, string)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> string == <span class="string">'stop'</span>:</span><br><span class="line">            self.text.clear()</span><br><span class="line">            self.worker.working = <span class="literal">False</span></span><br><span class="line">            self.worker.quit()</span><br><span class="line">            <span class="comment"># 强制结束进程的执行，但不推荐</span></span><br><span class="line">            <span class="comment"># 线程结束后，被这个线程阻塞的线程都会被唤醒</span></span><br><span class="line">            <span class="comment"># self.worker.terminate()</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            QApplication.processEvents()</span><br><span class="line">            self.text.append(string)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 启动线程</span></span><br><span class="line">        <span class="comment"># 自动调用类内的 run 方法</span></span><br><span class="line">        self.worker.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    q = QApplication([])</span><br><span class="line">    m = MainWindow()</span><br><span class="line">    m.show()</span><br><span class="line">    sys.exit(q.exec())</span><br></pre></td></tr></table></figure>
<h2 id="循环注意"><a href="#循环注意" class="headerlink" title="循环注意"></a>循环注意</h2><p>治理需要注意的是，<code>quit()</code>方法会退出当前事件的循环。所以，如果线程处理的事件是死循环时，即使调用<code>quit()</code>是无法退出的。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    string = <span class="string">"Index "</span> + str(self.num)</span><br><span class="line">    self.num += <span class="number">1</span></span><br><span class="line">    self.signal_out.emit(string)</span><br><span class="line">    self.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> self.num != <span class="number">0</span> <span class="keyword">and</span> self.num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        self.signal_out.emit(<span class="string">"stop"</span>)</span><br><span class="line"></span><br><span class="line">self.worker.quit()  <span class="comment"># 无法退出</span></span><br></pre></td></tr></table></figure>
<p>但是，一般程序并不需要<code>quit()</code>，因为这个线程根本就不需要事件循环。如以下程序虽然没有出错，但不够优雅：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># while 持续发送</span></span><br><span class="line"><span class="keyword">while</span> self.working == <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> self.num != <span class="number">0</span> <span class="keyword">and</span> self.num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        self.signal_out.emit(<span class="string">"stop"</span>)</span><br><span class="line">    string = <span class="string">"Index "</span> + str(self.num)</span><br><span class="line">    self.num += <span class="number">1</span></span><br><span class="line">    self.signal_out.emit(string)</span><br><span class="line">    self.sleep(<span class="number">1</span>)</span><br><span class="line">self.worker.working = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 自己就会结束，不用退出</span></span><br><span class="line">self.worker.quit()</span><br></pre></td></tr></table></figure>
<p><code>wait</code>一般放在<code>start</code>和<code>terminate</code>之后，前者是等待线程结束，所以配合下文提到的<code>QApplication.processEvents()</code>使用更加。后者是线程被强行杀死后可能没有立刻死亡，这取决于系统的调度策略，等待相关资源回收完毕。</p>
<h2 id="processEvents"><a href="#processEvents" class="headerlink" title="processEvents()"></a>processEvents()</h2><p>最终呈现的UI界面，要持续不断地循环刷新，以保证显示流畅、能及时响应用户输入。一般要有一个良好的帧率，比如每秒刷新60帧, 即经常说的FPS 60， 换算一下 1000 ms/ 60 ≈ 16 ms,也就是每隔16毫秒刷新一次。而我们有时候又需要做一些复杂的计算，这些计算的耗时远远超过了16毫秒。</p>
<p>在没有计算完成之前，主线程不会退出计算任务，相当于显示被阻塞，事件循环得不到及时处理，就会发生UI卡住的现象。这种场景下，就可以使用Qt为我们提供的接口，立即处理一次事件循环，来保证UI的流畅。所以，在容易卡顿的地方调用<code>processEvents()</code>函数即可。</p>
<h1 id="MWE"><a href="#MWE" class="headerlink" title="MWE"></a>MWE</h1><p>既然都是完结稿了，留个<code>Qt</code>的最小实例在这里吧，以后方便做简单的测试。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QMainWindow, QWidget, QHBoxLayout, QApplication, </span><br><span class="line">                             QPushButton)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mainwindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(mainwindow, self).__init__()</span><br><span class="line"></span><br><span class="line">        layout = QHBoxLayout()</span><br><span class="line">        w = QWidget()</span><br><span class="line">        w.setLayout(layout)</span><br><span class="line">        self.setCentralWidget(w)</span><br><span class="line"></span><br><span class="line">        btn = QPushButton(<span class="string">"点击"</span>)</span><br><span class="line">        layout.addWidget(btn)</span><br><span class="line">        btn.clicked.connect(self.count)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QApplication([])</span><br><span class="line">    m = mainwindow()</span><br><span class="line">    m.show()</span><br><span class="line">    sys.exit(app.exec())</span><br></pre></td></tr></table></figure>
<p>其实，学的越多才发现，我对真正的<code>Qt</code>一无所知。而以后的成长，只能靠阅读文档、阅读一些经验性博客来提升自己了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://doc.qt.io/qt-5/qthread.html" target="_blank" rel="noopener">qthread官方文档，想要的一切函数都有</a></li>
<li><a href="https://doc.qt.io/qt-5/qcoreapplication.html" target="_blank" rel="noopener">processEvents文档</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/72758194" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/72758194</a></li>
<li><a href="https://doc.qt.io/archives/qq/qq27-responsive-guis.html" target="_blank" rel="noopener">让Qt更快的响应</a>，如果不忙，且需要开发软件，我会考虑翻译这篇文章。</li>
</ol>
]]></content>
      <tags>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>DeepLearning准备进坑</title>
    <url>/2019/02/09/Start-deep-learning/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实是想把这个的标签设成python的，后来想想设置成keras，后来是改成了deeplearning。如果想看算法或代码请往他处，这里只是记录学习中的收获，或者更多的是理解。就像AI的发展，每次遇到坑都会出现新的解决方案和算法，所以重点不是那些算法，而是如何面对问题，解决问题，什么样的新思路。</p>
<p>本文内容如下：有关读完keras和tensorflow官方文档的收获。</p>
<a id="more"></a>
<p>如果对本文有疑问或者想找男朋友，可以联系我，<a href="https://muyuuuu.github.io/about/">点击此处有我联系方式</a>。</p>
<p>大概是元旦放假闲的没事干把剩余的Tensorflow的官方文档看完了，同样是大年初三又开始没事干，花了几天读完了Keras的官方文档，谈谈收获吧。当然不是说哪个库不好，还有更多的库比如pytorch，caffee，又不可能都学，重点是方法。</p>
<p>相比之下，两份文档都是先从基本的二分类开始说起，到后面的多分类，二分类是什么激活函数，多分类又是什么激活函数。之后开始了one-hot编码，词嵌入，图像卷积，循环神经网络，等等等等。</p>
<blockquote>
<p>说实话在官方文档的带领下，写一份代码并不是很难，重点是对中间数学过程的理解。</p>
</blockquote>
<p>比如什么是softmax，比如什么是词嵌入，为什么词嵌入，图像处理为什么使用卷积，valid和same卷积是什麽，循环网络是如何循环的，eproch，batch是什么，梯度下降是如何运行的，时间步、序列长度又是什么，等等等等，我感觉这些应该才是关心的重点。</p>
<blockquote>
<p>参数忘了可以随时查，参数含义忘了也可以查，但是还是要理解基本的观念。</p>
</blockquote>
<p>如果感兴趣会继续读下去，当然不在想说卷积、池化是如何运行的，只想更关心原理。</p>
<blockquote>
<p>虽然写了一堆看似没用的话，但是时至今日，踩了很多的坑后才发现这些才是重点。所以，不必着急写代码，也不用着急去干项目和比赛，先把基础的理念搞清楚。</p>
</blockquote>
<hr>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>易于理解的旋转矩阵求解算法</title>
    <url>/2020/02/05/Spiral-matrix/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近开了一个新坑，每天一道<code>OJ</code>，防止老年痴呆。好像在我刚开始刷题的时候，看到了一个题目，大概意思是：一个序列，排序，螺旋状放入一个矩阵并输出。当时我一看，这难度不适合我这种菜鸡，今天又看到了这道题目，冷静分析了下，草稿纸上写了写，实现了这个算法。</p>
<a id="more"></a>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805275146436608" target="_blank" rel="noopener">题目地址，PAT乙级1050</a></p>
<p><img data-src="/2020/02/05/Spiral-matrix/1.png" alt></p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">37 76 20 98 76 42 53 95 60 81 58 93</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">98 95 93</span><br><span class="line">42 37 81</span><br><span class="line">53 20 76</span><br><span class="line">58 60 76</span><br></pre></td></tr></table></figure>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先，我肯定是现在网上查找了相关的求解算法的，但是：潦草的说明、写的只有自己能看懂的介绍、胡乱的排版实在让人没有看下去的欲望。外加凌乱和毫不注释的程序，实在劝退。可能大佬上过学校的培训课或参加过算法比赛，我这种实力的人看不懂他们写的东西。</p>
<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>既然看不懂他们写的，不如自己分析下这个问题，然后自己设计算法。首先，我们可以把螺旋的过程拆为几个部分，先转最外侧一圈，然后内侧一圈，一层一层向内，直到不能转动位置。如下图所示，先转蓝色一圈，在转橙色一圈，在转绿色一圈，直到不能转动为止。</p>
<p><img data-src="/2020/02/05/Spiral-matrix/2.png" alt></p>
<p>把矩阵赋值当成『画圈』的过程，取决于『画的路线』，『画几次』，『画中的注意事项』。基于以上想法，实现起来便不再困难。</p>
<ul>
<li>第一步，读取有几个数字，求解矩阵该有几行几列，定义一个存放结果的数组<code>arr</code>；</li>
<li>第二步，读取序列，逆序排列；</li>
<li>第三步，将逆序的序列，按照最终结果下标的顺序，放入定义好存放结果的数组；</li>
<li>第四步，按下标顺序输出数组，即两次循环输出数组，数组赋值多下工夫，没必要在输出上浪费精力。示意输出代码如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i][j];</span><br><span class="line">        <span class="comment">// 防止结尾有空格</span></span><br><span class="line">        <span class="keyword">if</span> (j != b - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止最后一行输出空格</span></span><br><span class="line">    <span class="keyword">if</span> (i != a - <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>首先读取数字，然后求解打印的矩阵有几行几列。因题目要求行数大于列数，且行数减列数的值最小。不妨设行数为$row$，列数为$col$，元素个数为$N$。众所周知，行乘以列等于矩阵元素数量，且，满足：$col\leq\sqrt{N}$ 或者 $row\leq\sqrt{N}$。那么就以根号为界限，一个值$i$向$\sqrt{N}$的左侧搜索，一个值$j$向$\sqrt{N}$右搜索，并满足$j-i$最小，搜出满足要求的解。</p>
<p>代码如下:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &lt;= n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i * j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - i &lt;= min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = j - i;</span><br><span class="line">                row = j;</span><br><span class="line">                col = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>将读取的序列逆序，这个时候借助不定长数组<code>vector</code>输入数据，并借助<code>Algorithm</code>库提供的排序函数完成逆序。代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 逆序的比较器</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">    v.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line">sort(v.begin(), v.end(), cmp);</span><br></pre></td></tr></table></figure></p>
<h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>既然已经确定了螺旋的过程可以分为多个步骤，先外圈，在内圈，在内内圈，在最内圈，脑补『先转蓝色一圈，在转橙色一圈，在转绿色一圈』。那么，实现每一个圈的代码，在重复这个代码，到无法转圈为止，代码是不是就写好了呢。</p>
<p><img data-src="/2020/02/05/Spiral-matrix/2.png" alt></p>
<p>以蓝色圈为例，同样可以分为四个子问题，示意图如下：</p>
<ul>
<li>第一次，从顶端的左侧到顶端的右侧，此时行不变，列自增；</li>
<li>第二次，从顶端的右侧到右侧的底端，此时列不变，行自增；</li>
<li>第三次，从底端的右侧到底端的左侧，此时行不变，列自减；</li>
<li>第四次，从底端的左侧到顶端的左侧，此时列不变，行自减，完成圈的包围。</li>
</ul>
<p><img data-src="/2020/02/05/Spiral-matrix/3.png" alt></p>
<p>按照这四次顺序编写程序，似乎就能很好的解决掉。那么这个时候开始偷懒：</p>
<ul>
<li>如果矩阵只有一列，原样输出逆序好的数组，不用经过复杂的算法。</li>
<li>如果矩阵只有两列，那么一定是$2\times 2$的矩阵，也可以直接输出。代码如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (col == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = v.begin(); it != v.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (row == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[<span class="number">3</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; v[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而其他情况归为一类，『像不像高中数学大题的分类讨论』。对于最复杂的情况，有几个要注意的点，防止踩坑：</p>
<ul>
<li>第一，设立标志位<code>flag</code>并初始化为0，用于记录自己画过几圈，一圈过后自增一次。如已经画过一圈，那么新的一圈中，行要从下一行开始，列要少一列。如果感觉抽象，可以看图：橙色圈在蓝色圈里面，橙色圈的行都要比蓝色圈的行的下标多一或少一。</li>
<li>第二，如果$1\rightarrow 2$的过程画了最右侧的元素$B$，那么在$2\rightarrow 3$的过程中就要避开最上面的元素$B$，防止重复赋值。同理，在$4\rightarrow 1$的过程中，也不要画最上面的元素$A$，防止重复赋值。即考虑四条边的边角部分$A,B,C,D$，不要重复赋值，如下图所示。<br><img data-src="/2020/02/05/Spiral-matrix/4.png" alt></li>
<li>第三，循环的注意事项：如果$1\rightarrow 2$ 和 $3\rightarrow 4$ 两天路线的行标是一样的，那么停止$3 \rightarrow 4$ 的赋值行为，因为这样只会覆盖掉$1\rightarrow 2$已经赋好的值。同理，$4\rightarrow 1$的路线不能覆盖$2\rightarrow 3$的路线。</li>
<li>第四，每画完一圈，行<code>row</code>、列<code>col</code>都要减少一次。</li>
<li>第五，当<code>flag</code>大于等于当前行数时，程序退出，因为flag表示已经画过的行，和<code>row</code>重合时表示画完了。当<code>col</code>小于等于1时，程序退出，对于$3\times 2, 5\times 2, N\times 2$ 等只有两列的矩阵，一次即可画好。尽管满足$flag &lt; row $，但不能开始画下一次，所以增加第二个限制条件。</li>
</ul>
<p>综上，程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较器</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        v.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将序列逆序</span></span><br><span class="line">    sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="comment">// 求行数和列数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * j == n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i &lt;= <span class="built_in">min</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">min</span> = j - i;</span><br><span class="line">                    row = j;</span><br><span class="line">                    col = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key 表示 该放序列的哪个值</span></span><br><span class="line">    <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定义画过的圈数</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 标记有几行有几列， 因为 row 和 col 的值会修改。 </span></span><br><span class="line">    <span class="comment">// a b 用于输出时表示几行几列</span></span><br><span class="line">    <span class="keyword">int</span> a = row, b = col;</span><br><span class="line">    <span class="comment">// 只有一列，直接输出</span></span><br><span class="line">    <span class="keyword">if</span> (col == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有两行  直接输出</span></span><br><span class="line">    <span class="keyword">if</span> (row == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[<span class="number">3</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; v[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第三类情况 </span></span><br><span class="line">    <span class="keyword">while</span>(col &gt; <span class="number">1</span> &amp;&amp; flag &lt; row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// i 表示从第几次开始画，flag为0，画过零次，</span></span><br><span class="line">        <span class="comment">// flag为1 画过一次 i就从下标1 开始，即下一行</span></span><br><span class="line">        <span class="keyword">int</span> i = flag;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = flag; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1到2 的路线 行不变 列自增</span></span><br><span class="line">            arr[i][j] = v[key];</span><br><span class="line">            key++;</span><br><span class="line">            <span class="comment">// 如果 1到2 画完了 ，就 i 自增，防止给 B 多次赋值</span></span><br><span class="line">            <span class="keyword">if</span> (j == col - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2到3 行不变 将当前行赋值给 k 列减减</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; row; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[k][col - <span class="number">1</span>] = v[key];</span><br><span class="line">            key ++;</span><br><span class="line">            <span class="comment">// 2 到 3 画完了 </span></span><br><span class="line">            <span class="keyword">if</span> (k == row - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 检查 3到4 和 1到2 是否重复，防止重复赋值</span></span><br><span class="line">                <span class="comment">// 如 5X5 的矩阵 是没有 3到4 这条线的</span></span><br><span class="line">                <span class="keyword">if</span> (flag == row - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果没有重复，画 3到4 col-2 防止给 C 重复复制</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">2</span>; j &gt; flag; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[k][j] = v[key];</span><br><span class="line">                    key ++ ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4到1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = row - <span class="number">1</span>; l &gt; flag; l--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 4到1 和 2到3 重复的话，就不画了，防止覆盖赋好的值</span></span><br><span class="line">            <span class="keyword">if</span> (flag == col - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                arr[l][flag] = v[key];</span><br><span class="line">                key++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 画完一圈，行列减一，次数加一</span></span><br><span class="line">        row = row - <span class="number">1</span>;</span><br><span class="line">        col = col - <span class="number">1</span>;</span><br><span class="line">        flag ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[i][j];</span><br><span class="line">            <span class="keyword">if</span> (j != b - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != a - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><img data-src="/2020/02/05/Spiral-matrix/5.png" alt></p>
<p>这是我认为比较容易理解的算法，但绝对不是最好的算法。如果你发现了某大佬写的算法介绍很简洁明了，排版清晰，且内容是给人看的，也可以推荐给我，相互学习。</p>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>天津之旅</title>
    <url>/2018/09/29/TianJin-Traveling-2018-9-29/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="再逢明月照九州"><a href="#再逢明月照九州" class="headerlink" title="再逢明月照九州"></a>再逢明月照九州</h2><p>闲来无事，趁假期好好玩玩，毕竟这20多年还从未离开河北省，选择了附近的天津，说走就走。没有目标地，也没有旅行团，随便走走。</p>
<p>吹吹风，走走路，看看风景。不得不说天津的小姐姐真好看。</p>
<a id="more"></a>
<p>大概是中午到达的车站，然后去了欧洲风情街(我享受不起的高端资本主义，一地的好看小姐姐随意的走，毕竟在偏远地区的理工院校待时间长了，真的好久没见过大规模的小姐姐)，曹禺故居，梁启超故居(不得不说梁前辈在教育孩子方面确实有一套)，天大南开(好想复读，说的我复读能考上似的)，晚上的分手之眼(一地的情侣，啊，可惜没对象)，第二天四点匆匆离开。</p>
<p>来回车费加住宿费饮食费不过200money，当然旅游的这几天都是省吃俭用。</p>
<p>不得不赞叹这个城市很美丽。</p>
<p><img data-src="/2018/09/29/TianJin-Traveling-2018-9-29/IMG_20180929_120325.jpg" alt><br><img data-src="/2018/09/29/TianJin-Traveling-2018-9-29/IMG_20180929_120333.jpg" alt><br><img data-src="/2018/09/29/TianJin-Traveling-2018-9-29/IMG_20180929_120340.jpg" alt><br><img data-src="/2018/09/29/TianJin-Traveling-2018-9-29/IMG_20180929_120341.jpg" alt><br><img data-src="/2018/09/29/TianJin-Traveling-2018-9-29/IMG_20180929_120342.jpg" alt><br><img data-src="/2018/09/29/TianJin-Traveling-2018-9-29/IMG_20180929_120343.jpg" alt><br><img data-src="/2018/09/29/TianJin-Traveling-2018-9-29/IMG_20180929_120347.jpg" alt></p>
]]></content>
      <categories>
        <category>天津一日游</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode支持C++17特性配置</title>
    <url>/2021/02/01/Vscode-support-C-17/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我当时也想用宇宙第一IDE，可实在是太大了，<code>i7-9750H</code>的CPU配32GB内存运行起来都很卡顿，我人傻了，这得啥配置才能驾驭visual studio。后来想想还是废点劲去配轻量工具吧。</p>
<a id="more"></a>
<h1 id="Vscode配置C-17环境"><a href="#Vscode配置C-17环境" class="headerlink" title="Vscode配置C++17环境"></a>Vscode配置C++17环境</h1><p>来这里下载<a href="https://nuwen.net/mingw.html" target="_blank" rel="noopener">mingw</a>，运行后会得到一个文件夹，这个文件夹放到C盘就可以了(其他盘应该也行)。而后将<code>C:\MinGW\bin</code>放到系统的环境变量，命令行输入<code>gcc --version</code>，如果有反应，就说明编译器这边配置成功了。</p>
<p><img data-src="https://static01.imgkr.com/temp/088d8f35322c47518deb7283e485c837.png" alt></p>
<p>对于<code>vscode</code>，先安装<code>C/C++</code>这样必不可少的语法检查等插件，然后在安装<code>Code Runner</code>插件，在配置文件中添加以下命令：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">"code-runner.runInTerminal"</span>: true,</span><br><span class="line"><span class="string">"code-runner.executorMap"</span>: &#123;</span><br><span class="line">        <span class="string">"cpp"</span>: <span class="string">"cd $dir &amp;&amp; g++ -std=c++17 $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt"</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p>
<p>这样编译代码时就支持<code>c++17</code>了。<del>我要是会<code>vim</code>我还用这？</del></p>
<p><img data-src="https://static01.imgkr.com/temp/25d9d0e4f7fe4b1ca211c4889cede7f4.png" alt></p>
<p>为了使编辑器不报红色波浪线的错误，键盘输入<code>ctrl+shift+p</code>，输入<code>C/C++ Edit Configurations(json)</code>，之后在弹出的<code>c_cpp_properties.json</code>文件中，写入支持C++17标准：<code>&quot;cppStandard&quot;: &quot;c++17&quot;</code>，然后就可以了。</p>
<p>给段代码，如果代码不画红色波浪线，就说明配置成功了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::string_literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">namespace</span> fs = <span class="built_in">std</span>::filesystem;</span><br><span class="line"></span><br><span class="line">    fs::path p&#123; <span class="string">R"(D:\Github\Cpp-Notes\codes\Chapter-07)"</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.geeksforgeeks.org/complete-guide-to-install-c17-in-windows/" target="_blank" rel="noopener">minGW安装</a></li>
<li><a href="https://0xboz.github.io/blog/how-to-run-debug-cpp-with-vscode-on-debian/" target="_blank" rel="noopener">Code Runner配置C++17</a></li>
</ol>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>西安电子科技大学实验报告LaTeX模板</title>
    <url>/2020/10/20/XDU-report-LaTeX-template/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我自己写的西安电子科技大学实验报告的LaTeX模板，只是按照老师的要求添加了基本元素，<strong>非官方，非官方，非官方。</strong>如果老师有明确要求请勿使用此模板。接下来简单介绍下如何使用模板。</p>
<a id="more"></a>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>来这上学一个月了，我也没找到官方的，老师也没发过任何模板，也不要求格式。我本科老师一直要求格式，内容写成啥样都行，格式错一点都不行。如：必须使用某类作业纸，写报告必须某类模板，多一个空格，错一个字体都要重新打印。主要是应付上面检查，所以很忽略内容而注重格式。但研究生没这破要求了，作业、报告写成啥样的都有，于是决定开 <code>LaTeX</code> 放飞自我。</p>
<p>我写的代码首要目的是简介、易用和容易扩展，所以：</p>
<ul>
<li>图片大小、文字大小不合适你都可以调，cls代码简洁明了。图片logo来自这里：<a href="https://github.com/fredqi/xduthesis" target="_blank" rel="noopener">https://github.com/fredqi/xduthesis</a></li>
<li>想添加内容也很简单，比如在封面添加「指导教师」这一项，你看看其他选项如何声明并传参的就可以了，很简单。</li>
<li>文档目录与编译方式：windows 和 Arch Linux 都跑通了，TexLive 2020，编译方式为 xelatex 配 bibtex。</li>
<li>代码字体为 IBM Plex Mono，没有的话换一个或下载安装；</li>
<li>我是计算机学院的，对其他学院的了解很少，如果有其他建议，欢迎补充～</li>
<li>也可以来这里下载，下载一次我能挣一毛钱，顺便帮这个网站引流：<a href="https://latexstudio.net/index/details/index/mid/870.html" target="_blank" rel="noopener">https://latexstudio.net/index/details/index/mid/870.html</a></li>
</ul>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>第一步就是导入文档类：<code>\documentclass{xdureport}</code>，而后写入基本信息：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">major</span><span class="string">&#123;电子信息&#125;</span></span>                   <span class="comment">% 专业</span></span><br><span class="line"><span class="tag">\<span class="name">stuid</span><span class="string">&#123;201614420112&#125;</span></span>             <span class="comment">% 学号</span></span><br><span class="line"><span class="tag">\<span class="name">college</span><span class="string">&#123;计算机科学与技术学院&#125;</span></span>       <span class="comment">% 学院</span></span><br><span class="line"><span class="tag">\<span class="name">date</span><span class="string">&#123;\zhtoday&#125;</span></span>                  <span class="comment">% 日期</span></span><br><span class="line"><span class="tag">\<span class="name">expname</span><span class="string">&#123;小样本实验&#125;</span></span>               <span class="comment">% 实验名称</span></span><br><span class="line"><span class="tag">\<span class="name">course</span><span class="string">&#123;高性能智能计算实验&#125;</span></span>         <span class="comment">% 课程</span></span><br></pre></td></tr></table></figure>
<p>文档的目录结构如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XDU-exp</span><br><span class="line">├─ chapter                                  <span class="comment"># 各个章节</span></span><br><span class="line">│    ├─ abstract.tex                            <span class="comment"># 摘要页</span></span><br><span class="line">│    ├─ appendix.tex                            <span class="comment"># 附录</span></span><br><span class="line">│    ├─ conclusion.tex                          <span class="comment"># 实验结果分析</span></span><br><span class="line">│    ├─ experiment.tex                          <span class="comment"># 实验步骤</span></span><br><span class="line">│    └─ reference.tex                           <span class="comment"># 参考文献</span></span><br><span class="line">├─ figure                                   <span class="comment"># 图片文件</span></span><br><span class="line">│    ├─ xdubadge.eps                            <span class="comment"># 西电文字</span></span><br><span class="line">│    └─ xdulogo.eps                             <span class="comment"># 西电校徽 logo</span></span><br><span class="line">├─ code                                     <span class="comment"># 代码文件</span></span><br><span class="line">│    └─ demo.c                                  <span class="comment"># 一个C语言样例代码</span></span><br><span class="line">├─ books.bib                                <span class="comment"># 参考文献的 bib 文件</span></span><br><span class="line">├─ main.bbl                                 <span class="comment"># 编译生成的 bbl 文件，不用管</span></span><br><span class="line">├─ main.pdf                                 <span class="comment"># 结果 pdf 文件</span></span><br><span class="line">├─ main.tex                                 <span class="comment"># 要编译的主文件</span></span><br><span class="line">└─ xdureport.cls                            <span class="comment"># 要导入的文档类</span></span><br></pre></td></tr></table></figure>
<p>理解文档目录结构后，就很容易知道代码中指定的相对路径是什么意思，现在就可以开始写正文了：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">makecover</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 摘要</span></span><br><span class="line"><span class="tag">\<span class="name">input</span><span class="string">&#123;chapter/abstract.tex&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 目录</span></span><br><span class="line"><span class="tag">\<span class="name">thispagestyle</span><span class="string">&#123;empty&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">tableofcontents</span></span></span><br><span class="line"><span class="tag">\<span class="name">newpage</span></span> </span><br><span class="line"><span class="tag">\<span class="name">setcounter</span><span class="string">&#123;page&#125;</span><span class="string">&#123;1&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 实验过程</span></span><br><span class="line"><span class="tag">\<span class="name">input</span><span class="string">&#123;chapter/experiment.tex&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 标注环境</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;note&#125;</span></span></span><br><span class="line">ads 测试</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;note&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 结论</span></span><br><span class="line"><span class="tag">\<span class="name">input</span><span class="string">&#123;chapter/conclusion.tex&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 参考文献</span></span><br><span class="line"><span class="tag">\<span class="name">input</span><span class="string">&#123;chapter/reference.tex&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 附录</span></span><br><span class="line"><span class="tag">\<span class="name">appendix</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">input</span><span class="string">&#123;chapter/appendix.tex&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><h2 id="封面"><a href="#封面" class="headerlink" title="封面"></a>封面</h2><p><img data-src="https://static01.imgkr.com/temp/de8968992dd5421c84f8034c6d7a4655.png" alt></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p><img data-src="https://static01.imgkr.com/temp/6d135f696e7d4fe1af2534dd55ae1708.png" alt></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><img data-src="https://static01.imgkr.com/temp/0a451c77c18f4d8ea61d6e1f9aea482f.png" alt></p>
<h2 id="正文与标注环境"><a href="#正文与标注环境" class="headerlink" title="正文与标注环境"></a>正文与标注环境</h2><p><img data-src="https://static01.imgkr.com/temp/feac728074ee4f6391138c8913c36a7e.png" alt></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><img data-src="https://static01.imgkr.com/temp/cf8d17b244b14ba782709474be216a96.png" alt></p>
<h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p><img data-src="https://static01.imgkr.com/temp/384e43e486e74ed7b5b82e31df10bcc9.png" alt></p>
<h1 id="完整代码下载"><a href="#完整代码下载" class="headerlink" title="完整代码下载"></a>完整代码下载</h1><p><a href="https://github.com/muyuuuu/XDU-report-LaTeX-template" target="_blank" rel="noopener">https://github.com/muyuuuu/XDU-report-LaTeX-template</a></p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>我在网上看到了西电的 <code>Beamer</code> 和 <code>thesis</code> 模板，看样子写的不错，我应该不会去继续折腾那些了。</p>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>保研经验分享——二本院校热门专业</title>
    <url>/2020/06/06/about-graduate-or-work/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>背景：近期有较多的学弟学妹问我关于保研的事情，每次都回答一遍显得很累，所以整理在这里了，希望对学弟学妹有帮助。全文高能，歧视低学历（如我的外省二本院校），歧视高学历（如我之前的各种同学大多认为学历没用），这两类人自行忽略本文，没在一个世界。且，以下内容更多的针对我这种二本院校出身的，且身在热门专业的学生，如计算机、金融等。对于不是很热门的专业，或者211，985的学生可一笑而过。</p>
<p>最重要的：我校的大多专业都是一个专业只有一个保研名额，竞争激烈，且我校很多学院承认一些水平较低的论文，如国家级、省级的期刊，而这些论文是可以花钱买的，所以还请各位善良。多学学我，保研前一年丝毫没心思提成绩搞论文整比赛，反而天天在宿舍睡觉。二本双非的保研到211、985已经很不容易了，请不要再给他们添乱，把机会留给专业里真正有水平的人。</p>
<a id="more"></a>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本文就按照时间顺序介绍了。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h1 id="五六月份准备"><a href="#五六月份准备" class="headerlink" title="五六月份准备"></a>五六月份准备</h1><p>这段时段是推免前的前期准备，有以下需要准备的事项：</p>
<h2 id="简历："><a href="#简历：" class="headerlink" title="简历："></a>简历：</h2><p>个人介绍、绩点、排名、四六级、获奖荣誉、科研经历。（学生会的经历最好别写，没人看）。比如我就是在4月底美赛结果出来后开始写简历的，因为这个时候对我而言，所有的奖都到手了。</p>
<p>比如XX比赛一等奖之类的，不要客气，放心大胆的写。比如参加了某个含金量不错的比赛，但是遗憾的没有拿奖，但你的成果里是有真东西的，也写到简历里(比如写到<strong>项目经历</strong>里，不要害羞)。夏令营的时候带过去，只要自己认为有想法有含金量的东西，都带上。</p>
<p>而双非的学生可能需要注意的，成绩写专业排名就行了，如rank：2/72。具体多少分可以不写，因为二本学校的90分和211学校的90分可能不是一个概念。我是真的知道我校的考试多easy，听我华电电气的同学说，天天被考试折磨，这样考试、那样考试、平时测试等等等等，我很难想象被考试折磨的压力。</p>
<h2 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h2><p>200字版本，500字版本都准备下，有的学校要。（写自己学习经历，比赛经历，科研经历，对哪些感兴趣，未来会怎么做）。有的学校会要简历、简介的英文版，应为有的外教老师也要看。（不写也行，写了能证明英语水平）。</p>
<h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>大多好学校对英语的要求是：六级通过或者四级大于550，是绝大多数学校的要求，英语不好寸步难行，只能说上流985别想了，英语没过六级的小伙伴加油了。</p>
<h2 id="成绩单"><a href="#成绩单" class="headerlink" title="成绩单"></a>成绩单</h2><p>学工办打印成绩单，学习成绩排名证明，学院盖章，教务处盖章。（全部学校都会要这些，只要学院给盖，教务处那边都好说，但有的学院的老师不好说话，不给打印成绩单，问为什么就说成绩单打印不了（其实能打印，看老师那副怕事的嘴脸可能是怕担责任，他可能看到每年都有保研不错的，以为保研很容易，其实保研不比考研简单，但一定比考研舒服），多跑几次吧）。</p>
<h2 id="研究方向"><a href="#研究方向" class="headerlink" title="研究方向"></a>研究方向</h2><p>选好专业的研究方向，读专业前沿的论文（英文的），毕竟人家可能到时候会直接问你对哪些感兴趣，默认你除了学习之外做过一些研究。双非的学生只是成绩好没有竞争力，毕竟研究生做的是研究。</p>
<h1 id="外校夏令营"><a href="#外校夏令营" class="headerlink" title="外校夏令营"></a>外校夏令营</h1><p>你要知道，普遍很好的学校都没有学历歧视，但是他们就是不录取你。有的学校会有明确要求，双非的学生学习成绩必须多少、英语必须多少、双非学生的比例不能超过总人数的1%，甚至不是双一流的学生统统不要。以上是真实事件。脑补张雪峰的那句话，大企业会说我不歧视学历，但我就不要你。所以放宽心态，有部分985、211还是对双非的学生很友好的。</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>以下是我的真实经历：一个很一般的985对我说，本院已经接受了72名985的学生，300名211的学生，因此不在接受任何双非的学生。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>当然这也不能怪人家，换我我也一样。有优秀的学生谁要双非的，要怪就怪自己当初不好好学习。</p>
<p>保送的时候处处被拒，没有一个学校要我，最北边吉林大学，最南边哈尔滨深圳，最东边华东师范和上海科技，最西边重庆大学。但凡有一个学校要我，说，让他来，哪怕是垫底来激励其他同学，我也就认投了，但是并没有。甚至某东南沿海的985，老师和副院长都同意要我了，那个导员看到我是双非的就又把我踢出去了。那天彻底失眠了，也彻底放弃了去 985。</p>
<p>当然我很清楚的是，我校虽然是二本，但保研的人都是很强的。我还记得2018年冬季，美赛时间是2月13日结束，春节是2月16日。备战美赛是在期末结束后开始的，所有人都回家了。当时大概只有电子设计、Robomaster和建模的留校了，备战的一个月食堂只有两窗口开着，超不过8个菜我们连续吃了一个月，真的想吐，大部分菜还是拔凉拔凉的；一个月的时间内还没有地方洗澡。最后实在难受，学校就跟宾馆商量了一下让我们去洗了一次澡。比完赛，我还记得那天的场景，腊月28，市区空荡荡的，街上所有人都回家过年了。只有三辆公交车把我们一百多个学生从学校送到市区，这一百多个学生蓬头垢面，下车后拎着行李要赶火车回家过年。我家近，晚上十点就到了，家远的腊月29还在回家的火车上。我们知道自己出身双非，置身凡尘但我们仍然在仰望星空，我们也吃过苦也遭过罪但没有早早的放弃。这一百多个人大多都很优秀，但是，只有不超过30个人能拿到保研名额。真的很意难平，也希望后来的学子不在遭受这种苦难，哪怕真的遭受了，也希望都能有个好的归宿。</p>
<p>重要的一点是，别管你的对手出身自多好的学校，也别管对面的学校多厉害。只要想去，就投简历，投了可能没机会，不投永远没机会。以15信息院的学生而言，去年有俩推到了中科院，一个直博了中科院的计算所，今年也有一个推到了中科院，也有拿到北大、复旦、北邮信通offer的人，还有电子的学生直接进国防的，其他大多是北交、北科，所以看你自己实力够不够硬了；也有成型、能源、机械、地理这样的专业能推到北航、哈工大、北师范的，这些专业行情我不了解，就不瞎说了。（其实这也就是上文那一百多个人中的佼佼者，不过也有在其他实验室的，节能减排、模拟炼钢、嵌入式等实验室）</p>
<p>因为我在实验室这边，实验室学生最不缺的就是项目和比赛，一大把一大把的，所以实验室这边的学生基本都能推免到不错的211和985。我也有幸见过几个推免到中科院的，实力确实不错。不在实验室这边的人能推到哪里我就不清楚了。</p>
<p>夏令营期间别人各种忙着准备面试，我佛系的忙着吃喝玩乐。因为知识是多年的积累，一朝一夕改变不了啥。​​也认识了好多大佬，忙着加好友。双非的也有很强的，我自愧不如，啥啥都会，特别强。同理有985过来的是真的菜。​​双非可利用的资源很少，如果想上进，就得舔瓶盖式的抓住任何比赛，任何老师。比如给的保送名额少的可怜，还希望我们留本校（我有病啊留本校），科研资源也很少，某次比赛，暨南大学给他们的本科生投资了十万块的电脑，我们拿着自己的破笔记本。​​抛开这些，计算机公认的12门核心课，我们学校能开的只有大概8门？从培养方案上就没发和别人比。就相当于参加高考，学校开不起数学这门课一样，我拿啥跟人家比。</p>
<p>和其他学校对比，从培养方案、师资力量、培养方向而言，差距很远，差的实在是太多了，相差甚远。​​​即使是其他的一本院校，如青岛理工、江西理工。人家也是双非，但是有ACM集训队，计算机核心课都认真开，电路、数电、模电、微机接口、编译原理、ACM算法，这是人家的课，羡慕死了。​​​我们的课开成啥样，我们的培养方案，我就不吐槽了。​​​</p>
<p>当时老师就问我，你培养方案什么情况，怎么有这么些课都没学过？我说有的课我自学了，资源很少的情况下只能笨鸟先飞。​​而985的学生就像海里的鱼，只要自己肯张口，整个海都是你的。能提供的工作环境，科研环境，教学质量确实没法比。​​不过也不用慌，我当时在想，我和985面试一个学校，只有一种情况，他是真的菜，好学校真正强的那批人完全可以清北交复，何必跟我这种双非的抢学上。</p>
<p>想来想去，一些吐槽的话就不在这里说了，就把我保研期间在各校被问的专业题放到这里吧，就不注明学校了。</p>
<p>我曾经被问过 Github 如何使用，嵌套查询与连接查询的区别，读没读过算法的源码、特征值特征向量、条件概率、数据结构、编程水平、C++里面的STL组成，类与虚基类的区别、OJ、链表，堆栈，数据库范式，排序算法等。计算机网络的体系结构，CSMACD协议，局域网以太网，网络层和运输层的本质区别，套接字，Socket，ARP，DNS，我也不知道为啥那老师按着我问了一本计算机网络的东西，所以印象极度深刻。课程的实验，如计算机原理的实验，计算机网络的实验，我直接说的我没做过，毕竟我知道我说不上来。</p>
<p>以上是好多学校累积的面试问题，有的也记不清了，当然也有的那种学校问得特别多。一般私底下联系的面试，时间在半个小时到两个小时左右，更多的是求有个学上而主动找的话题（当然是技术方面的话题），正常的去对面学校的面试也就三五分钟。</p>
<p>还有一些比赛、项目里面的细节，这里就不说了，说了也没用。对于未来的认知，对于学习的观念，对于计算机的应用，对于基础知识的掌握，写代码收获，英语水平。这些难免要有，看着往高大上的扯吧。</p>
<h1 id="9月本校推免"><a href="#9月本校推免" class="headerlink" title="9月本校推免"></a>9月本校推免</h1><p>就不考虑以升那个学院了，以升的要求和其他学院的要求不一样。只分析学校发的针对普通学院的文件，一般是在9月开学的第一周周五左右开始搞，第二周基本能搞完。</p>
<h2 id="本校要求"><a href="#本校要求" class="headerlink" title="本校要求"></a>本校要求</h2><ul>
<li>学习成绩排名本专业前30%（含30%）有资格参与保研。</li>
<li>最后的加分是：学习成绩（不含任选课成绩）占85%，其余比赛加分占15%。因为水论文的太多了，学习成绩的比例逐年提升。</li>
<li>推荐工作程序：学生自愿申请报名→学院遴选推荐→领导小组办公室审核→公示、上报。</li>
<li>提交电子版、纸质版材料（到时候会发表，按照表格填就行，很简单）</li>
<li>一群老师看着你加分，造假是不可能的，一个下午加完，出结果。</li>
<li>从公示到9月28号之间这大约半个月的时间里，没人举报的话，基本稳了，然后天天像过年。</li>
<li>比赛证书等，尽量携带原件​​​​</li>
</ul>
<p>因为我是人工智能学院（原信息工程学院）的，就多说一点本院的要求：学习成绩占85%，其他比赛、论文占15%，专业成绩前30%的人有资格参与保研。这大概是学校硬性规定。</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>但是分数具体怎么加，取决于不同的学院。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>信息院就是：专业必修+专业选修算学习成绩，剩下的比赛、论文加分按平时的综测来。唯一不同的是：综测认水论文，保研不认。保研加分时，论文加分被削减，中文核心以下的论文加分很少很少，四舍五入等于没有，中文核心及其以上的论文加分正常。</p>
<p>把三年的东西都带上，证书，证明等，相同的比赛允许重复加分（如2018年美赛二等奖和2019年美赛一等奖不冲突），不会只取其一。一群老师看着你加分，比赛加分完结后，如一个专业，A的比赛加分是200，B的比赛加分是100，那么A的比赛成绩会折算为100，同时B的成绩折算为50。</p>
<p>然后，防止最后的加权总分（因为这个总分要上报教育系统，全国的推免生的分数都要上报）超过100，还会有个折算。没错，这个折算会继续折算比赛的分，而学习成绩的分数不会变动，所以学习成绩很重要的。两次折算后竞赛加分会大打折扣。这么说吧，用一个真实案例解释下，一个人的论文加分比我多100分，但是一波折算后论文加分就比我多4分，而我学习成绩比他多4分，显而易见还是学习成绩重要。</p>
<p>最后比赛成绩乘以15%，加学习成绩乘以85%，看谁是第一，因为很多专业一个专业就一个保研名额，如我的计算机专业。</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>本校的大多专业（大概85%的专业吧）都是一个专业只有一个保研名额，竞争激烈，还请各位善良。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<ol>
<li>并不是你靠买各种论文、挂名各种项目、随便找个有含金量或没含金量的比赛就能保送到好学校的；你以为对面老师傻还是咋地，对面老师带了多少年的学生、在带学生之前又做了多少年的学生，经历比你丰富多了。</li>
<li>就你一张口，你是什么水平、你的项目、你的比赛值不值钱，就算你的比赛值钱，但你在里面负责划水还是主力，这些情况一目了然。之前出现过一个学生美赛一等奖，去大连理工面试被一问三不知的情况。以我面试本校学生的经历而言（两年建模学术部招新由我面试）。学生一开口介绍，就能区分出三六九等，哪些人想蒙混过关，哪些是认真的，哪些人的思维不错，真的，很明显一眼就能看出来。</li>
<li>二本双非的学生推免很不容易了，不要再给真正有实力保研的人添乱，早早准备考研不好么？保研的数学、英语功底不知道比保研的强多少，而读研期间数学、英语是很重要的。</li>
<li>且你的朋友、你的品德、你的所作所为，真的是会伴随你的一生。有买论文的时间多和专业大佬交流交流技术，涨涨视野不好么？这可比保研强多了，眼光要放长远。</li>
<li>多学学我，保研前的一年我都在睡觉，睡觉不比勾心斗角的买论文舒服吗？</li>
<li>假设读到这里，你还是不肯放弃靠XX手段来保研的话。那我有必要说一下，保研可以举报，且每年举报的都挺激烈，买来的水论文等东西被抓住证据最容易被举报了。</li>
<li>读研的日子不一定很轻松，如果你侥幸靠这些推免到不错的学校。你较低的学习水平、科研水平将会迎来无数被毒打的日子，一问三不知的日子不舒服。当然啥都不会这不是重点，重点是你的导师可能从此以后都不会在理你，彻底放弃你，连毕业都困难。（所以准备举报的同学，可以顺手把举报信发送到对面学校的老师手里）。</li>
</ol>
<h1 id="9月28推免生报名"><a href="#9月28推免生报名" class="headerlink" title="9月28推免生报名"></a>9月28推免生报名</h1><p>假设9月初你就确定拿到了本校的推免名额，这个时候不要兴奋过头。你可以去继续联系学校，因为有的学校肯定会被放鸽子而导致名额没有招满，这个时候可以继续练习好学校。不要抱着捡漏的思想，而是我身边大约75%的学生都是在9月初到9月28号这段时间才找好学校的，夏令营就确定学校的人还是少，显然，我吃了这个亏。我一个金融的朋友就是在这个时间段找到了学校。</p>
<p>你这样想就简单了，211、985里面最强的大佬能割掉六七个offer。假设他割了6个offer，但他只能去一个学校，剩下的5个学校就没招满，这个时候就看谁运气好了。</p>
<p>当初某985的确也在9月中旬给我发了去面试的信息，呵，我就不去。当然我知道985多我一个不多，缺我一个不缺，我在他们眼里很不重要，这一点我很清楚。问题是他们做事太缺德了，我当初投简历不要我，最后发现保研没招满想起来让我去了，几个意思？显然我没有当备胎的习惯，尽管你是不错的985。</p>
<p>如果联系好了学校，9月28号凌晨开始报名，别问为啥是凌晨。因为全国研招办的老师都在这一时间点在研招网疯狂的给学生发录取信息，生怕到手的学生跑了。就保研学生的平均而言，保研的学生终归是学校各专业里的佼佼者（买论文造假的除外）。那天起床打开朋友圈，一个保送到浙大的朋友（没记错的话是机械专业）是在凌晨两点半录取的，一个敢发，一个敢等。</p>
<p>希望那天的网速够快，各位都能去心仪的学校，而9月28号那天在朋友圈里秀录取通知的希望也有你。（别问，问就是9月28号那天打开朋友圈，十几条信息都是保研的人在秀录取通知）。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>你可能认为文章里有些诋毁本校，奉承外校的语言。我承认我有些片面，因为我从来都不是满足现状的人，目光从来都是往上看，看看有没有更好的世界，有没有更好的待遇。所以我很少和本校的学生交流。社交也基本不在本校的群，本校的群基本都退了，聊的内容我是丝毫不感兴趣。基本都去水外校的群，也有幸认识了很多不错的学生。</p>
<p>和这些在其他学校专业里很不错的学生去交流，我承认通过他们我看到了更广阔的世界，我了解了更多，看到了更好的教学资源和教育水平。所以别和我抬扛，如果非要说，那就是对不起，我错了，你对了，是我阴阳怪气，是我井底之蛙，我校实力河北省一流，非常适合学习，非常不错，一切都是我不好，我没有和别人吵架的习惯，没意思。</p>
<p>最近也遇到了很奇怪的事情，朋友圈几个保研的人都在讨论什么时候退学，我也萌动了些许退学的想法。对于直接工作的人，三年的时间去公司学习技术，这基本上也能磨平任何学历差距。读研并不会提升找工作的技术水平，因为大多数的读研是读论文、做实验，只能提高你的学历（当然有少部分读研是帮老板接外面各大工厂的项目，这也不能说是一种坏处）。到了公司还是发现啥都不会，代码写的不咋地，实际流水线的生产流程还不熟悉。而和你同龄的，没考研直接找工作的人却靠三年的工作，有了不错的积蓄、经验和人脉了，等待被公司提拔，而你却是刚入职场的小白。当然你要读博、要在学术界追求更深的造诣当我以上都没说，所以一定要想好自己到底要不要读研。</p>
<p>也别说靠本科四年的知识找不到工作（仅限计算机专业），那是你水平不够，那是你懒，是你大学四年没认真的做项目，大学写过的代码太少，没好好学习。我身边大多找工作的同学都能在大四开学的时候入职，大四一年不在学校的那种。</p>
<p>以上是我大四临毕业时极度片面的观点，我没有体验过上班的生活，所以有的见解很片面。如果你看不惯，且，你有真实的，受益大众的经历（针对极其特殊的个人的经历不算，你的经历只适合比尔盖茨、扎克伯格那肯定不算），也欢迎分享，我虚心学习。还是那句话，我没有吵架的习惯，所以还请好好说话，我又不是不能接受你的观点并改正。</p>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>关于提问与回答</title>
    <url>/2020/01/07/about-qa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>真香，以及，多年（两年）混迹（摸鱼）在计算机的圈子，见过各式各类的人，也见过各式各样的问题，关于如何正确的对程序中存在的问题进行提问，也是一门技术活，也有许多要注意的地方，整理如下。</p>
<a id="more"></a>
<h1 id="提问不该廉价"><a href="#提问不该廉价" class="headerlink" title="提问不该廉价"></a>提问不该廉价</h1><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>不要不懂就问，这是一种陋习。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>提问应该是自己尝试多遍、千辛万苦但仍然无果的情非得已的无奈之举，不要把提问当成举手之劳、随口一说，沟通成本会带来回答者和提问者的负担，浪费时间与精力。提问时请证明你的确做了良好的前期工作。此外，<code>deadline</code>快到了、导师催得紧、比赛着急这些东西也不是你可以不求甚解、一步登天、顺理成章伸手的借口。</p>
<h1 id="错误提问"><a href="#错误提问" class="headerlink" title="错误提问"></a>错误提问</h1><ol>
<li><blockquote>
<p>拍个照片问问题在哪。</p>
</blockquote>
</li>
<li><blockquote>
<p>啥都不说就问能不能解决这个问题，其中以<code>无脑</code>问题居多。无脑问题即文档都有的东西张口就问，不读书不过脑子且无思考</p>
</blockquote>
</li>
<li><blockquote>
<p>态度不端正，现在年轻人心浮气躁：你行你上，不行就别说话；能回答就说，不回答就闭嘴，宛如一个大爷一样。</p>
</blockquote>
</li>
</ol>
<p>作为任何论坛、社区的管理员，他们都在义务的维护与回答，他们更想授人以渔，对他们来说授人以鱼很快，但对你没有好处，他们是为了让你多钻研、多思考。</p>
<ol>
<li><blockquote>
<p>一直再说出错，你说一百遍出错了它还是错的，务必提供有用的信息。</p>
</blockquote>
</li>
</ol>
<h1 id="正确提问"><a href="#正确提问" class="headerlink" title="正确提问"></a>正确提问</h1><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>假设此时的你已经做了前期工作，读过相关教程、文档，并实现过部分内容， 而非纸上谈兵。 </p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>如果你不满足以上条件，请停止提问，先去沉淀自己，做好足够的知识储备。</p>
<blockquote>
<p>首先，列出问题背景。</p>
</blockquote>
<p>务必提供操作系统版本、软件版本及其相关库的版本，只谈问题而不谈版本都是耍流氓行为。</p>
<blockquote>
<p>之后，列出问题描述。</p>
</blockquote>
<p>在什么环境下，使用了什么软件，进行了什么操作，得到了什么错误，描述清楚。甚至提供必要的命令、截图、报错信息，甚至<code>log</code>等信息。</p>
<blockquote>
<p>其次，给出<code>MWE</code></p>
</blockquote>
<p><code>Minimal Work Example</code>，能在他人电脑工作的最小实例，不包含与问题无关程序，做到简短，能<code>复现</code>问题即可。并提供文本形式的代码，而不是截图。没必要让他人照着你的图片在敲一遍你的程序，浪费时间。</p>
<blockquote>
<p>然后，列出自己的行动</p>
</blockquote>
<p>列出自己尝试过的解决方案，给出参考网址。避免他人重复你做过的工作。</p>
<blockquote>
<p>最后，写出进展情况</p>
</blockquote>
<p>如，毫无进展或者解决部分问题；都要写一下。</p>
<h1 id="结语，最后但很重要"><a href="#结语，最后但很重要" class="headerlink" title="结语，最后但很重要"></a>结语，最后但很重要</h1><ul>
<li>学会使用Github, Stackoverflow等主流工具</li>
<li>别看某度、某乎、某园、某DN等不靠谱不专业社区</li>
<li>当你熟悉上述的提问流程后，其实你能独立解决绝大多数问题。而会解决遇到的任何问题，比会提问要实在的多。</li>
</ul>
]]></content>
      <tags>
        <tag>Computer</tag>
      </tags>
  </entry>
  <entry>
    <title>提升方法（上）——基于AdaBoost：SAMME</title>
    <url>/2020/04/02/adaboost/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在多年前的某次任务中，看到了别人使用提升树等算法，取得了比较好的效果。今日眼馋，特来学习提升方法，并记录于此。提升方法是一种统计学习方法。在分类问题中，通过改变训练样本的权重，学习多个分类器，将多个分类器进行线性组合，以提升分类的性能。</p>
<p><img data-src="/2020/04/02/adaboost/error_rate.png" alt></p>
<a id="more"></a>
<p>本文收录：</p>
<ol>
<li>具有代表性的提升方法：AdaBoost算法；</li>
<li>算法原理</li>
<li>算法推导</li>
<li>算法解释</li>
<li>举例说明</li>
<li>代码实现</li>
</ol>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>提升算法的思想很简单：对于一个分类任务，一个专家说的结果可能不太可靠，但一群专家说的结果总是大体可靠的。即：多个专家说的话比一个专家说的话可信，多个分类器共同分类的结果要好于一个分类器分类的结果。</p>
<p>而训练一个弱分类器总比训练一个强分类器方便的多。那么针对一个训练集，提升方法就是先学习一个弱分类器，从弱分类器出发，改变训练数据的权重，反复学习到一系列的弱分类器，将这些弱分类器组合成一个强分类器。</p>
<p>这样，就导出了两个问题：</p>
<ol>
<li>反复训练时如何更新数据的权重；</li>
<li>如何将多个弱分类器组成一个强分类器；</li>
</ol>
<p>对于第一个问题：提高被前一轮分类器分类错误样本的权重，这样这些样本会在下一轮的弱分类器中受到更大的关注，于是分类问题将被一系列的弱分类器分而治之。</p>
<p>对于第二个问题：AdaBoost采用了加权多数表决的方法，即：加大分类误差率小的分类器的权重，降低分类误差率大的分类器的权重。使正确率高的分类器在表决的过程中起到更加关键的作用。</p>
<h1 id="算法推导"><a href="#算法推导" class="headerlink" title="算法推导"></a>算法推导</h1><p>输入：训练数据集$T\{(x_1, y_1), (x_n, y_n), \cdots ,(x_n, y_n)\}$，假设为二分类任务，标签为$\{-1, +1\}$。输出：最终的分类器 $G(x)$。</p>
<ol>
<li>初始换训练数据的权重，均匀分布权重。<script type="math/tex; mode=display">D=(w_{11}, w_{1i}, \cdots, w_{1n}), w_{1i}=1/N,i=1, 2, ..., N</script></li>
<li>设有$M$个弱分类器，对于$m=1, 2, …, M$：</li>
<li>使用权重 $D_m$ 的分类器训练数据，得到基本分类器 $G_m$</li>
<li>计算$G_m$ 在训练数据集合中的误差，误差率是分类错误样本的权重和。<script type="math/tex; mode=display">e_m=\sum_{i=1}^nP(G_m(x_i)\neq y_i)=\sum_{G_m{x_i}\neq y_i} w_{mi}</script></li>
<li>计算$G_m(x)$这个分类器的权重：$\alpha_m=\frac{1}{2}\log \frac{1-e_m}{e_m}$，不难得到$\log \frac{1-x}{x}$为减函数，误差越小，权重越大</li>
<li><p>更新数据集的权重分布，有点softmax的意思，确定所有样本的权重和为1且为正数：</p>
<script type="math/tex; mode=display">D_{m+1}=(w_{m+1, 1}, w_{m+1, i}, \cdots, w_{m+1, N})</script><script type="math/tex; mode=display">w_{m+1, i}=\frac{w_{m, i}}{Z_m}\exp (-\alpha_m y_i G_m(x_i))</script><script type="math/tex; mode=display">Z_m=\sum_{i=1}^Nw_{m, i}\exp (-\alpha_m y_i G_m(x_i))</script><p>当分类正确时，$y_i G_m(x_i)$同号，权重被减小；当分类错误时，权重放大，受到下一轮分类器的关注。</p>
</li>
<li><p>构建线性组合器：$f(x)=\sum_{i=1}^N\alpha_mG_m(x)$</p>
</li>
<li><p>得到最终分类器：$G(x)=\text{sign}(f(x))$，结果由$M$个分类器加权表决。</p>
</li>
</ol>
<h1 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h1><p>其实，AdaBoost本质上为一种前向加法模型。即每次只优化当前的一步，后一步根据前一步的结果继续优化，得到最终的分类器。</p>
<h2 id="前向分布算法"><a href="#前向分布算法" class="headerlink" title="前向分布算法"></a>前向分布算法</h2><p>考虑加法模型</p>
<script type="math/tex; mode=display">\begin{equation}
f(x)=\sum_{m=1}^M\beta_mb(x;\theta_m)
\end{equation}</script><p>$b(x;\theta_m)$为基函数，$\theta_m$为函数的参数，$\beta_m$为基函数的权重。在给定训练数据和损失函数的条件下，学习加法模型$f(x)$成为损失函数极小化的问题：</p>
<script type="math/tex; mode=display">\begin{equation}
\min_{\beta_m, \theta_m}\sum_{i=1}^N(y_i, \sum_{m=1}^M\beta_mb(x;\theta_m))
\end{equation}</script><p>这是一个复杂的优化问题，前向步算法求解此类问题的思路是：每一次只优化一个基函数和系数，逐步逼近优化目标，那么就可以简化优化的复杂度。因此每一步的极小化损失函数为：</p>
<script type="math/tex; mode=display">\begin{equation}
(\beta_m, \theta_m)=\text{argmin}_{\beta_m, \theta_m}\sum_{i=1}^NL(y_i, f_{m-1}(x_i)+\beta_{m-1}b(x_i;\theta_{m-1}))
\end{equation}</script><p>得到新的参数$\theta_m, \beta_m$，更新当前加法模型为</p>
<script type="math/tex; mode=display">\begin{equation}
f_m(x)=f_{m-1}(x)+\beta_mb(x;\theta_m)
\end{equation}</script><p>得到最终的加法模型：</p>
<script type="math/tex; mode=display">\begin{equation}
f(x)=f_M(x)=\sum_{m=1}^M\beta_mb(x;\theta_m)
\end{equation}</script><h1 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h1><p>也许你公式看的很枯燥，但看个例子也就明白了，训练数据如下。目标是训练三个分类器：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$x$</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>$y$</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>-1</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>第一个分类器：初始化每个样本的权重为0.1，分类误差率最低时，阈值$v_1=2.5$。得到的分类器为：当$x&gt;2.5$时，$y=-1$，当$x&lt;2.5$时，$y=1$，类似一个深度与1的决策树。计算得到误差率$e_1=0.3$，跟新第一个分类器的权重$\alpha$为$\frac{1}{2}\log\frac{1-0.3}{0.3}=0.4$，更新权重分布$D_1$（太长了就不一一列举了）。</li>
<li>第二个分类器：利用第一轮的权重结果$D_1$，更新数据集。此时分类错误率最低时，阈值$v_2=8.5$，且$x$小于8.5时判断为1。计算误差$e_2$，计算第二个分类器的权重$\alpha_2$，计算第三轮数据的权重$D_2$。因要求是训练三个分类器，这也是最后一次更新权重。</li>
<li>第三个分类器：按照第二轮的权重$D_2$，再次训练，分类错误率最低时的阈值为$v_3=5.5$，且$x$大于5.5时判断为1。而后计算误差，计算第三个分类器的权重。</li>
</ol>
<p>也许你会问为什么有的时候大于有的时候小于？脑补决策树，具体是大于还是小于不是固定的。</p>
<p>三轮过后，得到的分类器为：</p>
<script type="math/tex; mode=display">\begin{equation}
G(x)=\text{sign}[f_3(x)]=\text{sign}[0.4236G_1(x)+0.6496G_2(x)+0.7514G_3(x)]
\end{equation}</script><p>假设，输入的$x$为8，$x&gt;v_1$第一个分类器$G_1(x)$的判断结果为-1，同理，第二个分类器的判断结果为1，第三个分类器的判断结果为1。带入$G(x)$，得到$-0.4236+0.6496+0.7514=0.97$，经过$\text{sign}$函数后取值为1，分到1那一类，且分类正确。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>终于到了激动人心的代码实现了，只是简单的完成二分类任务，借助sklearn实现。</p>
<ul>
<li>首先通过sklearn创建训练数据；</li>
<li>其次设置不同的分类器的数量，观察分类的准确性；</li>
<li>打印分类器的误差和权重；</li>
<li>记录训练时间；</li>
<li>我看了源代码，样本权重封装的很好，想调出来不是很容易，就不调了；</li>
<li>绘制图像：随着分类器数量的增加误差逐渐减小；</li>
<li>更多操作请参考sklearn的官网，解释都挺详细的。</li>
</ul>
<h2 id="baseline-版本"><a href="#baseline-版本" class="headerlink" title="baseline 版本"></a>baseline 版本</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_hastie_10_2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建8000数据 4个特征 2个类</span></span><br><span class="line">X, Y = make_hastie_10_2(n_samples=<span class="number">12000</span>, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">n_split = <span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类器的个数</span></span><br><span class="line">num_estimators = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line"></span><br><span class="line">X_train, X_test = X[n_split:], X[:n_split]</span><br><span class="line">Y_train, Y_test = Y[n_split:], Y[:n_split]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> num_estimators:</span><br><span class="line">    clf = AdaBoostClassifier(n_estimators=num,</span><br><span class="line">                             random_state=<span class="number">0</span>,</span><br><span class="line">                             algorithm=<span class="string">'SAMME'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录算法的训练时间</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    clf.fit(X_train, Y_train)</span><br><span class="line">    end = time.time()</span><br><span class="line"></span><br><span class="line">    score = clf.score(X_train, Y_train)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Estimators ===&gt;'</span>, num, <span class="string">' Accuracy ===&gt;'</span>, score, <span class="string">'Time ===&gt;'</span>, round(end - start, <span class="number">2</span>), <span class="string">'s'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">5</span>):</span><br><span class="line">        print(<span class="string">'Errors '</span>, clf.estimator_errors_)</span><br><span class="line">        print(<span class="string">'Weights '</span>, clf.estimator_weights_)</span><br><span class="line">        print(clf.base_estimator_)</span><br></pre></td></tr></table></figure>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Estimators ===&gt; 1  Accuracy ===&gt; 0.5513 Time ===&gt; 0.01 s</span><br><span class="line">Estimators ===&gt; 5  Accuracy ===&gt; 0.6194 Time ===&gt; 0.06 s</span><br><span class="line">Estimators ===&gt; 20  Accuracy ===&gt; 0.7108 Time ===&gt; 0.23 s</span><br><span class="line">Estimators ===&gt; 50  Accuracy ===&gt; 0.8166 Time ===&gt; 0.55 s</span><br><span class="line">Estimators ===&gt; 100  Accuracy ===&gt; 0.8614 Time ===&gt; 1.1 s</span><br><span class="line">Estimators ===&gt; 200  Accuracy ===&gt; 0.8871 Time ===&gt; 2.23 s</span><br></pre></td></tr></table></figure></p>
<p>可见，对于较多的分类器，准确性有所提升。且，能在很短的时间内执行处不错的分类结果。当只有5个分类器时，我们打印一下每个分类器的误差和权重，并打印当前分类器，即选择了什么分类器。输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Errors  [0.4487     0.46195913 0.45847958 0.46397641 0.45167916]</span><br><span class="line">Weights  [0.20592461 0.15245809 0.16646502 0.14434448 0.19388849]</span><br><span class="line">DecisionTreeClassifier(ccp_alpha=0.0, class_weight=None, criterion=&apos;gini&apos;,</span><br><span class="line">                       max_depth=1, max_features=None, max_leaf_nodes=None,</span><br><span class="line">                       min_impurity_decrease=0.0, min_impurity_split=None,</span><br><span class="line">                       min_samples_leaf=1, min_samples_split=2,</span><br><span class="line">                       min_weight_fraction_leaf=0.0, presort=&apos;deprecated&apos;,</span><br><span class="line">                       random_state=None, splitter=&apos;best&apos;)</span><br></pre></td></tr></table></figure>
<p>由上不难看出选择的分类器为：深度为一的选用基尼系数进行决策的决策树。</p>
<h2 id="决策树版本"><a href="#决策树版本" class="headerlink" title="决策树版本"></a>决策树版本</h2><p>既然选用了决策树，何不增加一下决策树的深度？以此来提高分类的准确性。代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_hastie_10_2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct dataset</span></span><br><span class="line"><span class="comment"># 创建8000数据 4个特征 2个类</span></span><br><span class="line">X, Y = make_hastie_10_2(n_samples=<span class="number">12000</span>, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">n_split = <span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类器的个数</span></span><br><span class="line">num_estimators = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">X_train, X_test = X[n_split:], X[:n_split]</span><br><span class="line">Y_train, Y_test = Y[n_split:], Y[:n_split]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> num_estimators:</span><br><span class="line">    <span class="comment"># Create and fit an AdaBoosted decision tree</span></span><br><span class="line">    bdt = AdaBoostClassifier(DecisionTreeClassifier(max_depth=<span class="number">4</span>),</span><br><span class="line">                            algorithm=<span class="string">"SAMME"</span>,</span><br><span class="line">                            n_estimators=num)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录算法的训练时间</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    bdt.fit(X_train, Y_train)</span><br><span class="line">    end = time.time()</span><br><span class="line"></span><br><span class="line">    score = bdt.score(X_test, Y_test)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Estimators ===&gt;'</span>, num, <span class="string">' Accuracy ===&gt;'</span>, score, <span class="string">'Time ===&gt;'</span>, round(end - start, <span class="number">2</span>), <span class="string">'s'</span>)</span><br><span class="line"></span><br><span class="line">print(bdt.base_estimator_)</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Estimators ===&gt; 1  Accuracy ===&gt; 0.6295 Time ===&gt; 0.03 s</span><br><span class="line">Estimators ===&gt; 5  Accuracy ===&gt; 0.741 Time ===&gt; 0.2 s</span><br><span class="line">Estimators ===&gt; 20  Accuracy ===&gt; 0.841 Time ===&gt; 0.77 s</span><br><span class="line">Estimators ===&gt; 50  Accuracy ===&gt; 0.9105 Time ===&gt; 1.92 s</span><br><span class="line">Estimators ===&gt; 100  Accuracy ===&gt; 0.937 Time ===&gt; 3.86 s</span><br><span class="line">DecisionTreeClassifier(ccp_alpha=0.0, class_weight=None, criterion=&apos;gini&apos;,</span><br><span class="line">                       max_depth=4, max_features=None, max_leaf_nodes=None,</span><br><span class="line">                       min_impurity_decrease=0.0, min_impurity_split=None,</span><br><span class="line">                       min_samples_leaf=1, min_samples_split=2,</span><br><span class="line">                       min_weight_fraction_leaf=0.0, presort=&apos;deprecated&apos;,</span><br><span class="line">                       random_state=None, splitter=&apos;best&apos;)</span><br></pre></td></tr></table></figure>
<p>可见，在增加决策树深度后，准确性有了明显提升。</p>
<h2 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h2><p><img data-src="/2020/04/02/adaboost/error_rate.png" alt></p>
<p>如图所示，随着分类器数量的增加，误差率逐渐下降并稳定在一个区间内。因为提升算法是有训练误差的界限的，其训练误差为：</p>
<script type="math/tex; mode=display">\begin{equation}
\frac{1}{N}\sum_{i=1}^NI(G(x_i) != y_i) \leq \frac{1}{N}\sum_{i=1}\exp (-y_iG(x_i)) = \frac{1}{N}\sum_{i=1}\exp(-\sum_{m=1}^M\alpha_my_iG_m(x_i))
\end{equation}</script><p>上述误差式的取值也可以表示为：$\prod_mZ_m$。绘图的代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> zero_one_loss</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct dataset</span></span><br><span class="line"><span class="comment"># 创建8000数据 4个特征 2个类</span></span><br><span class="line">X, Y = datasets.make_hastie_10_2(n_samples=<span class="number">12000</span>, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n_split = <span class="number">2000</span></span><br><span class="line"></span><br><span class="line">X_train, X_test = X[n_split:], X[:n_split]</span><br><span class="line">Y_train, Y_test = Y[n_split:], Y[:n_split]</span><br><span class="line"></span><br><span class="line">train_errors = []</span><br><span class="line">test_errors = []</span><br><span class="line"></span><br><span class="line">num = <span class="number">350</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create and fit an AdaBoosted decision tree</span></span><br><span class="line">bdt = AdaBoostClassifier(DecisionTreeClassifier(max_depth=<span class="number">3</span>),</span><br><span class="line">                        algorithm=<span class="string">"SAMME"</span>,</span><br><span class="line">                        n_estimators=num)</span><br><span class="line"></span><br><span class="line">bdt.fit(X_train, Y_train)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> train_error, test_error <span class="keyword">in</span> zip(bdt.staged_predict(X_train), bdt.staged_predict(X_test)):</span><br><span class="line">    train_errors.append(zero_one_loss(train_error, Y_train))</span><br><span class="line">    test_errors.append(zero_one_loss(test_error, Y_test))</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">1</span>, num, num)</span><br><span class="line">plt.style.use(<span class="string">'ggplot'</span>)</span><br><span class="line">plt.plot(x, train_errors, <span class="string">'r'</span>, label=<span class="string">'SAMME Train Error'</span>)</span><br><span class="line">plt.plot(x, test_errors, <span class="string">'b'</span>, label=<span class="string">'SAMME Test Error'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'upper right'</span>, fancybox=<span class="literal">True</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Eestimator Numbers'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Error Rate'</span>)</span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line">plt.savefig(<span class="string">'error_rate.png'</span>, dpi=<span class="number">250</span>)</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>提升方法还有更多的应用空间，如提升树，回归树。梯度提升等。即可以在一个分类器中建立更多的层数，而不只是分为简单的$x&gt;v_1$时和$x&lt;v_1$时，用更多的层数来提高分类的准确性。</p>
<p>甚至可以和神经网络相结合，给不同的网络赋予不同的权重，最终决策。</p>
<p>为什么不在这里写？因为我忘了决策树里的一些东西，也忘记了回归树如何实现，等下次再写吧。</p>
<p>还有一点，本文提到的算法已经过时，本文的是<code>SAMME</code>版本的算法，目前已经发布<code>SAMME.R</code>版本的算法且准确率更高，也等下次再写吧。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>站在巨人的肩膀上，我们能走得更好：</p>
<ol>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostClassifier.html" target="_blank" rel="noopener">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostClassifier.html</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_classification.html" target="_blank" rel="noopener">https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_classification.html</a></li>
<li><a href="https://stackoverflow.com/questions/31981453/why-estimator-weight-in-samme-r-adaboost-algorithm-is-set-to-1" target="_blank" rel="noopener">https://stackoverflow.com/questions/31981453/why-estimator-weight-in-samme-r-adaboost-algorithm-is-set-to-1</a></li>
</ol>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系列（三）——Alembic数据库迁移</title>
    <url>/2020/01/26/alembic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据表并不是一成不变的，添加新的模型类或者给已有的模型类添加删除属性都是很正常的事情，此时都需要更新表。而只修改原有代码的表，重新部署是不能生效的，原因是那个表已经存在了。</p>
<p>举一个苛刻的例子：你的老板说，我们不要时间戳这个属性，你说好，写好代码并用了一年。一年后，你的老板说，把时间戳给我加上。这就涉及到了数据库的迁移。但是又不想：拷贝原有数据、重新建表、复制数据这样的更新，这种工作量很大很累赘，且数据是无价的，所以学会数据库迁移很有必要。</p>
<p>我想起了一个培训班来我们学校上课，说：公司不会给你重启服务器，所以一定要保证一次性把表写对不能更爱，呵，怪不得你的水平也只能来我校讲课。</p>
<a id="more"></a>
<h1 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h1><p>首先创立数据表，<code>python models.py</code>执行，并提交一个实例。（但这里并不用写提交的代码，只需要写数据表这个类即可，因为在数据库迁移的时候，这个表的内容会被系统自动提交）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, Integer, String, Text, Date, Time, create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker </span><br><span class="line"></span><br><span class="line">Model = declarative_base()</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:MyNewPass@localhost:3306/alembic"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Model)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">"users"</span></span><br><span class="line"> </span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">45</span>))</span><br><span class="line"></span><br><span class="line">Model.metadata.create_all(bind=engine)</span><br><span class="line"></span><br><span class="line">test = User(name = <span class="string">'lanling'</span>)</span><br><span class="line"></span><br><span class="line">session = sessionmaker(bind=engine)()</span><br><span class="line">session.add(test)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<p>可以看到数据库中的记录：</p>
<p><img data-src="/2020/01/26/alembic/1.png" alt></p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>在<code>models.py</code>目录下<code>执行初始化命令</code>：<code>alembic init migrate</code>，其中的<code>migrate</code>是要初始化的文件夹名称。会得到以下的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alembic</span><br><span class="line">│   models.py</span><br><span class="line">│   falembic.ini    </span><br><span class="line">└───migrate</span><br><span class="line">   │   env.py</span><br><span class="line">   │   README</span><br><span class="line">   │   script.py.mako</span><br><span class="line">   └───versions (现在里面还没有，更新一次才会有)</span><br><span class="line">       │   version1.py</span><br><span class="line">       │   version2.py</span><br></pre></td></tr></table></figure>
<h2 id="修改-alembic-ini"><a href="#修改-alembic-ini" class="headerlink" title="修改 alembic.ini"></a>修改 alembic.ini</h2><p>我的是MySQL, 其他的DBMS可能不一样，密码，端口，数据库名改成和自己一样的。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sqlalchemy.url = mysql+pymysql://root:MyNewPass@localhost:<span class="number">3306</span>/alembic</span><br></pre></td></tr></table></figure>
<h2 id="修改-env-py"><a href="#修改-env-py" class="headerlink" title="修改 env.py"></a>修改 env.py</h2><p>目标是让 alembic 获取模型模块中定义的信息。我的目录结构的修改方式代码如下，如果代码结构不同，下面代码无法生效。</p>
<p>将<code>target_metadata = None</code> 改为以下代码，</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 返回当前路径的上级路径 寻找 models.py 这个文件</span></span><br><span class="line">sys.path.append(os.path.dirname(os.path.abspath(__file__)) + <span class="string">"/../"</span>)</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> Model</span><br><span class="line">target_metadata = Model.metadata</span><br></pre></td></tr></table></figure>
<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>假设想在数据库内新建一个表，那么先自动创建更新的版本，执行以下命令（字符串里面的是备注信息，随意改）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">alembic revision  -m <span class="string">"create tables password"</span></span><br></pre></td></tr></table></figure>
<p>然后会在命令行内得到提示：生成了一个乱码开头的<code>.py</code>版本文件，在versions文件夹内找到这个文件，手动编写升级操作和降级操作，必须要写降级，万一升级升错了，岂不降不回去。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upgrade</span><span class="params">()</span>:</span></span><br><span class="line">    op.create_table(</span><br><span class="line">        <span class="string">'password'</span>,</span><br><span class="line">        sa.Column(<span class="string">'id'</span>, sa.Integer, primary_key=<span class="literal">True</span>),</span><br><span class="line">        sa.Column(<span class="string">'password'</span>, sa.Unicode(<span class="number">200</span>)),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downgrade</span><span class="params">()</span>:</span></span><br><span class="line">    op.drop_table(<span class="string">'password'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="开始升级"><a href="#开始升级" class="headerlink" title="开始升级"></a>开始升级</h1><p>命令行执行：<code>alembic upgrade head</code>，但更新会重新执行<code>models.py</code>里面的内容，所以会有</p>
<p><img data-src="/2020/01/26/alembic/2.png" alt></p>
<p>所以建议 <code>models.py</code> 里面只定义和提交，不写入数据。发现已经新建了password这个数据库：</p>
<p><img data-src="/2020/01/26/alembic/5.png" alt></p>
<p>推荐的<code>models.py</code>写法（不用提交和创建实例）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, Integer, String, Text, Date, Time, create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker </span><br><span class="line"></span><br><span class="line">Model = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Model)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">"users"</span></span><br><span class="line"></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">45</span>))</span><br></pre></td></tr></table></figure>
<p>假设我们要给一个表格新加一列，而重启服务器，拷贝原有数据库的数据，在创建新的数据表加入新的一列，在写入新的数据是很猥琐的行为，所以有必要使用数据库迁移。</p>
<p>我们再次创建一个更新版本：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">alembic revision  -m <span class="string">"add location column in users table"</span></span><br></pre></td></tr></table></figure>
<p>同样会在命令行的提示中，得到一个乱码开头的<code>.py</code>更新文件，在文件中编写更新函数：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upgrade</span><span class="params">()</span>:</span></span><br><span class="line">    op.add_column(<span class="string">'users'</span>, sa.Column(<span class="string">'location'</span>, sa.DateTime()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downgrade</span><span class="params">()</span>:</span></span><br><span class="line">    op.drop_column(<span class="string">'users'</span>, <span class="string">'location'</span>)</span><br></pre></td></tr></table></figure>
<p>命令行执行：<code>alembic upgrade head</code>开始升级，发现升级成功，而数据库内也做了改动：</p>
<p><img data-src="/2020/01/26/alembic/6.png" alt></p>
<h1 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h1><p><a href="https://www.cnblogs.com/turingbrain/p/6372086.html" target="_blank" rel="noopener">https://www.cnblogs.com/turingbrain/p/6372086.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/90106173" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/90106173</a></p>
<p><a href="https://www.cnblogs.com/derek1184405959/p/9100502.html" target="_blank" rel="noopener">https://www.cnblogs.com/derek1184405959/p/9100502.html</a></p>
<p>虽然参考了他们的文章，但是说实话他们写的并不好，我也是看了好多篇文章才终于搞懂如何更新的。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>得看一个项目，看看人家怎么写的代码，怎么组织的文件和分工。目前的代码还不够<code>pythonic</code>。如</p>
<ul>
<li>每次会话完是否关闭？</li>
<li>数据库的连接次数该怎么设置？(链接次数过多且不释放资源，会严重拉底系统性能)</li>
</ul>
]]></content>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>对抗攻击篇：一些关于对抗补丁的论文</title>
    <url>/2021/06/13/adversial-patch/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在对抗攻击中，有人尝试着去用对抗样本攻击目标检测的网络。但是，检测网络与分类网络不同，检测网络还有检测器，存在 RPN、ROI-Align 以及边界框回归器等。而分类接受的图像来自检测器的输出，并不是原始的输入。所以只在图片上产生细微的扰动很可能不起做作用 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。所以衍生出了一些基于 patch （补丁）的攻击。</p>
<a id="more"></a>
<h1 id="Adversial-Patch"><a href="#Adversial-Patch" class="headerlink" title="Adversial Patch"></a>Adversial Patch</h1><p>这篇论文 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 是最开始的，创建一些通用的小 patch，可以放到任何场景下去干扰分类，使得网络忽略真实的物体，而输出诱导的错误分类。传统的对抗攻击，都是在输入上叠加一些微小的扰动，人眼察觉不出来的那种，但需要修改图像中的每一个像素，对于 $1000\times 1000$ 的像素点，需要操作一百万个像素点，在现实世界难以应用。</p>
<p>而本文中，不在满足这一约束，而是生成一个独立于任何场景（光照、角度）的 patch 放到图片的任何位置，相反，这个 patch 大于只有 $20\times 20$ 的大小，所以这个计算量是可以在现实世界应用的。这个 patch 很容易被网络看到，但仍然可以导致网络错误的输出。当 patch 使用了很大的扰动，传统的防御算法只能防御小扰动的样本，对大扰动的样本鲁棒性反而很差，毕竟数据分布不同。如下所示：</p>
<p><img data-src="https://z3.ax1x.com/2021/06/13/2IOvY4.png" alt></p>
<p>所以，这个补丁攻击的仍然是分类网络。</p>
<h2 id="训练方式"><a href="#训练方式" class="headerlink" title="训练方式"></a>训练方式</h2><p>在全部数据集上进行训练，对 patch 进行各种各样的转换、缩放、旋转，这个 patch 允许被设置为任何形状。对于给定图像 $x$，patch $p$，位置 $l$，变换 $t$，定义一个补丁操作 $A(p,x,l,t)$，将 $t$ 应用到 $p$ 上，在把 $p$ 放到 $x$ 的 $l$ 位置。</p>
<p>而 patch 是经过训练的，以诱导网络输出错误的标签 $\hat{y}$，这个训练过程为：</p>
<p>\begin{equation}<br>p = \arg \max_p \mathbb{E}_{x\sim X,t\sim T, l\sim L}[\log P(\hat{y}|A(p,x,l,t))]<br>\end{equation}</p>
<p>$X$ 是训练数据的分布，$T$ 是 patch 变换的分布，$L$ 是位置。通过这个公式，生成的 patch 会忽略背景，所以生成的 patch 通用性较强。而为了伪装 patch，使得最终的 patch 不太离谱，加入了一个限制 $|p-p_{orig}|_\inf &lt; \epsilon$。</p>
<h1 id="DPATCH"><a href="#DPATCH" class="headerlink" title="DPATCH"></a>DPATCH</h1><p>这个补丁 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> 就正儿八经的攻击目标检测的网络了。不同于上一个补丁只误导分类器，同时也攻击边界框回归器，以产生错误的定位。其实目标检测是很难攻击的，毕竟有很多 anchor 和候选框，样本不一定能被选中。攻击目标检测的网络时，与传统分类不同的是，需要定位到不同大小的目标及其位置。</p>
<p>在无目标攻击中，让检测器不能检测到物体的位置，所以最大化真实类别和边界框回归器的损失，这里的类别 $y$ 是背景类。也就是，通过放置补丁，让网络的将真实的目标视为背景。</p>
<p>\begin{equation}<br>P_u=\arg \max_P \mathbb{E} [L(A(x,s,P);y;B)]<br>\end{equation}</p>
<p>在有目标攻击中，目标是只能检测到 patch 而忽略其它真正的目标。所以需要最小化 patch 的类别损失和边界损失，类别是自己选择的误导类别。也就是，让网络将补丁视为目标。</p>
<p>\begin{equation}<br>P_t=\arg \min_P \mathbb{E} [L(A(x,s,P);y_t;B_t)]<br>\end{equation}</p>
<p>$A(x,s,P)$ 表示将补丁 $P$ 通过变换 $s$ 添加到图像 $x$ 上。在补丁进入网络前，首先先添加一个随机噪音，而后定义 patch 的边界框。训练流程如下：</p>
<p><img data-src="https://z3.ax1x.com/2021/06/13/2Ijf2j.png" alt></p>
<ul>
<li>为了分析不同位置下 DPATCH 的影响，随机对 DPATCH 的位置进行变换，而保持像素点数值不变，在每轮训练时候都随机初始化变换 $s$</li>
<li>为了分析不同类别下 DPATCH 的影响，将 DAPTCH 的类别都设置为人，随机指定了四个类别</li>
<li>为了分析不同大小的 DPATCH 的影响，所以做了一些实验，分别分析 20 40 80 大小的 DPATCH 对结果的影响</li>
</ul>
<p>实验结果大概证明了，DAPTCH 在可以出现在图片的任何位置，更大的 DAPTCH 攻击性更强。</p>
<p>DPATCH 起作用的原因：DPATCH 的攻击目标就是目标检测网络，使得 ROI 提取到的区域被 DPATCH 覆盖，所以提取到的 ROI 区域，将会忽略其它目标。如果攻击成功了，许多提取到的 ROI 应该会有 DPATCH 的存在。为此，统计每个区域被提取为 ROI 的次数，也发现那里正好是 DPATCH 出现的地方。故此验证了攻击成功的原因是：DPATCH 欺骗了检测器，使得 ROI 含有 DPATCH，而不是正常目标，如下图所示：</p>
<p><img data-src="https://z3.ax1x.com/2021/06/13/2IvWTK.png" alt></p>
<h1 id="物理世界的补丁"><a href="#物理世界的补丁" class="headerlink" title="物理世界的补丁"></a>物理世界的补丁</h1><p>这篇论文 <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> 做了一个演示<a href="https://youtu.be/WXnQjbZ1e7Y" target="_blank" rel="noopener">视频</a>。与之前不同的是，不需要 patch 放到图像上误导分类和检测，而是设计了一个 patch 抑制其它目标的表达。所以可以 patch 到任何地点甚至是远离目标的地点。而且不需要训练位置参数，且不需要修改场景中的目标。</p>
<p>本文构造一个物理上的 patch，放到图像中，抑制其它目标的表达。寻找与制作 patch 的方式也很简单：</p>
<p>\begin{equation}<br>\arg \max_{\delta} \mathbb{E}_{(x, y) \sim D, t\sim T} [L(h_\theta(A(\delta, x, t)), y)]<br>\end{equation}</p>
<p>其中 $\delta$ 是补丁，$D$ 是数据分布，$T$ 是变换分布，$A$ 是将补丁 $\delta$ 经过 $t$ 变换放到 $x$ 上。但是，对 $\delta$ 的最大期望可能会超出预期，所以不够通用。所以像 PGD 一样，让扰动朝着其它目标移动：</p>
<p>\begin{equation}<br>\delta := \delta - \alpha \nabla_\delta [L(h_\theta(A(\delta, x, t)), \hat{y})]<br>\end{equation}</p>
<p>但是事实证明这种做法很差。所以尝试最大化与真实目标的损失，不对补丁设置任何的边界框和目标类别，而是直接抑制检测的其它类别：</p>
<p>\begin{equation}<br>\delta := clip_{[0,1]} (\delta + \alpha \nabla_\delta [L(h_\theta(A(\delta, x, t)), y)])<br>\end{equation}</p>
<p>这种方法成功的原因和上述的 DPATCH 是一样的，提取到的 ROI 还有 PATCH。作者和 DPATCH 做了对比，分析 DPatch 之所以时好时差，是因为它将 patch 放到了 ground truth box 的周围，patch 最终驻留在一个单一的单元中。这意味着损失由『负责』该单元的 rpn 控制。只要补丁被识别，模型在预测所有其他对象时受到的惩罚就很小，且边界框或类标签上不会受到惩罚。所以在实践中，补丁经常被检测到，但是，<strong>并没有抑制其他目标被检测</strong>。反而言之，一旦 patch 没被检测到，网络还是能识别到目标。</p>
<p>而在本文的方法中，patch 可以置于任何位置，当 patch 与任何一个 ground truth box 重叠都会造成损失，也就是，当前目标检测失败。当模型不能预测任何 ground truth box 时，损失增加最多。</p>
<h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/abs/1712.02494" target="_blank" rel="noopener">为什么难以攻击目标检测网络</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/abs/1712.09665" target="_blank" rel="noopener">Adversial Patch</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/abs/1806.02299" target="_blank" rel="noopener">DPATCH</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/abs/1906.11897" target="_blank" rel="noopener">物理世界的补丁</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>简易理解算法时间复杂度的重要性</title>
    <url>/2020/03/02/algorithm-time-complexity/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本来是被老师安排了写毕业论文的，但是歪打正着发现了个有趣的东西，决定先更新一下再去写(毕竟谁闲的没事想写那两万字的论文)。</p>
<ul>
<li>通过两个新旧CPU的对比分析算法时间复杂度的重要性；</li>
<li>以顺序结构实现 插入排序 算法（非正解），时间复杂度$O(n^3)$；</li>
<li>以链式结构（双向链表）实现 插入排序 算法，时间复杂度$O(n^2)$；</li>
<li>对比两者，分析时间复杂度的影响。</li>
</ul>
<p>首先，默认本文的读者有数据结构的基础，或者从任何一本《数据结构》教材里寻找：时间复杂度、插入排序、双向链表的定义。对于外行人(数据结构基础四舍五入等于没有或者只想来看热闹)，可以选择只看本文你能看懂得部分，同样很有意思。</p>
<a id="more"></a>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>参考任何一本《数据结构》的教材都能得到时间复杂度、空间复杂度的详细定义，这里不再解释。</p>
<p>那么，不如深刻来了解下算法复杂度对时间的影响。假设有两块<code>CPU</code>，第一块破旧的<code>CPU</code>为<code>A</code>，第二块<code>CPU</code>为<code>B</code>，<code>B</code>的性能比<code>A</code>好上10倍，这里假设为：<code>B</code>的计算速度是<code>A</code>的<code>10</code>倍。假设<code>A</code>计算规模为$N$的问题所需时间为$t$，理想情况下不难得到以下表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>问题规模</th>
<th>CPU: A执行时间</th>
<th>CPU: B执行时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>$N$</td>
<td>$t$</td>
<td>$t/10$</td>
</tr>
<tr>
<td>$N^2$</td>
<td>$t^2$</td>
<td>$t^2/10$</td>
</tr>
</tbody>
</table>
</div>
<p>那么对于同一个问题涉及了两种算法，第一种算法的时间复杂度为$O(n^2)$，而经过优化的算法的时间复杂度为$O(n)$，降低了一个数量级。那么，优化好的算法$O(n)$在<code>CPU A</code>上执行的时间为$t$，而另一个人感觉自己<code>CPU</code>很好没必要优化算法，那么没优化的算法$O(n^2)$在<code>CPU B</code>上执行的时间为$t^2/10$，设函数$g(t)$为$g(t)=t-t^2/10$，可以知道$g(t)$是开口向下的二次函数，也不难求出函数$g(t)$的两个根为$0, 10$。</p>
<p>当问题规模逐渐增加，问题逐步复杂，处理数据逐步增多时，即$n&gt;10$时，函数$g(t)&lt;0$，意味着优化过的算法在破旧的<code>CPU A</code>上的执行时间，要远小于性能好上十倍的<code>CPU B</code>。这里可以体现算法的时间复杂度的重要性。好的算法胜过好的处理器。所以，要想设计一款好软件，算法是必不可缺的功底，所以，只要还在计算机这个圈子里，数据结构就是逃不掉的。</p>
<p>况且在技术飞速发展的今天，硬盘空间显得不在像当初那么昂亏，可以花很便宜的价格买到容量几百个G的硬盘。所以，在不要求存储空间的问题中，可以放肆的使用硬盘空间来提升算法执行时间的效率，如：哈希算法、虚拟内存等技术，所以，一般情况下空间复杂度显得不是很重要。</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>通过一个图片简单的理解插入排序：遍历数组，把当前元素移动到合适位置即可。</p>
<p><img data-src="/2020/03/02/algorithm-time-complexity/1.png" alt></p>
<h2 id="顺序结构实现"><a href="#顺序结构实现" class="headerlink" title="顺序结构实现"></a>顺序结构实现</h2><h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>以下是顺序结构实现插入排序算法正解的核心代码，时间复杂度不难看出为$O(n^2)$：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> key = arr[i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((j &gt;= <span class="number">0</span>) &amp;&amp; (key &lt; arr[j]))&#123;</span><br><span class="line">        arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j+<span class="number">1</span>] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错解"><a href="#错解" class="headerlink" title="错解"></a>错解</h3><p>错解的意思是：代码实现的逻辑不好，但是代码执行的结果是对的。</p>
<p>一个人编程水平不咋地，如我(我是真的写错了)，我用一种错误的逻辑写出了顺序结构的插入排序代码，时间复杂度为$O(n^3)$，对序列<code>3, 5, 4, 7, 1, 6, 8, 5, 9, 2</code>进行插入排序，好在得到了正确的结果。如本文开头所说，本文的内容纯属歪打正着，所以之后会使用如下的错解代码，得到另外的有趣的东西。</p>
<p><img data-src="/2020/03/02/algorithm-time-complexity/2.jpg" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Remove "</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" : "</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt;= arr[i - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; arr[j] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> k = i;</span><br><span class="line">            <span class="comment">// 不知道为啥写了这么个没用的循环</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt;= arr[i] || (j == <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[i]))&#123;   </span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[i]) </span><br><span class="line">                        j = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (k &gt; j + <span class="number">1</span>)&#123;</span><br><span class="line">                        arr[k] = arr[k - <span class="number">1</span>];</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[j] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链式结构实现"><a href="#链式结构实现" class="headerlink" title="链式结构实现"></a>链式结构实现</h2><p>因为在插入的过程中会访问当前元素之前的元素，所以有必要使用双向链表(任何一本《数据结构》的教材都能得到双向链表的定义，这里不在解释)。移动元素仔细分析指针该如何移动即可。对序列<code>3, 5, 4, 7, 1, 6, 8, 5, 9, 2</code>进行插入排序，不难看出我实现的代码的时间复杂度为$O(n)$。指针恐惧者慎用链式结构。</p>
<p><img data-src="/2020/03/02/algorithm-time-complexity/4.jpg" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个节点的类型 存储数据 指向前者 指向后者</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    node *pre;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点 用于寻找链表在哪</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    node *first;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line">    node ans[len];</span><br><span class="line">    head L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i].data = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 类型为指针 所以ans取地址</span></span><br><span class="line">            L.first = &amp;ans[i];</span><br><span class="line">            ans[i].next = &amp;ans[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == len - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i].pre = &amp;ans[i - <span class="number">1</span>];</span><br><span class="line">            ans[i].next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans[i].pre = &amp;ans[i - <span class="number">1</span>];</span><br><span class="line">            ans[i].next = &amp;ans[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        L.len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of link is : "</span> &lt;&lt; L.len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    node *p;</span><br><span class="line">    p = L.first;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Raw Data : "</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*p).data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        p = (*p).next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 读取完毕 开始排序</span></span><br><span class="line">    p = L.first;</span><br><span class="line">    <span class="comment">// 从第二个元素开始插入</span></span><br><span class="line">    p = (*p).next;</span><br><span class="line">    node *s, *t;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*p).data &lt; (*(*p).pre).data)</span><br><span class="line">        &#123;</span><br><span class="line">            node *q;</span><br><span class="line">            q = L.first;</span><br><span class="line">            <span class="comment">// 用 q 表示合适的插入位置</span></span><br><span class="line">            <span class="comment">// q p 的位置不同时，操作不同，分四种情况</span></span><br><span class="line">            <span class="keyword">while</span> ((*q).data &lt;= (*p).data)</span><br><span class="line">                q = (*q).next;</span><br><span class="line">            <span class="comment">// case 1 pass</span></span><br><span class="line">            <span class="keyword">if</span> ((*p).next == <span class="literal">NULL</span> &amp;&amp; q == L.first)</span><br><span class="line">            &#123;</span><br><span class="line">                s = (*p).pre;</span><br><span class="line">                (*p).next = L.first;</span><br><span class="line">                (*q).pre = p;</span><br><span class="line">                (*(*p).pre).next = <span class="literal">NULL</span>;</span><br><span class="line">                (*p).pre = <span class="literal">NULL</span>;</span><br><span class="line">                L.first = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case 2 pass</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((*p).next == <span class="literal">NULL</span> &amp;&amp; q != L.first)</span><br><span class="line">            &#123;</span><br><span class="line">                s = (*p).pre;</span><br><span class="line">                (*(*p).pre).next = <span class="literal">NULL</span>;</span><br><span class="line">                (*p).pre = (*q).pre;</span><br><span class="line">                (*(*q).pre).next = p;</span><br><span class="line">                (*p).next = q;</span><br><span class="line">                (*q).pre = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case 3 pass</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == L.first &amp;&amp; (*p).next != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s = (*p).next;</span><br><span class="line">                (*(*p).pre).next = (*p).next;</span><br><span class="line">                (*(*p).next).pre = (*p).pre;</span><br><span class="line">                (*p).next = q;</span><br><span class="line">                (*q).pre = p;</span><br><span class="line">                (*p).pre = <span class="literal">NULL</span>;</span><br><span class="line">                L.first = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case 4</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q != L.first &amp;&amp; (*p).next != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s = (*p).next;</span><br><span class="line">                (*(*p).next).pre = (*p).pre;</span><br><span class="line">                (*(*p).pre).next = (*p).next;</span><br><span class="line">                (*p).next = q;</span><br><span class="line">                (*p).pre = (*q).pre;</span><br><span class="line">                (*(*q).pre).next = p;</span><br><span class="line">                (*q).pre = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Remove "</span> &lt;&lt; (*p).data &lt;&lt; <span class="string">" :"</span>;</span><br><span class="line">            p = s;</span><br><span class="line">            t = L.first;</span><br><span class="line">            <span class="keyword">while</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; (*t).data;</span><br><span class="line">                t = (*t).next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = (*p).next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>此时，我想起了上《算法设计》这门课老师很爱干的事情，实现一个xxx算法，然后分别读入：十万、百万的数据，记录算法执行时间，对比结果。那么，既然我都写错顺序结构实现插入排序的代码了，不如歪打正着，正好对比下$O(n^3)$的算法和$O(n^2)$的算法差异。</p>
<p>首先用<code>python</code>（别问，问就是不会C++）产生随机整数，规模分别为10万，11万，15万，20万，30万，将结果保存至<code>txt</code>文件中。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 第一个参数是左区间 a，第二个参数是右区间 b，第三个参数是个数 c</span></span><br><span class="line"><span class="comment"># 即会产生 c 个 [a, b) 区间内的整数</span></span><br><span class="line">a = np.random.randint(<span class="number">0</span>, <span class="number">500000</span>, <span class="number">500000</span>)</span><br><span class="line"><span class="comment"># fmt 表示取消科学计数法的保存形式</span></span><br><span class="line">np.savetxt(<span class="string">'Five_hundred_thousand.txt'</span>, a, fmt=<span class="string">'%d'</span>)</span><br></pre></td></tr></table></figure></p>
<p>之后，在<code>C++</code>内读取文件数据，并对排序部分进行计时，顺序结构代表了$O(n^3)$的算法，链式结构代表了$O(n^2)$的算法，修改后的代码如下：</p>
<h2 id="顺序结构计时"><a href="#顺序结构计时" class="headerlink" title="顺序结构计时"></a>顺序结构计时</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1000002</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// path 是读取的文件</span></span><br><span class="line">    <span class="built_in">string</span> path = <span class="string">"Five_hundred_thousand.txt"</span>;</span><br><span class="line">    <span class="comment">// out 是输出结构的文件</span></span><br><span class="line">    <span class="built_in">string</span> out = <span class="string">"Five_hundred_thousand_seq.txt"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(path.c_str())</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">ou</span><span class="params">(out.c_str())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!in.is_open())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"open file failed!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ou.is_open())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"create file failed!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取文件 存入数组</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (in &gt;&gt; a)</span><br><span class="line">        arr[len++] = a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="comment">// 开始计时</span></span><br><span class="line">    <span class="keyword">clock_t</span> start = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt;= arr[i - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> k = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt;= arr[i] || (j == <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[i]))&#123;   </span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[i]) </span><br><span class="line">                        j = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (k &gt; j + <span class="number">1</span>)&#123;</span><br><span class="line">                        arr[k] = arr[k - <span class="number">1</span>];</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">clock_t</span> end   = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;  (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">" seconds"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="comment">// 把结果记录到文件 检查算法是否正确</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        ou &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ou.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链式结构计时"><a href="#链式结构计时" class="headerlink" title="链式结构计时"></a>链式结构计时</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样 记录前驱、后继、和本身的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    node *pre;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点记录链表在哪</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    node *first;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 占据的空间大 所以声明在主函数外部</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1000002</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">node ans[<span class="number">300002</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> path = <span class="string">"one_hundred_thousand.txt"</span>;</span><br><span class="line">    <span class="built_in">string</span> out = <span class="string">"one_hundred_thousand_link.txt"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(path.c_str())</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">ou</span><span class="params">(out.c_str())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!in.is_open())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"open file failed!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ou.is_open())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"create file failed!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (in &gt;&gt; a)</span><br><span class="line">        arr[len++] = a;</span><br><span class="line">    </span><br><span class="line">    head L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i].data = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L.first = &amp;ans[i];</span><br><span class="line">            ans[i].next = &amp;ans[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == len - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i].pre = &amp;ans[i - <span class="number">1</span>];</span><br><span class="line">            ans[i].next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans[i].pre = &amp;ans[i - <span class="number">1</span>];</span><br><span class="line">            ans[i].next = &amp;ans[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        L.len++;</span><br><span class="line">    &#125;</span><br><span class="line">    node *p;</span><br><span class="line">    p = L.first;</span><br><span class="line">    p = (*p).next;</span><br><span class="line">    <span class="comment">// s 表示 p 下一步该指向哪里</span></span><br><span class="line">    node *s;</span><br><span class="line">    <span class="keyword">clock_t</span> start = clock();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*p).data &lt; (*(*p).pre).data)</span><br><span class="line">        &#123;</span><br><span class="line">            node *q;</span><br><span class="line">            q = L.first;</span><br><span class="line">            <span class="keyword">while</span> ((*q).data &lt;= (*p).data)</span><br><span class="line">                q = (*q).next;</span><br><span class="line">            <span class="comment">// q p 的位置不同时，操作不同，分四种情况</span></span><br><span class="line">            <span class="comment">// case 1 pass</span></span><br><span class="line">            <span class="keyword">if</span> ((*p).next == <span class="literal">NULL</span> &amp;&amp; q == L.first)</span><br><span class="line">            &#123;</span><br><span class="line">                s = (*p).pre;</span><br><span class="line">                (*p).next = L.first;</span><br><span class="line">                (*q).pre = p;</span><br><span class="line">                (*(*p).pre).next = <span class="literal">NULL</span>;</span><br><span class="line">                (*p).pre = <span class="literal">NULL</span>;</span><br><span class="line">                L.first = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case 2 pass</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((*p).next == <span class="literal">NULL</span> &amp;&amp; q != L.first)</span><br><span class="line">            &#123;</span><br><span class="line">                s = (*p).pre;</span><br><span class="line">                (*(*p).pre).next = <span class="literal">NULL</span>;</span><br><span class="line">                (*p).pre = (*q).pre;</span><br><span class="line">                (*(*q).pre).next = p;</span><br><span class="line">                (*p).next = q;</span><br><span class="line">                (*q).pre = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case 3 pass</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == L.first &amp;&amp; (*p).next != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s = (*p).next;</span><br><span class="line">                (*(*p).pre).next = (*p).next;</span><br><span class="line">                (*(*p).next).pre = (*p).pre;</span><br><span class="line">                (*p).next = q;</span><br><span class="line">                (*q).pre = p;</span><br><span class="line">                (*p).pre = <span class="literal">NULL</span>;</span><br><span class="line">                L.first = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case 4</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q != L.first &amp;&amp; (*p).next != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s = (*p).next;</span><br><span class="line">                (*(*p).next).pre = (*p).pre;</span><br><span class="line">                (*(*p).pre).next = (*p).next;</span><br><span class="line">                (*p).next = q;</span><br><span class="line">                (*p).pre = (*q).pre;</span><br><span class="line">                (*(*q).pre).next = p;</span><br><span class="line">                (*q).pre = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每种情况对应的 s 都不一样 但最后都要指向 s</span></span><br><span class="line">            p = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = (*p).next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">clock_t</span> end = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;  (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">" seconds"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    in.close();</span><br><span class="line">    p = L.first;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ou &lt;&lt; (*p).data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        p = (*p).next;</span><br><span class="line">    &#125;</span><br><span class="line">    ou.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>文档结构如下：(每个数据规模产生一个<code>txt</code>文件，用于读取，输出结果加<code>seq</code>或者<code>link</code>的后缀保存到<code>txt</code>文件中，用于检查排序是否正确，事实证明结果是正确的，尽管代码逻辑不好，但能保证执行结果对)</p>
<p><img data-src="/2020/03/02/algorithm-time-complexity/3.jpg" alt></p>
<p>在<code>i7-9750H</code>的CPU上执行结果如下：（执行三次，取平均）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据规模</th>
<th>链式结构计时，单位：秒</th>
<th>顺序结构计时，单位：秒</th>
</tr>
</thead>
<tbody>
<tr>
<td>10万</td>
<td>24.7</td>
<td>8.477</td>
</tr>
<tr>
<td>11万</td>
<td>30.8</td>
<td>10.247</td>
</tr>
<tr>
<td>15万</td>
<td>62</td>
<td>19</td>
</tr>
<tr>
<td>20万</td>
<td>116.112</td>
<td>33.765</td>
</tr>
<tr>
<td>30万</td>
<td>272</td>
<td>75.5</td>
</tr>
</tbody>
</table>
</div>
<p>也许你会感到意外，为何$O(n^2)$的算法比$O(n^3)$的算法还要慢？不是不符合前文的规律？显然，这里$O(n^2)$的算法比$O(n^3)$的算法慢的原因是：链式结构要经常操作指针，来寻找下一个地址，时间耗费在地址空间的寻找上；而顺序结构中，逻辑相邻即物理相邻，不用浪费多余的时间去寻找下一个元素的地址，使用下标访问即可。</p>
<p>那么，如何证明前文的思想是对的？我本来是想用三次函数拟合顺序结构的数据，用二次函数拟合链式结构的数据，求两个函数的交点。结果发现数据量太少，居然只能拟合出开口向下的二次函数和单调递减的三次函数，这显然是不对的，因为这两个函数都在随着问题规模的增加，耗时逐步减少。</p>
<p>然而我还不想做更多的数据，拟合不对并不代表数据是错误的，所以，我决定用链式结构的时间减去顺序结构的时间，得到一个时间差。对时间差进行三次函数拟合（三次函数减二次函数仍然为三次函数），得到拟合结果：$g(t)=-0.0007601 x^3 + 0.2858 x^2 - 1.431  x + 2.719$，通过<code>sympy</code>求解，得到一个实数根为$370.95$，绘制$[10, 380]$区间内的函数图像：</p>
<p><img data-src="/2020/03/02/algorithm-time-complexity/4.png" alt></p>
<p>可以发现，在$n&gt;371$后，函数值小于0，说明在问题规模大于某个阈值后，$O(n^2)$的算法比$O(n^3)$的算法耗时要少，速度要快。那么这个时候，不管操作指针寻找地址多么的麻烦，时间开销总会比$O(n^3)$的算法小，只是前期可能会因为操作指针的关系影响执行的效率。</p>
<p>当然实际情况中，371并不代表三千多万的数据，毕竟实际情况会比单独的数据排序复杂得多。所以，也有必要根据实际问题的规模，合理的选择算法。</p>
<h1 id="程序下载"><a href="#程序下载" class="headerlink" title="程序下载"></a>程序下载</h1><p><a href="https://github.com/muyuuuu/Algorithm/tree/master/Insert_sort" target="_blank" rel="noopener">下载</a>。我把全部文件，包括原始的随机数据、排列好的数据都放上了，后缀为seq表示顺序结构排列的结果，后缀为link表示为链式结构排列的结果。第一是证明我写的代码是对的，第二是预留这些数据，供后来者玩耍。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.geeksforgeeks.org/insertion-sort/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/insertion-sort/</a></p>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>元胞自动机——万物皆可模拟</title>
    <url>/2020/02/14/autocell/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>假期实在无聊，开始整理过去的文件，发现了自己原来是数学建模起家的。长话短说，翻阅了在过去时间里自己做过的模拟题，所有的模型是自己设计的，代码也是自己写的。而倾注了自己心血的东西，难免会有些有意思的地方。比如：</p>
<ul>
<li>数据缺失，如何去除，如何补充，哪些去除，哪些补充，都是有学问的；</li>
<li>另外就是今天的主角，元胞自动机——万物皆可模拟。</li>
</ul>
<p>另一方面是，当初在学习元胞自动机这个模型时，网上的资料是在少之又少，且内容凌乱的不堪入目，我猜作者也不知道他在写啥，自己也走了很多弯路。遂决定，以实战的背景，演示元胞自动机的工作原理和使用方法。而在看本文之前，你只需要知道元胞自动机里面有很多格子，格子间通过某种规则相互影响即可。</p>
<p><img data-src="/2020/02/14/autocell/1.gif" alt></p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>模拟题是2015年的MCM的A题，决定用元胞自动机去模拟埃博拉病毒的传播。但我不会把论文的全部内容放上来，只写关键的文字，什么参考文献，数据网址就不放了。且时过境迁，本文使用的数据为过去式，和今天对不上则选择性忽略。</p>
<p>The world medical association has announced that their new medication could stop Ebola and cure patients whose disease is not advanced. Build a realistic, sensible, and useful model that considers not only the spread of the disease, the quantity of the medicine needed, possible feasible delivery systems (sending the medicine to where it is needed), (geographical) locations of delivery, speed of manufacturing of the vaccine or drug, but also any other critical factors your team considers necessary as part of the model to optimize the eradication of Ebola, or at least its current strain. In addition to your modeling approach for the contest, prepare a 1-2 page non-technical letter for the world medical association to use in their announcement.</p>
<p>代码的原作者和链接：<a href="https://zeroto521.github.io/2018/09/23/MVC.html" target="_blank" rel="noopener">https://zeroto521.github.io/2018/09/23/MVC.html</a></p>
<h1 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h1><ul>
<li>$v_{psd}$：病毒传播速度。在正式确定埃博拉病毒导致疾病后，截止于2014年12月31日，每天感染病毒的人数。 </li>
<li>$\eta_1$：埃博拉病毒的感染率，即与携带埃博拉病毒的宿主接触后被感染的几率。</li>
<li>$\eta_2$：埃博拉病毒的死亡率，即感染埃博拉病毒后的死亡几率。</li>
<li>$N$：三个国家总人数。1181万。</li>
<li>$N_1$：三个国家的感染人数</li>
<li>$N_2$：三个国家的死亡人数</li>
</ul>
<h1 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h1><ol>
<li>假设我们运输药物的路径可以视为直线。</li>
<li>假设在治疗疫情期间，运输药物的车辆、直升机等可自由穿越国界。</li>
<li>疫情传播并不会因国家不同而传播方式不同，因此假设三个国家的死亡率、感染率相同。</li>
<li>后期分配药物建立运输系统时，考虑到疫情的严重性，及生命的重要性，我们会将三个国家视为一个地区。</li>
<li>假设三个国家的所有机场、港口均能使用，且在疫情期间内能够支持药物的运营。</li>
<li>在根除西非区域的埃博拉病毒时，假设病毒患者在家中、医院或隔离区，视为静止点。规定医疗人员前往静止点进行救治，而不是感染患者来急救站点进行救治，防止因感染人员流动而导致病毒扩散带来的不良后果。</li>
</ol>
<h1 id="前期工作"><a href="#前期工作" class="headerlink" title="前期工作"></a>前期工作</h1><h2 id="元胞自动机"><a href="#元胞自动机" class="headerlink" title="元胞自动机"></a>元胞自动机</h2><p>后文的元胞自动机均简称为CA。</p>
<p>CA(Cellular automaton)具有模拟复杂系统演化过程的能力，以网格代表不同的状态，通过定义相关的规则来模拟真实世界的发生情况，不用考虑复杂的计算公式，只需通过网格之间的规则来模拟真实情况因而在社会学、物理学、化学领域都有广泛的应用。</p>
<h2 id="SIR状态"><a href="#SIR状态" class="headerlink" title="SIR状态"></a>SIR状态</h2><p>在最简单的情况下，按照区间可以将人群分成两个健康状态：易感染病原体（通常用$S$表示）; 感染的病原体（用符号$I$表示）；免疫体状态（用符号$R$表示）。因此，我们基于元胞自动机设立演化规则，呈现病人的SIR状态，模拟埃博拉病毒的传播。</p>
<h2 id="埃博拉病毒"><a href="#埃博拉病毒" class="headerlink" title="埃博拉病毒"></a>埃博拉病毒</h2><p>考虑到不同地区的卫生条件、对疫情不同的控制方式，因此难以给出明显的函数关系式来描述所有情况下人口密度与疾病传播的内在联系。</p>
<p>埃博拉病毒能够通过各种渠道进行传播，通常潜伏期为5-10天，并且有极高的致死率。埃博拉病毒爆发于塞拉利昂国家东部与几内亚和利比里亚同时接壤的区域。病毒首先从人口密度大的爆发起点城区区域感染，然后向外扩散。距离爆发区域近的人口密度小的森林区域感染程度处于中等水平，而距离爆发区域近的人口密度大的城区区域感染程度处于较高水平。总体来看病毒感染水平随着距离爆发起点区域的距离越远感染程度越低，森林区域的病毒感染水平要比附近的城区区域低。</p>
<h1 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h1><p>以SIR状态为CA模拟病毒传播时元胞状态的表现形式。在埃博拉病毒初期传播过程中，因没有完全有效的抵制病毒传播的有效疫苗和药物，因此不考虑完全免疫个体，但存在临时免疫的个体，即在康复后仍然具有被感染的概率。由此，结合传统的SIR“易染-感染-移除”（Susceptible-Infected-Removed）模型，建立符合实际情况的“易染-感染-死亡-暂时免疫”（Susceptible-Infected-Dead-Temporarily immunized）模型，进而模拟埃博拉病毒传播的实际情况。即网络节点被假设成以下的四种状态：</p>
<ul>
<li>易感状态$S$，不会传染其他人，但是有几率被感染；</li>
<li>感染状态$I$，已经患病且具有传染性</li>
<li>死亡状态$D$，因感染疾病而死亡，且死亡后若尸体处置不恰当，仍然能够传播病毒</li>
<li>暂时免疫状态$T$，因采取及时隔离、药物治疗等措施，病人暂时康复，但是没有长期的抵抗力。</li>
</ul>
<p><img data-src="/2020/02/14/autocell/1.png" alt></p>
<h2 id="定义CA规则"><a href="#定义CA规则" class="headerlink" title="定义CA规则"></a>定义CA规则</h2><h3 id="定义CA格子表达含义"><a href="#定义CA格子表达含义" class="headerlink" title="定义CA格子表达含义"></a>定义CA格子表达含义</h3><ul>
<li><p>因埃博拉病毒的传播过程中，每一个国家均存在感染病毒的几率与感染病毒后的死亡几率，不会受到地理空间分布的影响，用CA表示国家的空间分布没有实际意义，因此不考虑用元胞空间表示实际地理空间。</p>
</li>
<li><p>在前期工作中，我们了解到在一个区域内，会因人口密度、人口数量不同，而导致感染水平不同。即在人口密度大的城市，感染水平会高于人口密度低的城市，人口密度在很大程度中影响疾病传播率。因此元胞自动机模拟埃博拉传染过程中，设定CA的每一个方格代表人口密度，并且每个方格所代表的人口密度相同。并根据三个国家的人口数量比例划分元胞空间，划分域如下。</p>
</li>
</ul>
<p><img data-src="/2020/02/14/autocell/2.png" alt></p>
<h3 id="定义CA颜色含义"><a href="#定义CA颜色含义" class="headerlink" title="定义CA颜色含义"></a>定义CA颜色含义</h3><ul>
<li>缺少计算服务器，因此元胞数量设置为$20\times 20$，用于表示并模拟区域内疾病的传播，进而得到患病者死亡率、感染率的分布规律。并且定义灰色表示死亡状态；红色表示已经被感染状态，且颜色越深代表被感染时间越长；白色表示易染状态和暂时免疫状态。</li>
</ul>
<h3 id="定义CA迭代含义"><a href="#定义CA迭代含义" class="headerlink" title="定义CA迭代含义"></a>定义CA迭代含义</h3><ul>
<li>假设 CA 的迭代次数$i$时，每一次迭代可视为模拟的埃博拉病毒传播$\lambda$天的传染效果，其中$\lambda$为迭代一次代表的时间长度，则$\lambda=365/i$。</li>
</ul>
<h3 id="定义CA中人口流动的频率与范围"><a href="#定义CA中人口流动的频率与范围" class="headerlink" title="定义CA中人口流动的频率与范围"></a>定义CA中人口流动的频率与范围</h3><ul>
<li>在埃博拉病毒的爆发之际，病毒主要的传染方式为人口的流动导致病毒的扩散，进而导致各地区开始出现疫情，最终导致疫情恶化而难以控制。因此，我们需要考虑人口流动现象对疫情的影响。在疫情初期，人口流动的频率$F$与范围$R$会高于疫情严重时期人口流动的频率与范围。流动半径$R$在CA中的表达形式为：格子的数量。流动频率$F$在CA中的表达形式为：在时间长度为100天的期限内，发生人口流动现象的天数。因随着时间的增加，疫情逐渐严重，人口流动频率会逐渐降低，符合指数分布的特征，设符号$t$表示疫情爆发时间，则流动频率的表达式为$F(t)=\frac{1}{\theta}e^{-t/\theta}$，$\theta$为参数。</li>
</ul>
<h2 id="数学表达CA所需的参数"><a href="#数学表达CA所需的参数" class="headerlink" title="数学表达CA所需的参数"></a>数学表达CA所需的参数</h2><h3 id="理论死亡率"><a href="#理论死亡率" class="headerlink" title="理论死亡率"></a>理论死亡率</h3><p>埃博拉病毒传染具有潜伏期，潜伏期的时间通常为为5-10天，过了潜伏期之后便会死亡，因此感染时间越长，死亡率越高。当被感染埃博拉病毒的人足够多时，可认为潜伏期$\phi(t)$服从正态分布$N(\mu, \sigma^2)$，$\mu=7.5, \sigma^2=1$为假定参数。以易染状态的元胞$i$举例，若在第一次迭代后被感染变为状态$I$；第二次迭代以$\Phi(5+\lambda)$的概率变为死亡状态（ 为迭代一次所代表的时间长度）；第三次迭代以$\Phi(5+3\lambda)$的概率变为死亡状态，以此类推第j次迭代后以$\Phi(5+(j-1)\lambda)$的概率变为死亡状态。</p>
<p><img data-src="/2020/02/14/autocell/3.png" alt></p>
<h3 id="理论治愈率"><a href="#理论治愈率" class="headerlink" title="理论治愈率"></a>理论治愈率</h3><p>实际情况中，国家政府会对埃博拉病毒采取一定的抵抗措施，因此定义治愈率函数$f_1(t)$，治愈率包含自身对埃博拉的抵抗力，以及国家对疫情的控制情况，如隔离、医疗救助、及时医治等措施能够减缓疫情的蔓延率与死亡率。</p>
<p>因自身免疫力与国家对疫情控制度共同影响了死亡率，而在前期调查中得知三个国家的死亡率并不相同，三个国家死亡率分布：利比里亚死亡率$\eta’=42.7\%$，几内亚死亡率$\eta’’=63.1\%$，塞拉利昂死亡率$\eta’’’=29.2\%$。</p>
<p>当元胞$i$变为感染状态$I$时，随着时间增加，治愈系数会逐渐减弱。假设这种减弱的关系服从指数分布，则治愈函数$f_1(t)$的表达式为$f_1(t)=\frac{1}{\theta_1}e^{-t/\theta_1}$。而实际中三个国家的治愈系数并不相同，为反应出三个国家治愈率的不同之处，用三个国家的死亡率进一步表示治愈率，得到如下的关系式：</p>
<script type="math/tex; mode=display">
f_1(t)=\frac{1}{\theta_1}e^{-t/\theta_1} + 
\begin{cases}
    1 - \eta' & \text{利比里亚} \\
    1 - \eta'' & \text{几内亚} \\
    1 - \eta''' & \text{塞拉利昂} \\
\end{cases}</script><p>理论死亡率与康复率分布图如下：</p>
<p><img data-src="/2020/02/14/autocell/4.png" alt></p>
<h2 id="计算真实死亡率与真实治愈率"><a href="#计算真实死亡率与真实治愈率" class="headerlink" title="计算真实死亡率与真实治愈率"></a>计算真实死亡率与真实治愈率</h2><p>计算真实死亡率与康复率：目前只提出了理论死亡率与理论治愈率的计算方法，因假设死亡率随时间增加符合正态分布，因此死亡率会逐渐增加，并十分接近100%，因此提出的理论情况并非真实情况下的死亡率与康复率。在实际情况中，当死亡率很高时，仍会有个体康复；在个体康复率很高时，仍会有个体死亡；为表示这一关系，采用下列方程式计算真实情况下的康复率与死亡率：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>真实治愈率$O_1$</th>
<th>继续被感染率</th>
<th>真实死亡率$\eta_3$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$f_1(t)&gt;\Phi$</td>
<td>$\frac{1}{t}e^{f_1(t)-\Phi}\sqrt{f_1(t)-\Phi}$</td>
<td>$1-O_1-\eta_3$</td>
<td>$\frac{t}{t+\epsilon}e^{\Phi-f_1(t)}\sqrt{f_1(t)-\Phi}$</td>
</tr>
<tr>
<td>$f_1(t)&lt;\Phi$</td>
<td>$\frac{1}{t}e^{f_1(t)-\Phi}\sqrt{\Phi-f_1(t)}$</td>
<td>$1-O_1-\eta_3$</td>
<td>$\frac{t}{t+\epsilon}e^{\Phi-f_1(t)}\sqrt{\Phi-f_1(t)}$</td>
</tr>
</tbody>
</table>
</div>
<p>$\frac{1}{t}$和$\frac{t}{t+\epsilon}$为时间修正公式：$\frac{1}{t}$是减函数，随时间增加而减小，用于修正康复率，则康复率随感染时间增加而减小；$\frac{t}{t+\epsilon}$是增函数，随时间增加而增加，用于修正死亡率，则死亡率随感染时间增加而增加，更具真实性。</p>
<p>$e^{f_1(t)-\Phi}$为概率修正公式：在理论治愈率$f_1(t)$大于理论死亡率$\Phi$时，有一定几率死亡，也有一定几率康复；当$\Phi$大于$f_1(t)$时，仍有一定几率被治愈；但$f_1(t)+\Phi$可能高于100%，且死亡率与康复率之间存在着继续感染的几率。因此，需要将理论死亡率$\Phi$、治愈率$f_1(t)$进行变换为$e^{f_1(t)-\Phi}$，得到更接近实际的死亡率与治愈率，并求解继续感染的几率。</p>
<p>借鉴模拟退火算法的思想，在解空间内以一定的几率发生跳变,即某种事件发生的概率较低时，仍能有一定几率发生。因而，在$\Phi$大于$f_1(t)$时，康复的概率修正为$e^{f_1(t)-\Phi}$，当$\Phi$小于$f_1(t)$时，死亡的概率修正为$e^{\Phi-f_1(t)}$。</p>
<p>$\sqrt{f_1(t)-\Phi}$为误差修正公式：当$f_1(t)&lt;\Phi$且$f_1(t)$接近于$\Phi$时，存在</p>
<script type="math/tex; mode=display">\text{limit:}f_1(t)\rightarrow \Phi, e^{f_1(t)-\Phi}=1</script><p>的现象，得到了当死亡率接近康复率时，康复率接近于1的错误结论。为避免这种现象的发生，增加修正项$\sqrt{\Phi-f_1(t)}$，当$f_1(t)\rightarrow\Phi^{-}$时，$e^{\Phi-f_1(t)}\sqrt{\Phi-f_1(t)}$趋于稳定（不是高数题，没那么无限趋近于0），因此避免治愈率接近于死亡率时概率计算错误现象。</p>
<h2 id="开始CA模拟"><a href="#开始CA模拟" class="headerlink" title="开始CA模拟"></a>开始CA模拟</h2><ul>
<li><p>当元胞$i$为状态$S$时，若它的邻居中存在感染者(即有状态$I$的邻居)，则在下个时间步里，元胞$i$的状态以概率$\eta_1$变为被感染状态$I$。</p>
</li>
<li><p>对尸体处置不当，导致尸体仍然能继续传播埃博拉病毒的情况，因此假设死亡元胞$i$会以概率$\eta_2$感染其他元胞。</p>
</li>
<li><p>当元胞$i$为状态$I$时，元胞$i$会以概率$\eta_3$由感染状态变为死亡状态。</p>
</li>
<li><p>当元胞$i$为状态$I$时，元胞$i$会以概率$O_1$由感染状态变为暂时免疫状态$T$。</p>
</li>
<li><p>同时暂时免疫状态会以概率$\eta_1$再次变为被感染状态$I$；</p>
</li>
</ul>
<h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><p>采用定义的CA规则，对2014年内埃博拉爆发情况进行模拟，当CA迭代完成后，得到如下的结果，其中灰色代表死亡状态，白色代表易染状态，红色代表被感染状态，颜色越深表示被感染程度越高。</p>
<p><img data-src="/2020/02/14/autocell/2.gif" alt></p>
<p>如图所示，每一个方格代表感染人口，埃博拉病毒迅速传染至每个区域，区域内人口开始出现感染埃博拉病毒以及死亡的现象，并且在国家政策干预和患者自身免疫力的抵抗下，在感染区域内仍有康复个体。</p>
<p>我们计算元胞自动机模拟结果中几内亚感染数（<code>GI</code>）与几内亚死亡数（<code>GD</code>）比例，塞拉利昂感染数（<code>SI</code>）与塞拉利昂死亡数（<code>SD</code>）比例，利比里亚感染数（<code>LI</code>）与利比里亚死亡数（<code>LD</code>），总感染案例（<code>TI</code>）与总体死亡数（<code>TD</code>），（格子数乘以对应人口密度）。并与原始数据对比，得到的对比情况如下图。</p>
<p><img data-src="/2020/02/14/autocell/6.png" alt></p>
<p>与实际情况对比之下，发现我们建立模型的模拟的效果较好，与实际结果极为接近，并且证实了之前假设的合理性。并根据实际数据调节模型中的参数，最终调整参数的结果为：传染率：$\eta_1=0.8$ ，死亡传染率：$\eta_2=0.15$，时间修正函数：$\epsilon=10$，迭代步长：$\lambda=1$，游走频率指数分布中$\theta=5$，游走半径$R=2$，治愈率指数分布$f_1(t)$中，$\theta_1=10$，理论死亡率的正态分布$\phi(t)$中：$N=7.5, \sigma^2=5$。</p>
<h1 id="开始治疗"><a href="#开始治疗" class="headerlink" title="开始治疗"></a>开始治疗</h1><p>假设采用空运的形式将疫苗从制药工厂送往区域E内的所有机场。针对疫情最为严重的三个国家，在Google Map中我们查询到疫情覆盖范围内最远距离为1135公里左右，假设以直升机或卡车的方式进行运输，则在一天内足够将药物送到我们设立的急救站点处，因此不再考虑运输药物时间对疫情的影响。</p>
<p>创立良好的医助条件：①当地政府需要指挥相关人员配合医生，及时对染病患者进行隔离，建立隔离区或在医院对患者进行隔离，防止疾病传播疫情难以控制；②在对患者进行救治时，将救治好的患者及时脱离隔离区，避免二次感染；③对因感染疾病而死的患者尸体，及时进行有效的火化处理，防止尸体传播病毒。</p>
<h1 id="治疗模型建立"><a href="#治疗模型建立" class="headerlink" title="治疗模型建立"></a>治疗模型建立</h1><p>假设此时已经开始建立良好的医疗条件，如：隔离、焚烧尸体等。</p>
<h2 id="改进感染率"><a href="#改进感染率" class="headerlink" title="改进感染率"></a>改进感染率</h2><p>在实际情况中，当周围被感染埃博拉病毒的人数较少时，若及时对染病人群就进行隔离，则病毒对易感染人群的感染率较低；若一个区域内疫情严重爆发，染病人群远远高于易染人群，则病毒对易染人群的传染率会相对较高。为在CA中描述这种关系，建立以下数学模型。</p>
<p>在最初的CA中感染率为固定参数，病毒仍以固定的感染率在元胞之间进行传播。在状态为$S$（易染）的元胞附近，没有充分考虑状态为$I$（感染）的元胞数量对传染率的影响，即$S$状态元胞附近被感染的元胞数量较多时，传染率会有所改变而并非常数。</p>
<p>因此，假设元胞$i$处于$S$（易染）状态，在近邻8个元胞方格中有$\Psi(0\leq\Psi\leq 8)$个元胞处于$S$（感染）状态，有$\xi(0\leq\xi\leq 8)$个元胞处于死亡状态，但因及时有效对尸体进行火化处理，死亡状态不会在传染病毒，因此$\eta_2=0$。则元胞$i$以$P$的概率被感染，其中$P=\frac{1}{8}(1+k)(\eta_1\Psi)$，$k$为参数。</p>
<h2 id="增加药物治疗效果"><a href="#增加药物治疗效果" class="headerlink" title="增加药物治疗效果"></a>增加药物治疗效果</h2><p>随着感染时间的延长，病情逐渐恶化，药物的有效率逐渐降低。若患者第一天被感染病毒，设药物的有效率为$\beta_0$，患者处于潜伏期最后一天时药物有效率为$\beta_n$，则$\beta_n &gt; \beta_0$。假设药物的有效率与时间变化仍服从指数分布，则有效率随感染期限的变化函数为$f_2(t)=\frac{1}{\theta_2}e^{-t/\theta_2}$，$\theta_2$为参数，$t$为感染时间。</p>
<p>在最初CA模拟疾病爆发时，疫情的蔓延和死亡受到治愈率的影响，而在对患者使用药物后的治愈率同样会提高。药物的治疗率为$f_2(t)$，初始治愈率为$f_1(t)$，但对于病人而言，最终的药物治疗效果并非简单叠加：$f_1(t)+f_2(t)$，因为这会导致康复率大于1，出现完全治愈的现象，不符合实际情况。因此假设药物治疗效果与国家监管对治疗患者的成功率存在交互影响作用，此交互影响作用表达式为$(1-\alpha)(f_1(t)+f_2(t))$，$\alpha$为交互因子，因此，得到使用药物后的治愈率：$f_3(t)=(1-\alpha)(f_1(t)+f_2(t))$。</p>
<h1 id="模拟结果"><a href="#模拟结果" class="headerlink" title="模拟结果"></a>模拟结果</h1><p>根据模拟2014年埃博拉爆发得到的不同区域内元胞的感染状态与死亡状态，并以此为基础，加入药物治疗因素影响，在感染与死亡基础之上进一步模拟药物治疗效果，随迭代时间增加，感染率逐渐降低，被感染的患者也被医治好，得到如下的药物的治疗效果。</p>
<p><img data-src="/2020/02/14/autocell/7.png" alt></p>
<p>感染率由最初的24%逐渐降到0%。</p>
<p>在CA迭代15次时，模拟的是2014年内埃博拉爆发时死亡情况与感染情况，感染率达到高峰；在迭代15次之后，加入药物治疗因素影响，模拟加入药物对埃博拉疫情的根除效果，感染率逐步降低。感染率示意图如下图所示：</p>
<p><img data-src="/2020/02/14/autocell/8.png" alt></p>
<p>在埃博拉病毒爆发期间，感染人数持续上升，并且一年后，在缺乏有效药物的抵抗的情况下，感染病毒人数达到顶峰。在加入药物治疗对病情进行控制后，感染人数急剧降低，并在迭代22次后，感染元胞数量为零，即所有的感染患者都被治愈。而通过CA模拟药物的治疗效果，可以得到根除埃博拉的预计时间为3个月。（忘了咋算的了）</p>
<p>同时，在分析下埃博拉病毒的死亡率，定义的死亡率为：死亡元胞数量除以死亡元胞数量与感染元胞数量的和。</p>
<p><img data-src="/2020/02/14/autocell/9.png" alt></p>
<p>在埃博拉病毒爆发期间，死亡率呈上升趋势，但在加入药物对病情进行控制后，被感染元胞迅速被治愈，在迭代22次后死亡率迅速上升至100%，因为此时只含死亡元胞。感染元胞数量为零，即所有的感染患者都被治愈。</p>
<p>以红色代表感染状态，且颜色越深感染时间越长，灰色代表死亡状态，白色代表康复状态。下图描绘了加入药物治疗因素后，对埃博拉病毒的根除效果，感染人数（红色元胞）逐渐减少，逐渐转化为白色元胞，即被感染患者逐步开始被治疗。</p>
<p><img data-src="/2020/02/14/autocell/3.gif" alt></p>
<p><img data-src="/2020/02/14/autocell/10.png" alt></p>
<h1 id="灵敏性分析"><a href="#灵敏性分析" class="headerlink" title="灵敏性分析"></a>灵敏性分析</h1><h2 id="人口流动"><a href="#人口流动" class="headerlink" title="人口流动"></a>人口流动</h2><p>人口流动为传播埃博拉病毒的主要形式，当接触埃博拉病毒之后，随着人口流动，病毒也开始扩散，由最初的小村落传染至西非三个国家，甚至传播至欧洲、美洲，并且造成了破坏性影响。因此，我们讨论人口流动现象对疾病传播造成的影响。</p>
<p><img data-src="/2020/02/14/autocell/11.png" alt></p>
<p>如图所示，当不存在人口流动现象时，元胞的存活率最高，即更少的人会被病毒感染，元胞的被感染几率最低，死亡率最低。而随着流动频率与流动范围的增加，元胞被感染几率上升，死亡率也上升。因此，人口流动现象影响了疾病传播情况，也影响了死亡率与感染率，因此，对于国家政府而言，应采取“戒严”形式，减少人口流动频率，对于减缓疾病传播与降低死亡率有着至关重要的作用。</p>
<h2 id="加大治理力度"><a href="#加大治理力度" class="headerlink" title="加大治理力度"></a>加大治理力度</h2><p>在以上灵敏性分析中，我们提出了国家应采取戒严措施防治疾病的进一步蔓延。而在其他方面，如提供充足的医疗设施；及时建立急救站点；发动较多医生甚至志愿者及时为患者提供的医疗服务，提高医疗效率，都能提高染病患者的存活几率。因此，我们讨论在加大疾病治理力度的情况下，对疫情的控制情况。</p>
<p><img data-src="/2020/02/14/autocell/12.png" alt></p>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p><a href="https://github.com/Zeroto521/Zeroto521.github.io/tree/master/assets/source/CellMachine" target="_blank" rel="noopener">下载</a>，程序的原作者不是我，模型关系复杂到这里，这种难度的程序已经不是我这种技术渣可以写出来的了。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>针对埃博拉病毒传染问题，建立了符合题目要求的CA模型。充分考虑了感染率、死亡率、人口流动现象、治愈率等多方面因素，将这些因素影响融入CA中传播规则，模拟对疾病传播的影响，并与实际情况对比调整参数；在埃博拉病毒传播基础上，考虑药物治疗因素，重新定义CA传播规则，进一步模拟治疗效果。整体而言，准确模拟了疾病传播情况，并模拟药物治疗效果，预计根除艾比拉病毒所需时间，完成了工作。</p>
<p>并且在面临其他问题时，可对模型进行灵活的改动。根据需求重新定义传播规则，在改变元胞之间的联系规则后，可以模拟其他现象，并解决问题，具有很强的应用范围，如石油扩散、人口流动、交通运输等，因此，CA 模型具有很强的扩展性与灵活性。</p>
]]></content>
      <tags>
        <tag>Modeling</tag>
      </tags>
  </entry>
  <entry>
    <title>图解反向传播与梯度下降</title>
    <url>/2020/05/09/back-propagation-and-gradient-descent/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在之前的学习深度学习的过程中，以MLP为例，仅仅是知道了梯度下降和反向传播能很好的降低预测误差(本文暂且不谈论梯度消失和爆炸的问题)，使得训练出来的模型能够对未知的数据进行预测或者分类，以此来达到智能的目的。</p>
<p>时至今日，意识到不求甚解释不好的行为，于是下决心搞懂梯度下降和反向传播的原理。结果上网一搜，呵，大部分tm的是各处偷来的截图，截图里还有三四个水印，最后胡乱的堆一些数学公式，讲解的并不够彻底，也不通俗易懂。于是本文决定图解反向传播和梯度下降，并配备必要的数学计算，使读者一目了然。</p>
<a id="more"></a>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>求偏导的概念得会一下(懂概念即可，不用自己求)，激活函数如何工作得会，网络的连接得会(搞明白参数在哪里工作就好了)。</p>
<h1 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h1><p>我们先设一个简单的函数$y=3x^2+2x+1$。假设此时$x=10$，那么$y=321$，我们想优化这个函数，即利用梯度下降的方式来求得$y$的最小值和对应的$x$的值。<del>为什么不求导直接算$y$的最小值？因为现实中的函数维度极度复杂，在复杂的函数空间内可能求不出来极小值点，这里只是用简单函数举例。</del>可以求出目标函数的导函数为：$y’=6x+2$。万事具备，再来回顾下导数的意义<del>非严谨数学定义，不要较真</del>：</p>
<p><img data-src="/2020/05/09/back-propagation-and-gradient-descent/2.png" alt></p>
<p>如上图所示，无限放大曲线的一小部分，在$y$轴方向截取一段$dy$，向$x$轴方向截取一段$dx$，则$f’(x)=dy/dx$即为这一小段曲线的斜率，也为导数值。当然，具体到实际问题，并不是取一段曲线而是以一个具体的点计算，这里只是距离。如$f(x)=2x^2$在$x=2$处的导数值为8。</p>
<p>梯度的本意是一个向量（矢量），即函数在该点处沿着该方向（此梯度的方向）变化最快，变化率最大，显而易见，对一元函数而言就是求导(多元函数求偏导并含有方向)。继续推导，可以得到这样的式子：$f’(x)dx=dy$。在详细一点，当前$x=10$，我们取一个固定的$dx=0.2$，沿着导数的方向，让$x$逐渐的变化，此时的$y$也逐渐变小，是不是就能逐步得到目标函数的最小值呢？数学语言如下：</p>
<ol>
<li>初始化$x$</li>
<li>开始迭代：<ul>
<li>求$f(x)$的导数$f’(x)$</li>
<li>$x_{i+1} = x_i - dx * f’(x)$</li>
<li>$i ++$</li>
</ul>
</li>
</ol>
<p>即迭代示意图如下：</p>
<p><img data-src="/2020/05/09/back-propagation-and-gradient-descent/3.png" alt></p>
<ul>
<li>$x_1-f’_1dx=x_2$，$f’_1$为$x_1$处的导数值</li>
<li>$x_2-f’_2dx=x_3$，$f’_2$为$x_2$处的导数值</li>
</ul>
<p>当然，$dx$也可以换成$\alpha$表示，含义为学习率，即每次行走的步幅。直到行走到最低点结束，代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dx = <span class="number">0.2</span></span><br><span class="line">n_eproch = <span class="number">1000</span></span><br><span class="line">x = <span class="number">-10</span> </span><br><span class="line">ls = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n_eproch):  </span><br><span class="line">    y = <span class="number">3</span> * x ** <span class="number">2</span> + <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">    ls.append(y)</span><br><span class="line">    x = x - (<span class="number">6</span> * x + <span class="number">2</span>) * dx</span><br><span class="line"></span><br><span class="line">print(ls[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># 0.67</span></span><br></pre></td></tr></table></figure>
<p>可见在迭代1000次后，$y$的最终取值为0.67，和函数实际的最小值不谋而合<del>利用中学知识求一下即可</del>，这就是梯度下降的力量。当然，对于复杂的多元函数求偏导，或者求导的链式法则，还是借助<code>Tensorflow</code>这种专业工具更加省事。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">X = tf.constant([<span class="number">0.</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.74</span>, <span class="number">1.</span>])</span><br><span class="line">y = tf.constant([<span class="number">0.</span>, <span class="number">0.36</span>, <span class="number">0.54</span>, <span class="number">0.82</span>, <span class="number">1.</span>])</span><br><span class="line"></span><br><span class="line">a = tf.Variable(initial_value=<span class="number">0.</span>)</span><br><span class="line">b = tf.Variable(initial_value=<span class="number">0.</span>)</span><br><span class="line">variables = [a, b]</span><br><span class="line"></span><br><span class="line">num_epoch = <span class="number">100</span></span><br><span class="line">optimizer = tf.keras.optimizers.SGD(learning_rate=<span class="number">5e-4</span>)</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(num_epoch):</span><br><span class="line">    <span class="comment"># 使用tf.GradientTape()记录损失函数的梯度信息</span></span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        y_pred = a * X + b</span><br><span class="line">        loss = tf.reduce_sum(tf.square(y_pred - y))</span><br><span class="line">    <span class="comment"># TensorFlow自动计算损失函数关于自变量（模型参数）的梯度</span></span><br><span class="line">    grads = tape.gradient(loss, variables)</span><br><span class="line">    <span class="comment"># TensorFlow自动根据梯度更新参数</span></span><br><span class="line">    optimizer.apply_gradients(grads_and_vars=zip(grads, variables))</span><br><span class="line"></span><br><span class="line">print(a, b)</span><br></pre></td></tr></table></figure>
<h1 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h1><p>反向传播是一种以梯度下降为基础，对误差进行反馈，并调节相关参数的方法，因网络文章普遍都是公式较为晦涩，因此这里以数学计算为主，给出反向传播的实例，供读者理解。(因此期待看数学公式的可以移步了)。以MLP为例，首先构建结构如下图所示的网络：</p>
<p><img data-src="/2020/05/09/back-propagation-and-gradient-descent/4.png" alt></p>
<p>然后完成参数的初始化，且激活函数均采用Sigmoid($f(x)=\frac{1}{1 + e ^{-x}}$)</p>
<p>$x=2,w_{11}=1,w_{12}=-1,b_1=3,w_{21}=2,w{22}=1,b_2=0,y_{true}=1,\alpha=0.2$</p>
<h2 id="前向计算"><a href="#前向计算" class="headerlink" title="前向计算"></a>前向计算</h2><ol>
<li>隐藏层第一个神经元：$x\times w_{11} + b_1 = 5$，激活后的输出为0.99</li>
<li>隐藏层第二个神经元：$x\times w_{12} + b_1 = 1$，激活后的输出为0.73</li>
<li>输出层的预测输出为：$y_{temp}=0.99\times w_{21} + 0.73\times w_{22} + b_2=2.71$，激活后的输出为0.93</li>
<li>计算Loss：$E=\frac{1}{2}(y_{true}-y_{pred})^2$ (选用这类型是是因为求导方便，绝对值函数不一定可导)</li>
</ol>
<h2 id="反向传播-1"><a href="#反向传播-1" class="headerlink" title="反向传播"></a>反向传播</h2><ol>
<li>补充一下对$\text{Sigmoid}$函数求导的结果为：$\frac{1}{1+e^{-x}}’=\frac{e^x}{e^{2x}+2e^x+1}$</li>
<li>$E$对输出层求导：$\frac{\partial E}{\partial y_{pred}}=y_{pred}-y_{true}=-0.07$</li>
<li>而$y_{pred}=\text{Sigmoid}(y_{temp})$，$\frac{\partial y_{pred}}{\partial y_{temp}}=\frac{e^{2.71}}{e^{5.42}+2e^{2.71}+1}=0.058$</li>
<li>而计算$y_{temp}$对$w_{21}$这个参数的偏导值：$\frac{y_{temp}}{w_{21}}=0.99$ (求偏导时无关变量视为常量)</li>
<li>通过链式法则求误差$E$对参数$w_{21}$的梯度：$\frac{\partial E}{\partial w_{21}}=\frac{\partial E}{\partial y_{pred}}\times \frac{\partial y_{pred}}{\partial y_{temp}} \times \frac{\partial y_{temp}}{\partial w_{21}}=-0.004$</li>
<li>$w_{21}$沿着梯度下降即可：$w_{21}=w_{21} + \alpha \times -0.004=2+0.2\times -0.004=1.9992$，这样，参数$w_{21}$就得到了更新。(同上文的梯度下降方法)</li>
</ol>
<p>以此类推，通过不断的迭代，参数会逐渐修改，最终的结果是模型能有效的对输入进行预测或者分类。其他参数的更新同理。对于经常变成的小伙伴，会发现训练过程经常使用batch，此时最终的误差为这个bacth的总误差，需要对总误差求均值或求和等操作：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">loss = tf.keras.losses.sparse_categorical_crossentropy(y_true=y, y_pred=y_pred)</span><br><span class="line">loss = tf.reduce_mean(loss)</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ol>
<li>总算搞明白了梯度下降和反向传播的工作原理。其实，这么手推一下也就对梯度爆炸和梯度消失有了大概的了解。</li>
<li>学习率$\alpha$不是一成不变的，可以根据学习状态进行更新，参考这里：<br><a href="https://muyuuuu.github.io/2019/02/20/gradient-function/">https://muyuuuu.github.io/2019/02/20/gradient-function/</a></li>
<li>与大部分网文不同的是，本文尽力用通俗的语言讲解清楚了这两个东西，同时也会成为我的学习笔记。所以我没有给图片打水印的打算，只是受到网页浏览的限制，并没有上传高清图。如果你感觉本文还不错，且想分享，可以随意拷贝走本文的图片，嫌清晰度低可以在评论区找我要原图。</li>
<li>如果你对本文的某些细节描述还是不懂，可以评论区见，我也尽力做一个用大白话讲明白<del>高深</del>原理的人。</li>
</ol>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次重返唐山</title>
    <url>/2021/03/31/back-to-TangShan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>好久不更新生活类的博客了，正好最近该忙的都忙完了，下一波 deadline 还早，<del>其实也就一周</del>，忙里偷闲写篇博客。</p>
<a id="more"></a>
<p>16 年考上唐山的大学的时候落差很大，所以对唐山也没什么特别的印象，除了大地震。2020 年毕业的时候，却发现对唐山，对理工，对实验室，对朋友，对老师都有了很深的感情，魂牵梦绕。</p>
<p>20 年因一个 SB 吃了蝙蝠，导致我毕业季只给了一天的返校时间。那天回学校的时候，才发现一切是如此亲切，才发现这竟然是我见的最后一面。比赛没拿奖没关系，朋友的感情和师生情谊这些更重要，也知道来日方长还有机会。回家的时候，发现来日不长了，送走了舍友，队友以后再也见不到了，老师也见不到了，朋友也见不到了，我都没好好告别，越想越不舍。在车上哭成了一条狗，口罩都湿透了，也不敢动作太大让旁边的人看见。</p>
<p>周六日接到了同学结婚的邀请，正好同学留在了唐山，婚礼也在唐山。我也回唐山好好看看，算是弥补一年前没好好告别的遗憾吧，哪怕是聊聊闲天，哪怕是拍个照片。上午决定要去，买票就走了，就是这么果断。</p>
<ol>
<li>收到了同学婚礼邀请，想着大学毕业太匆忙了，很多人没见一面。正好天南海北的同学都来，见上一面，以后见面也不容易了。晚上联系了老师，老师听说我们都回来了，打车过来和我们一起玩，聊一聊，折腾到了凌晨两三点。虽然我在写流水帐，但真的挺感动的。</li>
<li>第二天婚礼，新郎追新娘从初二到研二，十年青春啊，快节奏的生活下真的不容易。</li>
<li>婚礼，新娘挽着父亲，一位质朴的农民，沧桑的脸颊，杂乱的头发。说『我闺女今天就正式交给你了』，沙哑的声音却掷地有声。新娘湿红了双眼，新郎嘴角微抿。婚礼的其它流程都像排练好的，唯独这段情节不像。我在台下泪目，可能最诚挚的亲情、爱情都浓缩在那一句话里吧。</li>
<li>这次婚礼来了很多人，从2011级到2017级，铁打的实验室，流水的人。很多人只听说过名字，不认识真人。男生见面：你代码怎么样，你项目怎么样，有论文了吗？有了女生，聊天内容逐步转变，这个真好吃，你能不能吃慢点，你在哪要饭等等，酒席之间推杯换盏打打闹闹，原来这 TM 才是生活。</li>
<li>见到了熟悉的面孔，胡乱的扯一扯，算是给生活充充电吧。研一过的太混乱了，自己也很难受，混的很差。回首才发现原来他们依然对我充满了期待，无论走到哪里，无论身在何方，依然是同学、老师眼中的骄傲。哪怕是为了他们，我也该依旧热情下去，依旧努力。</li>
<li>分别的时候，好好告别了，和我的恩师，和我最好的队友，没那么仓促。也有女生提出了要拥抱，可能下次见面真的是很多年后了，不舍吧。与君离别意，同是宦游人，初中不懂的诗，现在懂了。</li>
</ol>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>研究生生活伊始</title>
    <url>/2020/09/27/begin-postgraduate-life/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近的生活像一团屎，我是一个棍子，开心了就搅动一下，不开心了就跟它一起呆着。经历了很多，一件一件来吧。</p>
<a id="more"></a>
<p>我本科学校的推免名单出来了，看了下好多人我还认识。一年又一年，希望他们有个好的归宿吧。我记得我那会儿大二，他们大一，学术部招新，要招7-10人左右，我要从几百个人里把他们选上来。靠谱或能力比较强的人说话和普通人说话的语气、用词和态度是不一样的。面试的时候一开口说话，一听就知道这人水平咋样，靠不靠谱。结果我没看错，招上来的大部分人都保研了，去了哈工大、浙大、国防科技等高校。看着他们从大一到大四，他们也长大了。</p>
<p>他们招上来的人也很不错，8个队有7个队拿奖，美赛获奖占比也很大。保研后他们拍的学校的照片，有一种终于结束的惬意，海边风景也挺不错的。</p>
<p><img data-src="https://static01.imgkr.com/temp/57b92a67df5e406f939fee791b61218f.jpeg" alt></p>
<ul>
<li><p>新学校各方面都不怎么样，上世纪留下来的破烂建筑。保研不一定好，考研上岸也不一定好，去找工作或没考上也不一定差。即使上了佷牛逼的学校也不一定很好，从事高薪职业也不一定多享受，从事低薪的工作也不一定不好。也许是我大学毕业了，<strong>发现很多事情不能再用暂时的成绩或学生时代的标准去衡量了</strong>。这种东西真的没办法再去用工资、成绩、比XX混的好去衡量了。师兄说，等我在长大，差不多研二下那会儿，会有新的感悟，大概意思是输赢不在棋盘内，或者说以后的生活不止是输赢。我还没体会到这层境界。</p>
</li>
<li><p>读研方向已经十分内卷，不管是不是计算机的都来算法这一行分一杯羹了，毕竟算法这一行入门门槛低、程序实现相对简单。也不知道自己毕业后能不能找到相关的工作。或者说，一个公司可以没有算法，可以没有数据分析，但一定不能没有开发。</p>
</li>
<li><p>搞科研搞算法的确能在学术圈发一篇论文，但到了工程实际呢？如何落地转换为生产力？提高那么几个百分点在实际生活中到底有没有用？或者，结果是65%，其他论文是66%，把结果改成67%这样也能中论文。学院的AI和实际工程的AI完全是两回事，只是高高在上的科研，但不考虑生产实际，没有搬砖和落地的本事，<strong>这样忽略『计科的基本功』真的好吗？</strong></p>
</li>
<li><p>Ideals are cheap, what valuable is to implement and make it work. 或者说，每个人都有想法，连街上打扫卫生的都会有<strong>创新</strong>的想法，比如造个<strong>智能创新</strong>扫地机器人，工人想造一个<strong>智能创新</strong>干苦力机器人，服务员想做个<strong>智能创新</strong>刷碗机，厨师想造个<strong>智能创新</strong>切菜炒菜机器人。从这一点看，扫大街的和大学里的只会提创新、发论文的老师并无二致，那些老师甚至连写代码、装软件都不会。想法每个人都有，但并不是每个人都有能力去实现它。换个角度思考，论文多到底是因为老师的身份高还是因为老师的实力好。</p>
</li>
</ul>
<p>这个世界需要有人在领域前沿从事科研，但更多的也需要人去搬砖，将科研结果转变为生产力，造福广大群众。至少，看着自己的程序实实在在的跑在系统上并取得效果，比神经网络提高几个百分点在扯一堆智能的词骗外行的项目经费要安心。设计师是少数，但工人居多。对于学生而言，只关心领域前沿还是远远不够的，<strong>还要关心这个时代</strong>，这个时代的需求。不可能一直用爱发电去科研。或者说，以我见过的人和看过的简历而言，一个专业里最厉害的人往往是去实习、去工作的人，技术不太行的人才会去选择保研和考研。</p>
<ul>
<li><p>我的家庭条件并不支持继续读博或深造。同龄人早已结婚生子买车买房，而自己的父母年事已高被公司安排到不太挣钱的岗位或退休，家庭也即将没有经济来源，<strong>而自己在那拿着为很低很低很低甚至还要被克扣的补助苦逼的科研，我不可能用爱发电。其实除了国家补助，别的补助一分都没有。</strong>对我这种普通人来说做论文的收益四舍五入等于没有，毕竟有作者的排名问题，一等奖学金也就学费一半，补助连半个月的饭费都不够甚至没有。</p>
</li>
<li><p>交一次学费，我妈几个月工资没了，现实就是这么残酷且绝望。我也大概理解了，为什么有人放弃了读书放弃了继续求学，是真 TM 的没钱啊。有的时候就在想，如果有两百块钱就好了，就不愁未来一个星期的饭钱了，可惜就是连这两百块钱都没有。世界总是这样，充满了绝望。</p>
</li>
<li><p>自己的年龄和家庭都消耗不起了，家里人退休、生病等等等等，还是需要工资需要钱的，待遇也摆在这，所以我已决定不再继续读书，打工人苦或累，但好在有够吃饭的钱啊。<del>大学那会儿还满脑子想着要科研，要读博，要为科学事业做贡献，可真是年轻没接受过生活的毒打。</del></p>
</li>
<li><p>我可以忍受冷板凳，可我也想每顿饭都有肉，我想买几件合适的衣服，我想回家的时候坐高铁，我也不想为了几块钱去淘宝店铺刷好评，可是是真的没钱啊。我也佷无奈，吃饭的时候都要默默告诉自己，这个我吃不起，去吃旁边那个便宜的吧。</p>
</li>
<li><p>也向生活低头了，开始去做那些曾经自己最厌恶的事，只为了那几百块钱。我不想找家里要八千学费的同时，还接着要每个月的生活费。一个大男人，二十几岁还在找家里要钱去吃饭，我感觉有些许羞愧。我也没钱去继续读书了，研究生毕业后赶紧工作。曾经为了未来努力的时候，我一定没想到居然会沦落到这一步。</p>
</li>
</ul>
<h1 id="我想我告别了学生时代"><a href="#我想我告别了学生时代" class="headerlink" title="我想我告别了学生时代"></a>我想我告别了学生时代</h1><p>上了高中后最让我失望的一件事，就是发现自己不是天才。这是多么遗憾，天才那么多，为什么不能加我一个。我身上没有特殊才能，甚至记忆力也不行，很多东西背好几遍才能记住；理解力也差的很远，别人一遍就能看懂的东西，我需要两遍三遍甚至四遍，甚至写一遍或者敲一遍代码才能入门。别人半小时写完的作业，我甚至要写上一个星期。大二下数据结构期末考完了，我甚至都不知道数据结构的概念和应用场景是什么，直到大三下才稍稍领悟了。</p>
<p>世界上确实有些天才，英雄出少年，雄姿英发。而我只能坐在小房间里面做一些看起来有用但很可能没用的工作，看来『奇迹』是不会发生在我身上的了。我经常犯低级错误，例如花一个下午发现一个极度简单的 bug，或者花一周的时间搞明白一个问题。兴奋过后又沮丧，为什么我花了这么多时间在这些浅显的问题上。如果问我问题，我能答上来，这绝对不是因为天资聪颖或知识渊博，只是因为已经花时间动手实践过了。如果有什么问题还解决不了，那就是实践的太少。所以我也极度不想回答那些简单的问题，明明动手就能解决，为什么非要问呢？</p>
<p>很难讲那是一种怎样的感受、压力、兴奋，如同注射了多年的可卡因无法让人激动起来，麻木了，反而会更疼、更着急。无论多努力都达不到自己想要高度，且不想呆在低层的感觉我很清楚。毕竟我学习很差，也可惜我不是个天才。我走了很长的路才到这里，可我还要和这种感觉走一段很长的路。</p>
<p>自己也不太敢接受太美好的事情。期望越大，失望也就越大。这一路走来，有好多人对我十分友好，给予我帮助和鼓励。可我却无以回报。我只是在逃避那些可能的美好。我终于感受到了毫无方向的迷茫。没有人爱，没有想做的事情，也对未来没有了期待，连幻想都不想去想了。甚至觉得梦想这个词就是笑话，现在做什么事都是说『追求』，绝对不会说梦想，与我而言，梦想这个词只适合中学生。我不知道是为什么，也许是孤单吧，也许是成熟了？也许是年纪渐渐大了追不上青春逝去的脚步。<strong>所以我想，我告别了学生时代。</strong></p>
<p>这只是我刚开学两周的感受，之后可能也会有新的体会。世上只有一种英雄主义，据说是看透事物的本质后能依然热爱。可我肉体凡胎吃五谷杂粮长大，只是一个凡人，并不是英雄。什么时候我才能被岁月温柔以待呢？</p>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是 bert</title>
    <url>/2022/03/28/bert/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>书接上文，因为参加 NLP 的比赛不知道什么是 bert 实在有点说不过去，于是花了三天时间看了下 bert 的基本概念和代码。不得不说，网上阳间的 bert 预训练代码太少了，大多是转载和 mark 之类没啥用的东西，属实是占据了搜索引擎的首页，占够了热度。</p>
<a id="more"></a>
<h1 id="transformer"><a href="#transformer" class="headerlink" title="transformer"></a>transformer</h1><p>这个就不得不提一下 Attention is all your need. 由于处理序列的时候 RNN 不容易并行计算，输出 $b_4$ 的时候需要输入 $a_1, a_2, a_3, a_4$。所以使用 CNN 来代替 RNN，一个 CNN 按顺序划过序列输入产生一个输出，就不用看完一个句子才会有输出，而多个 CNN 就可以产生多个输出，模型就可以可以并行化。如下图所示，不需要等待红色的输出算完，再算黄色的输出。</p>
<p><img data-src="https://s1.ax1x.com/2022/03/28/qs1mct.jpg" alt></p>
<p>如果考虑让一个 CNN 看到更多的输入，那么只需要在模型的隐层叠加另外的 CNN 即可，也就是上图的蓝色三角。基于这个概念，就有了后面的 self-attention。</p>
<h2 id="self-attention"><a href="#self-attention" class="headerlink" title="self-attention"></a>self-attention</h2><p>$A=Wx, Q=W_qA, K=W_kA, V=W_vA$，这里其实就是乘以一个大矩阵，只不过图里分开写清楚一些。</p>
<p><img data-src="https://s1.ax1x.com/2022/03/28/qs1Y3n.png" alt></p>
<p>之后每个 $q$ 和每个 $k$ 做 attention，也就是内积，得到如下的 $\alpha$ 输出，然后再除以维度数，防止维度过高导致的内积过大。</p>
<p><img data-src="https://s1.ax1x.com/2022/03/28/qs1auV.png" alt></p>
<p>然后将 $\alpha$ 经过 softmax 操作得到 $\hat{\alpha}$：</p>
<p><img data-src="https://s1.ax1x.com/2022/03/28/qs1wHU.png" alt></p>
<p>对于 $b_1$ 输出，只需要让 $\hat{\alpha_{1,i}}$ 和所有的 $v_i$ 做乘积并求和即可。同理，可以得到 $b_2,b_3,b_4$ 的输出。</p>
<p><img data-src="https://s1.ax1x.com/2022/03/28/qs1DN4.png" alt></p>
<p>对应的，下图左上角就是我们的 self-attention 层，期中的运算可以总结成矩阵乘法：</p>
<p><img data-src="https://s1.ax1x.com/2022/03/28/qs1r4J.png" alt></p>
<h3 id="multi-head-self-attention"><a href="#multi-head-self-attention" class="headerlink" title="multi-head-self-attention"></a>multi-head-self-attention</h3><p>可以再计算 $Q,K,V$ 的时候产生多个结果，然后在输出 $b$ 的时候再通过一个矩阵将多个结果融合成一个。而我看的程序，就分开注意力，最后 view 到一起。</p>
<p><img data-src="https://s1.ax1x.com/2022/03/28/qs1Ru6.png" alt></p>
<h3 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional Encoding"></a>Positional Encoding</h3><p>现在的 self-attention 没有考虑到序列的位置信息，而是使用全局信息，不能利用单词的顺序信息，而这部分信息对于 NLP 来说非常重要，所以需要加入位置的 embedding。人工设定每一个位置的 embedding，和 $A$ 加在一起作为新的 $A$ 参与后面的运算，等价于在 $X$ 拼接一个 one-hot 向量后再做运算：</p>
<p><img data-src="https://s1.ax1x.com/2022/03/28/qs1fHO.png" alt></p>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>网上最常见的图就是它了，在看完理论后还是由些许的疑惑之处，比如位置编码如何实现，比如注意力机制具体如何执行，只能看代码来解决。</p>
<p><img data-src="https://s1.ax1x.com/2022/03/28/qs178A.png" alt></p>
<h2 id="MultiHeadAttention"><a href="#MultiHeadAttention" class="headerlink" title="MultiHeadAttention"></a>MultiHeadAttention</h2><ol>
<li>在这个类的初始化阶段，首先初始化 $W_Q,W_K,W_V$ 三个全连接层，输入维度和输出维度保持一致。假设输入维度是 512，有 8 个头；</li>
<li>计算 $Q,K,V$，大小是 <code>B, L, 8, 64</code>，毕竟有 8 个头。在 softmax 之后经过 0.1 的 dropout，最后在把这 8 个头 view 到一起，加上最开始的 $Q$</li>
</ol>
<h2 id="FeedForwardNetwork"><a href="#FeedForwardNetwork" class="headerlink" title="FeedForwardNetwork"></a>FeedForwardNetwork</h2><ol>
<li>经过全连接降维，而后 relu 激活并 dropout</li>
<li>在经过一个全连接，升到之前的维度，加上最开始的输入做一个残差，layer norm 后输出</li>
</ol>
<h2 id="PositionalEncoding"><a href="#PositionalEncoding" class="headerlink" title="PositionalEncoding"></a>PositionalEncoding</h2><p>这个就是生成一个 $200\times dim$ 的表，每次输入一个 $x$，查看 $x$ 的维度，从表中取到对应维度的数值，和 $A$ 直接相加。这个表采用的是 sin-cos 规则，使用了 sin 和 cos 函数的线性变换来提供给模型位置信息。</p>
<p><img data-src="https://s1.ax1x.com/2022/03/28/qs1HgI.png" alt></p>
<p>如上图所示，随着维度越来越大，周期变化会越来越慢，而产生一种包含位置信息的纹理。</p>
<h2 id="Encoder-Layer"><a href="#Encoder-Layer" class="headerlink" title="Encoder Layer"></a>Encoder Layer</h2><ol>
<li>输入 $x$ 经过 layer norm，经过 MultiHeadAttention，经过 dropout 得到 $y$，进行 $x+y$</li>
<li>将 $x+y$ 经过 layer norm，经过 FeedForwardNetwork，经过 dropout 得到 $y’$，最终的输出为 $x+y+y’$</li>
</ol>
<p>通常，这个 Encoder Layer 堆叠 6 次 （因为维度没有发生变化）得到 Encoder。Encoder 的输入是输入序列的 embedding，如果是最开始的输入，需要叠加位置 embedding 后 dropout-&gt;layer norm，在经过堆叠的 Encoder Layer。</p>
<h2 id="Decoder-Layer"><a href="#Decoder-Layer" class="headerlink" title="Decoder Layer"></a>Decoder Layer</h2><p>大部分内容和 Encoder Layer 一样，先将 target 进行 embedding 并叠加位置 embedding，然后 dropout-&gt;layer norm，得到解码输出。拿到 encoder 的输出和解码输出送入 decoder，再依次经过堆叠的 6 个 decoder layer 时（解码输出注意力机制，结果在和encoder 输出进行注意力）得到新的解码输出，上一个解码状态输出下一个状态的解码输入。</p>
<p>在拿到 decoder 的输出后，经过一个全连接层，将 dim 映射到 n_vocab。而 bert 的结构就是 transformer 的多个 Encoder 双向堆叠到一起：</p>
<p><img data-src="https://s1.ax1x.com/2022/03/28/qs1HgI.png" alt></p>
<p>其输入的 embedding 为：</p>
<p><img data-src="https://s1.ax1x.com/2022/03/28/qs1Xb8.jpg" alt></p>
<ul>
<li>Token Embeddings 是词向量，第一个单词是CLS标志，可以用于之后的分类任务，通过 embedding 层实现。如果句子很短，pad 为 0。</li>
<li>Segment Embeddings 用来区别两种句子，因为预训练还要做 NSP 任务，同样是 embedding 层。</li>
<li>Position Embeddings 和之前的 Transformer 不一样，不是三角函数而是学习出来的，非人工设定，而是 embedding 层。</li>
</ul>
<p>将这三者的相加作为输入，经过 layernorm 和 dropout 后输出。大概理论就是这些，不过它的预训练是真的靠谱，或者说，应用到具体任务，可以针对具体任务设计与训练。借着预训练，解释一下上面的符号，也是困扰我很久的东西。</p>
<p>之前一直不知道 CLS 这种东西是干什么的，直到看了代码才清楚，这个符号输入网络，最后一层的输出经过全连接和激活，得到的输出，所以这个符号对应位置的输出能用于下游分类任务。</p>
<p>此外，常用 bert 训练时会传入三个参数，<code>input_ids</code> 表示输入序列的原始 <code>token id</code>，即根据词表映射后的索引，<code>token_type_ids</code> 用于不同序列之间的分割，例如 <code>[0,0,0,0,1,1,1,1]</code> 用于区分前后不同的两个句子，形状为 <code>[src_len,batch_size]</code>。而最重要的 mask 值得细说：</p>
<h1 id="MASK"><a href="#MASK" class="headerlink" title="MASK"></a>MASK</h1><p>bert 有效的原因取决于它的预训练，比如 MLM（Mask language model） 和 NSP （Next sentence prediction），而这其中依赖的主要是 mask。</p>
<h2 id="处理非定长序列"><a href="#处理非定长序列" class="headerlink" title="处理非定长序列"></a>处理非定长序列</h2><p>在NLP中，文本一般是不定长的，所以在进行 batch训练之前，要先进行长度的统一，过长的句子可以通过truncating 截断到固定的长度，过短的句子可以通过 padding 增加到固定的长度，但是 padding 对应的字符只是为了统一长度，并没有实际的价值，因此希望在之后的计算中屏蔽它们，这时候就需要 Mask。此外，self-attention中，$Q$ 和 $K$ 在点积之后，需要先经过 mask 再进行 softmax，因此，对于要屏蔽的部分，mask之后的输出需要为负无穷，这样softmax之后输出才为0。</p>
<h2 id="辅助预训练"><a href="#辅助预训练" class="headerlink" title="辅助预训练"></a>辅助预训练</h2><p>做 MLM 预训练时，需要对句子进行 mask，使得模型看不到输入句子的单词。而后，其 label 为被 mask 掉单词的 id。由于 bert 本身的结构，由于预训练的时候，需要做 NSP 和 MLM，而 NSP 是二分类任务，MLM 是多分类任务，因此需要在 bert 上插入两个头分别实现这两个功能，前者就是将缺失的词汇预测回去，后者加入一个全连接输入 pooler output，判断句子是否为上下文。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/jadore801120/attention-is-all-you-need-pytorch/blob/master/transformer/Models.py" target="_blank" rel="noopener">https://github.com/jadore801120/attention-is-all-you-need-pytorch/blob/master/transformer/Models.py</a></li>
<li><a href="https://qixinbo.info/2021/11/09/transformer/" target="_blank" rel="noopener">https://qixinbo.info/2021/11/09/transformer/</a></li>
<li><a href="https://www.ylkz.life/deeplearning/p10602241/" target="_blank" rel="noopener">https://www.ylkz.life/deeplearning/p10602241/</a></li>
</ol>
]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>从分词到自然语言的世界</title>
    <url>/2019/05/19/basic-nlp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp; 在上个世纪，规则派的思想制约了自然语言处理的发展。比如主语后面是谓语，还有各种时态规则，加上当时并不是很强大的处理器，自然语言处理根本做不起来。在编译原理中，即使只有很少的语法，处理起来也很困难，更别说要规则话自然语言的语法了。那么统计派的学者登上历史舞台，解决了这个问题，甚至可以说是开创了现代人工智能世界的大门。</p>
<p>&emsp;&emsp;起初并不对NLP的东西感兴趣，但是还是回归思想。数学和计算机的应用层出不穷，但背后的数学思维值得学习和借鉴。本文收录：</p>
<ul>
<li>简单分词（基于维特比算法）</li>
<li>统计语言模型</li>
<li>词嵌入模型：负采样、Word2Vec，Skip Gram等</li>
</ul>
<p>&emsp;&emsp;其实我总在思考，感觉编译原理中对句法成分分析的东西也不是不能用到NLP中，不过最近事太多了，有时间再去研究吧。应该有前人的研究成果的，到时候读论文先。</p>
<a id="more"></a>
<h1 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h1><p>&emsp;&emsp; 首先，对于一个句子：“燕山大学生”，是分为燕山大学-生呢还是燕山-大学生呢？显然有二义性。二义性的句子还是靠后来的统计模型加以解决。（猜想：是不是现实世界过于灵活的东西都不能加太多的限制规则）。假设有两种分词方法，第一种是$A$，第二种是其他的分词方法$B$。对于两种分词方式，计算其产生句子的概率：$P(A)&gt;P(B)$，那么就认为$A$的分词方法是最好的。</p>
<p>&emsp;&emsp;如何计算出来生成句子的概率来比较大小呢？当然是统计模型和维特比算法。</p>
<h2 id="统计语言模型"><a href="#统计语言模型" class="headerlink" title="统计语言模型"></a>统计语言模型</h2><p>&emsp;&emsp; 借助马尔可夫性（一个假设，此时刻状态只与上一时刻状态相关，即今天的天气只与昨天的天气有关）。假设一个词$w_i$出现的概率只与前一个词$w_{i-1}$相关。那么一个句子$S$出现的概率就是$P(S)=P(w_1)\cdot P(w_2|w_1)\cdot P(w_3|w_2)\cdots P(w_n|w_{n-1})$。现在来看这个联合概率分布$P(w_n|w_{n-1})$和边缘概率分布$P(w_n)$呢？开始统计。当数据量足够大的时候，我们可以认为出现的频率就是事件发生的概率。$P(w_i)$就是$w_i$这个词出现的频率，$P(w_n|w_{n-1})$就是这两个词一起出现的频率。既然得到了词出现的概率，在计算句子出现的概率就不难了。之后就能轻易的确定出最好的分词方法。</p>
<h2 id="维特比算法"><a href="#维特比算法" class="headerlink" title="维特比算法"></a>维特比算法</h2><p>&emsp; &emsp;但是，不能穷举所有分词情况下每个句子出现的概率，过于复杂。比如一次分词就判断一下，一次分词就判断一下还是很复杂的。这个时候就有维特比算法了，算法的核心思想是动态规划，不过这个算法最初是用来解决通信领域的问题，现在被用在了求最短路径、导航等领域。</p>
<p>&emsp; &emsp; 算法的核心思想：可能会有多种分词，每次分词导致的结果还不同，就会得到下图的一个网络。每个分词的区域都是一个网络的岔路口。</p>
<p><img data-src="/2019/05/19/basic-nlp/1.png" alt></p>
<p>首先：如果从S到O的最短路径经过了A，那么S到A的路径也一定是最短的。否则可以选出另外一条最短路径代替SA。</p>
<p>其次：好了没其次了。看算法吧。</p>
<p>&emsp;&emsp;起点设为$S$，第一个状态有三个节点，对应三种分词情况。计算$S$到它们的距离$d(S,w_{1n})$，对于第二个状态的节点$w_2$，从$S$到状态2的路径必经过状态1，对应的路径长度是$d(S,w_2)=d(S,w_1)+d(w_1,w_2)$，然后一个暴力破解找个最小值，就是必须经过的状态1的节点。之后同理，到状态3的时候就能确定出经过哪一个状态2的节点。循环往复，就能求出起点到重点的最短路径，也确定了最好的分词方案。</p>
<p>&emsp;&emsp;时间复杂度分析：节点最多有$D$个状态，句子的长度是$N$，那么时间复杂度是$O(N^2\cdot D)$。也就是对于一个很复杂的句子，当每一步分词有10种情况，句子长度为10，1000次计算对CPU而言是小儿科，无论句子多复杂，分词永远都是瞬时的。</p>
<p>&emsp;&emsp;对了，这个算法也用在了输入法上，就是一边打字一边出结果的那种。输入拼音 “nihao”，输入法提示的内容是“你好”，拼音”ni”有好多字，拼音”hao”也对应好多字。只需要选择一种最为可能的方案即可，而这个方案也不是遍历所有的”ni”， “hao”情况输出的，而是用了动态规划的思想降低了时间复杂度。这也是一个典型的维特比算法的应用。</p>
<p><img data-src="/2019/05/19/basic-nlp/2.jpg" alt></p>
<h1 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h1><h2 id="词嵌入模型"><a href="#词嵌入模型" class="headerlink" title="词嵌入模型"></a>词嵌入模型</h2><p>&emsp;&emsp;有了前文的基础后，有循环神经网络的基础就更好了，开始更深入的自然语言处理。</p>
<p>&emsp;&emsp;在之前提到的循环神经网络解决翻译、推测的博客中，都是使用的one-hot作为输入。当然结果也是能看的，那么对于一个输入：apple candy，现在把apple换成orange，那么是不是还能推理出candy呢？基本不能，为啥呢，因为apple和orange的one-hot的距离相差太大，神经网络可能学习不到这么大跨度的距离。</p>
<p>&emsp;&emsp;这时候如果有个表就好了，在这个表里面每个单词都有自己的300维特征向量。apple有自己的特征向量，orange有自己的特征向量。这两个特征向量距离很近，但是与Iron这个词的特征向量又很远。总之是现实中相似物体词汇的特征向量接近，八杆子打不着的物体词汇的特征向量距离就远。那么就能很轻易的从apple candy推导出orange candy。那么这个表就叫做词嵌入（embedded）表，如何求这个词潜入表呢？目前有多种方案。</p>
<p>&emsp;&emsp;为什么叫词嵌入呢，因为词嵌入表的作用就是把这个词赋予了一个多维的向量，比如300维，那么这个词就嵌入在一个300维的空间里。</p>
<h2 id="传统方案"><a href="#传统方案" class="headerlink" title="传统方案"></a>传统方案</h2><p>&emsp;&emsp;首先，记词嵌入表为$E$，假设有1000个词和想生成300维特征，先随机生成$E$，维度是$300\times 1000$。则对于一个one-hot编码，$E\cdot O=e$，即嵌入表乘以一个词的one-hot得到这个词的特征向量，而所有词的特征向量组成嵌入词表。此时一个只能推断的任务：I want a glass orange <u>candy</u>，candy是需要推断的内容。</p>
<p>&emsp;&emsp;那么我们先把 I， want， a， glass， orange的$e$给求出来（glass 的 $e$ 求法为：$E\cdot O_{\mathrm{glass}}$，$O_{glass}$是glass的one-hot编码）。把5个$e$扔给一个softmax单元，希望的输出为juice。反向传播，训练这个网络直到误差逐渐的减小，最后得到想要的$E$。</p>
<p>&emsp;&emsp;这个时候把orange换成apple，因为apple和orange的$e$很接近，很容易从orange candy 推导出 apple candy了。</p>
<h2 id="Skip-Gram"><a href="#Skip-Gram" class="headerlink" title="Skip Gram"></a>Skip Gram</h2><p>&emsp;&emsp; 给定一个句子：”<em>Black Widow</em> is a playable character in Lego Marvel’s Avengers, voiced by Scarlett Johansson.”从中选择一个单词作为上下文context，在正负五个单词内选择target， 建立一个监督学习的模型，建立从context到target的映射，这个网络的规模就会比上一个算法的规模小一点。</p>
<script type="math/tex; mode=display">O\rightarrow E\rightarrow e\rightarrow \mathrm{softmax}\rightarrow \hat{y}</script><p>&emsp;&emsp;交叉熵计算误差时还是使用的one-hot编码。</p>
<p>&emsp;&emsp;这里的softmax是有参数的：</p>
<script type="math/tex; mode=display">P(t|c)=\frac{e^{\theta_t e_c}}{\sum_{i=1}^{1000}e^{\theta_i^te_c}}</script><h2 id="负采样"><a href="#负采样" class="headerlink" title="负采样"></a>负采样</h2><p>&emsp;&emsp; 和Skip Gram算法类似，先来一个句子：”<em>Avengers Assemble</em> is an American animated television series based on the fictional Marvel Comics superhero team known as the Avengers”。</p>
<p>&emsp;&emsp;随机选择一个词汇，比如avengers， 在选择它的下一个词汇Assemble，这个映射关系就是正样本。在随机从牛津字典里面选取五个单词，比如“organized”,“cup”作为负样本。继续一个神经网络的拟合：$P(y=1|c,t)$。</p>
<script type="math/tex; mode=display">O\rightarrow E\rightarrow e\rightarrow \mathrm{softmax}\rightarrow \hat{y}</script><p>在$\hat{y}$的过程中，输出维度取决于单词的数量，如果有1000个单词，那么我们之训练6个节点，1个是正样本的，另外5个是选择的负样本的。一波训练之后求出$E$。</p>
<h1 id="情感分类"><a href="#情感分类" class="headerlink" title="情感分类"></a>情感分类</h1><p>&emsp;&emsp;以现在常见的影评为例：“这是哪个智障导演拍出来的无剧情无主线，无病呻吟的破电影”，让后评分是一个星。对于此类的数据，我们可以用每个词汇的$e$，作为循环神经网络的输入，规定这个网络的输出是星的数量。在大量的数据训练下，我们会得到对于一个评论进行分级，进而确定大家对这个电影的评论好坏。</p>
<p>&emsp;&emsp;只要还有类似的评论，就很快的能从评分数量的角度来数字量化好坏程度。</p>
<h1 id="类比推理"><a href="#类比推理" class="headerlink" title="类比推理"></a>类比推理</h1><p>&emsp;&emsp;继续，man相对与doctor， 等于woman相当于什么。我们只需要在选择一个向量$e_x$，使下式成立：</p>
<script type="math/tex; mode=display">e_{man}-e_{doctor}=e_{woman}-e_x</script><p>&emsp;&emsp;然后把这个$x$向量求出来即可。但是，为了消除性别歧视，doctor相对于man，那么woman的结果也应该是doctor。所以在训练结束后，形如性别类、种族类的词汇还需要进一步处理。比如对于性别而言，需要消除在性别方向上的差异。</p>
<p>&emsp;&emsp;形如，我们知道了男人的特征向量$e_{man}$和女人的特征向量$e_{woman}$，将这两个向量相减，可以认为差异最大的那一维有性别的成分。然后平均一下那个温度上的差异就可以啦。</p>
<p><img data-src="/2019/05/19/basic-nlp/3.jpg" alt></p>
<hr>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>二分搜索的亿点点细节</title>
    <url>/2021/06/18/binary-search/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不能继续开坑了，得整理一下。最近在刷二分法，思路很简单，细节是魔鬼。时而减一时而不用，仿佛在面向玄学编程，所以特意来整理一下。<a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.md" target="_blank" rel="noopener">本文参考</a>。</p>
<a id="more"></a>
<p>对于最常见的二分查找框架：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析二分查找的一个技巧是：不要出现 <code>else</code>，而是把所有情况用 <code>else if</code> 写清楚，这样可以清楚地展现所有细节。本文都会使用 <code>else if</code>，旨在讲清楚，读者理解后可自行简化。</p>
<ol>
<li>其中 <code>...</code> 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</li>
<li>另外声明一下，计算 <code>mid</code> 时需要防止溢出，代码中 <code>left + (right - left) / 2</code> 就和 <code>(left + right) / 2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> <strong>太大直接相加导致溢出。</strong></li>
</ol>
<h1 id="查找一个数"><a href="#查找一个数" class="headerlink" title="查找一个数"></a>查找一个数</h1><p>这个场景是最简单的，在一个数组中搜索一个数，如果存在，返回其索引，否则返回 -1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6  7  8  9  10</span></span><br><span class="line">    <span class="comment">// 1 3 5 5 8 9 12 23 34 56 84</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">56</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">84</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">23</span>;</span><br><span class="line">    <span class="comment">// 有序是使用二分的前提</span></span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">int</span> a = binarySearch(v, target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>为什么 <code>while</code> 循环的条件中是 &lt;=，而不是 &lt;？因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，而不是 <code>nums.length</code>。这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>。我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间，<strong>这个区间其实就是每次进行搜索的区间。</strong></li>
<li>那 <code>while</code> 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。<code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见这时候区间为空，因为没有数字既大于等于 3 又小于等于 2 。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</li>
<li>为什么 <code>left = mid + 1</code>，<code>right = mid - 1</code>？我看有的代码是 <code>right = mid</code> 或者 <code>left = mid</code>，或者时而减时而不减，到底怎么回事，怎么判断？答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[left, right]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，下一步应该去搜索哪里呢？之前提到搜索区间是闭区间，所以当然是去搜索 <code>[left, mid-1]</code> 或者 <code>[mid+1, right]</code> ，因为 mid 已经搜索过，应该从搜索区间中去除。之后还有有这方面的细节。</li>
<li>扩展一些，如果不返回 -1 而是直接返回 <code>left</code>。如果数字在数组中，返回的就是索引；如果不在数组中且以升序为例，返回的就是这个元素插入数组中应该放到哪个位置。</li>
<li>而对于 <code>while(left &lt; right)</code> 这种情况，也就是搜索区间是 <code>[left, right)</code>，那么终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[right, right]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，这时候区间非空，还有一个数 2，但此时 <code>while</code> 循环终止了。也就是说这区间 <code>[2, 2]</code> 的第一个 2 被漏掉了，索引 <code>2</code> 没有被搜索，如果这时候直接返回 -1 就是错误的。我们已经知道了出错的原因，就打个补丁好了：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left &lt; right ? left : <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="搜索左侧边界"><a href="#搜索左侧边界" class="headerlink" title="搜索左侧边界"></a>搜索左侧边界</h1><p>给定一个数组，<code>1 2 2 2 3</code>，搜索数字 2 最开始出现的左侧区间，这里就返回索引 1。代码如下，这里写成左闭右开的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.size(); <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == nums.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6  7  8  9  10</span></span><br><span class="line">    <span class="comment">// 1 3 5 5 8 9 12 23 34 56 84</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">56</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">84</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">1000</span>;</span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">int</span> a = binarySearch(v, target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>为什么 <code>while</code> 中是 &lt; 而不是 &lt;=? 用相同的方法分析，因为 <code>right = nums.length</code> 而不是 <code>nums.length - 1</code>。因此每次循环的「搜索区间」是 <code>[left, right)</code> 左闭右开。<code>while(left &lt; right)</code> 终止的条件是 <code>left == right</code>，此时搜索区间 <code>[left, left)</code> 为空，所以可以正确终止。</li>
<li>如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办？对于一个数组 <code>1 2 2 2 3</code>，<code>target</code> 为 2 返回 1，含义是：<code>nums</code> 中小于 2 的元素有 1 个；<code>target = 1</code>，算法会返回 0，<code>nums</code> 中小于 1 的元素有 0 个；<code>target = 8</code>，算法会返回 4，<code>nums</code> 中小于 8 的元素有 4 个。综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 <code>[0, nums.length]</code>，所以我们简单添加两行代码就能在正确的时候 <code>return -1</code>。</li>
<li>为什么 <code>left = mid + 1，right = mid</code> 和之前的算法不一样？因为我们的「搜索区间」是 <code>[left, right)</code> 左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉 <code>mid</code> 分割成两个区间，即 <code>[left, mid)</code> 或 <code>[mid + 1, right)</code>。</li>
<li>为什么返回 <code>left</code> 而不是 <code>right</code>？都是一样的，因为 <code>while</code> 终止的条件是 <code>left == right</code>。</li>
<li>能不能想办法把 <code>right</code> 变成 <code>nums.length - 1</code>，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了。由于 <code>while</code> 的退出条件是 <code>left == right + 1</code>，所以当 <code>target</code> 比 <code>nums</code> 中所有元素都大时，会存在以下情况使得索引越界。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == nums.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6  7  8  9  10</span></span><br><span class="line">    <span class="comment">// 1 3 5 5 8 9 12 23 34 56 84</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">56</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">84</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">1000</span>;</span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">int</span> a = binarySearch(v, target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="寻找右侧边界"><a href="#寻找右侧边界" class="headerlink" title="寻找右侧边界"></a>寻找右侧边界</h1><p>给定一个数组，<code>1 2 2 2 3</code>，搜索数字 2 最开始出现的最右侧区间，这里就返回索引 3。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left<span class="number">-1</span>] == target ? (left<span class="number">-1</span>) : <span class="number">-1</span>; <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>搜索区间」是 <code>[left, right)</code> 左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉 <code>mid</code> 分割成两个区间，即 <code>[left, mid)</code> 或 <code>[mid + 1, right)</code>。</li>
<li>为什么最后返回 <code>left - 1</code> 而不像左侧边界的函数，返回 <code>left</code> ？而且我觉得这里既然是搜索右侧边界，应该返回 <code>right</code> 才对。首先，<code>while</code> 循环的终止条件是 <code>left == right</code>，所以 <code>left</code> 和 <code>right</code> 是一样的，你非要体现右侧的特点，返回 <code>right - 1</code> 好了。</li>
<li>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在<strong>等式条件</strong> <code>nums[mid] == target</code> 下的判断：<code>left = mid + 1</code>，因为最后一定是找到了和 <code>target</code> 相等的数字，且是最右侧的。对 <code>left</code> 的更新是 <code>left = mid + 1</code>，就是说 <code>while</code> 循环结束时，<code>nums[left]</code> 一定不等于 <code>target</code> 了，而 <code>nums[left-1]</code> 可能是 <code>target</code>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.size(); <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left - <span class="number">1</span>] == target ? left - <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6  7  8  9  10</span></span><br><span class="line">    <span class="comment">// 1 3 5 5 8 9 12 23 34 56 84</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">56</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">84</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">34</span>;</span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">int</span> a = binarySearch(v, target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="STL-开车"><a href="#STL-开车" class="headerlink" title="STL 开车"></a>STL 开车</h1><p>对于一些高级语言而言，其实都内置了二分搜索。以 <code>C++</code> 为例，搜索数组 <code>1 2 2 2 3</code> 中有几个 2。第一种方案是搜索 2 出现的左边界，而后搜索出现的右边界。但是也可以通过 <code>lower_bound</code> 和 <code>upper_bound</code> 来解决，因为在某些复杂应用下，二分只是一个小点，没必要花费大多精力在不重要的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator lower, upper;</span><br><span class="line"></span><br><span class="line">    lower = lower_bound(v.begin(), v.end(), target);</span><br><span class="line">    upper = upper_bound(v.begin(), v.end(), target);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(upper - lower) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2020/09/01/binary-indexed-tree/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>9 月了，虽然开学前还是充满了焦虑和担忧，越来越能胡思乱想，愈发的抑郁。但想想这么持续下去也不是办法，想来想去还是找点事干吧。先充实好自己，总不能说以后机会来临，自己还没准备好。想想我目前也只能干这些了。</p>
<p>之前刷算法题的时候遇到了『树状数组』这种结构，网上大多教程实在是不够通俗，不适合新手（<del>但新手并不是自己不会和看不懂的理由</del>）。遂仔细研究了一番，有了理解的同时也争取写一份通俗易懂的博客。</p>
<a id="more"></a>
<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>给定一个数组，和一堆索引<code>[a, b]</code>，求出数组中 <code>a</code> 到 <code>b</code> 区间内的元素和。正常情况下，遍历一次数组并求和的复杂度是 $O(n)$。</p>
<ul>
<li>在频繁的对区间元素求和的问题中，这样的效率会很低（比如这样的索引对有一万组）；</li>
<li>如果数组内元素也要频繁更新，那么要重新遍历求和。</li>
</ul>
<p>这种情况下，虽然代码容易编写，但时间复杂度实在太高，这时就引出了树状数组。如果你不能理解问题背景，那么来看一道题。</p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地，Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚，每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手，但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术，所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人，例如Derek问:“Tidy，马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救，Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.</p>
</blockquote>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行一个整数$T$，表示有$T$组数据。<br>每组数据第一行一个正整数$N(N&lt;=50000)$，表示敌人有$N$个工兵营地，接下来有$N$个正整数，第$i$个正整数$A_i$代表第$i$个工兵营地里开始时有$A_i$个人$(1&lt;=A_i&lt;=50)$。<br>接下来每行有一条命令，命令有4种形式：</p>
<ol>
<li><code>Add i j</code>，$i$和$j$为正整数，表示第$i$个营地增加$j$个，$j$不超过30；</li>
<li><code>Sub i j</code>，$i$和$j$为正整数，表示第$i$个营地减少$j$个人，$j$不超过30；</li>
<li><code>Query i j</code>，$i$和$j$为正整数，$i&lt;=j$，表示询问第$i$到第$j$个营地的总人数；</li>
<li><code>End</code> 表示结束，这条命令在每组数据最后出现。</li>
</ol>
<p>每组数据最多有40000条命令。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><ol>
<li>对第$i$组数据,首先输出“Case i:”和回车；</li>
<li>对于每个Query询问，输出一个整数并回车，表示询问的段中的总人数，这个数保持在int以内。</li>
</ol>
<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p><img data-src="/2020/09/01/binary-indexed-tree/1.png" alt="树状数组"></p>
<p>树状数组就长上面那个样子，数组 <code>C</code> 就是树状数组，<code>A</code> 是原数组。这里需要注意的是：</p>
<ol>
<li>传统的树都有左孩子右孩子，树状数组是没有这些的，只是这个数组的形状像一个树；所以这样的树就不必创建成结点、指针那样的动态树形结构；</li>
<li>求<code>[1, 4]</code>的和，不用求<code>A[1] + A[2] + A[3] + A[4]</code>，直接输出 <code>C[4]</code> 即可；</li>
<li>$i$ 表示数组 <code>C</code> 的索引，十进制；</li>
<li>$j$ 表示数组 <code>A</code> 的索引，十进制。</li>
</ol>
<h2 id="数组C与数组A的关系"><a href="#数组C与数组A的关系" class="headerlink" title="数组C与数组A的关系"></a>数组C与数组A的关系</h2><p>根据上文，我们很容易知道数组 <code>C</code> 是一个对原始数组 <code>A</code> 的预处理数组。观察上图，我们很容易得到下面的表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数组 C 索引</th>
<th>数组 C 与数组 A 的关系</th>
<th>数组 C 元素来自数组 A 元素的个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>C[1]</td>
<td>C[1]=A[1]</td>
<td>1</td>
</tr>
<tr>
<td>C[2]</td>
<td>C[1]=A[1]+A[2]</td>
<td>2</td>
</tr>
<tr>
<td>C[3]</td>
<td>C[1]=A[3]</td>
<td>1</td>
</tr>
<tr>
<td>C[4]</td>
<td>C[1]=A[1]+A[2]+A[3]+A[4]</td>
<td>4</td>
</tr>
<tr>
<td>C[5]</td>
<td>C[1]=A[5]</td>
<td>1</td>
</tr>
<tr>
<td>C[6]</td>
<td>C[1]=A[5]+A[6]</td>
<td>2</td>
</tr>
<tr>
<td>C[7]</td>
<td>C[1]=A[7]</td>
<td>1</td>
</tr>
<tr>
<td>C[8]</td>
<td>C[1]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p>其中：『数组 <code>C</code> 中的元素来自数组 <code>A</code> 的元素个数』，它们的规律如下：将数组 <code>C</code> 的索引 i 表示成二进制。从<strong>右向左</strong>数，遇到 1 则停止，数出 0 的个数记为 $k$，则计算 $2^k$ 就是『数组 <code>C</code> 中的元素来自数组 <code>A</code> 的个数』。下面举例说明：</p>
<ul>
<li><p>当 $i=5$ 时，因为 5 的二进制表示是 0000 0101，从右边向左边数，第 1 个是 1 ，因此 0 的个数是 0，此时 $k=0,2^k=1$，所以 <code>C[5]</code> 只有一个元素 <code>A[5]</code>；</p>
</li>
<li><p>当 $i=8$ 时，因为 8 的二进制表示是 0000 1000，从右边向左边数遇到 1 之前，遇到了 3 个 0，此时 $k=3,2^k=8$，所以 <code>C[5]</code> 由 8 个元素组成。</p>
</li>
</ul>
<p>那么，$2^k$是我们想要的，如何计算呢？这是有公式的：</p>
<p>\begin{equation}<br>\text{lowbit}(i)=2^k，\text{lowbit}(i) = i \&amp; (-i)<br>\end{equation}</p>
<h2 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h2><p><img data-src="/2020/09/01/binary-indexed-tree/2.png" alt="树状数组"></p>
<p>我们在数组 <code>C</code> 每个元素的右下角标注这个元素代表了几个数组 <code>A</code> 中的元素（就是绿色圆圈内的数字）。假设此时我们修改 <code>A[1]</code>，来分析对数组 <code>C</code> 的影响，显而易见，<code>C[1], C[2], C[4], C[8]</code> 的值都要发生改变：</p>
<ul>
<li>对于 <code>C[1]</code>，$\text{lowbit}(1)=1, 1+\text{lowbit}(1)=2$，得到 <code>C[1]</code> 的父节点索引值 2；</li>
<li>对于 <code>C[2]</code>，$\text{lowbit}(2)=2, 2+\text{lowbit}(2)=4$，得到 <code>C[2]</code> 的父节点索引值 4；</li>
<li>对于 <code>C[4]</code>，$\text{lowbit}(4)=4, 4+\text{lowbit}(4)=8$，得到 <code>C[4]</code> 的父节点索引值 8；</li>
</ul>
<p>1 即 0001，从右向左，遇到 0 放过，遇到 1 为止，给这个数位加 1。这个操作就相当于加上了一个 $2^k$ 的二进制数，即一个 $\text{lowbit}$ 值，马上就发生了进位。得到 0010 ，即 2 的二进制表示。</p>
<p>接下来处理 0010。同样地，这个操作就相当于加上了一个 $2^k$ 的二进制数，即一个 $\text{lowbit}$ 值，马上就发发生了进位，得到 0100，即 4 的二进制表示。</p>
<p>然后一直循环下去直到超出数组界限前停止……</p>
<p>由此我们可以总结出规律（并不是规律，而是计算方式导致的）：从已知子结点的索引 $i$ ，则结点 $i$ 的父结点的索引 $\text{parent}$ 的计算公式为：</p>
<p>\begin{equation}<br>\text{parent}(i)=i+\text{lowbit}(i)<br>\end{equation}</p>
<p>分析到这里<strong>单点更新</strong>的伪代码就可以马上写出来了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// len 为数组长度</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= len) &#123;</span><br><span class="line">        tree[i] += delta;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间求和"><a href="#区间求和" class="headerlink" title="区间求和"></a>区间求和</h2><p>和单点更新的过程相反，单点更新是通过自己节点索引找出父节点；求和是根据自己节点索引找出子节点，自己和子节点的值相加，就是结果。（理解单点更新就很容易理解区间求和了）</p>
<ul>
<li>求前四项的和：$\text{lowbit}(4)=4, 4-\text{lowbit}(4)=0$，结果是 <code>C[4]</code> 与前0项的和，（<code>C[0]</code> 默认为 0）；</li>
<li>求前五项的和：$\text{lowbit}(5)=1, 5-\text{lowbit}(5)=4$，结果是 <code>C[5]</code> 与前4项的和；</li>
<li>求前六项的和：$\text{lowbit}(6)=2, 6-\text{lowbit}(6)=4$，结果是 <code>C[6]</code> 与前4项的和；</li>
<li>求前七项的和：$\text{lowbit}(7)=1, 7-\text{lowbit}(7)=6$，结果是 <code>C[7]</code> 与前6项的和；</li>
<li>求前一项的和：$\text{lowbit}(1)=1, 1-\text{lowbit}(1)=0$，结果是 <code>C[1]</code> 与前0项的和。</li>
</ul>
<p>经过以上分析，也可以很快写出求区间和的伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从右到左查询</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += tree[i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给出文章开头那道题的 AC 代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; (-x))</span></span><br><span class="line"><span class="keyword">int</span> tree[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pos = i; pos &lt; MAXN; pos += lowbit(pos))</span><br><span class="line">        tree[pos] += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pos = n; pos; pos -= lowbit(pos))</span><br><span class="line">        ans += tree[pos];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cases;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cases);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = <span class="number">1</span>; I &lt;= cases; ++I)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="keyword">sizeof</span>(tree));</span><br><span class="line">        <span class="keyword">int</span> n, x, a, b;</span><br><span class="line">        <span class="keyword">char</span> opr[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, I);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            update(i, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, opr), opr[<span class="number">0</span>] != <span class="string">'E'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (opr[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">                update(a, b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">                update(a, -b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Q'</span>:</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  query(b) - query(a - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>来看一道实际的题目。来看一下另外的问题背景下如何使用树状数组，源自<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805417945710592" target="_blank" rel="noopener">PAT甲级1057</a>。（如果上文的例子都没有看懂，那么也没必要看这个了，这个更难），先来看题：</p>
<p>Stack is one of the most fundamental data structures, which is based on the principle of Last In First Out (LIFO). The basic operations include Push (inserting an element onto the top position) and Pop (deleting the top element). Now you are supposed to implement a stack with an extra operation: PeekMedian — return the median value of all the elements in the stack. With $N$ elements, the median value is defined to be the $(N/2)$-th smallest element if $N$ is even, or $((N+1)/2)$-th if $N$ is odd.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer $N(≤10^5)$. Then $N$ lines follow, each contains a command in one of the following 3 formats:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Push key</span><br><span class="line">Pop</span><br><span class="line">PeekMedian</span><br></pre></td></tr></table></figure>
<p>where key is a positive integer no more than $10^5$. For each Push command, insert key into the stack and output nothing. For each Pop or PeekMedian command, print in a line the corresponding returned value. If the command is invalid, print Invalid instead.</p>
<p>Sample Input:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">17</span><br><span class="line">Pop</span><br><span class="line">PeekMedian</span><br><span class="line">Push 3</span><br><span class="line">PeekMedian</span><br><span class="line">Push 2</span><br><span class="line">PeekMedian</span><br><span class="line">Push 1</span><br><span class="line">PeekMedian</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 4</span><br><span class="line">PeekMedian</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure></p>
<p>Sample Output:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Invalid</span><br><span class="line">Invalid</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">Invalid</span><br></pre></td></tr></table></figure>
<h2 id="常见思路"><a href="#常见思路" class="headerlink" title="常见思路"></a>常见思路</h2><p>题目很简单，最简单的想法是：创建数组，压栈弹栈，并排序求出中位数，但显而易见的是，用常见的方法去操作绝对超时（别试了，我试过了）。</p>
<p><img data-src="/2020/09/01/binary-indexed-tree/te.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'o'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Invalid"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; v.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                v.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'u'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">            v.push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'e'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Invalid"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m.<span class="built_in">clear</span>();</span><br><span class="line">                m.assign(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">                sort(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">if</span> (v.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; m[v.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; m[(v.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用树状数组"><a href="#使用树状数组" class="headerlink" title="使用树状数组"></a>使用树状数组</h2><p>先理顺下思路，要知道这道题最难的不是压栈和弹栈，而是求出栈内元素的中位数。我们知道了题目的最大长度，那么用 0 初始化对应长度的数组 <code>C</code> 。（注意：数组初始化时不能用变量而应该用常量），初始化代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br></pre></td></tr></table></figure>
<p>换种角度思考，如果压栈3，那么我们更新 <code>C[3]</code> 及以后的元素，让他们加1；如果压栈6，那么更新 <code>C[6]</code> 及以后的元素，那么最后一个元素 <code>C[maxn-1]</code> 表示栈内元素有几个。单点更新代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; maxn; i += lowbit(i))</span><br><span class="line">        c[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x 表示入栈的元素</span></span><br><span class="line">update(x, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>而在求栈内元素中位数时，借助树状数组可以避免排序。可以思考下，按 <code>4, 2, 1, 6, 8</code> 顺序和按 <code>[8, 1, 4, 6, 2]</code> 顺序压入得到的数组 <code>C</code> 是一样的，和 <code>[1, 2, 4, 6, 8]</code>顺序压入得到的 <code>C</code> 也是一样的。那么无论压栈的顺序是如何的，我们都可以认为这种逻辑结构下，元素是顺序压入的。</p>
<p>剩下的就好办了，比如一直到$x$的前缀和就表示：从0一直到$x$，有几个元素。那么简单二分法写一下，临界值是到$\text{mid}$的前缀和与中位数相等，那么输出即可。其实这个问题可以转化为：在数据更新较为频繁、且不能直接排序的情况下，求出一组无序序列的中位数。完整代码如下，<code>left</code>也一定是压入栈内的元素。可以理解为，在顺序序列中，刚好在 <code>left</code> 那使得栈内元素对半分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(i) ((i) &amp; (-i))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; maxn; i += lowbit(i))</span><br><span class="line">        c[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &gt;= <span class="number">1</span>; i -= lowbit(i))</span><br><span class="line">        sum += c[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PeekMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = maxn, mid, k = (s.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(getsum(mid) &gt;= k)</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">1</span>] == <span class="string">'u'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">            s.push(temp);</span><br><span class="line">            update(temp, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">1</span>] == <span class="string">'o'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty()) &#123;</span><br><span class="line">                update(s.top(), <span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Invalid\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())</span><br><span class="line">                PeekMedian();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Invalid\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>树状数组就写完了，也不知道自己讲清楚了没有，哪里写的不好可以留言，我在整改。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>题目出处：<a href="https://zhuanlan.zhihu.com/p/93795692" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/93795692</a></li>
<li>思想参考（自己做了整改和计算，没有照抄，原文写的也挺不错的）：<br><a href="https://www.acwing.com/blog/content/80/" target="_blank" rel="noopener">https://www.acwing.com/blog/content/80/</a></li>
</ol>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>博客两年了</title>
    <url>/2020/10/13/blog-two-years/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>湿云如梦雨如尘。之前都没注意到博客建立已经两周年了，当时建立博客也就是想着玩一玩，没想到一路坚持下来了，也越玩越深，这之间也认识了很多很厉害的朋友。折腾过很多主题和样式，以至于我都稍微懂点前端设计了。</p>
<a id="more"></a>
<p>立一个 flag ，到博客周年纪念日的时候，写下近期感受，用于日后看看。</p>
<h1 id="补上去年的"><a href="#补上去年的" class="headerlink" title="补上去年的"></a>补上去年的</h1><p>去年这个时候我在写代码，学 Python 的 GUI 设计，给学校写软件。然后约了朋友去了海边，感觉未来可期。<del>我当初就该跟她一起去北京师范</del>。</p>
<h1 id="今年"><a href="#今年" class="headerlink" title="今年"></a>今年</h1><p>雨落长安，雨淅淅沥沥的下了一个月了，没怎么见到太阳，到处都阴沉沉灰蒙蒙的，感觉环境污染好严重。一如消沉的心情，读研体验感并不是很好，集中在生活和补助两个方面吧，我还没有调整好状态。甚至都不敢去打扰自己喜欢的女孩，她知道我喜欢她，关系也还好。但我自己状态不好，说出来的话也不好，给她带来压力和极差的体验就不好了。</p>
<p>万般皆是命，半点不由人。有一种悲伤，是夜色再深也无法逼出眼泪，是即便你拥有非常真诚的朋友和良师依然感到很孤独，是任何光亮再也没法刺痛你。你在太阳底下认真地学习，工作，生活，看着一个又一个的生命和我一起努力工作认真学习，像你自己和所有人期待的那样，安分守己地做自己的事情。可是只有你最清楚，你成为了深渊本身。坐在没人能看到的黑暗角落，经历命运带来的溃烂，抓不住世间的美好，只能装出一副万事顺遂的样子。</p>
]]></content>
      <tags>
        <tag>Life</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>一些不常见的进阶博客优化</title>
    <url>/2020/03/12/blog-optimize/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先，如果你是想来搭建博客的小白，那么这篇文章不适合你，这篇文章写的优化博客是一些进阶操作。常见的：文章字体、打赏按钮、图片加载、数学公式、音乐链接、不蒜子统计等等等等，网上一搜一大把的我都认为是常规设置，本文在详细描述。而本文收录的进阶优化有：</p>
<ul>
<li>降低网页功耗</li>
<li>快速加载博客</li>
</ul>
<p>此外，本次优化仅针对<code>next</code>主题，但其他主题也可参考借鉴优化思路，只是操作方法不敢保证完全一致。</p>
<a id="more"></a>
<h1 id="降低网页功耗"><a href="#降低网页功耗" class="headerlink" title="降低网页功耗"></a>降低网页功耗</h1><p>起初，我还真没在意网页的功耗问题，首先举个例子明白功耗是干什么用的。假设，你打开电脑，不管是写<code>word</code>，听音乐还是看电影，只要电脑在工作就会产生功耗，单位是瓦(W)。一般打开网页和浏览网页的功耗是10W~15W左右(我亲手测过)，而你笔记本的电池是60Wh的，那么你笔记本在满电、不充电的情况下，浏览网页的时长大约为6小时（$60\text{Wh} \div 10\text{W} = 6\text{h}$）。而浏览网页的同时，如果再有一些写<code>word</code>，听音乐或者跑程序的操作，那么电脑的续航时长也就4小时左右。</p>
<p>这就是笔记本续航的粗暴计算方法。但是很遗憾，市面上常见轻薄本的电池均为60Wh左右，但都在宣传自己笔记本续航高达10小时以上，我实在不能理解这是怎么计算出来的。所以，买电脑的时候不要看它吹嘘的续航时间多长，应该看电池是多少Wh的。</p>
<p>扯远了，回归正题，如何降低博客的功耗呢？我第一次发现问题是在<code>Linux</code>系统中，打开我的博客后发现，电脑风扇在飞速旋转，键盘也开始发烫。嗯？这是为何，我也没载入杀病毒啊。找了一个查看功耗的命令显示下现在的功耗。右上角为查看<code>CPU</code>，内存等利用率，右下角为功耗，单位W。可以看到，我博客当初的功耗为55W。</p>
<p><img data-src="/2020/03/12/blog-optimize/1.png" alt></p>
<p>经过一段时间的排查变量实锤了一个现象：观看我的博客，功耗飞速上升到55W，CPU利用率<code>10%</code>，然后关闭我的博客，功耗降低到1W左右，极度真实。55W的功耗，意味着，我笔记本在看我博客的时候只能保证一个小时的续航，岂不给看我博客的用户带来极度不良体验？我寻思我就看个网页不至于啊，那么看一下别人同款<code>next</code>主题的博客，什么？5W？<code>CPU</code>利用率从<code>10%</code>降到了<code>0%</code>，见鬼了？不行，得优化。</p>
<p><img data-src="/2020/03/12/blog-optimize/2.png" alt></p>
<p>废话扯多了，优化的方案无非就是排除变量，（毕竟我不会前端无法确定哪个插件的功耗影响有多大）。索性打开了主题文件夹（非站点文件夹）下的<code>_config.yml</code>文件，大不了一个一个改。</p>
<p>我看到了其中的<code>minify, lazyload, quicklink, pjax, jquery, SEO, baidu_push</code>等等一些列配置，发现，问题丝毫没在这些上面，且与我魔改主题的字体，颜色都无关。不绕弯子了，问题出在<code>live2d</code>这个看板娘上，就是他导致的过高的功耗。注意，不仅要在博客里关闭看板娘，还要删除安装在站点文件夹下<code>node_modules</code>里面的<code>live2d</code>的配置文件。<del>（因为我最开始也只是关闭，结果发现看板娘还在，索性在<code>node_modules</code>文件夹里面搜索名称含有<code>live2d</code>的文件，全部删除，<code>live2d</code>才正式在我博客里消失）</del>。后续就正常很多了，功耗也降低了下来，希望看我博客的人能有一个好的体验感。</p>
<h1 id="优化博客访问速度"><a href="#优化博客访问速度" class="headerlink" title="优化博客访问速度"></a>优化博客访问速度</h1><p>如果你不幸的读到了这里，我先引入<code>next</code>官方的一句话吧：<strong>DO NOT EDIT THE FOLLOWING SETTINGS UNLESS YOU KNOW WHAT YOU ARE DOING</strong>，意思是：不要改以下的配置，除非你知道自己在干什么。</p>
<p>很高兴，我不知道我在干什么，但我想改改看。（当然，如果你迫切想优化博客，可以跟随我的步伐一起魔改，否则本文对你来说就到此结束了）。但是<code>next</code>官方对每个选项都给了注释，仔细读一读，也不是很难改。</p>
<p><code>pjax</code>是一个<code>jQuery</code>插件，它提供了极速的浏览体验，并且保持了真实的地址、网页标题，浏览器的后退（前进）按钮也可以正常使用。没学过前端的我只注意到了<code>pjax</code>能提速，其他一概不懂。好，那就直接开启设置。以下所有操作均在主题文件夹下的<code>_config.yml</code>文件里进行。</p>
<p>第一步，将<code>pjax: false</code>改为<code>pjax: true</code>，先开启，而后，在<code>vendors</code>选项中，将注释取消，即导入这么一句话，指定<code>CDN</code>的链接即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pjax:</span> <span class="string">//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js</span></span><br></pre></td></tr></table></figure>
<p>之后你博客的访问速度就能飞速提升啦～</p>
<h2 id="其余杂项优化"><a href="#其余杂项优化" class="headerlink" title="其余杂项优化"></a>其余杂项优化</h2><ul>
<li><code>minify</code>，意思是不<code>push</code>无关的东西，看着有用，改为<code>true</code>。</li>
<li><code>quciklink</code>，官方的解释是：<strong>Faster subsequent page-loads by prefetching in-viewport links during idle time</strong>。翻译过来的意思就是：在打开网页后，趁你不注意加载网页中的链接，以此加快后续网页的访问速度。看样子有用，先改为<code>true</code>，在将<code>vendors</code>选项里的<code>quicklink</code>注释给取消掉，方法同<code>pjax</code>。</li>
<li><code>lazyload</code>，同样先看官方解释：<strong>LazyLoad is a fast, lightweight and flexible script that speeds up your web application by loading your content images, videos and iframes only as they enter the viewport</strong>。翻译过来的意思就是：图片进入窗口我才加载，在网页最后面的图片、视频啥的文件我先不加载，看到那里在加载。因为用户可能看不到网页结尾，那么在打开网页的时候就加载网页结尾处的图片是没意义的，这不利于提高浏览速度。既然如此，增加这个配置，方法同<code>pjax</code>，先改为<code>true</code>，在去<code>vendors</code>里面加上链接。</li>
</ul>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>以下情况仅供参考。关于<code>pjax</code>要补充一点，如果在页面里设置了不蒜子来统计人数和每篇文章的访问量，那么，最好不要开启<code>pjax</code>。因为设置<code>pjax</code>后，每个页面中的不蒜子统计可能不会加载，意思是，别人看了你的文章但是你没统计。就像这样：</p>
<p><img data-src="/2020/03/12/blog-optimize/3.png" alt></p>
<p>这只是我实践出来的结论，所以，我选择关闭<code>pjax</code>，开启<code>quicklink</code>和<code>lazyload</code>也同样能秒开博客～。</p>
<p>但是，在我更新<code>Next</code>后，就又没这个问题了，我现在是<code>pjax</code>和<code>lazyload</code>都在启用。</p>
<h1 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h1><p>我把上述全部的配置代码放到了网上，如果还是不懂如何设置可以对照参考。<a href="https://github.com/muyuuuu/My-Next-theme-blog-config-files/blob/master/_config.yml" target="_blank" rel="noopener">点我过去</a>。</p>
]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>环渤海骑行</title>
    <url>/2016/12/09/bohai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>经过大海时，眼望着海水与天相接的地方，天是那样低，水是那样蓝，蓝蓝的海水就荡漾在心里，心跳缓缓的，悠悠的，有一种说不出的舒畅与宁静，心中就像没有云彩的天空一片，宽了、静了，渐渐的觉得没有烦恼的世界是多么美妙，广阔海洋和蓝天下的肆无忌惮。</p>
<p>以此记录那些年曾环渤海骑行40公里，路在脚下，风景在眼中。</p>
<a id="more"></a>
<h2 id="三万里河东入海"><a href="#三万里河东入海" class="headerlink" title="三万里河东入海"></a>三万里河东入海</h2><p>我记得初中的时候学过，海边的气候是温暖潮湿，很幸运我的大学是在海边的，而且是没有人工开发的纯净海~但是美滋滋的，后来真的想打死地理老师，海边气候夏季高温，一年四季多妖风(能吹动人的那种风)，没有秋天，夏天过后3个星期迅速切换到冬天，寒风和低温更配哦～</p>
<p>切入正题，学校附近的海还是很美的，所以立下了flag，每年至少抽出一个下午去海边转转。</p>
<p>在阳光的照射下，海面波光粼粼，美丽极了。海鸥在蔚蓝的天空中自由自在地飞翔着；在海里面，轮船缓缓地在水面行驶着，发出“呜呜”的汽笛声；海鸥在海面翱翔，时而发出悦耳的鸣叫。人们在海边嬉戏，有的拾贝壳、有的洗海澡、有的享受沙滩日光浴……</p>
<hr>
<h2 id="照片精选"><a href="#照片精选" class="headerlink" title="照片精选"></a>照片精选</h2><hr>
<p><img data-src="/2016/12/09/bohai/1.jpeg" alt><br><img data-src="/2016/12/09/bohai/3.jpeg" alt><br><img data-src="/2016/12/09/bohai/4.jpeg" alt><br><img data-src="/2016/12/09/bohai/5.jpeg" alt><br><img data-src="/2016/12/09/bohai/6.jpeg" alt><br><img data-src="/2016/12/09/bohai/103.jpeg" alt><br><img data-src="/2016/12/09/bohai/7.jpeg" alt><br><img data-src="/2016/12/09/bohai/8.jpeg" alt><br><img data-src="/2016/12/09/bohai/9.jpeg" alt></p>
<hr>
<h2 id="幽蓝平静"><a href="#幽蓝平静" class="headerlink" title="幽蓝平静"></a>幽蓝平静</h2><hr>
<p><img data-src="/2016/12/09/bohai/100.jpeg" alt><br><img data-src="/2016/12/09/bohai/22.jpeg" alt><br><img data-src="/2016/12/09/bohai/23.jpeg" alt><br><img data-src="/2016/12/09/bohai/24.jpeg" alt></p>
<hr>
<h2 id="奔腾不止"><a href="#奔腾不止" class="headerlink" title="奔腾不止"></a>奔腾不止</h2><hr>
<p><img data-src="/2016/12/09/bohai/28.jpeg" alt><br><img data-src="/2016/12/09/bohai/34.jpeg" alt></p>
<h2 id><a href="#" class="headerlink" title></a><img data-src="/2016/12/09/bohai/35.jpeg" alt></h2><h2 id="风卷残云海鸥争鸣"><a href="#风卷残云海鸥争鸣" class="headerlink" title="风卷残云海鸥争鸣"></a>风卷残云海鸥争鸣</h2><hr>
<p><img data-src="/2016/12/09/bohai/11.jpeg" alt><br><img data-src="/2016/12/09/bohai/12.jpeg" alt><br><img data-src="/2016/12/09/bohai/14.jpeg" alt><br><img data-src="/2016/12/09/bohai/15.jpeg" alt><br><img data-src="/2016/12/09/bohai/16.jpeg" alt><br><img data-src="/2016/12/09/bohai/17.jpeg" alt><br><img data-src="/2016/12/09/bohai/18.jpeg" alt></p>
<hr>
<h2 id="海边落日"><a href="#海边落日" class="headerlink" title="海边落日"></a>海边落日</h2><hr>
<p><img data-src="/2016/12/09/bohai/13.jpeg" alt></p>
<hr>
]]></content>
      <categories>
        <category>海</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>归尘</title>
    <url>/2019/06/30/bye/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="/2019/06/30/bye/bye.jpg" alt></p>
<a id="more"></a>
<p>看完了小蜘蛛，英雄远征整体剧情和特效还是不错的。</p>
<p>开篇第一句，谨以此片致敬Iron Man, Captain America and Black Widow.</p>
<p>漫威的电影里虽然有十多位英雄，但每个英雄都有自己的背景和鲜明的人物风格。比普通的电影要好了好多。</p>
<p>普通电影大概也只有两种情况：</p>
<ol>
<li>草根出身，努力奋斗，半路翻车，然后逆袭，最后煽情升华。</li>
<li>出身很好，半路翻车，突然醒悟，然后逆袭，最后煽情升华。</li>
<li>如果是动作片，那么最后打boss的时候一定分两个阶段；第一个阶段一定打不过，第二个阶段一定稳赢。</li>
</ol>
<p>以至于看了标题，剧情也猜的差不多。尤其是最后一定要强行煽情看的真难受，一定要有乱七八糟莫名其妙的爱情线，男主女主没爱情是不是拍不了电影了，有了爱情是不是得有误会？有了误会还得再加一条线加深误会，比如女二，最后因为啥啥啥原因误会解除，比如男主得病了，癌症，治不好，然后强行升华回主题，woc。以至于垃圾电影遍地。</p>
<p>托尼·斯塔克，钢铁侠，花花公子，天才科学家，慈善家，亿万富豪。孤独、疲惫的科学家，内疚的凡人。拥有一切，也一无所有。</p>
<p>队长说他永远不懂得为他人牺牲。他说没错，转过身，耗费了所有力量抱着核弹冲进了太空。</p>
<p>甚至他刚想和小辣椒说想生个孩子，下一秒奇异博士就站在他的眼前，要他去保卫地球。对于今晚的约会，他只能在太空里拯救世界。抱歉地说，对不起，今晚的晚餐我赶不回去了。</p>
<p>我也忘了托尼·斯塔克本来是个端着酒杯，在光影缭乱的欢乐场里纵情大笑的男人，而不是如今所有人习惯的，钢铁面罩下肃然迎敌的战士。他脱掉铁甲，不仅是亿万富翁、花花公子、慈善家，也许是可以为战友爬铁丝网的人。</p>
<p>以凡人之躯，比肩神明。</p>
<p>像大多数人一样，我也可能会把事情搞砸，后悔每一个决定，这个形象塑造的很成功。看电影的当天也遭遇了很不舒服的事，而终究要告别，我也要走。</p>
<hr>
]]></content>
      <tags>
        <tag>Movie</tag>
      </tags>
  </entry>
  <entry>
    <title>修补hexo-next不蒜子不显示问题</title>
    <url>/2019/11/22/busuanzi-notdisplay/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>问题描述：并不是不蒜子域名的问题，就是那种即使修改了<code>_config.yml</code>文件的<code>busuanzi为true</code>，它就是不显示，之前也是这个问题。而网上搜索不蒜子不显示这个问题，全是修改域名，但我不是域名的问题啊。毕竟自己是学计算机的，虽然没学过前端。但忍无可忍，决定改源代码使<code>busuanzi</code>显示正常，结果还真改出来了，我可真是个天才。</p>
<p>昨天还给一个研究生学长改好了一个bug，那还是我没见过的算法，要不是我见过比那还烂的代码，不然真的镇不住场面了，日常感觉自己是个天才。之前一个同学说：我校都是本科生带研究生，别的学校都是老师和研究生带本科生，现在我多少信了，现在想想我帮过他们多少东西了，滑稽。</p>
<a id="more"></a>
<h1 id="版本依赖"><a href="#版本依赖" class="headerlink" title="版本依赖"></a>版本依赖</h1><p>不谈版本只说问题都是在耍流氓。确定使用本文的方法前，请确定版本是否适用。</p>
<ul>
<li>computer： Linux version 4.19.79-1-MANJARO</li>
<li>node.js： 12.11.1</li>
<li>hexo： 3.9.0</li>
<li>Next：7.5.0</li>
</ul>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>每次修改不蒜子后，网页缓存可能没更新，需要重新<code>hexo s --watch</code>一下才能查看修改后的效果。</p>
<h1 id="开始修改"><a href="#开始修改" class="headerlink" title="开始修改"></a>开始修改</h1><h2 id="主题的配置文件"><a href="#主题的配置文件" class="headerlink" title="主题的配置文件"></a>主题的配置文件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  total_visitors: <span class="literal">true</span></span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: <span class="literal">true</span></span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: <span class="literal">true</span></span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>
<p>可是这样丝毫没用，还是不显示。没有浏览人数和浏览量的博客没有灵魂，于是决定在线Debug查找问题所在。</p>
<h2 id="修复总访问量和总访问人数"><a href="#修复总访问量和总访问人数" class="headerlink" title="修复总访问量和总访问人数"></a>修复总访问量和总访问人数</h2><p>在网页中按下<code>F12</code>这个键，点击图中的鼠标，定位到要显示总访客人的地方。不要因为界面很复杂就感觉自己不会，在这之前我啥也不会，在这之后我还是不会。</p>
<p><img data-src="/2019/11/22/busuanzi-notdisplay/1.png" alt></p>
<p>定位后，发现不蒜子的东西是有的，span还有数量都有，可就是不显示。再次定位到页脚访问人数那里，看看不蒜子的<code>span id</code>里是否有<code>style = &quot;display: none&quot;</code>这句话，如果有，去掉后面的<code>style = &quot;display: none&quot;</code>才可以正常显示（纯属巧合发现，我没学过前端嘛），我也不知道开发者明明开发出了显示，为啥还要加这句话使开发出来的东西不显示，我想不通。</p>
<p>两种去除方法：</p>
<ol>
<li><code>F12</code>出来的界面中，直接删除这个语句，回车确定，会发现去掉了，也可以显示了，但刷新后那句话又会回来，有没有什么一劳永逸的方法呢？有。</li>
<li>打开<code>theme-next/layout/_third-party/statistics/busuanzi-counter.swig</code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.busuanzi_count.total_views %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item"</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_pv"</span> <span class="attr">style</span>=<span class="string">"display: none;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-pv"</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; __('footer.total_views') &#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>看到里面的<code>&lt;span class=&quot;post-meta-item&quot; id=&quot;busuanzi_container_site_pv&quot; style=&quot;display: none;&quot;&gt;</code>了没，对，去掉，直接去掉，明明开发出来了还设置不显示，不知道咋想的。</p>
<p>我修改的<code>theme-next/layout/_third-party/statistics/busuanzi-counter.swig</code>内容如下，仅供参考：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.busuanzi_count.enable %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"busuanzi-count"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-uv"</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; __('footer.total_visitors') &#125;&#125;"</span>&gt;</span></span><br><span class="line">    我的第<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>位朋友, </span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-pv"</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; __('footer.total_views') &#125;&#125;"</span>&gt;</span></span><br><span class="line">    经过<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次回眸与你相遇</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="修复每篇文章的浏览人数"><a href="#修复每篇文章的浏览人数" class="headerlink" title="修复每篇文章的浏览人数"></a>修复每篇文章的浏览人数</h2><p>这个的设置没在<code>busuanzi.swig</code>中，再次定位，发现是一个div叫<code>post-meta</code>的东西，而所有发表的博客页面都和<code>post</code>有关（折腾多了，经验），所以，我们在去寻找有没有大概叫<code>post</code>文件名的，里面有没有<code>post-meta</code>，这次又找到了。</p>
<p>打开<code>theme/next/layout/_macro/post.swig</code>，接着分析，首先找到不蒜子的代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;%- if not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item"</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; __('post.views') &#125;&#125;"</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_page_pv"</span> <span class="attr">style</span>=<span class="string">"display: none;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-&#123;&#123; theme.busuanzi_count.post_views_icon &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>&#123;&#123; __('post.views') + __('symbol.colon') &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_page_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p>对没错，又看到了<code>style display none</code>，二话不说直接删了，不删的话，会发现，网页源代码的确有不蒜子的信息，但就是不显示。</p>
<p>我修改后的配置如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;%- if  not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;emsp;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-eye"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>&#123;&#123; __('post.views') + __('symbol.colon') &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_page_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p>如上，修改完毕。也能正常显示了。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>看着轻松嘛，但是我前后折腾了四个小时，学会了F12在线debug，至少还是有收获的。如果你还是不能显示，可以按照本文介绍的方法，一点点去寻找问题所在，然后解决掉。可能每个人和每个人面临的情况不一样。</p>
<p>授人以鱼不如授人以渔，会独立分析，解决各种问题总比会查询解决一个问题来的实在。</p>
]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>DIY智能小车——寻迹与马达</title>
    <url>/2018/05/23/c511/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在完成超声波避障和1602液晶显示之后，下一步要对小车车增加寻迹的功能，寻迹的模块TCRT5000红外反射传感器，主要的实现原理是：TCRT5000传感器的红外发射二极管不断发射红外时，3脚的电压大于2脚的电压，输出为低电平。根据这个原理就可以写代码啦~</p>
<p>实现的主要功能：</p>
<ul>
<li>白纸上画黑线，小车车会沿着黑线走</li>
<li>顺路介绍下L298N电机驱动模块</li>
</ul>
<a id="more"></a>
<h3 id="L298N"><a href="#L298N" class="headerlink" title="L298N"></a>L298N</h3><p><img data-src="/2018/05/23/c511/3.png" alt></p>
<p>可能这个图片已经写的很清楚了，一个驱动模块带动两个电极，一个L298N模块需要三个IO口。</p>
<h3 id="寻迹程序"><a href="#寻迹程序" class="headerlink" title="寻迹程序"></a>寻迹程序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************寻迹IO口声明********************/</span></span><br><span class="line">sbit trace1 = P3^<span class="number">5</span>;     <span class="comment">/*1路*/</span>设置的为两个模块去寻迹</span><br><span class="line">sbit trace2 = P2^<span class="number">5</span>;     <span class="comment">/*2路*/</span></span><br><span class="line"><span class="comment">/**********************电机的IO口*****************/</span></span><br><span class="line">sbit em1 = P1^<span class="number">4</span>;        <span class="comment">//左后，四个电机的驱动</span></span><br><span class="line">sbit em2 = P1^<span class="number">7</span>;        <span class="comment">//右后</span></span><br><span class="line">sbit em3 = P2^<span class="number">7</span>;        <span class="comment">//右前</span></span><br><span class="line">sbit em4 = P2^<span class="number">3</span>;        <span class="comment">//左前</span></span><br><span class="line"><span class="comment">/*电机口*/</span></span><br><span class="line">sbit in1 = P1^<span class="number">2</span>;        <span class="comment">//左后</span></span><br><span class="line">sbit in2 = P1^<span class="number">3</span>;</span><br><span class="line">sbit in3 = P1^<span class="number">5</span>;        <span class="comment">//右后</span></span><br><span class="line">sbit in4 = P1^<span class="number">6</span>;</span><br><span class="line">sbit in5 = P3^<span class="number">6</span>;        <span class="comment">//右前</span></span><br><span class="line">sbit in6 = P3^<span class="number">7</span>;</span><br><span class="line">sbit in7 = P2^<span class="number">1</span>;        <span class="comment">//左前</span></span><br><span class="line">sbit in8 = P2^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cycle 200       <span class="comment">//宏定义一个周期，下面会进行说明</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************延时函数*****************/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delayms</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="keyword">for</span> (a = z; a &gt; <span class="number">0</span>; a--)</span><br><span class="line">            <span class="keyword">for</span> (b = <span class="number">110</span>; b &gt; <span class="number">0</span>; b--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****因为单片机上电后，电机对应端口送高电平，所以电机被启动，em1就没赋值****/</span></span><br><span class="line"><span class="comment">/********************电机转动************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Forward</span><span class="params">()</span> <span class="comment">//前进</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in1 = <span class="number">1</span>;</span><br><span class="line">    in2 = <span class="number">0</span>;</span><br><span class="line">    in3 = <span class="number">1</span>;</span><br><span class="line">    in4 = <span class="number">0</span>;</span><br><span class="line">    in5 = <span class="number">1</span>;</span><br><span class="line">    in6 = <span class="number">0</span>;</span><br><span class="line">    in7 = <span class="number">1</span>;</span><br><span class="line">    in8 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span>    <span class="comment">//停止</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in1 = <span class="number">0</span>;</span><br><span class="line">    in2 = <span class="number">0</span>;</span><br><span class="line">    in3 = <span class="number">0</span>;</span><br><span class="line">    in4 = <span class="number">0</span>;</span><br><span class="line">    in5 = <span class="number">0</span>;</span><br><span class="line">    in6 = <span class="number">0</span>;</span><br><span class="line">    in7 = <span class="number">0</span>;</span><br><span class="line">    in8 = <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">()</span>  <span class="comment">//倒车</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in1 = <span class="number">0</span>;</span><br><span class="line">    in2 = <span class="number">1</span>;</span><br><span class="line">    in3 = <span class="number">0</span>;</span><br><span class="line">    in4 = <span class="number">1</span>;</span><br><span class="line">    in5 = <span class="number">0</span>;</span><br><span class="line">    in6 = <span class="number">1</span>;</span><br><span class="line">    in7 = <span class="number">0</span>;</span><br><span class="line">    in8 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Turn_left</span><span class="params">()</span>  <span class="comment">//左转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in1 = <span class="number">0</span>;</span><br><span class="line">    in2 = <span class="number">1</span>;</span><br><span class="line">    in3 = <span class="number">1</span>;</span><br><span class="line">    in4 = <span class="number">0</span>;</span><br><span class="line">    in5 = <span class="number">1</span>;</span><br><span class="line">    in6 = <span class="number">0</span>;</span><br><span class="line">    in7 = <span class="number">0</span>;</span><br><span class="line">    in8 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Turn_right</span><span class="params">()</span>   <span class="comment">//右转   </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in1 = <span class="number">1</span>;</span><br><span class="line">    in2 = <span class="number">0</span>;</span><br><span class="line">    in3 = <span class="number">0</span>;</span><br><span class="line">    in4 = <span class="number">1</span>;</span><br><span class="line">    in5 = <span class="number">0</span>;</span><br><span class="line">    in6 = <span class="number">1</span>;</span><br><span class="line">    in7 = <span class="number">1</span>;</span><br><span class="line">    in8 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************寻迹函数************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trace</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>((trace1 == <span class="number">0</span>) &amp;&amp; (trace2 == <span class="number">0</span>))       <span class="comment">//0代表检测到黑线</span></span><br><span class="line">    &#123;  </span><br><span class="line">        Delayms(<span class="number">50</span>);                         <span class="comment">//首先先做略微的延时，因为trace1、2不是很稳定</span></span><br><span class="line">        Forward();                           <span class="comment">//前进</span></span><br><span class="line">        Delayms(cycle);                      <span class="comment">//前面宏定义的周期</span></span><br><span class="line">        Stop();                              <span class="comment">//小车停止，防止小车走的太快，不能很好的寻迹  </span></span><br><span class="line">        Delayms(cycle);                      <span class="comment">//再次延时，结束后进入下次循环</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//因为这里没有写PWM小车的调速程序，怕小车走的太快而不能很好的寻迹，因此，就让小车以</span></span><br><span class="line"><span class="comment">//“走走停停的”形式缓慢前进。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((trace1 == <span class="number">0</span>) &amp;&amp; (trace2 == <span class="number">1</span>))       <span class="comment">//0代表检测到黑线</span></span><br><span class="line">    &#123;  </span><br><span class="line">        Delayms(<span class="number">50</span>);</span><br><span class="line">        Turn_left();</span><br><span class="line">        Delayms(cycle);</span><br><span class="line">        Stop();                           <span class="comment">//防止走的太快  </span></span><br><span class="line">        Delayms(cycle);  </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((trace1 == <span class="number">1</span>) &amp;&amp; (trace2 == <span class="number">0</span>))       <span class="comment">//0代表检测到黑线</span></span><br><span class="line">    &#123;  </span><br><span class="line">        Delayms(<span class="number">50</span>);</span><br><span class="line">        Turn_right();</span><br><span class="line">        Delayms(cycle); </span><br><span class="line">        Stop();                           <span class="comment">//防止走的太快  </span></span><br><span class="line">        Delayms(cycle);  </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((trace1 == <span class="number">1</span>) &amp;&amp; (trace2 == <span class="number">1</span>))  </span><br><span class="line">    &#123;  </span><br><span class="line">        Delayms(<span class="number">50</span>);</span><br><span class="line">        Forward();</span><br><span class="line">        Delayms(cycle);  </span><br><span class="line">        Stop();                           <span class="comment">//防止走的太快  </span></span><br><span class="line">        Delayms(cycle); </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;          </span><br><span class="line">       Trace();                          <span class="comment">//死循环，进入寻迹</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻迹收获"><a href="#寻迹收获" class="headerlink" title="寻迹收获"></a>寻迹收获</h3><ul>
<li>可能没啥好展示的，其中宏定义中的cycle数值，可能要根据自己的实际情况去改变一下，好了，明天写蓝牙的那部分代码，今晚有点困，先睡了，不熬夜~~~</li>
<li>以及这些代码都是能运行的，不知道当初调了多少BUG，莫名其妙的不对，寻迹模块还是中途换过<br>的，今晚过了测试，才写的这个博客。</li>
<li>每个程序猿经历过的莫名奇妙的让人脑仁疼的破BUG，可能都能当一段故事吹一下，前几天不对，<br>今天又对了，还真是奇怪，被我归结为模块原因（其实是代码是在改不动了）。嗯，Goodnight.</li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>microcomputer</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记——《挪威的森林》</title>
    <url>/2020/01/07/book-norway-forest/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>想来还是继续我的读书笔记，说来惭愧，2019年只看了一本课外书——《挪威的森林》。配上一副红色的落日和《起风了》这首歌，似乎有了那么点意境。</p>
<ul>
<li>而长野的天，依旧那么暖，风吹起了从前。</li>
<li>不知抚摸的是故事还是段心情，也许期待的不过是与时间为敌。再次看到你，微凉晨光里，笑得很甜蜜。</li>
<li>措不及防闯入你的笑颜。</li>
</ul>
<p><img data-src="/2020/01/07/book-norway-forest/5.jpg" alt></p>
<a id="more"></a>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>我不尬吹，也不吹爆，也不说他的作品陪跑，我也只看过他的这一本书。不得不说村上春树的文字功底还是很好的，只言片语的描写很容易把人带入角色，和角色一起思考；或者说是一些景物描写，描写的足够真实，仿佛身临其境向读者自己亲身经历过一样。很平凡的词汇，很好的描写意境和传达角色心理、动作、神态。</p>
<p>而除此之外，作者在书里表述的三观我也很认同，索性做了这次的读书笔记。也许你可能有以下的两个疑问：</p>
<ul>
<li>Q1: 为什么动不动就死人，就自杀，如：木月、直子、初美、直子的姐姐？</li>
<li>Q2: 据说这本书写的很色情？</li>
<li>Q3: 这本书讲了啥故事？</li>
</ul>
<p>回答</p>
<ul>
<li>A1: 我不知道作者为什么这么写成很多人都自杀，放心不会被洗脑。但口味比国产电影的堕胎、癌症和狗血青春要好的多。</li>
<li>A2: 关于色情分为两点。男主很随意的性行为我不敢苟同，书中给出的回答是排除孤寂，不曾感同身受，没有经历所以我不能回答；而关于性行为细节的色情，我倒想问那些人过着怎样高尚的性生活，请你仔细描写一下，大家都想学习。</li>
<li>A3: <img data-src="/2020/01/07/book-norway-forest/11.jpg" alt></li>
</ul>
<h1 id="风景描写"><a href="#风景描写" class="headerlink" title="风景描写"></a>风景描写</h1><p>风景描写在书中随处可见，也许是日本的绿化率高，也许是故事大多发生在城镇和山野。</p>
<blockquote>
<p>即使在经历过十八度春秋的今天，我仍可真切的记起那片草地的风景。连日温馨的霏霏细雨，将夏日的尘埃冲洗无余。片片山坡叠青泻翠，抽穗的芒草在十月金风的吹佛下蜿蜒起伏，逶迤的薄云紧贴着仿佛冻僵的湛蓝的天壁。凝眸望去，长空寥廓，直觉双目隐隐作痛。</p>
</blockquote>
<p><code>直觉双目隐隐作痛</code>真的真实。</p>
<blockquote>
<p>而那恋情又把我带到一处纷纭而微妙的境地，根本不容我有欣赏周围风景的闲情逸致。</p>
</blockquote>
<p>也许，不是也许，热恋中的人肯定懂得这种——思想完全被抓住没有丝毫反应的余地。</p>
<blockquote>
<p>只有夜风从我们身旁掠过，榉树在黑暗中摩擦着无数的叶片，簌簌作响。</p>
</blockquote>
<p>看到这里感觉，仿佛回到了盛夏。</p>
<blockquote>
<p>杉树简直像原始树林一样拔地而起，遮云蔽日，将万物笼罩在幽暗的阴影中。从窗口进来的风突然骤然变冷，湿气砭人肌肤。极目四望，盆地中禾苗青青，平展展的向下延伸开去。</p>
</blockquote>
<p>我大概找到描写天气冷：『好冷啊』的替换词汇了。</p>
<blockquote>
<p>月光十分皎洁，我关掉房间的灯，倒在沙发上听钢琴曲。窗口泻进的月光银辉，把东西的影子拖的长长的，宛如一层淡墨隐隐约约印在墙壁上。我从帆布包中取出装有白兰地的薄金属筒，倒进嘴里一些，缓缓咽下。一种温煦的感觉从喉头往胃里慢慢下移，继而又从胃向身体的各个角落扩散开去。我又喝了一口，然后把筒盖好，放回帆布包。月光似乎随着音乐摇摆不定。</p>
</blockquote>
<p>脑补最后一句，『摇摆不定』，与作者的醉酒、音乐的光色、风吹过簌簌作响的树叶都有关，就宛如画龙点睛，写的很妙。</p>
<blockquote>
<p>翌日清晨，雨仍下个不停，但和昨晚不同，成了毛毛秋雨。四下一片迷蒙，若非一洼洼基于的水纹和顺檐滴落的雨点声，几乎察觉不出下雨。睁眼醒来时，窗外笼罩着乳白色的雾霭，随着太阳的升起，雾霭随风散去，于是杂木林和山脉的棱线一点点显露出来。</p>
</blockquote>
<h1 id="本书最美"><a href="#本书最美" class="headerlink" title="本书最美"></a>本书最美</h1><p>应当有配乐(起风了)：</p>
<p><div class="note danger"><p><audio src="http://music.163.com/song/media/outer/url?id=1330348068.mp3" style="max-height :100%; max-width: 800%; display: block; margin-left: auto; margin-right: auto;" controls="controls" loop="loop" preload="meta">Your browser does not support the audio tag.</audio></p></div><br>车到涩谷之前，我一直注视着初美，一直在思索她在我心中激起的这种感情震颤究竟是什么东西，但直到最后也未能明了。</p>
<blockquote>
<p>当我恍然领悟到其为何物的时候，已是十二三年以后的事了。那是，当我采访一位画家来到新墨西哥州的圣菲城。傍晚，我走进附近一家意大利批萨饼店，一边喝啤酒嚼批萨，一边眺望美丽的夕阳。天地间的一切全都红彤彤的一片。我的手、盆子、桌子，凡是目力所及的东西，无不被染成了红色，而且红的非常鲜艳，俨然被特殊的果汁从上方直接淋下来似的。就在这种气势夺人的暮色当中，我猛然想起了初美，并且这时才领悟她给我带来的心灵震颤究竟是什么东西——它类似一种少年时代的憧憬，一种从来不曾实现而且永远不可能实现的憧憬。这种直欲燃烧般的天真烂漫的憧憬，我在很早以前就已遗忘在什么地方了，甚至很长时间里我连它曾在我心中存在过都记不起了。而初美所摇撼的恰恰就是我身上长眠未醒的“我自身的一部分”。当我恍然大悟时，一时悲怆之极，几欲涕零。她的确、的的确确是位特殊的女性，无论如何都应该有人向她伸出援助之手。</p>
</blockquote>
<p>很遗憾我至今也没找到那张配图，也没有找到合适的配图。前两张图是我自己拍的，后面的图是网上下载的。</p>
<p><img data-src="/2020/01/07/book-norway-forest/13.jpg" alt></p>
<p><img data-src="/2020/01/07/book-norway-forest/14.jpg" alt></p>
<p><img data-src="/2020/01/07/book-norway-forest/3.jpg" alt></p>
<h1 id="一个有趣的医院"><a href="#一个有趣的医院" class="headerlink" title="一个有趣的医院"></a>一个有趣的医院</h1><blockquote>
<p>“啊，是这样，我么，在这里当教音乐的老师，所以也有人就叫我老师，其实我本人也是患者。在这里一待就是7年，平时教大家音乐，帮忙做点事务性活计，结果就闹不清是职员还是病人了。”</p>
<p>“首先第一点希望你理解的是，这里不是一般意义的’医院‘。简单来说，这里不是治病的地方。其他地方则不是这样，医生始终是医生，患者始终是患者，患者有求于医生，医生给予患者以帮助。但这里却是相互帮助，相互引以为鉴。而且医生是我们的同伴，在旁一发现我们需要什么，就赶紧过来帮忙。有时候我们也帮他们忙，因为在某种情况下我们是强于他们的。”</p>
<p>“例如我就教过一个医生探亲，有个患者教护士学法语，就是这样。得我们这种病的人，有不少人学有专长，所以在我们这里一概平等，无论是患者还是工作人员。”</p>
</blockquote>
<p>别误会，这里只是精神疗养恢复的医院，如：做手术、烧伤、肿瘤等，肯定不能来上文描述的这种医院，还是去常规医院接受治疗为好。</p>
<h1 id="猜测书名的由来"><a href="#猜测书名的由来" class="headerlink" title="猜测书名的由来"></a>猜测书名的由来</h1><blockquote>
<p>玲子揉了好几下手指，开始弹奏《挪威的森林》。曲子里注满了她的感情，而她又不为感情所驱使。</p>
<p>“一听这曲子，我就时长悲哀的不行。也不知道为什么，我总是觉得似乎自己在茂密的森林中迷了路。“直子说，”一个人孤单单的，里面又黑又冷，又没有一个人来救我。”</p>
</blockquote>
<p>我自己猜测：这本书是作者在欧洲写的，可能想不出来给书叫啥名就叫了这个玩意。</p>
<h1 id="人物心境"><a href="#人物心境" class="headerlink" title="人物心境"></a>人物心境</h1><blockquote>
<p>1969这一年，总是令我想起进退两难的泥沼——没迈一步都几乎把整只鞋陷掉那般的滞重而深沉的泥沼。而我就在这片泥沼中气喘吁吁的挪动脚步，前方一无所知，后方渺无来者，只有昏暗的泥沼无边无际的延展开去。</p>
<p>同情自己是卑劣懦夫干的勾当。</p>
</blockquote>
<p>有道理，对无力改变周围环境、又不努力提升自己的怜悯。</p>
<blockquote>
<p>我写道：“春回大地，新的学年开始了。不得相见，实在怅惘莫名。我很想见你，同你说话，无论通过什么形式都可以。但不管怎样，我都决心自强不息，此外别无他路可走。”</p>
</blockquote>
<p>仿佛魔幻的高一。</p>
<blockquote>
<p>哪里会有人喜欢孤独，只是不乱交朋友罢了。</p>
</blockquote>
<p>也有道理，家人经常让我联系之前的同学，万一有用，可能也不止一个家长是此类思想。可我也从来不联系。联系作甚呢？有话说话，同学也就那么几个聊得来的，想起来可能就聊两句。而其余人，和自己的三观、见识、视野、未来的方向都不一样，联系何用呢？徒增尴尬。就像我之前的很多同学都认为读书无用，这让我怎么联系，去哪里找共同话题，就好比：『我买菜不用高等数学，可为什么要学微积分』一个道理。</p>
<blockquote>
<p>人生中无需那种东西，需要的不是理想，而是行为规范。</p>
</blockquote>
<p>成年人的世界，搞不懂。</p>
<p>本书的结尾，倒映了男主的孤寂、失落和没有归宿的灵魂，埋下继续成长的伏笔。</p>
<blockquote>
<p>绿子在电话的另一头久久沉默不语，如同全世界所有的细雨落在全世界所有的草坪上一般的沉默在持续。这时间里，我一直合着双眼，把额头顶在电话亭玻璃上。良久，绿子用沉静的声音开口道：“你现在在哪里？”</p>
<p>我现在在哪里？</p>
<p>我拿着听筒扬起脸，飞快的环视电话亭四周。我现在在哪里？我不知道这是哪里，全然摸不着头脑。这里究竟是哪里？目力所及，无不是不知走去哪里的无数男男女女。我在哪里也不是的场所的正中央，不断的呼唤着绿子。</p>
</blockquote>
<h1 id="我比较认同的三观"><a href="#我比较认同的三观" class="headerlink" title="我比较认同的三观"></a>我比较认同的三观</h1><blockquote>
<p>宣布罢课决议之时他们那般慷慨激昂，将反动派学生骂得狗血淋头，或群起围攻不休。于是我走到他们面前，问他们何以前来教室而不继续罢课，他们没有回答，也无法回答。他们害怕因缺课过多而拿不到学分。此等人物居然也高喊什么肢解大学，想来令人喷饭。如此卑劣小人，唯有见风使舵投敌变节之能事。</p>
</blockquote>
<p>很显然，至少，在我上学的几年，从小学到大学，这些人并不少见。某个例子：一方面骂着学校没空调，没网，甚至还深夜断电，甚至还高呼找校长抗议：『说大学生难免在深夜学习，很多作业深夜不加班会做不完』。晚上做不完可以早起，深夜在玩游戏，打视频，还是在学习自己心里没数吗。况且大学的作业都会留好几天，没有拖延症也不必最后深夜赶deadline。尽管这样，还是很多人抗议。其实：深夜断电后他们的作业也能很快写完，不必担心，甚至作息也会规律很多。</p>
<p>更有甚者一面抱怨着老师讲课太难，要求太高，可自己从来不认真听课、从来不听老师要求、从来不认真学习，日常在打游戏中度过，在快要挂科或被老师返工要求重做的时候来上那么一句：老师不负责不早说，老师要求太严了难度太大了，老师事太多了不是好老师，诸如此类。</p>
<blockquote>
<p>我说木月，这世道真是江河日下！这帮家伙一个不少的拿得大学学分，跨出校门将不遗余力的构筑一个同样卑劣的社会。</p>
<p>”所以，有时我环顾世人就气不打一处来——这些家伙为什么不知道努力呢？不努力何必还满腹牢骚呢？“</p>
<p>我惊讶地看着永泽的脸：“在我的印象中，世上的人也都在辛辛苦苦拼死拼活地忙个没完，莫不是我看错了？”</p>
<p>“那不是努力，知识劳动。”永泽断然说道，“我所说的努力与这个截然不同。所谓努力，指的是主动而有目的的活动。”</p>
</blockquote>
<p>多年前曾深刻了解到：努力不同于劳动，是在全力做自己想做的事情；而抱怨也从来不能解决任何问题。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>此外，男主在绿子死后开始了一个月的穷游，而本书也用大量篇幅描写了这部分，用心境与景物相结合的描写方式，通过展示与渔夫的矛盾、幻想和内心的独白，将男主对死去女主的思念跃然纸上。同理，因篇幅过长，此处不予展示。</p>
<p>满分10分的话，推荐指数5分，3分给文字功底，2分给内心独白和心境描写，毕竟刻画到位，2分爱学习的男主，这个故事的剧情倒扣2分。就这样。因为，我也看过其他书，故事的精彩程度不输《挪威的森林》，如《简爱》，如《追风筝的人》。</p>
<p>可能我是个爱看故事的人，所以从推荐的角度会更侧重剧情本身，这个故事好不好。当然如果你更想看人性，这本书可能是不错的选择；而我对人性这个东西没有兴趣，无论是电影还是书。看与不看就看你自己喽～</p>
]]></content>
      <tags>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>DIY智能小车——手机蓝牙</title>
    <url>/2018/05/24/c512/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>承接上文，在完成小车的避障、1602显示距离、寻迹功能后，最后一步是对小车的蓝牙控制，用手机完成的小车的控制：前进、停车、倒车、左转、右转，想想还是很帅的。此文还跟之前的文章一样，只谈论代码。<br>  不过笔者最近发现，只会写程序而不懂原理似乎真的不太好，比如，TMOD为什么是这样设置的，波特率是什么，他又是怎么工作的，51单片机的IO口额外的功能是什么样的，中断到底是怎么执行的，之前在学习的时候学的<strong>一知半解</strong>，不过学习终究是自己的事情。因此，在后续的文章中，将会对这些基本概念提出自己的理解，弄清楚这些最基本的概念，毕竟总不能糊弄着去写程序，闲扯结束，进入正题。</p>
<a id="more"></a>
<h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ul>
<li>蓝牙控制小车的前进、后退等功能。 </li>
<li>由于本人学渣，不会写手机APP，用的手机软件是“蓝牙串口助手”，应用商店搜索就能下载。</li>
</ul>
<p><img data-src="/2018/05/24/c512/4.png" alt></p>
<h3 id="HC-05"><a href="#HC-05" class="headerlink" title="HC-05"></a>HC-05</h3><p>HC-05模块就是市场（淘宝）中一搜索就有的，也是最常见的那种。之前说的“蓝牙串口助手”也支持HC-05模块，虽然他说的是支持HC-06模块，不过也没关系。 </p>
<p><img data-src="/2018/05/24/c512/5.png" alt></p>
<p>在程序的调试过程中发现了一个问题，蓝牙模块能正常连接，但是却接收不到手机发送的信息。思来想去，改过了$n$次程序，却还是不对，索性搜索起了有关蓝牙模块的东西，最终发现了问题，重要的事情说三遍：</p>
<blockquote>
<p>蓝牙模块的RXD接到单片机的TXD，蓝牙的TXD接到单片机的RXD，不然串口中断无法受到手机发来的信息 。</p>
</blockquote>
<p>    在上电的时候同时将按键按下，将进入ATAT模式，可以通过串口发送ATAT指令，进行相关操作；如果在上电时未按下按键，将进入自动模式，这时如果模块设置的是从机的话，就可以通过手机蓝牙进行连接，也可以通过手机蓝牙调试助手进行连接进行调试。</p>
<p>    HC-05 嵌入式蓝牙串口通讯模块（以下简称模块）具有两种工作模式：命令响应工作模式和自动连接工作模式，在自动连接工作模式下模块又可分为主（Master）、从（Slave）和回环（Loopback）三种工作角色。当模块处于自动连接工作模式时，将自动根据事先设定的方式连接的数据传输（即手机端命令）；当模块处于命令响应工作模式时能执行下述所有AT命令，用户可向模块发送各种 AT 指令，（AT真心不太懂）为模块设定控制参数或发布控制命令。</p>
<p>  HC-05注明：</p>
<ul>
<li>RXD：接收数据引脚 </li>
<li>TXD：发送数据引脚 </li>
<li>LED指示灯，指示模块工作状态，模块上电后闪烁，不同的状态闪烁间隔不同。</li>
</ul>
<h3 id="蓝牙控制程序"><a href="#蓝牙控制程序" class="headerlink" title="蓝牙控制程序"></a>蓝牙控制程序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"></span><br><span class="line">sbit led = P2^<span class="number">0</span>;             <span class="comment">//led灯的IO口</span></span><br><span class="line"></span><br><span class="line">uchar bluetoothdata;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(uint z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint a, b;</span><br><span class="line">    <span class="keyword">for</span>(a = z; a &gt; <span class="number">0</span>; a--)</span><br><span class="line">        <span class="keyword">for</span>(b = <span class="number">115</span>; b &gt; <span class="number">0</span>; b--);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>        </span></span><br><span class="line"><span class="function"></span>&#123;                                                                       </span><br><span class="line">    SCON = <span class="number">0x50</span>;                        </span><br><span class="line">    TMOD = <span class="number">0x21</span>;</span><br><span class="line">    PCON = <span class="number">0x00</span>;</span><br><span class="line">    TH1 = <span class="number">0xfd</span>;</span><br><span class="line">    TL1 = <span class="number">0xfd</span>;</span><br><span class="line">    RI = <span class="number">0</span>；</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    ES = <span class="number">1</span>;    </span><br><span class="line">    TR1 = <span class="number">1</span>;                         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    led = <span class="number">1</span>;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);                  <span class="comment">//一直执行中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ckzd</span><span class="params">()</span> interrupt 4        <span class="comment">//串口中断</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(RI)                     <span class="comment">//RI为收到信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        RI = <span class="number">0</span>;                <span class="comment">//手动清零</span></span><br><span class="line">        bluetoothdata = SBUF;</span><br><span class="line">        bluetoothdata = bluetoothdata &amp; <span class="number">0x0f</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">switch</span>(bluetoothdata)<span class="comment">//实现流水灯的闪烁</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x00</span>: led = <span class="number">0</span>;  Delay(<span class="number">2000</span>); led = <span class="number">0</span>; <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x01</span>: led = <span class="number">0</span>;  Delay(<span class="number">2000</span>); led = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x02</span>: led = <span class="number">0</span>;  Delay(<span class="number">2000</span>); led = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x03</span>: led = <span class="number">0</span>;  Delay(<span class="number">2000</span>); led = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x04</span>: led = <span class="number">0</span>;  Delay(<span class="number">2000</span>); led = <span class="number">0</span>; <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;                                          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等过几天，一定看懂中断、寄存器、波特率，完善以下代码的注释，起码自己写的代码自己要懂，啊啊啊啊，学艺不精不太好。先去忙考试去了，撤。后序更新会把所有程序整合到一起。哦，对了，还有PWM调速，看书，看书，看书……把东西都搞懂。</p>
<hr>
]]></content>
      <tags>
        <tag>microcomputer</tag>
      </tags>
  </entry>
  <entry>
    <title>DIY智能小车——PWM调速与产品问世</title>
    <url>/2018/05/25/c513/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>承接所有的上文，在完成小车的避障、1602显示距离、寻迹、蓝牙控制功能后，把所有的子函数整合到一起，实现一个完整的功能，貌似简单，实际上我调了至少8个小时的BUG，以及会注明BUG存在的问题，还有解决方案。</p>
<a id="more"></a>
<h2 id="PWM调速"><a href="#PWM调速" class="headerlink" title="PWM调速"></a>PWM调速</h2><p>PWM意为脉冲宽度调制（好了不抄教材了），PWM调速我个人的理解为：产生一个函数，可用于调整输出直流平均电压，对于一个矩形波而言，占空比是一个脉冲周期内高电平时间与周期的比值。其实对我这种不学模电、不学电路的人理解到这就可以了，就可以开始写程序了。 </p>
<p><img data-src="/2018/05/25/c513/6.png" alt></p>
<p>如图所示，可以产生一种时序，进行高低电平的变换，在高电平的时候做A任务，低电平的时候不能对A任务进行操作，这样就可以了，下面结合代码进行说明。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PWM</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10000</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        i = i + x;</span><br><span class="line">        <span class="keyword">if</span>(i % y == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Forward();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>极度简单的PWM函数，由有两个参数$x$和$y$，当$x=100$时， $y$的取值为200或300的时候，即A：PWM（100,200）和B：PWM（100,300），则在A情况下，有较多的时间处于Forward前进状态，在B任务下，处于前进状态的时间比少，即实现了利用PWM函数进行调速的功能。</p>
<h2 id="程序综合"><a href="#程序综合" class="headerlink" title="程序综合"></a>程序综合</h2><p>程序亲测可用，直接烧进去小车就拥有以上的全部功能啦。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg52.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">/****************1602**I/O口******************/</span></span><br><span class="line">sbit rs = P1^<span class="number">1</span>;</span><br><span class="line">sbit lcden = P3^<span class="number">3</span>;   <span class="comment">//外部中断入口</span></span><br><span class="line">sbit state = P0^<span class="number">7</span>;   <span class="comment">//1说明液晶繁忙</span></span><br><span class="line"><span class="comment">/*********模式选择端口************/</span></span><br><span class="line">sbit key = P2^<span class="number">4</span>;</span><br><span class="line"><span class="comment">/***************超声波**I/O口******************/</span></span><br><span class="line">sbit trig = P1^<span class="number">0</span>;                  </span><br><span class="line">sbit echo = P3^<span class="number">2</span>; </span><br><span class="line"><span class="comment">/******************寻迹IO口声明********************/</span></span><br><span class="line"><span class="comment">/*白线为0，黑线为1*/</span></span><br><span class="line">sbit trace1 = P3^<span class="number">5</span>;     <span class="comment">/*1路*/</span></span><br><span class="line">sbit trace2 = P2^<span class="number">5</span>;     <span class="comment">/*2路*/</span></span><br><span class="line">sbit trace3 = P2^<span class="number">6</span>;     <span class="comment">/*3路*/</span></span><br><span class="line"><span class="comment">/***************测试灯**I/O口******************/</span></span><br><span class="line">sbit led = P2^<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*****************电机驱动**IO口*****************/</span></span><br><span class="line"><span class="comment">/*使能端*/</span></span><br><span class="line">sbit em1 = P1^<span class="number">4</span>;        <span class="comment">//左后</span></span><br><span class="line">sbit em2 = P1^<span class="number">7</span>;        <span class="comment">//右后</span></span><br><span class="line">sbit em3 = P2^<span class="number">7</span>;        <span class="comment">//右前</span></span><br><span class="line">sbit em4 = P2^<span class="number">3</span>;        <span class="comment">//左前</span></span><br><span class="line"><span class="comment">/*电机口*/</span></span><br><span class="line">sbit in1 = P1^<span class="number">2</span>;        <span class="comment">//左后</span></span><br><span class="line">sbit in2 = P1^<span class="number">3</span>;</span><br><span class="line">sbit in3 = P1^<span class="number">5</span>;        <span class="comment">//右后</span></span><br><span class="line">sbit in4 = P1^<span class="number">6</span>;</span><br><span class="line">sbit in5 = P3^<span class="number">6</span>;        <span class="comment">//右前</span></span><br><span class="line">sbit in6 = P3^<span class="number">7</span>;</span><br><span class="line">sbit in7 = P2^<span class="number">1</span>;        <span class="comment">//左前</span></span><br><span class="line">sbit in8 = P2^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************定义全局变量******************/</span></span><br><span class="line">uchar table1[] = <span class="string">"Distance:"</span>;     <span class="comment">//1602显示</span></span><br><span class="line">uchar table2[] = <span class="string">"cm"</span>;</span><br><span class="line">uchar table3[] = <span class="string">"Tracing"</span>;</span><br><span class="line">uchar flag_ula;               <span class="comment">//超声波接收标志</span></span><br><span class="line"><span class="keyword">float</span> distance;               <span class="comment">//计算距离</span></span><br><span class="line">uchar bluetoothdata;          <span class="comment">//接受蓝牙串口数据</span></span><br><span class="line"><span class="comment">/****************函数声明******************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*****************宏定义******************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cycle   15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cycle1  100</span></span><br><span class="line"><span class="comment">/***********************延时类函数***********************/</span></span><br><span class="line"><span class="comment">/*毫秒延时*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delayms</span><span class="params">(uint x)</span>            </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint a, b;</span><br><span class="line">    <span class="keyword">for</span>(a = x; a &gt; <span class="number">0</span>; a--)</span><br><span class="line">        <span class="keyword">for</span>(b = <span class="number">110</span>; b &gt; <span class="number">0</span>; b--); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*微妙延时*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay10us</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> i)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> j; </span><br><span class="line">    <span class="keyword">do</span>&#123; </span><br><span class="line">        j = <span class="number">10</span>; </span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123; </span><br><span class="line">            _nop_(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(--j); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(--i); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/***************初始化中断************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">init_T0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TMOD = <span class="number">0x20</span>;  </span><br><span class="line">    TH0 = <span class="number">0</span>;          </span><br><span class="line">    TL0 = <span class="number">0</span>;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    IT0 = <span class="number">1</span>;       <span class="comment">//外部0中断的中断方式为：下降沿中断</span></span><br><span class="line">    ES = <span class="number">1</span>;        <span class="comment">//开串口中断</span></span><br><span class="line">    SCON = <span class="number">0x50</span>;                        </span><br><span class="line">    TMOD = <span class="number">0x20</span>;</span><br><span class="line">    PCON = <span class="number">0x00</span>;</span><br><span class="line">    TH1 = <span class="number">0xfd</span>;</span><br><span class="line">    TL1 = <span class="number">0xfd</span>;</span><br><span class="line">    RI = <span class="number">0</span>;       <span class="comment">//RI清零  </span></span><br><span class="line">    TR1 = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***************测量距离******************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">meas_distance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">        TMOD = <span class="number">0X01</span>;</span><br><span class="line">        trig = <span class="number">0</span>;</span><br><span class="line">        Delay10us(<span class="number">2</span>);</span><br><span class="line">        trig = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (trig == <span class="number">1</span>)&#123; Delay10us(<span class="number">2</span>);&#125;</span><br><span class="line">        trig = <span class="number">0</span>;</span><br><span class="line">        trig = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(trig == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TR0 = <span class="number">1</span>;            </span><br><span class="line">            EX0 = <span class="number">1</span>;</span><br><span class="line">            Delayms(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(flag_ula == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag_ula = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;trig = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***************利用中断计算距离*****************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time1</span><span class="params">()</span> interrupt 0   <span class="comment">// </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    TR0 = <span class="number">0</span>;                 <span class="comment">//一旦受到下降沿，立马停止定时器计数</span></span><br><span class="line">    Delay10us(<span class="number">10</span>);</span><br><span class="line">    distance = (TH0 * <span class="number">256</span> + TL0) * <span class="number">1.09</span> / <span class="number">58</span> - <span class="number">8</span>; <span class="comment">//先取出定时器里的时间值，之后再将定时器置0  </span></span><br><span class="line">    flag_ula = <span class="number">1</span>;<span class="comment">//将标志位置0  </span></span><br><span class="line">    TH0 = <span class="number">0</span>;  </span><br><span class="line">    TL0 = <span class="number">0</span>;</span><br><span class="line">    TMOD = <span class="number">0x20</span>;             <span class="comment">//计算距离的TMOD是0x01，计算完后恢复0x20，不然不工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************1602类**************************/</span></span><br><span class="line"><span class="comment">/*液晶是否繁忙*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P0 = <span class="number">0xff</span>;</span><br><span class="line">    rs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(state == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        lcden = <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_com</span><span class="params">(uchar com)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wait();</span><br><span class="line">    rs = <span class="number">0</span>;</span><br><span class="line">    P0 = com;</span><br><span class="line">    lcden = <span class="number">0</span>;</span><br><span class="line">    Delayms(<span class="number">10</span>);</span><br><span class="line">    lcden = <span class="number">1</span>;</span><br><span class="line">    Delayms(<span class="number">10</span>);</span><br><span class="line">    lcden = <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_date</span><span class="params">(uchar date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wait();</span><br><span class="line">    rs = <span class="number">1</span>;</span><br><span class="line">    P0 = date;</span><br><span class="line">    Delayms(<span class="number">10</span>);</span><br><span class="line">    lcden = <span class="number">1</span>;</span><br><span class="line">    Delayms(<span class="number">10</span>);</span><br><span class="line">    lcden = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init1602</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wait();</span><br><span class="line">    lcden = <span class="number">0</span>;</span><br><span class="line">    write_com(<span class="number">0x38</span>);</span><br><span class="line">    Delayms(<span class="number">10</span>);</span><br><span class="line">    write_com(<span class="number">0x0c</span>);</span><br><span class="line">    Delayms(<span class="number">10</span>);</span><br><span class="line">    write_com(<span class="number">0x06</span>);</span><br><span class="line">    Delayms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">float</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> dis1 = dis;</span><br><span class="line">    uchar  bai, shi, ge, p1, p2;</span><br><span class="line">    <span class="keyword">if</span>(dis1 &lt; <span class="number">20</span>)      <span class="comment">//用的局部变量dis1设置自动避障，用全局变量distance设置是不对的。</span></span><br><span class="line">    &#123;</span><br><span class="line">        led = <span class="number">0</span>;</span><br><span class="line">        Stop();</span><br><span class="line">        Delayms(<span class="number">50</span>);</span><br><span class="line">        Reverse();</span><br><span class="line">        Delayms(<span class="number">500</span>);</span><br><span class="line">        Stop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                <span class="comment">//自动避障时灯亮一下</span></span><br><span class="line">    &#123;</span><br><span class="line">        led = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bai = (dis1 / <span class="number">100</span>);                          <span class="comment">//浮点不能取模运算</span></span><br><span class="line">    shi = (dis1 - bai * <span class="number">100</span>) / <span class="number">10</span>;  </span><br><span class="line">    ge = dis1 - bai * <span class="number">100</span>-shi * <span class="number">10</span>;</span><br><span class="line">    p1 = (dis1 * <span class="number">10</span>) - bai * <span class="number">1000</span> - shi * <span class="number">100</span> - ge * <span class="number">10</span>;  </span><br><span class="line">    p2 = (dis1 * <span class="number">100</span>) - bai * <span class="number">10000</span> - shi * <span class="number">1000</span> - ge * <span class="number">100</span> - p1 * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    write_date(<span class="number">0x30</span> + bai);<span class="comment">//将数字转换为字符，必须+0x30，</span></span><br><span class="line">    Delay10us(<span class="number">10</span>); </span><br><span class="line">    write_date(<span class="number">0x30</span> + shi);<span class="comment">//另外，1602液晶只能接收字符型的数据   </span></span><br><span class="line">    Delay10us(<span class="number">10</span>);</span><br><span class="line">    write_date(<span class="number">0x30</span> + ge);</span><br><span class="line">    Delay10us(<span class="number">10</span>);  </span><br><span class="line">    write_date(<span class="string">'.'</span>);</span><br><span class="line">    Delay10us(<span class="number">10</span>);  </span><br><span class="line">    write_date(<span class="number">0x30</span> + p1);</span><br><span class="line">    Delay10us(<span class="number">10</span>);  </span><br><span class="line">    write_date(<span class="number">0x30</span> + p2);</span><br><span class="line">    Delay10us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar a;</span><br><span class="line">    init1602();</span><br><span class="line"></span><br><span class="line">    write_com(<span class="number">0x80</span>);     <span class="comment">//设置地址，在第一行第一列显示distance：，0x80是第一行的起始地址 </span></span><br><span class="line">    Delayms(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(a = <span class="number">0</span>; a &lt; <span class="number">9</span>; a++)</span><br><span class="line">    &#123;</span><br><span class="line">        write_date(table1[a]);</span><br><span class="line">        Delayms(<span class="number">5</span>);     </span><br><span class="line">    &#125;</span><br><span class="line">    write_com(<span class="number">0x80</span> + <span class="number">0x40</span> + <span class="number">6</span>);<span class="comment">//设置地址，在第二行第7位显示cm，0x80+0x40是第二行的起始地址  </span></span><br><span class="line">    <span class="keyword">for</span>(a = <span class="number">0</span>; a &lt; <span class="number">2</span>; a++)</span><br><span class="line">    &#123;</span><br><span class="line">        write_date(table2[a]);</span><br><span class="line">        Delayms(<span class="number">5</span>);     </span><br><span class="line">    &#125;</span><br><span class="line">        init_T0();</span><br><span class="line">        Delayms(<span class="number">1</span>);</span><br><span class="line">        meas_distance();</span><br><span class="line">        write_com(<span class="number">0x80</span> + <span class="number">0x40</span>); </span><br><span class="line">        Delayms(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">display</span>(distance);</span><br><span class="line">        Delayms(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************电机类***************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Forward</span><span class="params">()</span> <span class="comment">//前进</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in1 = <span class="number">1</span>;</span><br><span class="line">    in2 = <span class="number">0</span>;</span><br><span class="line">    in3 = <span class="number">1</span>;</span><br><span class="line">    in4 = <span class="number">0</span>;</span><br><span class="line">    in5 = <span class="number">1</span>;</span><br><span class="line">    in6 = <span class="number">0</span>;</span><br><span class="line">    in7 = <span class="number">1</span>;</span><br><span class="line">    in8 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span>    <span class="comment">//停止</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in1 = <span class="number">0</span>;</span><br><span class="line">    in2 = <span class="number">0</span>;</span><br><span class="line">    in3 = <span class="number">0</span>;</span><br><span class="line">    in4 = <span class="number">0</span>;</span><br><span class="line">    in5 = <span class="number">0</span>;</span><br><span class="line">    in6 = <span class="number">0</span>;</span><br><span class="line">    in7 = <span class="number">0</span>;</span><br><span class="line">    in8 = <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">()</span>  <span class="comment">//倒车</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in1 = <span class="number">0</span>;</span><br><span class="line">    in2 = <span class="number">1</span>;</span><br><span class="line">    in3 = <span class="number">0</span>;</span><br><span class="line">    in4 = <span class="number">1</span>;</span><br><span class="line">    in5 = <span class="number">0</span>;</span><br><span class="line">    in6 = <span class="number">1</span>;</span><br><span class="line">    in7 = <span class="number">0</span>;</span><br><span class="line">    in8 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Turn_left</span><span class="params">()</span>  <span class="comment">//左转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in1 = <span class="number">0</span>;</span><br><span class="line">    in2 = <span class="number">1</span>;</span><br><span class="line">    in3 = <span class="number">1</span>;</span><br><span class="line">    in4 = <span class="number">0</span>;</span><br><span class="line">    in5 = <span class="number">1</span>;</span><br><span class="line">    in6 = <span class="number">0</span>;</span><br><span class="line">    in7 = <span class="number">0</span>;</span><br><span class="line">    in8 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Turn_right</span><span class="params">()</span>   <span class="comment">//右转   </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in1 = <span class="number">1</span>;</span><br><span class="line">    in2 = <span class="number">0</span>;</span><br><span class="line">    in3 = <span class="number">0</span>;</span><br><span class="line">    in4 = <span class="number">1</span>;</span><br><span class="line">    in5 = <span class="number">0</span>;</span><br><span class="line">    in6 = <span class="number">1</span>;</span><br><span class="line">    in7 = <span class="number">1</span>;</span><br><span class="line">    in8 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************寻迹函数***********************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trace</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>((trace1 == <span class="number">0</span>) &amp;&amp; (trace2 == <span class="number">0</span>))       <span class="comment">//0代表检测到黑线</span></span><br><span class="line">    &#123;  </span><br><span class="line">        Stop();</span><br><span class="line">        Delayms(<span class="number">5</span>);</span><br><span class="line">        Forward();</span><br><span class="line">        Delayms(cycle);                   </span><br><span class="line">        Stop();                           <span class="comment">//防止小车走的太快  </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((trace1 == <span class="number">0</span>) &amp;&amp; (trace2 == <span class="number">1</span>))       <span class="comment">//0代表检测到黑线</span></span><br><span class="line">    &#123;  </span><br><span class="line">        Stop();</span><br><span class="line">        Delayms(<span class="number">5</span>);</span><br><span class="line">        Turn_right();                   <span class="comment">//这个cycle与两路寻迹模块之间的距离有关</span></span><br><span class="line"><span class="comment">//当距离过小时，右转的幅度会偏大，使小车脱离轨道，cycle参数根据实际情况自己设置，所以设置了</span></span><br><span class="line"><span class="comment">//宏定义，改动方便。</span></span><br><span class="line">        Delayms(cycle);</span><br><span class="line">        Stop();     </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((trace1 == <span class="number">1</span>) &amp;&amp; (trace2 == <span class="number">0</span>))       <span class="comment">//0代表检测到黑线</span></span><br><span class="line">    &#123;  </span><br><span class="line">        Stop();</span><br><span class="line">        Delayms(<span class="number">5</span>);</span><br><span class="line">        Turn_left();</span><br><span class="line">        Delayms(cycle);</span><br><span class="line">        Stop(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((trace1 == <span class="number">1</span>) &amp;&amp; (trace2 == <span class="number">1</span>))  </span><br><span class="line">    &#123;  </span><br><span class="line">        Stop();</span><br><span class="line">        Delayms(<span class="number">5</span>);</span><br><span class="line">        Forward();</span><br><span class="line">        Delayms(cycle);</span><br><span class="line">        Stop(); </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PWM</span><span class="params">(uint x, uint y)</span>   <span class="comment">//x = 100, y = 200或300</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">10000</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        i = i + x;</span><br><span class="line">        <span class="keyword">if</span>(i % y == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Forward();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/******************主函数****************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        init_T0();</span><br><span class="line">        show();                   <span class="comment">//安静的等待蓝牙中断的发生。   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ckzd</span><span class="params">()</span> interrupt 4   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(RI)</span><br><span class="line">    &#123;</span><br><span class="line">        RI = <span class="number">0</span>;</span><br><span class="line">        bluetoothdata = SBUF;</span><br><span class="line">    &#125;   </span><br><span class="line">    Delayms(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">switch</span>(bluetoothdata)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'f'</span>: Forward();<span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="string">'s'</span>: Stop();  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'l'</span>: Turn_left();  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'i'</span>: Turn_right();  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'r'</span>: Reverse();  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'T'</span>: </span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Trace();</span><br><span class="line">                    <span class="keyword">if</span>(RI)               <span class="comment">//如果收到其他命令，则退出寻迹</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'x'</span>: <span class="keyword">while</span>(<span class="number">1</span>)               <span class="comment">//低速</span></span><br><span class="line">                  &#123;</span><br><span class="line">                        PWM(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">                        <span class="keyword">if</span>(RI)</span><br><span class="line">                        &#123;</span><br><span class="line">                            Stop();</span><br><span class="line">                            Delayms(<span class="number">50</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'y'</span>: <span class="keyword">while</span>(<span class="number">1</span>)                        <span class="comment">//高速</span></span><br><span class="line">                &#123;</span><br><span class="line">                    PWM(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">if</span>(RI)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Stop();</span><br><span class="line">                        Delayms(<span class="number">50</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="keyword">break</span>;                                          </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="手机端指令"><a href="#手机端指令" class="headerlink" title="手机端指令"></a>手机端指令</h2><p><img data-src="/2018/05/25/c513/7.png" alt></p>
<hr>
]]></content>
      <tags>
        <tag>microcomputer</tag>
      </tags>
  </entry>
  <entry>
    <title>因果扩张卷积</title>
    <url>/2021/03/10/causal-dilated-conv/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前一直在看他们用『<strong>因果扩张卷积</strong>』这个东西，当时我只看到了一张图，大概了解了那是个什么东西。今天，在某次比赛中用到了这个模型，顺手看了下源代码，来做个整理。</p>
<a id="more"></a>
<p>在时序序列的预测问题中，很容易想到LSTM等循环神经网络。给定序列数据，预测下一时刻的输出，如翻译、问答等。</p>
<p>\begin{equation}<br>p(x)=\prod_{t=1}^T P(x_t|x_{t-1},…,x_1)<br>\end{equation}</p>
<p>当然也可以有隐藏状态：</p>
<p>\begin{equation}<br>p(x|h)=\prod_{t=1}^T P(x_t|x_{t-1},…,x_1, h)<br>\end{equation}</p>
<p>时至今日，也可以用 CNN 来代替这一过程，卷积的输入是历史数据，产生一个时刻的输出。且，相对而言 CNN 的参数要少很多，也可以叠加 CNN 层。需要注意的是，因果扩张卷积包括因果卷积和扩张卷积两部分。</p>
<h1 id="扩张卷积"><a href="#扩张卷积" class="headerlink" title="扩张卷积"></a>扩张卷积</h1><p>扩张卷积是为了增大卷积核感受野而设计的一种东西，看图就知道了：</p>
<p><img data-src="https://s3.ax1x.com/2021/03/10/6JPvCt.gif" alt></p>
<p>卷积核与图像计算时填充了间隙，在移动相同步伐的情况下，能卷积更多的数据，这样就能扩大视感受野。这里的扩张步是2。代码实现也很简单，指定参数即可：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">model = torch.nn.Conv2d(in_channels, out_channels, kernel_size, dilation=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>默认情况下<code>dilation</code>取值为1，也就是没有扩张。</p>
<h1 id="因果卷积"><a href="#因果卷积" class="headerlink" title="因果卷积"></a>因果卷积</h1><p>因果卷积的重点突出在<strong>因果</strong>两个字上，输入的历史数据是因，输出的数据是果。来看一下模型结构图，这里有三层卷积网络。</p>
<p><img data-src="/2021/03/10/causal-dilated-conv/1.png" alt></p>
<p>第一层的卷积块读取几个历史数据，经过后几层的卷积块后输出一个数据，达到预测的目的。</p>
<p>但是，在逐层卷积的同时，每步只卷积两个模块。这就导致了视野域比较小。所以增加了扩张卷积，来增大网络的感受野，即：每次预测时能比之前看到更多的数据，做出更稳定的决策。此时的网络结构为：</p>
<p><img data-src="https://s3.ax1x.com/2021/03/10/6Jc9hT.png" alt></p>
<p>可以看到网络在预测输出时，能看到16个数据的信息，比之前的5个数据的信息要多出三倍，做出的决策也会更加稳定。在某种意义上，也就能像LSTM那样处理序列数据了。</p>
<p>也会你会有疑问，<code>1</code>号节点有历史数据，假设<code>1</code>号节点已经是输出序列的最后一个元素了，那<code>2</code>号节点和<code>3</code>号节点呢，他们的输入从哪里来？看了代码我才明白，填充即可，也就是<code>conv</code>里面常用的<code>padding</code>。卷积过程保证输入和输出的长度不变，填充多少，</p>
<p>至于残差连接或加入条件信息，这些都是可以的，在<a href="https://arxiv.org/pdf/1609.03499.pdf" target="_blank" rel="noopener"> casual dilated conv </a>首次被提出的论文中都有这些内容。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>读懂一个算法精髓最好的方式是读<a href="https://github.com/muyuuuu/Algorithm/blob/master/causal-dilated-conv/casualCNN.py" target="_blank" rel="noopener">代码</a>，理解一个算法精髓最好的方式是尝试去理解它为什么这么做，而不是这么做有什么好处。</p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>计算器问题</title>
    <url>/2022/04/13/calculator/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算器问题大约在大二数据结构的课程上学过，当时是使用栈来解决，此外还需要设置很多符号的优先级，以此判断是否弹栈，代码写的很长很麻烦。今天又遇到了这种题，也有了简单的解法，做一个整理。</p>
<a id="more"></a>
<p>计算器的难点在于先算乘除后算加减，如果有小括号，需要先算括号里面的内容。因此从简往难，一点点的来看问题如何解决。</p>
<h2 id="无括号"><a href="#无括号" class="headerlink" title="无括号"></a>无括号</h2><p>无括号相对简单一些，我们只需要考虑先算乘除后算加减即可。那么思路就是：如果当前符号是加法或减法，那么将符号连带数字压入栈中，比如 +10 或 -11；如果遇到的是乘法或除法，那么就需要把栈尾的元素拿出来，做乘法或除法运算在放入栈中。最后，对栈内的元素求和即可。</p>
<p>我们来看程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> subcal(s, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subcal</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span>&amp; idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                num = <span class="number">10</span> * num + (c - <span class="string">'0'</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">' '</span> || i == s.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sign == <span class="string">'+'</span>) &#123;</span><br><span class="line">                    stk.push(num);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'-'</span>) &#123;</span><br><span class="line">                    stk.push(-num);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(tmp * num);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'/'</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(tmp / num);</span><br><span class="line">                &#125;</span><br><span class="line">                sign = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (stk.size()) &#123;</span><br><span class="line">            res += stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>程序中有很多的细节，一点点来分析：</p>
<ul>
<li><code>sign</code> 初始值为 <code>+</code>，这样如果开头的数字是正数，那么这个数会被放入栈中；如果开头的数字是负数，那么栈中先放入 0，在放入负数，不影响。</li>
<li>符号 <code>c</code> 的判断不构成 if-else-if 关系，因为当 <code>i=s.size()-1</code> 的时候，需要处理最后一个数字。即，<code>c</code> 是数字且是最后一个字符的情况下，需要经过这两个分支的处理。</li>
</ul>
<h2 id="有括号"><a href="#有括号" class="headerlink" title="有括号"></a>有括号</h2><p>右括号就比较烦人，因为括号的优先级高于一切，需要找到最内部的括号，逐层往外回退得到答案。而这，也让人容易联想到传说中的递归。</p>
<p>那么递归需要记录关于括号的哪些东西呢？想法自然是遇到一个左括号，那么就计算括号内部的东西，遇到右括号返回。之后跳过括号里面的内容，计算下一个表达式。括号中的括号也是同理。我们来看程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> subcal(s, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subcal</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span>&amp; idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">                num = <span class="number">10</span> * num + (c - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                num = subcal(s.substr(i+<span class="number">1</span>), idx);</span><br><span class="line">                i += (idx + <span class="number">2</span>);</span><br><span class="line">                c = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">' '</span> || i == s.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sign == <span class="string">'+'</span>)</span><br><span class="line">                    stk.push(num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'-'</span>)</span><br><span class="line">                    stk.push(-num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(num * tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'/'</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(tmp / num);</span><br><span class="line">                &#125;</span><br><span class="line">                sign = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(stk.size()) &#123;</span><br><span class="line">            res += stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样来解读一下：</p>
<ul>
<li>如果遇到右括号，记录索引，表示当前括号的内容计算完了，退出。</li>
<li>如果遇到左括号，那么计算左括号后面子串的内容得到数字，<code>i=i+(idx+2)</code> 的意思是，跳到右括号后面第一个字符继续计算，+2 为什么是后面第一个字符呢？因为 substr(i+1) 了，这里向后移动了一位，对于 i 来说，+2 才是后面的第一位。</li>
</ul>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>集群资源监控与任务调度</title>
    <url>/2021/03/26/cluster-monitor-and-taskAssignment/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前阵子写了个集群计算资源监控程序，我觉得架构设计的还行，于是来整理成一篇博客。内容只有架构，不含代码，因为自己的实验室要用。<del>利益相关，人在美国，刚下飞机，懂的自然懂，匿了匿了。</del></p>
<a id="more"></a>
<h1 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h1><p>首先来看一下集群的结构，也就是计算节点如何连接，以及每个计算节点配备的计算资源如何，方便编写后续程序。</p>
<p><img data-src="https://z3.ax1x.com/2021/03/31/ck5RyR.png" alt></p>
<p>首先 <code>ssh</code> 到登录节点，而后可以由登录节点前往各个计算节点，假设这里一共由 <code>N</code> 个计算节点。其中，第 <code>M</code> 个计算节点配备了 <code>n</code> 个 GPU。这里就假设要监控 GPU 资源了，如果要监控 CPU 资源，一个道理。</p>
<h1 id="多线程工作模式"><a href="#多线程工作模式" class="headerlink" title="多线程工作模式"></a>多线程工作模式</h1><p>既然要监控这么多 GPU 的占用情况，轮询显然是一种最差的做法，毕竟 ssh 过去有网络延迟，且<strong>同步阻塞</strong>调用的方式效率很是低下。首先通过多线程的形式，将阻塞调用改为<strong>异步非阻塞调用</strong>。</p>
<p>这里，我们创建一个子线程去完成 GPU 负载信息的查询任务，使其不影响主进程的执行，这实现了<strong>异步</strong>；在子线程查询 GPU 负载信息时，再次创建多个子线程并发的完成查询，对于结果的返回选择<strong>非阻塞</strong>的方式，啥时候结果执行完了反馈回来就行；但多个子线程<strong>阻塞</strong>了子线程的执行，因为毕竟要等到多个子线程拿到结果才能返回，不然白执行一趟。理论上这里也应该非阻塞，但非阻塞也不需要去执行其他任务，索性让它阻塞在这里。</p>
<p>当然，我这里计算节点很少，可以为每个节点创建一个线程。当面临成百上千个计算节点时，可以分组创建线程，一次性创建这么多线程，维护、切换之类的开销太大了。</p>
<p>此时多线程的调用结构图如下所示：</p>
<p><img data-src="https://z3.ax1x.com/2021/03/31/ckLviq.png" alt></p>
<p>主进程核心代码如下：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主进程创建子线程定期轮询</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">monitor</span><span class="params">(compute_num, shell_path, timeout)</span>:</span></span><br><span class="line">    set_gpu_infoes_list(</span><br><span class="line">        get_all_gpu_node_info(compute_num, shell_path, timeout))</span><br><span class="line">    threading.Timer(interval, monitor, (compute_num, shell_path, timeout)).start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    th = threading.Timer(interval, monitor, (compute_num, shell_path, timeout))</span><br><span class="line">    <span class="comment"># 子线程去访问GPU信息，主进程干其他的</span></span><br><span class="line">    th.start()</span><br></pre></td></tr></table></figure></p>
<p>子线程核心代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 子线程创建多个子线程去查询</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_gpu_node_info</span><span class="params">(compute_num, shell_path, timeout)</span>:</span></span><br><span class="line">    task_list = []</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, compute_num+<span class="number">1</span>):</span><br><span class="line">        params = &#123;&#125;</span><br><span class="line">        params[<span class="string">'hostname'</span>] = <span class="string">'gpu0&#123;&#125;'</span>.format(i)</span><br><span class="line">        params[<span class="string">'shell_path'</span>] = shell_path</span><br><span class="line">        params[<span class="string">'timeout'</span>] = timeout</span><br><span class="line">        <span class="comment"># 创建线程</span></span><br><span class="line">        task = athread.AThread(get_single_gpu_node_info, args=params)</span><br><span class="line">        task_list.append(task)</span><br><span class="line">        task.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> task_list:</span><br><span class="line">        <span class="comment"># 等待每个线程结束</span></span><br><span class="line">        task.join()</span><br><span class="line">        result.append(task.get_result())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1 id="log-写出"><a href="#log-写出" class="headerlink" title="log 写出"></a>log 写出</h1><p>这个是为了记录计算资源的历史使用信息准备的，每个计算节点一个 log 文件，每个 log 文件限长 1000 行，超过 1000 行后就先入先出处理掉。</p>
<h1 id="socket-通信"><a href="#socket-通信" class="headerlink" title="socket 通信"></a>socket 通信</h1><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://juejin.cn/post/6844903817348136968" target="_blank" rel="noopener">什么是消息队列</a></li>
<li><a href="https://myblog.huajianjiang.com/post/detail/python-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%BA%E4%BA%8E-redis-%E5%90%8E%E7%AB%AF%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">消息队列实现</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/52845869" target="_blank" rel="noopener">上下文切换</a></li>
</ol>
]]></content>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学笔记</title>
    <url>/2020/02/17/cg/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当时为了增长业余知识，在<code>MOOC</code>上听完了中国农业大学的计算机图形学这门课，后面几章的方程没有听，仅仅听到了三维变换。这是当时的电子版笔记，后来发现电子版笔记是真的累人，累倒有的笔记都不想放上来了。这是第一次，也是最后一次。</p>
<p>当然感觉这些东西还是挺有意思的，就准备放上来。如果你是华北理工大学的学生选了这门课，把这个网页里的内容看完85+也没问题了（缺少二维变换的例题，主要是太长了，真懒的写了。还有一些基础概念靠自己的悟性了）。</p>
<a id="more"></a>
<h1 id="Chapter-01-计算机图形学概述"><a href="#Chapter-01-计算机图形学概述" class="headerlink" title="Chapter-01 计算机图形学概述"></a>Chapter-01 计算机图形学概述</h1><h2 id="什么是计算机图形学"><a href="#什么是计算机图形学" class="headerlink" title="什么是计算机图形学"></a>什么是计算机图形学</h2><ul>
<li>计算机图形：由计算机产生的图像。</li>
<li>计算机图形学是研究如何利用计算机显示、生成和处理图形的原理、方法和技术的一门学科。</li>
<li>是真实世界或者虚拟世界的数字模拟。</li>
</ul>
<h2 id="计算机图形学的研究内容"><a href="#计算机图形学的研究内容" class="headerlink" title="计算机图形学的研究内容"></a>计算机图形学的研究内容</h2><ul>
<li>包括计算机图形学中定义的内容；</li>
<li>图形硬件，显示器，图形加速卡，图形输出设备(不重要)</li>
<li>基本图形元素的生成算法</li>
<li>图形的变换和裁剪</li>
<li>自由曲线、曲面的生成算法</li>
<li>几何造型技术</li>
<li>真实感图形的生成算法</li>
<li>计算机动画、虚拟现实、交互式三维图形处理</li>
</ul>
<p><strong>计算机生成物体的三个步骤</strong>：</p>
<ul>
<li>几何造型：规则物体应该建立生成图像的物理模型，即对应的几何数据和拓扑关系；非规则的工具表示不规则物体；几何造型技术：用简单的体素(圆柱、圆锥等)构建复杂的模型。</li>
<li>光照模型：表示颜色，表示光源；使用简单的数学模型表示、近似为实际中的物理学中的光学模型。</li>
<li>绘制(渲染)技术：选择恰当的算法渲染将场景渲染出来，将模型真实的显示在屏幕上。</li>
</ul>
<p>计算机屏幕由像素构成，像素是构成图形的基本单位。为了显示图形，需要研究哪些像素显示图形，显示哪些颜色，也就有了光栅显示器(70年代)中的一套算法。</p>
<h2 id="计算机图形学的应用领域"><a href="#计算机图形学的应用领域" class="headerlink" title="计算机图形学的应用领域"></a>计算机图形学的应用领域</h2><ul>
<li>人机交互GUI(Windows, Icon, Mouse, Pointer)</li>
<li>计算机辅助制造(CAD, 电路设计)</li>
<li>真实感图形绘制(计算机重现自然界真实场景)与自然景物仿真</li>
<li>计算机游戏、动画、电影</li>
<li>计算机艺术：钢笔画、油画</li>
<li>计算机仿真：二维、三维结果的表示</li>
<li>科学计算与可视化</li>
<li>虚拟现实</li>
<li>地理信息系统(geographic information system)，如三维地图重建</li>
<li>农业种植模拟</li>
</ul>
<h2 id="计算机图形系统的组成"><a href="#计算机图形系统的组成" class="headerlink" title="计算机图形系统的组成"></a>计算机图形系统的组成</h2><p>输入、输出、计算、交互、存储是五个最基本的功能。</p>
<p>图形系统由图形软件和图形硬件组成。</p>
<ul>
<li>图形软件：<ul>
<li>图形应用数据结构： 对应图形的数据文件，存放欲生成的图形的全部描述信息。</li>
<li>图形应用软件：核心部分，解决某个问题的软件，包含图形生成处理等个重技术，如Photoshop。</li>
<li>图形支撑软件：是图形应用软件的底层，有规范的接口。</li>
</ul>
</li>
<li>图形硬件：包括图形计算机平台和图形设备(如显示器)。</li>
</ul>
<p>实现图形软件的放歌方法：用子程序写包(如OpenGL)，扩充计算机语言，设计专用的图形系统。</p>
<h2 id="交互式计算机图形处理系统"><a href="#交互式计算机图形处理系统" class="headerlink" title="交互式计算机图形处理系统"></a>交互式计算机图形处理系统</h2><p>图形系统中重要的为：图形处理器、图形输入、输出设备。</p>
<ul>
<li>图形输入设备：穿孔纸$\rightarrow$键盘,光笔$\rightarrow$鼠标,触摸屏$\rightarrow$三维输入设备$\rightarrow$智能人机接口:用户语音、手势等。</li>
<li>图形输出设备：图形的输出包括图形的显示和绘制，显示是指在屏幕上输出图形，图形的绘制是指将图形画在纸上，如打印机。<ul>
<li>CRT显示器：阴极射线管，加热电子轰击荧光屏，荧光屏有三种颜色。</li>
<li>LCD液晶显示器：液晶粒子每一面的颜色为红绿蓝，按照收到的数据控制每个粒子转向对应的面，以此来显示颜色。(用于电脑显示)</li>
<li>LED显示器：发光二极管。(光源器件用于照明，如广告牌)</li>
<li>等离子显示器：厚度薄，分辨率好。显示屏排列小低压气体室，电流激发紫外光，紫外光撞击三原色的屏幕，发出可见光。</li>
<li>3D显示器：不用戴眼镜即可看到，用的时差栅栏技术。</li>
</ul>
</li>
</ul>
<p><strong>帧缓冲器与屏幕像素</strong></p>
<p>帧缓冲器每一点可以存储颜色、强度信息，在计算机上画图形，需要计算每个像素的RGB值，因此帧缓存写RGB等价于屏幕画图像。帧缓冲器的单元个数和像素总数相同，存储单元一一对应可寻址的屏幕像素位置。</p>
<ul>
<li>分辨率：一行有几个点，一共多少行。<ul>
<li>屏幕分辨率：屏幕上显示的像素的个数。</li>
<li>显示分辨率：对于文本的显示方式，水平和垂直方向上能显示的字符总数的乘积表示；对于图形显示方式，水平和垂直能显示的像素点数的乘积表示。</li>
<li>显卡分辨率：显卡输出给显示器，并能在显示器上扫描的像素点的数量。电脑的最高分辨率取决于显卡和显示器的最低分辨率。</li>
</ul>
</li>
<li>帧缓冲器的存储单元的位长决定了一副画面能显示的颜色的种类。(256色需要8bit， $2^8=256$)</li>
<li>显存的大小：2MB显存，分辨率$1204\times 768$，每个帧缓冲器的存储单元的位长：$x = 2\times 1204\times 1024 \div 1024 \div 768$，则$2\leq x \leq 3$，最多需要两个字节表示，故支持64K色彩数。</li>
</ul>
<p><strong>显示器的点距</strong></p>
<p>相邻像素点的距离，距离越小越好。028mm足够，小于则更好。</p>
<p><strong>显卡的作用与性能指标</strong></p>
<p>基本作用是显示图文，显示卡与显示器构成了计算机的显示系统。除了CPU与内存外，显卡对计算机的显示性能起了决定性作用。(也可以处理数据)</p>
<h2 id="图形与图像的区别"><a href="#图形与图像的区别" class="headerlink" title="图形与图像的区别"></a>图形与图像的区别</h2><ul>
<li>图形：计算机绘制，矢量图。</li>
<li>图像：认为用外部设备拍摄捕捉，点阵图。</li>
</ul>
<p>图形图像的构成属性</p>
<ul>
<li>几何属性：几何要素，轮廓，形状，点线面。(如圆心、半径)</li>
<li>非几何属性：视觉属性，颜色，材质，明暗，透明度，纹理。</li>
</ul>
<p>图形分类</p>
<ul>
<li>几何属性很重要：基于线条信息表示，如等高图、工程图。</li>
<li>非几何属性很重要：明暗图，通常的真实感图形。</li>
</ul>
<p><strong>矢量图与位图的区分</strong></p>
<p>两者可以相互转换，矢量扫描转换到点阵，点阵图像处理到矢量。</p>
<ul>
<li>概念区分：<ul>
<li>位图：点阵图，图由屏幕上的像素构成，每个点用二进制表述颜色与明暗。</li>
<li>矢量图：数学描述曲线及曲线围成的色块制作的图形。矢量图中的图形元素也成为对象。每个对象自成一个实体，具有颜色、形状、大小和位置等属性。</li>
</ul>
</li>
<li>存储方式的区别：<ul>
<li>点阵文件存储每个像素点的位置、颜色和灰度信息(存储空间大)</li>
<li>矢量文件用数学方程对图形进行描述，用图形的形状参数和属性参数表示图形</li>
</ul>
</li>
<li>缩放的区别：<ul>
<li>位图与分辨率有关，在一定面积上含有固定数量的元素，所以放大后失真</li>
<li>不会影响清晰度，无失真的放大缩小。</li>
</ul>
</li>
<li>存储格式的区别：<ul>
<li>位图：png, bmp, gif, jpeg</li>
<li>矢量图：eps, svg(scalable vector graphics), DXF(data exchange file), WMF, EMF.</li>
</ul>
</li>
</ul>
<p>位图更容易模仿真实感图形效果，矢量图不失真，用于文字设计、标志设计、插图等。</p>
<h1 id="Chapter-02-光栅图形学算法"><a href="#Chapter-02-光栅图形学算法" class="headerlink" title="Chapter-02 光栅图形学算法"></a>Chapter-02 光栅图形学算法</h1><p>出现了光栅显示器，为了在计算机上处理和显示图形，需要一套算法。属于计算机图形的底层算法，设计了计算机图形学的基本概念和思想。</p>
<h2 id="直线段的扫描转换算法-1"><a href="#直线段的扫描转换算法-1" class="headerlink" title="直线段的扫描转换算法(1)"></a>直线段的扫描转换算法(1)</h2><p>直线无限，而像素有限，所以要用有限的像素逼近无限的直线，所以可能存在锯齿情况，不够理想。</p>
<p>问题：求每个像素点的$x, y$坐标。</p>
<p>求解：</p>
<p>过$P_0(x_0, y_0), P_1(x_1, y_1)$的直线$y=kx+b$ 得到 $k=\frac{y_1-y_0}{x_1-x_0}(x_1\neq x_0)$</p>
<p>假设$x$已知，从$x$的起点$x_0$开始，沿$x$前进一个像素，则步长为1。</p>
<p>计算相应的$y$值，因为像素坐标是整数，$y$需要+0.5，向下取整。</p>
<p>真实感图形往往调用成千上万次的画线程序，因此这个算法影响了图形的质量和显示速度。在函数$y=kx+b$中，存在$kx$的乘法运算，而计算机最快的运算是加法，所以接下来要取消乘法的运算。</p>
<h2 id="直线段的扫描转换算法-2"><a href="#直线段的扫描转换算法-2" class="headerlink" title="直线段的扫描转换算法(2)"></a>直线段的扫描转换算法(2)</h2><p>一共有三个比较出名的算法</p>
<ul>
<li>数值微分法(DDA)</li>
<li>中点画线法</li>
<li>Bresenham算法</li>
</ul>
<p><strong>DDA算法</strong></p>
<p>重要的思想为增量思想。设单位步长为一个像素。</p>
<script type="math/tex; mode=display">y_i=kx_i+b \Longrightarrow y_{i+1}=kx_{i+1}+b</script><script type="math/tex; mode=display">y_{i+1}=k(x_i+1)+b = kx_i+b+k = y_i+k</script><p>即：$y_{i+1}=y_i+k$，$k$是增量。$y_i$加$k$得到$y_{i+1}$，取消了乘法。当$|k|\leq 1$时，一切正常。参考下列例题。</p>
<p><strong>例题</strong></p>
<p>DDA算法扫描转换连接两点$P_0(0, 0)$，$P_1(5, 3)$的直线段。</p>
<p>$k=\frac{3-0}{5-0}=0.6$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$x$</th>
<th>$y$</th>
<th>int($y$+0.5)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>0 | 0 | 0<br>1 | 0.6 | 1<br>2 | 0.6+0.6 | 1<br>3 | 1.2 + 0.6 | 2<br>4 | 1.8 + 0.6 | 2<br>5 | 2.4 + 0.6 | 3</p>
<p><strong>思考</strong> </p>
<p>在DDA算法的$|k|&gt;1$时，如$(0, 0)$到$(2, 100)$画点，光栅点会很系数，点很少，没有办法表达直线(只是每个点亮)。此时不能$x+1$作为基本单位。</p>
<p>$y_{i+1}=y_i+k$，一般情况下，$y$和$k$都是小数，而且每一步都需要取整，唯一的改进方法是，将浮点数计算改为整数计算。</p>
<p>如果换一种直线方程的表达形式，是否可以改进效率。</p>
<p><strong>中点画线法</strong></p>
<p>直线的一般式：$F(x, y)=0$ 即 $Ax + By + C = 0$。</p>
<ul>
<li>直线上的点：$F(x, y) = 0$</li>
<li>直线上方的点：$F(x, y) &gt; 0$</li>
<li>直线下方的点：$F(x, y) &lt; 0$</li>
</ul>
<p>每次在最大位移方向走一步，另一个方向是否移动取决于中点误差项的判断。</p>
<p>对于$0\leq|k|\leq 1$，$x$在方向上加1， $y$方向是否加1需要判断。如下图所示：</p>
<p><img data-src="/2020/02/17/cg/midpoint1.png" alt></p>
<ul>
<li>交点$Q$在Midpoint上方时，$Q$距离$P_u$近；</li>
<li>交点$Q$在Midpoint下方时，$Q$距离$P_t$近；</li>
</ul>
<p>将$M$带入理想的只想方程，$F(x_m, y_m) = Ax_m + By_m + C$，记为距离$d$。</p>
<ul>
<li>当$d &lt; 0$时，$M$在$Q$下方，选择$P_u$</li>
<li>当$d &gt; 0$时，$M$在$Q$上方，选择$P_t$</li>
<li>当$d = 0$时， 选择$P_t$或者$P_u$都可以</li>
</ul>
<p>得到：</p>
<script type="math/tex; mode=display">d < 0 \Longrightarrow y_{i+1} = y_i+1</script><script type="math/tex; mode=display">d \geq 0 \Longrightarrow y_{i+1} = y</script><script type="math/tex; mode=display">d_i = A(x_i+1)+B(y_i+0.5)+C</script><p>上面的公式两个乘法，四个加法，所以要提升效率。</p>
<ol>
<li>在$d&lt;0$时</li>
</ol>
<p><img data-src="/2020/02/17/cg/midpoint2.png" alt></p>
<ul>
<li>在点$M_0$处，$d_0=F(x_{m0}, y_{m0})=A(x_i+1)+B(y_i+0.5)+C$</li>
<li>在点$M_1$处，$d_1=A(x_i+2) + B(y_i+1.5) + C=d_0+A+B$</li>
</ul>
<ol>
<li>在$d\geq 0$时</li>
</ol>
<p><img data-src="/2020/02/17/cg/midpoint3.png" alt></p>
<ul>
<li>在点$M_0$处，$d_0=F(x_{m0}, y_{m0})=A(x_i+1)+B(y_i+0.5)+C$</li>
<li>在点$M_1$处，$d_1=A(x_i+2) + B(y_i+0.5) + C=d_0+A$</li>
</ul>
<p>于是得到$d$的递推公式：</p>
<script type="math/tex; mode=display">d_0 = A(x_0+1)+ B(y_0+0.5) + C = A + 0.5B</script><script type="math/tex; mode=display">d\geq0  \Longrightarrow d_{i+1}=d_i+A</script><script type="math/tex; mode=display">d < 0 \Longrightarrow d_{i+1}=d_i+A+B</script><p>但是在$d_0$中有小数，且只判断$d$的符号，所以可以使用$2d$代替$d$，即$d_0=2A+B$，摆脱浮点运算，提高到整数加法，优于DDA算法。</p>
<p><strong>Bresenham算法</strong></p>
<p>效率没办法提升，所以算法要解决其它问题，如是否可以画圆，不限于直线的方程形式。</p>
<p><img data-src="/2020/02/17/cg/bresenham.png" alt></p>
<p>此时不再依赖直线的方程形式，更加一般化。</p>
<p>计算直线的起点到终点与垂直网格线的交点，根据误差项判断与交点最近的像素点。</p>
<p>每次$x+1$，$y$的增量为0或者1， 取决于最近光栅网格点的距离。最开始是，$d_0=0$，递增公式为$d=d+k$。一旦$d&gt;1$，则$d=d-1$，使得$d$在$[0, 1]$区间内。所以：</p>
<script type="math/tex; mode=display">d > 0.5 \Longrightarrow y_{i+1}=y_i+1</script><script type="math/tex; mode=display">d \leq 0.5  \Longrightarrow  y_{i+1}=y_i</script><p>但是需要将浮点计算提升到整数运算。</p>
<p>Step1: $e=d-0.5$</p>
<script type="math/tex; mode=display">e > 0 \Longrightarrow y_{i+1}=y_i+1</script><script type="math/tex; mode=display">e \leq 0 \Longrightarrow y_{i+1}=y_i</script><p>Step2: $e_0=-0.5$，$e=e+k$，$e&gt;0.5$时，$e=e-1$。</p>
<p>Step3：$e_0=-0.5$，$k=\frac{dy}{dx}$。用$2e\Delta x$代替$e$(计算过程为两边同时乘以$2\Delta x$，并将$2e\Delta x$写为$e$)，于是</p>
<script type="math/tex; mode=display">e_0=-\Delta x</script><script type="math/tex; mode=display">e=e+2\Delta y</script><script type="math/tex; mode=display">e>0, e = e - 2\Delta x</script><p>最终的算法步骤:</p>
<ul>
<li>输入起点$P(x_0, y_0)$和终点$P_n(x_n, m_n)$</li>
<li>计算初始值$e_0$</li>
<li>绘制点$(x_0,y_0)$</li>
<li>$e$更新为$e+2\Delta y$。若$e&gt;0.5$，更新$e$为$e - 2\Delta x$，$(x_i,y_i)$更新为$(x_i+1,y_i+1)$；否则$e$不更新，坐标更新为$(x_i+1,y_i)$。</li>
<li>如果没有画完，持续三四步骤，如果画完了就结束。</li>
</ul>
<h2 id="多边形的扫描转换与区域填充"><a href="#多边形的扫描转换与区域填充" class="headerlink" title="多边形的扫描转换与区域填充"></a>多边形的扫描转换与区域填充</h2><p>实际上为离散的像素点到连续的二维图形之间的转换。</p>
<p>多边形的两种表现形式：</p>
<ul>
<li>顶点表示：描述为顶点的序列，侧重几何意义，没有指明哪些点在多边形的内部。</li>
<li>点阵表示：多边形内部的像素点集合，丢失了边界信息和顶点信息，常用于光栅显示器的显示。</li>
</ul>
<p>进一步，导出两个问题：</p>
<ul>
<li>知道边界，就知道了哪些像素在多边形内，就可以转换为点阵表示，也叫多边形的扫描转换。即将顶点表示转换为点阵表示，寻找内部的像素点并填充颜色。</li>
<li>知道多边形内部的像素，但不可以确定多边形的边界。(属于图像处理课程的东西)</li>
</ul>
<p><img data-src="/2020/02/17/cg/muliangle.png" alt></p>
<p><strong>X扫描线算法</strong></p>
<p>以数值扫描为例，按照扫描的顺序，求与多边形相交的区间，对区间内部的像素点进行颜色填充。同样，坐标点需要四舍五入为整数。</p>
<p><img data-src="/2020/02/17/cg/scan-fill.png" alt></p>
<p>需要以$x$递增的排列顺序得到$x$的坐标，也就是要在$[2,4],[7,9]$两个区间内填充。</p>
<p>如果图形中，$y_{\mathrm{min}}$值为$1$，$y_{\mathrm{max}}$值为$12$，一共需要$12$条扫描线从下向上扫描，其他线不考虑。在$y\in [y_{\mathrm{min}},y_{\mathrm{max}}]$中，对每一条扫面线的扫描结果进行填充，步骤为：</p>
<ul>
<li>求交点</li>
<li>升序对$x$的坐标进行排序</li>
<li>保证交点为偶数个，配对</li>
<li>填充</li>
</ul>
<p>为了保证交点为偶数个，需要对交点的取舍问题进行解决。</p>
<ul>
<li>共享顶点的两条边在扫描线的两侧，算一个交点</li>
<li>共享顶点的两条边在扫面线的一侧，需要检查共享顶点的另外两个端点的$y$值，按照大于$y$值的个数决定交点的个数。</li>
</ul>
<p><img data-src="/2020/02/17/cg/pair.png" alt></p>
<p>如上图所示</p>
<ul>
<li>左图：共享顶点的两条边在扫描线的两侧，算一个交点</li>
<li>中间图：$O_2 &lt; O_1, O_3 &lt; O_1$，零个交点</li>
<li>右图：$y_1&gt;y_4,y_3&gt;y_5$，共四个交点，每个交点有两个</li>
</ul>
<p>例题：</p>
<p><img data-src="/2020/02/17/cg/pair-exam.png" alt></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编号</th>
<th>个数</th>
<th>编号</th>
<th>个数</th>
<th>编号</th>
<th>个数</th>
<th>编号</th>
<th>个数</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>1 | 0 | 2 | 1 | 3 | 1 | 4 | 1<br>5 | 1 | 6 | 0 | 7 | 2 | 8 | 2</p>
<p>同理可知，最右下脚的交点个数为2。但是，每次都需要求交点，暴力循环会导致计算量过大，应该采取某种方法避免求交。</p>
<p><strong>改进的多边形扫面转换算法</strong></p>
<p>解决每次的扫面线和边求交点的问题。</p>
<ul>
<li>有效边饥溺羞赧感相交运算，而暂时用不到的边则不计算</li>
<li>当前扫描线与下条扫描线与当前边或下一条边的交点顺序可能相似，即扫描线的连贯性</li>
<li>多边形的连贯线，某边与扫描线相交，还可能与下条扫描线继续相交</li>
</ul>
<p>如$P_1,P_2,P_3$三条扫描线连贯性，多边形的边也有连贯性。</p>
<p><img data-src="/2020/02/17/cg/continue.png" alt></p>
<p>此时需要引入特殊的数据结构，活性边表AET(Active Edge Table)，活性边是指与扫描线相交的边，同样以$x$递增的顺序放入一个表内。这个表的节点内容为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$x$</th>
<th>$\Delta x$</th>
<th>$y_{\mathrm{max}}$</th>
<th>$\mathrm{next}$</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>$x$是当前交点的值</li>
<li>$\Delta x$是$x$的增量，用于计算下一个$x$。扫面线移动，和多边形的交点与上一个交点是有关的。</li>
<li>$y_{\mathrm{max}}$表示当前活性边的最高点，即扫描线何时此笔边相交，及时删除。</li>
<li>next指向下一条边</li>
</ul>
<p>$\Delta x$的计算过程：</p>
<script type="math/tex; mode=display">k=\frac{\Delta y}{\Delta x}=\frac{y_{i+1}-y_i}{x_{i+1}-x_i}=\frac{1}{x_{i+1}-x_i}</script><p>得到：</p>
<script type="math/tex; mode=display">x_{i+1}=x_i+\frac{1}{k}\Longrightarrow \Delta x=\frac{1}{k}</script><p><strong>例题</strong></p>
<p><img data-src="/2020/02/17/cg/AET.png" alt></p>
<p>为了方便存放多边形的边，AET的建立与更新，需要建立新边表NET(New Edge Table)。是一种纵向链表，长度为最大扫描线的数量，每个节点是一个吊桶，对应一条扫描线，节点的结构为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$y_{\mathrm{max}}$</th>
<th>$x_{\mathrm{min}}$</th>
<th>$\frac{1}{k}$</th>
<th>$\mathrm{next}$</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><strong>例题</strong></p>
<p><img data-src="/2020/02/17/cg/NET.png" alt></p>
<p>$1,3,5,7$处需要更新，读入新的边，所以存入NET表，从最低点的$y=1$开始做，引入两条边放入AET处理。</p>
<p><strong>总结</strong></p>
<p>每次扫描线要经过三个处理</p>
<ul>
<li>判断是否需要取出(读$y_{\mathrm{max}}$即可)</li>
<li>不取出的话以$x=x+\frac{1}{k}$对$x$更新</li>
<li>判断有无新边的进入，新边在NET中，插入排序插入即可。(读$y_{\mathrm{max}}$和next判断)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python code for algorithm flow</span></span><br><span class="line">Begin Algorithm</span><br><span class="line">--------------------------------------------------</span><br><span class="line">sort(every_scanline)</span><br><span class="line">num = len(every_scanline) + scanline[<span class="number">0</span>].height</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(scanline[<span class="number">0</span>].height, num):</span><br><span class="line">    init NET[e]</span><br><span class="line">    insert the edge <span class="keyword">in</span> NET[e] which edge.y_min = e</span><br><span class="line"></span><br><span class="line">y = min(scanline)</span><br><span class="line">init AET</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(scanline[<span class="number">0</span>].height, num):</span><br><span class="line">    <span class="comment"># x's value is in ascending</span></span><br><span class="line">    Insert to AET <span class="keyword">from</span> NET[e] by Insert Sort Method</span><br><span class="line">    loop through AET, pair x <span class="keyword">and</span> brush(x, y, color)</span><br><span class="line">    loop through AET, delete edge.y_max = e <span class="keyword">from</span> AET</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line">End  Algorithm</span><br></pre></td></tr></table></figure>
<p>这样就可以完成对任意多边形的填充，利用了扫描线增量的思想，多边形的连贯性和一种新的数据结构。但是要求待填充区域必须已知，无法对位置边界的区域进行填充。</p>
<p>此外还有其他多种算法可以完成对多边形的填充，如边缘填充算法，随机则一条边和边的遍历顺序，对每条边的右侧像素取补运算，即可完成对多边形区域额填充。</p>
<p><img data-src="/2020/02/17/cg/edge-fill.png" alt></p>
<p><strong>区域填充算法</strong></p>
<p>将区域内的某个点赋予颜色(种子点)，并将此颜色扩展到整个区域，其中的区域是指：已经点阵表示的填充图形的像素的集合。</p>
<p>区域表示的两种方法：</p>
<ul>
<li>内点表示：枚举所有像素，着同一颜色</li>
<li>边界表示：枚举边界的所有像素，内部点着同一颜色</li>
</ul>
<p>这个算法要求区域是连通的，进行四向连通和八向连通。</p>
<p><img data-src="/2020/02/17/cg/connected.png" alt></p>
<p>以四连通填充为例，边界的像素与内部的像素颜色不同，找到内部的种子像素，并填充到内部的其他像素。使用栈结构实现(和栈结构的米够求解问题类似)</p>
<p>算法伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">push seed</span><br><span class="line"><span class="keyword">while</span>(!empty(stack)):</span><br><span class="line">    e = pop(shack)</span><br><span class="line">    brush(e)</span><br><span class="line">    a = go through adjacent pixels by four directions</span><br><span class="line">    <span class="keyword">if</span> a <span class="keyword">not</span> brushed:</span><br><span class="line">        push(a)</span><br></pre></td></tr></table></figure>
<p>可以脑补栈结构的迷宫求解问题理解上述代码。有些像素需要入栈多次，浪费时间，多次循环浪费时间，效率低下。</p>
<p><strong>总结</strong></p>
<p>扫描线算法与区域填充算法的对比：</p>
<ul>
<li>扫描算法只将顶点转换为点阵表示，从顶点出发，利用连贯性填充和全新的数据结构。</li>
<li>区域填充没有改变区域的表示方法，依赖连通性，需要知道多边形边界与内部的像素差异，要求的条件更多。</li>
</ul>
<h2 id="反走样算法"><a href="#反走样算法" class="headerlink" title="反走样算法"></a>反走样算法</h2><p>走样是理想世界数字化的必然产物，发生走样的原因是像素本身是离散的，可能会导致锯齿状、微小物体丢失的现象。</p>
<p>走样可以总结为:原始信号变化快，采样频率低而导致，最终的结果会取决于低频的采样信号(低频的采样信号可以理解为很少的像素点，分辨率低，分辨率高则采样频率也会高)</p>
<p><img data-src="/2020/02/17/cg/frequency.png" alt></p>
<p>反走样：减少或消除走样的效果。所有的图像处理系统都会对基本图形进行反走样处理。</p>
<ul>
<li>提高分辨率：像素更密集，但是付出的存储代价和扫描转换时间都要提升，还要提高电子枪的射击速度，并不可取。</li>
<li>以一种模糊的形式去平滑，如白纸黑字下，黑子旁边增加灰色像素柔滑尖锐的效果。</li>
</ul>
<p><strong>两种反走样算法</strong></p>
<p><strong>非加权采样方法</strong></p>
<p>以物体的覆盖率计算像素的颜色，即某个像素区域被物体覆盖的比例，覆盖率越大，颜色越亮。</p>
<p><img data-src="/2020/02/17/cg/coverage.png" alt></p>
<p>如上图所示的第$3$号区域，覆盖了一个像素的一般的区域，所以颜色取原来的二分之一。如果为小数则进行四舍五入的取整。</p>
<p>缺点</p>
<ul>
<li>与相交的区域成正比，与区域块的位置无关，仍然可能会存在锯齿的现象，因为没有良好的区分边界位置与中心位置。</li>
<li>相邻的像素点会有较大的灰度差，因为每个像素的权重一样，亮度完全取决于覆盖面积。</li>
</ul>
<p><strong>加权采样方法</strong></p>
<p>亮度取决于距离像素中心的远近，区域与像素中心的距离决定了对像素亮度的贡献。将一个像素分为$3\times 3$的矩阵，矩阵的每个值被赋予权重，乘以颜色求平均，得到最后的亮度值。(和图像处理中的高斯模糊过程一致)</p>
<h2 id="裁剪算法"><a href="#裁剪算法" class="headerlink" title="裁剪算法"></a>裁剪算法</h2><p>内部存储的比实际显示的要大，所以要对不分区域进行裁剪，确定哪些像素落在显示区域内。(基于点阵的判断)</p>
<p><img data-src="/2020/02/17/cg/cat.png" alt></p>
<p>判断一个点$P(x,y)$是否在区域内部的方法：</p>
<script type="math/tex; mode=display">x_{\text{left}}\leq x\leq x_{\text{right}}, y_{\text{bottom}}\leq y\leq y_{\text{top}}</script><p>而直线段的裁剪，是复杂图形裁剪的基础，分为以下三种情况。</p>
<ul>
<li>完全在window内</li>
<li>完全在window外</li>
<li>与window的边界相交</li>
</ul>
<p>有常用的三种算法</p>
<ul>
<li>Cohen-Sutherland算法</li>
<li>中点分割算法</li>
<li>Liang-Barsky算法</li>
</ul>
<p><strong>Cohen-Sutherland</strong></p>
<p><img data-src="/2020/02/17/cg/cat-cate.png" alt></p>
<p>设直线的两个端点$p_1,p_2$</p>
<ul>
<li>$p_1,p_2$全部在窗口内，保留直线</li>
<li>完全在窗口外，抛弃<ul>
<li>$x_1\leq x_{\text{left}} \&amp; x_2\leq x_{\text{left}}$</li>
<li>$x_1\geq x_{\text{right}} \&amp; x_2\geq x_{\text{right}}$</li>
<li>$y_1\geq y_{\text{top}} \&amp; y_2\geq y_{\text{top}}$</li>
<li>$y_1\geq y_{\text{bottom}} \&amp; y_2\geq y_{\text{bottom}}$</li>
</ul>
</li>
<li>与窗口相交，则按照交点分段，抛弃一部分，保留窗口内的线段。</li>
</ul>
<p>以窗口的延长线将区域分为9部分，编码四位数$D_0D_1D_2D_3$，编码规则为</p>
<ul>
<li>$x\leq x_{\text{left}}, D_0=1 \text{ else } D_0=0$</li>
<li>$x\geq x_{\text{right}}, D_1=1 \text{ else } D_1=0$</li>
<li>$y\leq y_{\text{bottom}}, D_2=1 \text{ else } D_2=0$</li>
<li>$y\geq y_{\text{top}}, D_3=1 \text{ else } D_3=0$</li>
</ul>
<p>通过二进制的运算来判断是否保留线段</p>
<ul>
<li>两个交点的与运算后，$\neq0$，在窗口外，抛弃</li>
<li>两个交点的或运算后，$=0$，在窗口内，保留</li>
<li>如果以上均不成立，则需要求交点，划分线段，然后继续</li>
</ul>
<p><strong>例题</strong></p>
<p><img data-src="/2020/02/17/cg/cohen.png" alt></p>
<p>编码的思想值得学习，二进制计算速度快，适用于直线的大部分在区域内可见或者大部分在区域外不可见的情况。</p>
<p><strong>Liang-Barsky算法</strong></p>
<p><img data-src="/2020/02/17/cg/liang.png" alt></p>
<p>核心思想：</p>
<ul>
<li>将直线以参数方程进行表示</li>
<li>将线段视为有方向的线段</li>
<li>入边：直线由窗口外向窗口内移动时会与边界有交点(左侧与下侧)，出边：直线由窗口内向窗口外移动时会与边界有交点(上侧与下侧)。</li>
<li>最后只需要求解裁剪后的起点与终点，即参数方程中的参数是，求解得到裁剪后的方程。</li>
<li>$u_1$窗口内可见的起点，$u_1=max(0, u_l, u_b)$(入边)</li>
<li>$u_2$窗口内可见的终点，$u_2=min(1, u_t, u_r)$(出边)</li>
</ul>
<p><img data-src="/2020/02/17/cg/barsky.png" alt></p>
<p>所以现在的问题是：</p>
<ul>
<li>如何判断入边与出边</li>
<li>$u_l, u_b, u_t, u_r$如何去求</li>
</ul>
<p>判断线段的某各部分是否在窗口内，可以判断线段上的一个点$P$是否在窗口内，于是转换为裁剪不等式：</p>
<script type="math/tex; mode=display">x_{left}\leq x_1+u\Delta x \leq x_{right}</script><script type="math/tex; mode=display">y_{bottom}\leq y_1+u\Delta y \leq y_{top}</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">u(-\Delta x) \leq x_1-x_{left}</script><script type="math/tex; mode=display">u(\Delta x) \leq x_{right}-x_1</script><script type="math/tex; mode=display">u(-\Delta y) \leq y_{1}-y_{bottom}</script><script type="math/tex; mode=display">u(\Delta y) \leq y_{top}-ys_1</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">up_k\leq q_k \Longrightarrow u = \frac{q_k}{p_k}(k=1,2,3,4)</script><p>$u$为直线与四条边交点的参数，求出四个交点。通过$p_k$的符号来判断入边与出边。</p>
<ul>
<li>$\Delta x &gt; 0 \Longrightarrow u(-\Delta x) &lt; 0$, 外到内，左侧，入边。</li>
<li>$\Delta x &gt; 0 \Longrightarrow u(\Delta x) &gt; 0$, 内到外，右侧，出边。</li>
<li>$\Delta y &gt; 0 \Longrightarrow u(-\Delta y) &lt; 0$, 外到内，下侧，入边。</li>
<li>$\Delta y &gt; 0 \Longrightarrow u(\Delta y) &gt; 0$, 内到外，上侧，出边。  </li>
</ul>
<p>如此，求得了出边与入边，以及相关的$u$值，求解即可。</p>
<p><strong>例题</strong></p>
<p><img data-src="/2020/02/17/cg/liang-exam.png" alt></p>
<p>可以看到，Liang-barsky算法一般情况下会更好，但只适用于矩形的裁剪窗口。更改的底层算法效率更高，可以固化到计算机底层硬件中，加速显示与执行效率，且图形软件则不用研究此类算法（如photoshop）</p>
<p><strong>多边形裁剪</strong></p>
<p>裁剪后的多边形边界的顶点序列。保留封闭区域，可能一个，也可能多个。Sutherland-hodgemen算法针对裁剪过程中出现的四种情况，作出了分类求解：</p>
<p><img data-src="/2020/02/17/cg/hodgemen.png" alt></p>
<p><strong>例题</strong></p>
<p><img data-src="/2020/02/17/cg/hodgemen-exam.png" alt></p>
<p><strong>文字裁剪算法</strong></p>
<ul>
<li>串精度的裁剪：字符串全部在窗口内部，保留；一个字符不在，全部舍弃。</li>
<li>字符精度裁剪：一个字符位于边界没完全在窗口内，舍弃这个字符，字符串的其他字符保留。</li>
<li>笔划、像素精度的裁剪：哪些像素在窗口内，保留，即但个字符会切为两部分。</li>
</ul>
<h2 id="消隐算法"><a href="#消隐算法" class="headerlink" title="消隐算法"></a>消隐算法</h2><p>消隐：当物体不透明时，物体的背面时看不到的，于是不可见一侧的面不用绘制。消除不可见的线与面。消隐的过程与对象有关，与观察者的位置有关。</p>
<p>按消隐对象分类：</p>
<ul>
<li>线消隐：消除的是线</li>
<li>面消隐：消除的是面</li>
</ul>
<p>按消隐空间分类：</p>
<ul>
<li>物体空间：$k$个物体与$k-1$个物体的对比遮挡。</li>
<li>图像空间：像素位置距离观察者的远近（主流研究）</li>
</ul>
<p>消隐的基础算法：画家算法。先画远的，再画近的，近的遮盖远处的物体，实现最简单的消隐。三维中，随观察者视野的变化，不同物体的近远可能会发生变化，此时可能会随视野变化相互遮挡。</p>
<p>消隐算法：</p>
<ul>
<li>Z-buffer算法</li>
<li>扫描线算法</li>
<li>Warnock算法</li>
</ul>
<p><strong>Z-buffer算法</strong></p>
<p>可用于生成复杂图形，首先设立帧缓冲器：</p>
<ul>
<li>帧缓冲器（像素点）存储每个可见像素的光强与颜色</li>
<li>深度数组（与像素点等量）存储可见像素的$z$坐标，近的$z$大，远的$z$小</li>
</ul>
<p>$z$的求法：空间中的平面方程为：$Ax+By+Cz+d=0\Longrightarrow z=\frac{Ax+By+d}{-C}$</p>
<p>在同一条视野线上：$P_1$在$P_2$前面，则只显示$P_1$的颜色。同一组$(x,y)$，通过判断$z$的大小来决定显示哪个像素，与在屏幕中的出现顺序无关。</p>
<p><img data-src="/2020/02/17/cg/z-buffer.png" alt></p>
<p>特点：</p>
<ul>
<li>占用空间大</li>
<li>没有利用到图形的相关性与连续性</li>
<li>像素级的消隐，复杂度高</li>
</ul>
<p><strong>只用一个帧缓冲器</strong></p>
<p>以$i,j$表示像素的在多边形内的某个点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">depth = minValue</span><br><span class="line"><span class="keyword">if</span> depth(i, j) &gt; depth:</span><br><span class="line">    depth = depth(i, j)</span><br><span class="line"><span class="keyword">if</span> depth(i, j) != minValue:</span><br><span class="line">    show_beam()</span><br><span class="line"><span class="keyword">if</span> new_polygen: <span class="comment"># 到了新的多边形</span></span><br><span class="line">    depth = minValue</span><br></pre></td></tr></table></figure>
<p>如何判断像素$(i,j)$是多边形内部的点：</p>
<ul>
<li>射线法</li>
<li>弧长法</li>
<li>弧长判断法</li>
</ul>
<p><strong>射线法</strong></p>
<p><img data-src="/2020/02/17/cg/ray.png" alt></p>
<p><strong>弧长法</strong></p>
<p><img data-src="/2020/02/17/cg/arc.png" alt></p>
<p>但是弧长的计算比较不容易，还需要考虑精度问题。需要加以改进。</p>
<p><strong>弧长判断法</strong></p>
<p><img data-src="/2020/02/17/cg/arc-judge.png" alt></p>
<p>虽然加以改进，仍是基于像素级别的消隐，时间效率不高。</p>
<p><strong>区间扫描线算法</strong></p>
<p>不再基于像素级别的消隐，加快了执行速度。</p>
<p>按照扫描线的思想，同款区间设置同款颜色，而相交的区间取决于谁在前。而在染色时，一个像素决定了一个区间的颜色，以逐段染色的方式对区间进行染色。</p>
<p>同样，借助图形的连贯性和连续性，以增量的形式避免求交，排序$x$点，染色。</p>
<p><img data-src="/2020/02/17/cg/scan-color.png" alt></p>
<ul>
<li>无多边形，$[a_4,a_5]$染背景颜色</li>
<li>一个多边形内，$[a_1,a_2]$染对应的颜色</li>
<li>多个多边形相交，$[a_6,a_7]$取决于$z$值</li>
</ul>
<p><strong>Warnock算法</strong></p>
<p>效率不是很高，而是一种全新的思想。</p>
<p>将区域递归分割，直到窗口内的目标足够简单到可以显示为止。</p>
<p>足够简单的定义（足够简单则直接显示）：</p>
<ul>
<li>只有一个多边形</li>
<li>窗口内无其他多边形</li>
<li>窗口被一个多边形包围</li>
<li>窗口与一个多边形分离</li>
</ul>
<p>判断一个多边形在窗口内：</p>
<script type="math/tex; mode=display">x_{min} \geq x_{left} \quad and \quad  x_{max} \leq x_{right}</script><script type="math/tex; mode=display">y_{min} \geq y_{bottom}\quad  and\quad  y_{max} \leq y_{top}</script><script type="math/tex; mode=display">OR</script><script type="math/tex; mode=display">x_{min}>x_{right} \text{ or } x_{max}<x_{left}</script><script type="math/tex; mode=display">y_{min}>y_{top} \text{ or } y_{max}<y_{bottom}</script><p>判断多边形与窗口相交：用直线方程（规定定义域内）求交点判断即可。</p>
<p>当窗口内有多个多边形无法直接显示时：</p>
<ul>
<li>没有物体染背景色</li>
<li>一个面则直接显示</li>
<li>窗口有两个面及其以上，等分为四个窗口，递归执行。</li>
</ul>
<p><img data-src="/2020/02/17/cg/warmock-exam.png" alt></p>
<h1 id="二维图形变换"><a href="#二维图形变换" class="headerlink" title="二维图形变换"></a>二维图形变换</h1><h2 id="向量的基础"><a href="#向量的基础" class="headerlink" title="向量的基础"></a>向量的基础</h2><p>对对象的变换：形状、位置、方向，最后计算每个点的像素值。变换的基础是向量，有长度方向，无位置；对于单纯的点，有位置，无长度与方向。且可以上升到$n$维向量，便于处理问题。</p>
<p>向量的线性组合：$\vec{w}=a_1\vec{v}_1+a_2\vec{v}_2+a_3\vec{v}_3+\dots+a_n\vec{v}_n$</p>
<p>仿射组合：$a_1+a_2+a_3+\dots+a_n=1$</p>
<p>基本运算：</p>
<ul>
<li>$|w|=\sqrt{a_1^2+a_2^2+a_3^2+\dots+a_n^2}$, $\hat{w}=\frac{\vec{w}}{|w|}$</li>
<li>$a\cdot b=a_1b_1+a_2b_2$</li>
<li>$\mathrm{cos}\theta = \frac{a\cdot b}{|a||b|}$</li>
<li>$a\times b=|a||b|\mathrm{sin}\theta$(求法向量)</li>
</ul>
<h2 id="图形坐标系"><a href="#图形坐标系" class="headerlink" title="图形坐标系"></a>图形坐标系</h2><p>坐标分为一维、二维、三维等，联系了图形与数。（当然也有直角座标，极座标，球坐标等）。用于描述对象的几何信息，应用于建模；表述对象的大小与位置，用于观察。（像素点坐标下没有小数）</p>
<ul>
<li>世界座标系：一个参考的标准，公共座标系，统一参考系。</li>
<li>建模座标系：物体内部的座标系。</li>
<li>观察座标系：不同观察角度对象的重新定位与描述，用于指定输出范围，在世界座标系中指定坐标，选定方向和位置进行裁剪。</li>
<li>设备座标系：（整数），针对一个具体设备的坐标系。</li>
<li>规范化座标系：不依赖于设备，但容易转化为不同设备的座标系（打印机、手机），范围在$[0,1]$。</li>
</ul>
<h2 id="二维图形转换"><a href="#二维图形转换" class="headerlink" title="二维图形转换"></a>二维图形转换</h2><p>基本的变换包括比例、旋转和镜像等。</p>
<p>变换的原理：</p>
<ul>
<li>图形在变化，但是连边规则不变</li>
<li>图形变化因为顶点位置在变</li>
<li>坐标变换，拓扑关系没变</li>
</ul>
<p>上述的变换符合二维到二维的线性变换（也符合仿射变换），具有以下性质</p>
<ul>
<li>平直性：直线经过变换仍然是直线</li>
<li>平行性：平行的直线变换后依然平行，直线上点的顺序不变</li>
</ul>
<script type="math/tex; mode=display">x'=ax+by+m</script><script type="math/tex; mode=display">y'=cx+dy+n</script><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><p>$(x,y)$ ，表示一个点 $(x*, y*)=(x,y) \cdot M$，$M$表示变换矩阵。 </p>
<script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">x^*=a_1x+b_1y+c_1</script><script type="math/tex; mode=display">y^*=a_2x+b_2y+c_2</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">[x^\*\;y^\*]=[x\;y\;1]\cdot M</script><script type="math/tex; mode=display">[x\;y\;1]\text{增加了一维}</script><p>$n+1$维表示$n$维：称为齐次坐标表示法，$(p_1,p_2,p_3,\dots,p_n)$推到$(hp_1,hp_2,hp_3,\dots,hp_n)$，$h$称为哑坐标，$h=1$是规格化坐标，前$n$个坐标是普通坐标下的$n$维坐标。</p>
<p>也可以这样考虑，$(x,y)$是$z=0$上的点，$(x,y,1)$是$z=1$上的点。会加速计算的方便性。</p>
<p><strong>平移变换</strong></p>
<p>$P$点沿直线到另一个点重定位的过程，平移变换是不产生形变的物体的刚体变换。</p>
<script type="math/tex; mode=display">x+T_x=x^*</script><script type="math/tex; mode=display">y+T_y=y^*</script><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><ol>
<li>bresenham算法的 $e$ 到底大于几</li>
<li>加权采样法如何计算</li>
<li>X扫描线算法(3)</li>
<li>NET的放入AET的标准</li>
<li>Z-buffer算法的帧缓冲器存储光强还是像素存储光强</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上内容和图片都参考了<code>MOOC</code>上中国农业大学计算机图形学的课程，如有雷同，雷同就雷同吧，反正是我抄的他的PPT。</p>
]]></content>
      <tags>
        <tag>Computer</tag>
      </tags>
  </entry>
  <entry>
    <title>大学毕业的前夕</title>
    <url>/2020/03/20/college-graduation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>想来也快要大学毕业了，2016年唐县一中毕业，2020年某不太行大学毕业，四年了。</p>
<a id="more"></a>
<p>在我眼里学校一直是二本水平，包括好多老师也这么说。也许你会反驳说学校不是二本啊，河北省明明一本招生，可在河北省外，肉眼可见的大多省都是二本招生。出去参加了几趟夏令营深有感悟，以我的专业为例，和外面其他一本学校的的教学水平、资源差得很远很远。</p>
<p>当然说这些也没用，每个人都懂一个道理，<strong>就是外界环境与自身水平关系不大</strong>。就好比，写代码水平的高低与程序员用的什么牌子的电脑没有必然联系。</p>
<p>老师通知的时间是5月中旬毕设答辩，6月份就可以走人，想来，也就俩月了，真他娘的快。</p>
<ul>
<li>谢师宴想去吗？不想去，水平可以且认真讲课的老师超不过那么几个，何况我会的只是都靠自学，也没有老师能给我关键性的、受用的指导和教育。都是走一个流程，有什么可谢的呢？大多老师都是完成学校任务，念PPT，考试，挣钱，下一轮回。</li>
<li>有想见的老师吗？有啊，那种能当朋友的老师，能随意聊天不push的老师，关键时刻在的老师，当然要去见一面。大学能让老师主动的记住一个学生的名字的确不是很容易。</li>
<li>有想见的人吗？可能没有，似乎真的没有，有什么值得留恋的呢？没有与其他人有过多交集，也不会谈恋爱，也没对谁说过我好喜欢你，撩过的小姐姐早已悄然无踪影。</li>
</ul>
<p>高考结束后，年级下降了三百名，想放弃又不敢，想复读又懒，勉强能走本一，比录取分数线多两分来了这所学校。不过大抵也怪我高中的心思都不在学习上，心猿意马，青春疼痛矫情文学描述过去的我可真是再合适不过。还好许多文字已经删除，无迹可寻。而我也意识到过去的众多错误：矫情、猜忌、暴躁、偏执、自私，自我为中心等等等等，只要是个贬义词，大概率的能用在我身上。对于太多不堪回首的东西我选择了失忆，不去回忆，就真的记不起来了。后来和朋友聊起，才发现高中的我大概率是抑郁症，终日目光涣散、懒散、双目无神、行尸走肉，到处都有压迫的窒息感，窒息到胸闷心慌，盯着书都看不下去两个字。不是因为懒惰而不学习，是身体真的不允许。<strong>这是一种正常的疾病，希望不要被误会，可以被正视。</strong></p>
<p>高中毕业后的几个月，也还是那样的多愁善感，沉浸在自己的世界，瘦了十多斤，和几个关系好的朋友吹了吹牛逼也就开启新的生活了。来了大学里没办法，除了学习and看书我不会其他，也别无出路。大一上半学期是过渡时期，慢慢熬呗，沉迷高数和经典名著，每天都去上自习，每天晚上操场跑步，也就不在想其他的了。大概也开始摆脱自私和矫情等青春疼痛文学等缺陷。逐步的能够控制自己的情绪，这比什么都好。不再低落，除了偶尔几次的牢骚，大多时期也挺过来了，现在想来，就这？能有啥。</p>
<p>《明天你好》——此处应有这首音乐。</p>
<p>逐步自学了C语言，参加了数学建模，对计算机产生了兴趣，转专业到了计算机。学着专业课，鼓捣自己感兴趣的东西，参加着比赛，一周三四次跑步，偶尔读读课外书，隔几天看一次电影，无聊了打打游戏，考试也很简单，随便背背拿个高分不成问题。大学四年就这么过去了，平淡无奇。</p>
<p>如果非要说什么印象深刻的事情，第一次是看到了图书馆，通过书籍，我知道了原来外面还有这么精彩的世界；第二次是看到了实验室，吾辈虽置身沟渠但仍可仰望星空；第三次是从你眼睛里看到了星河，但又转瞬成空；第四次是看到了柳神的代码；第五次是出去走走看到了外面更广阔的世界。</p>
<ul>
<li>大一上学期过渡期间的迷茫时期，用半年的时间拯救了自己。我也实在不知道也去干些什么，就一直在从学校的图书馆借书看。大一时图书馆刚刚建立，只有一层，可山不在高有仙则名啊。大一上学期我看完了《简爱》，《假如给我三天光明》，《牧羊少年的奇幻之旅》，《追风筝的人》，《麦田守望者》，《激流男孩》，《一怒之下和DH劳伦斯的决斗》和《荒野猎人》。现在想来真是不可思议，也许当初课少吧。当然学业也没落下，每晚去上晚自习，高数20分钟交卷100分，出了考场奔去图书馆看完了《荒野猎人》。看过的书就像吃过的饭，吃过的饭融入你的血液，促使你长成了今天的体格；读过的书融入你的血液，让你成为这样的人，对待事物有了不同的想法和深度。据说读书能长气质，可我没有。《假如给我三天光明》是这里面我感觉最好的吧，世间竟然还有如此清澈的情感，的确能强力洗涤当初的我污秽不堪的情感和思想，至少，不再是青春疼痛文学。<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>走过黑暗的那段没人拉我一把，我自己把自己带出了深渊。 </p>

            <i class="fa fa-quote-right"></i>
          </blockquote></li>
<li>实验室，的确是个神奇的地方，认识了好多人，跨专业跨学院跨性别跨年级。这里并不像学生会那样，各种开会，各种活动，回复收到。好在我天生不喜欢去学生会那种地方，也丝毫不想去学生会所谓的锻炼自己，更不想参加XX举办的XX活动而后发个动态说自己多不容易或显示自己多有水平，对我的成长来说没有丝毫帮助。<strong>还是选择了实验室。</strong>每个人都放的很开，也玩的来，毕竟都是来这里交流学习和技术，平时约饭and一起玩耍，也可以放心的交流学术，交流未来要走的路，当然更多的都是在交流读研，或是读研经验分享。你可以直呼打你三届四届学长的名字，甚至私底下直呼老师的名字，这里更多的像是朋友。比赛期间互相扯淡，考试周相继来实验室通宵，几个人就挤着睡在实验室的沙发和凳子拼凑的床上。比赛期间是绝对主力，玩起来也不输任何人。实验室这栋楼里，保研的人也占了理工科专业的一半以上，大约三分之二的样子，就像我去保研的那天，去保研的人我都认识，XX是对门实验室的，XX是楼上实验室的，XX和我在同一个机房一起比赛等等。好在学校也支持这些，所有的教学楼只有这里安装了中央空调，冬暖夏凉。也配备了一些门禁的教室，不过上次去那个教室是我们一群人假期去玩游戏了，打扑克，象棋五子棋，放下了手中的代码和电路板，其实我们都会玩。回归正题，我还是在这里学了很多知识的，要想当初实验室要每个人的课表，抽公共事件让学长学姐来给我们讲课，数学模型、代码编写、论文编写，最后考核上交作业，还真是到位，每天忙的不亦乐乎。不过这里只是提供一个门，门后更多的世界还要靠自己探索。后来又自学了更多东西，这些知识、解决问题的思路，将陪伴我走很长的路。自此，也彻底甩掉了之前的坏习惯，不在抱怨，也不再崩溃，也不存在还需要控制情绪这件事情。<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>学习的痛苦是暂时的，学不到的痛苦是终身的。 </p>

            <i class="fa fa-quote-right"></i>
          </blockquote></li>
<li>自高中毕业后，高三的同桌也终于选择离我而去。差一个3分选择题我能去她的学校，同样，再错一个3分的选择题，我连本一都考不上，可能这就是命吧，终究要告别过去走向新的生活。大学期间钢铁直男的水平超常发挥，单身全凭本事。</li>
<li>后来看到了柳神的代码，也是第一次见到如此精简但不失神奇的算法，也有幸和她通了一次邮件。她的学校比我的二本还要不好，她的学校的确是所三本，但她看过的书比我要多得多，写的算法也比我强百倍，项目接触的比我多得多，更不要提英语词汇量和学习成绩，没有一点能比上她。当然她现在去了哪里我也不知道，我只是个路过的小粉丝。我也看过985，211的学生的代码，也有幸和其中的几位聊天，无论是加好友还是群聊。我只想说有人浪费的985的资源，无论是学习还是实践水平都不咋地，有人借助很好的平台达到了更高的高度。所以，英雄各有见，何必问出处。但更可怕的是，虽然他比你聪明，但是他比你勤奋；虽然他出身名校，但他实力比你好得多。总要相信，有很多人站在一流的平台靠着天赋或勤奋，比我要努力的多。</li>
<li>出去走走说的就很笼统了，也许是操场的一次跑步，也许是上网的一次冲浪，也许是一次旅行。每次出去走走，都能看到各色各样的人，无论是端庄优雅的小姐姐，还是行走天涯的行者；各有千秋的风景，无论是温润婉约的江南水乡，还是一马平川万里飞沙的塞上西北；亦或是网上冲浪看到了不同人的自我介绍和展示，都会促使着我去看更加广阔的世界，认识更多的人，在这条路上走的更远，促使着我打开眼界，目光放长远，对我来说是一种积极的鼓励。</li>
</ul>
<p>当然，我也和大多数人一样，喜欢熬夜看电影，拖延症晚期，偶尔做错的决定会把生活搞得一团糟，像众多的大学生一样。只不过我不爱玩游戏，更不要说男生聚在一起玩游戏，我实在受不了这些，浪费大好年华。相反的爱好学习和折腾，爱好读书和跑步锻炼身体，就走到了今天吧。</p>
<p>一介书生，生于天地之间，受过教育，恰同学少年，当以『为天地立心，为生民立命，为往圣继绝学，为万世开太平』，这也是中国古代文人的风骨，也许我永远都达不到这个高度和水平。但我也很反感『仗义每多屠狗辈，无情最是读书人』这种想法，并不是每个学生都学傻了，都无情，都没有骨气，那为何这个社会的人不是挣前恐后的去做个屠夫之类？我至今怀疑现代人对这句诗的理解有所误差，对没有当大官的文化和水平而酸涩。如果说，朋友打个电话叫你过去填XX组织的外联，而我不去被理解为无情；关键时刻通过XX手段避免自己承担事件后果，把主要责任推到别人身上称为没有学傻；某人心情不好叫一堆朋友喝个酒，拍个照，发个动态，评论区在走个队形，以此来显示自己的”地位”和朋友的仗义。那么的确和我理解的仗义与无情有所不同，我倒也可以承认自己无情不够仗义，也学傻了，相形见绌，比不过。</p>
<p>以下是恶心的高中回忆和决绝，谨慎阅读。反正我也开启了新的朋友圈和生活，谁还会回头看呢？</p>
<p>也许是我的这种性格，三观不同导致了我不在和之前的同学联系。每当我表达真实想法的时候，就会一直被说幼稚。当初搞的我还很自卑，毕竟不知道自己哪里做得不好，也许是思想不成熟吧。不过我也没看出来他们行为多高级，上了大学开始自由散漫，整日吃吃喝喝沉迷游戏不务正业。最后落得考研没考上，技术技术没学会，不想工作，开始寻思考公务员或者考教师资格证或者考金融证或者考司法证或者怎样怎样。在一开始就不为自己的未来着想和负责，开始堕落，这样很成熟？可能在他们眼里，组成小团体，相互矫情那样的同流合污随遇而安及时行乐才是成熟的体现吧，毕竟我幼稚且不合群。</p>
<p>我也曾劝过我的朋友不要去考计算机二级，结果被挂在朋友圈骂了狗血淋头，反过来教育我不懂计算机，而且还影响她的进步，最后被评论：你事真多；我也曾在高中群说去图书馆看会儿书被骂装B，不成熟；也曾因为不想帮那个小团体的忙而在大庭广众之下被骂半个小时，然后联合其他人来一起诋毁我。不过的确是我交友不慎占主要原因。郭德纲说得好，吃亏要趁早，高考没考好很自卑后，几乎是个人都站在道德制高点来批评我两句，当然的确是我做错了。但我知道我还没放弃，我也不会放弃，反而那些批评我的人却早早的开始温水煮青蛙。</p>
<p>之前的同学，有的在不断的发展所谓的人际关系，以求生老病死时打个电话能有好多人来看望自己；有的逐步巴结讨好自己眼中的优等人而对自己眼中的低等人嗤之以鼻，中学阶段就开始<strong>选择性欺负</strong>弱小的同学；有的认同学习无用论认为学习过多的知识没用，要去多参加学生会的活动来提升自己，最后企图只用学习成绩和社团活动来争取保研名额（二本院校，一个专业只有一个保研名额，竞争很激烈），一开始便把大学、读研这条路理解为了学习及格就行，项目比赛等多余的学习没用，还是要多做学生会活动，大肆的弘扬学习无用论，那你为何又来保研呢？思之令人发笑；有的在上学期间故意做一些出格之事来展示自己不同凡响，所以在偶尔学习时一定要突出自己所谓的”品学兼优”，以此来证明自己是坏学生里最能学的，是学习这群人里最放荡不羁还没有学傻的；有的开始挂科来完整自己的大学；有的开始考研；有的终日吹嘘自己在学习高大上的东西，学会了的好处，却不见一个成果；有的开始倒买倒卖论文；有的开始参加各种课外活动以显示自己的水平，XX国际班，XX国际组织，最后也只是一个人的成果在挂十个人的名字而已；有的开始游戏人生；有的逐步归于平凡；有的趁着大学的黄金学习时间不去上课反而出去当服务员挣一时外快。</p>
<p>我的高中并不是很好，学生质量可见一斑，所以我之前大多数同学的真实写照是这样也不足为奇。我也不敢评价他们的选择正确与否，不能因为和自己走的路不同就去否定他人，人各有志罢了，这也是我不再联系的原因。以上都是我个人的态度，也许你认同，也许你不喜欢，但都要认真的确定自己要走的路，然后认真的走下去。当然也可以悟已往之不谏，知来者之可追；实迷途其未远，觉今是而昨非。</p>
<p>至于我大学的朋友没有之前的同学这么千奇百怪的现象，这里的千奇百怪也只是我认为。因为我的圈子基本在实验室，同班同学都认不全（转专业过来的，人实在认不全），交友限制在了志同道合的人里面。小部分朋友保研成功，大部分朋友考研成功，剩下的对研究生无感的朋友也已找好了不错的工作准备就业。所以对我来说也就很难看到各种千奇百怪的人和三观不同的行为了，反正我也不想看。</p>
<p>不过还是要在毕业之前见几个好朋友，吃顿饭也好，聊天也罢，还是要好好告别。之前有个朋友对我说，研究生毕业就找个人嫁了。现如今大家都是恰同学少年，风华正茂，还是一起玩耍一起吃饭一起跑步的好朋友，想到三年后要嫁为人妻沦为人母，还是些许的难以接受。此去经年，也许三年五载，也许此生不见。莫愁前路无知己，西出阳关后，海内仍然存在其他志同道合的好友。</p>
<p>满纸荒唐，一介狷狂。《曾经我也想过一了百了》——此处应有这首音乐。</p>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>张掖七彩丹霞</title>
    <url>/2020/01/18/colorful-danxia/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>遭遇暴雪，路途遥远，没看成嘉峪关，直接去的七彩丹霞。怀疑怎么上5A景区的，遗憾也没看到落日。</p>
<p>明天要分别，我们几个组团的陌生人聚在一起吃了饭，推荐甘州名吃这家店，铁锅焖饼（好象是这个名字）太香了，是我吃过最香的面，感觉以前吃的面都不配叫面。</p>
<p>总是这样，相聚，分离，相聚。</p>
<p><img data-src="/2020/01/18/colorful-danxia/5.jpg" alt></p>
<a id="more"></a>
<p><img data-src="/2020/01/18/colorful-danxia/40.jpg" alt><br><img data-src="/2020/01/18/colorful-danxia/6.jpg" alt><br><img data-src="/2020/01/18/colorful-danxia/8.jpg" alt><br><img data-src="/2020/01/18/colorful-danxia/10.jpg" alt><br><img data-src="/2020/01/18/colorful-danxia/14.jpg" alt><br><img data-src="/2020/01/18/colorful-danxia/16.jpg" alt><br><img data-src="/2020/01/18/colorful-danxia/24.jpg" alt><br><img data-src="/2020/01/18/colorful-danxia/30.jpg" alt><br><img data-src="/2020/01/18/colorful-danxia/33.jpg" alt><br><img data-src="/2020/01/18/colorful-danxia/36.jpg" alt><br><img data-src="/2020/01/18/colorful-danxia/38.jpg" alt><br><img data-src="/2020/01/18/colorful-danxia/39.jpg" alt><br><img data-src="/2020/01/18/colorful-danxia/41.jpg" alt></p>
]]></content>
      <categories>
        <category>塞上西北行</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的常量与指针</title>
    <url>/2021/06/22/const-pointer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>和指针联用有佷微妙的地方，之前一直佷晕，现在来继续研究下。诸如以下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><code>const</code> 是一种处理符号常量的方法，以 <code>const</code> 声明的变量，一般首字母大写，声明之后无法被修改。相比于 <code>define</code>，<code>const</code> 会显式的指定类型。除定义符号外，一般可用于函数声明，表示函数不会修改任何值；用于参数，表示函数不会修改参数；甚至可以用于声明数组的长度。</p>
<h1 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h1><p>const默认作用于其左边的东西。左边没东西的情况下，作用于其右边的东西。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<ol>
<li><code>const int* p</code>，只有右边有东西，修饰的为 <code>int</code>，所以数值不能被修改。在与 <code>*</code> 结合，意思是<code>*p</code>不能被修改，其它的都可以。即不可通过该指针改变其指向的内容，但可改变指针本身所指向的地址。</li>
<li><code>int const* p</code>，先作用于左侧的 <code>int</code> 为 <code>int const</code>，在叠加上右侧的 <code>*</code>，所以修饰的为 <code>int* p</code>，所以，<code>*p</code>不能被修改，其它的都可以。即不可通过该指针改变其指向的内容，但可改变指针本身所指向的地址。也就是，和上面的是一样的。</li>
<li><code>int* const p</code>，左边是 <code>*</code>，所以 <code>const</code> 作用于指针，指向一个 <code>int</code> 变量。即不可以修改 <code>p</code>，但可以修改 <code>*p</code>，即不可改变指向的地址。</li>
<li><code>const int* const p</code>，对于第一个 <code>const</code>，左边没东西，修饰右边的 <code>int</code>，指向的值不能修改；对于第二个 <code>const</code> 修饰 <code>*</code>，指针不能修改。即不可改变指针本身所指向的地址，也不可通过指针改变其指向的内容。同 <code>int const* const p</code>。</li>
<li><code>int const* const* p</code>，第一个 <code>const</code> 修饰 <code>int</code>，第二个 <code>const</code> 修饰第一个 <code>*</code>，也就是，指向 <code>const int* const p</code> 的指针，最后一个 <code>*</code> 没有被修饰，因此可以指向其它变量。<code>int const* const* const</code> 就不可以了。</li>
<li>之后再出现此类情况，也可以慢慢分析满天飞的 <code>const</code> 和指针。</li>
</ol>
<h1 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h1><p>为了更好的理解上述内容，这里来举一些例子。常见的一般有两种选择：</p>
<ul>
<li>常指针指向一个变量，防止修改指针修改变量值</li>
<li>常指针指向一个常量</li>
<li>非常指针指向常量（错误）</li>
</ul>
<p>先看第一种情况：解引用只是取出指向内存区域的值，因此指向内存区域的值是可以直接修改的，但不能通过指针修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a&#123;<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="comment">// *p 为 const，不能被修改</span></span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    <span class="comment">// *p ++;</span></span><br><span class="line">    <span class="comment">// p 指向的不是常量，因此，可以修改 a</span></span><br><span class="line">    a ++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> b&#123;<span class="number">12</span>&#125;;</span><br><span class="line">    p = &amp;b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于第二种情况：不能修改变量，也不能修改常量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a&#123;<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="comment">// *p 为 const，不能被修改，a 也不能被修改</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b&#123;<span class="number">12</span>&#125;;</span><br><span class="line">    p = &amp;b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于第三种情况：修改指针来修改常量会显得佷荒谬，因此编译会直接报错：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a&#123;<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="comment">// error: invalid conversion from 'const int*' to 'int*'</span></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    *p ++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><p>之前说到，常指针可以指向变量，但是涉及二级指针后，情况又会发生逆转。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a&#123;<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>** p1;</span><br><span class="line">    <span class="keyword">int</span>* p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error: invalid conversion from 'int**' to 'const int**'</span></span><br><span class="line">    p1 = &amp;p2;</span><br><span class="line">    *p1 = &amp;a;</span><br><span class="line"></span><br><span class="line">    *p2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果上述代码通过，那么完全可以通过 <code>p2</code> 指针修改常量。因此我们可以得到以下结论：</p>
<ul>
<li>若数据类型本身不是指针，可以将 <code>const</code> 数据或非 <code>const</code> 数据的地址赋给指向 <code>const</code> 的指针，但指针可以修改，指向别的值。因此，<code>const</code> 修饰的数组不能传参给非常量指针。</li>
<li>如果数据类型是指针，非 <code>const</code> 数据的地址只能赋值给非 <code>const</code> 指针，如二级指针中，<code>p1 = &amp;p2</code> 是错误的。</li>
</ul>
<h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">https://www.zhihu.com/question/443195492</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络</title>
    <url>/2019/02/10/computer-vision/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文收录内容：</p>
<ul>
<li>边缘检测与卷积运算</li>
<li>卷积神经网络的Keras实现</li>
<li>残差网络，Inception，迁移学习的简单介绍。</li>
</ul>
<p>重点是对于这些概念的理解，如果想观看具体概念的实现请往他处。</p>
<hr>
<a id="more"></a>
<p>如果对本文有疑问或者想找男朋友，可以联系我，<a href="https://muyuuuu.github.io/about/">点击此处有我联系方式</a>。</p>
<h2 id="有关卷积"><a href="#有关卷积" class="headerlink" title="有关卷积"></a>有关卷积</h2><p>高通滤波器(HPF)是检测图像的某个区域，然后根据像素与周围像素的差值来提升该像素亮度的滤波器。以如下的核(kernal)为例，也称为滤波器(filter)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">0</span>, <span class="number">-0.25</span>, <span class="number">0</span>],</span><br><span class="line">[<span class="number">-0.25</span>, <span class="number">1</span>, <span class="number">-0.25</span>],</span><br><span class="line">[<span class="number">0</span>, <span class="number">-0.25</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
<p>核是一组权重的集合，他会应用与原图像的一个区域，并生成目标区域的一个像素。可以将核视为一个窗口，这个窗口在原图像上移动时，覆盖区域的像素会按着某种形式(对应相乘相加)透过此窗口，形成一个像素点；<a href="https://developers.google.cn/machine-learning/crash-course/glossary?hl=zh-CN#logit" target="_blank" rel="noopener">随着窗口的不断移动</a>，形成最终的目的图像(提取想要的特征)。如下所示。</p>
<p><img data-src="/2019/02/10/computer-vision/Convolution.gif" alt></p>
<p>卷积的过程中，原始图像尺寸会在滤波器的作用下会逐渐缩小，因此提供了两种卷积方式，一种是valid卷积(图像逐渐缩小)，一种是same卷积(图片大小不变)，Keras有对应函数。此外还有卷积步长，也就是filter一次移动的长度，和滤波器的大小共同决定了原始图像会缩小多少。</p>
<p>实战一下，在设置核后，与读入的图像进行卷积运算，卷积运算可以使用opencv提供的函数实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">kernel_9 = np.array([[<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>],</span><br><span class="line">                     [<span class="number">-1</span>, <span class="number">8</span>, <span class="number">-1</span>],</span><br><span class="line">                     [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>]])</span><br><span class="line"></span><br><span class="line">kernel_25 = np.array([[<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>],</span><br><span class="line">                      [<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>],</span><br><span class="line">                      [<span class="number">-1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">-1</span>],</span><br><span class="line">                      [<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>],</span><br><span class="line">                      [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>]])</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'test.jpg'</span>)</span><br><span class="line">ndimg = np.array(img)</span><br><span class="line"></span><br><span class="line">k3 = cv2.filter2D(ndimg, <span class="number">-1</span>, kernel_9)      <span class="comment">#convolve calculate </span></span><br><span class="line">k5 = cv2.filter2D(ndimg, <span class="number">-1</span>, kernel_25)     <span class="comment">#the second parameters measns the deepth of passageway.</span></span><br><span class="line"><span class="comment">#such as cv2.CV_8U means every passageway is 8 bit.</span></span><br><span class="line"><span class="comment">#-1 means the passageway of the source file and the object file is equal.</span></span><br><span class="line">plt.subplot(<span class="number">131</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.title(<span class="string">"source image"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">132</span>)</span><br><span class="line">plt.imshow(k3)</span><br><span class="line">plt.title(<span class="string">"kernel = 3"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">133</span>)</span><br><span class="line">plt.imshow(k5)</span><br><span class="line">plt.title(<span class="string">"kernel = 5"</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>得到的结果如下：</p>
<p><img data-src="/2019/02/10/computer-vision/1.png" alt></p>
<p>与高通滤波器相反的还有低通滤波器(LPF)，低筒滤波器与高通滤波器相反，当一个像素与周围像素的插值小于一个特定值时，平滑该像素的亮度，用于去燥和模糊化，比如PS软件中的高斯模糊，就是常见的模糊滤波器之一，属于削弱高频信号的低通滤波器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">kernel_25h = np.array([[<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>],</span><br><span class="line">                      [<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>],</span><br><span class="line">                      [<span class="number">-1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">-1</span>],</span><br><span class="line">                      [<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>],</span><br><span class="line">                      [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>]])</span><br><span class="line"></span><br><span class="line">kernel_25l = np.array([[<span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>],</span><br><span class="line">                      [<span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>],</span><br><span class="line">                      [<span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>],</span><br><span class="line">                      [<span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>],</span><br><span class="line">                      [<span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.04</span>]])</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'test.jpg'</span>)</span><br><span class="line">ndimg = np.array(img)</span><br><span class="line"></span><br><span class="line">k3 = cv2.filter2D(ndimg, <span class="number">-1</span>, kernel_25h)</span><br><span class="line">k5 = cv2.filter2D(ndimg, <span class="number">-1</span>, kernel_25l)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">131</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.title(<span class="string">"source image"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">132</span>)</span><br><span class="line">plt.imshow(k3)</span><br><span class="line">plt.title(<span class="string">"kernel5hpf"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">133</span>)</span><br><span class="line">plt.imshow(k5)</span><br><span class="line">plt.title(<span class="string">"kernel5lpf"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：中间的图为高通滤波，最右方的图为模糊化后的。</p>
<p><img data-src="/2019/02/10/computer-vision/2.png" alt></p>
<hr>
<h2 id="有关卷积神经网络"><a href="#有关卷积神经网络" class="headerlink" title="有关卷积神经网络"></a>有关卷积神经网络</h2><p>在下图中，伴随着三个卷积核对原始图像进行卷积，每个卷积核加一个偏执项biases，这一层网络便会得到三维的输出结果，即输出的通道数(channels)等于检测的特征数(filter numbers)，可以认为一个滤波器检测一个特征。</p>
<p><img data-src="/2019/02/10/computer-vision/3.png" alt></p>
<p>对比全连接神经网络，卷积的优点显而易见：参数共享(每次的输入图像都公用滤波器)、稀疏连接(滤波器的参数明显少于全连接网络的参数数量)。</p>
<p>卷积过后一般会伴随池化，池化虽然没有参数可以调节，但是最大池化会保留下区域的最大的特征(平均池化会淡化最强烈的特征)，最强烈的特征也更加易于区分，使得神经网络的工作更有效。</p>
<p>至此，无论是LeNet，Alexnet，VGG16这些经典的网络的共性便是卷积、池化、卷积、池化一层层堆叠，最后全连接至softmax进行判别分类。</p>
<p><img data-src="/2019/02/10/computer-vision/4.png" alt></p>
<h2 id="使用Keras搭建卷积神经网络"><a href="#使用Keras搭建卷积神经网络" class="headerlink" title="使用Keras搭建卷积神经网络"></a>使用Keras搭建卷积神经网络</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Conv2D, MaxPooling2D</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate dummy data</span></span><br><span class="line">x_train = np.random.random((<span class="number">100</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>))</span><br><span class="line">y_train = keras.utils.to_categorical(np.random.randint(<span class="number">10</span>, size=(<span class="number">100</span>, <span class="number">1</span>)), num_classes=<span class="number">10</span>)</span><br><span class="line">x_test = np.random.random((<span class="number">20</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>))</span><br><span class="line">y_test = keras.utils.to_categorical(np.random.randint(<span class="number">10</span>, size=(<span class="number">20</span>, <span class="number">1</span>)), num_classes=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line"><span class="comment"># input: 32x32 images with 3 channels -&gt; (32, 32, 3) tensors.</span></span><br><span class="line"><span class="comment"># this applies 32 convolution filters of size 3x3 each.</span></span><br><span class="line">model.add(Conv2D(<span class="number">10</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>, input_shape=(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>)))</span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">model.add(Conv2D(<span class="number">5</span>, (<span class="number">4</span>, <span class="number">4</span>), activation=<span class="string">'relu'</span>, input_shape=(<span class="number">15</span>, <span class="number">15</span>, <span class="number">10</span>)))</span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(<span class="number">180</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dense(<span class="number">70</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD</span><br><span class="line"></span><br><span class="line">sgd = SGD(lr=<span class="number">0.01</span>, decay=<span class="number">1e-6</span>, momentum=<span class="number">0.9</span>, nesterov=<span class="literal">True</span>)</span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>, optimizer=sgd)</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">10</span>)</span><br><span class="line">score = model.evaluate(x_test, y_test, batch_size=<span class="number">32</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="残差网络ResNets"><a href="#残差网络ResNets" class="headerlink" title="残差网络ResNets"></a>残差网络ResNets</h2><p>在传统的网络中，数据的传播都是由上一层到下一层，下一层再到下下层，是一种顺序传播的形式。</p>
<p>那么能不能从第一层直接传递到第十层，或者最后一层呢？这就是跳远连接的形式，第一层跨过好几层直接连接到后面的网络，如下图所示。</p>
<p><img data-src="/2019/02/10/computer-vision/6.png" alt></p>
<p>在上图中，蓝色的层输出的数据记为$X$，只考虑一号线，沿着一号线向绿色的层传播时，黄色层的输入为$X_1$，输出为$g(W_1X+b_1)$，记为$Z_1$。绿色层的输入为$Z_1$，输出记为$Z_2$。再来看上面的二号线，就是跳远连接的形式。考虑到二号线时，绿色层的输入是什么呢，是$Z_1+X_1$，即黄色层的输出加上最初的输入作为绿色层的输入。绿色层的输出是对输入的激活。上面的黄色层和绿色层就组成了一个残差块；二号线的连接形式即为跳远连接。</p>
<p>继续以上的内容，假设给一个神经网络添加两层，也就是一个残差块，做一个极端的假设，我们用了relu激活函数，残差块的输入$X_1$(正数)和残差块的输出(正数)保持一致，也就是$g(W_2X_2+b_2+X_1)=X_1$，可以推出$W_2=0,b_2=0$，让一个神经网络去学习这样的一个恒等式不是什么难度。</p>
<p>在跳远连接的过程中，增加这两层和不增加这两层的区别是一样的，也就是，现在我们可以增加网络的层数了。当然也不可能完美的学习出这样的恒等式，如果在学习恒等式的过程中学到了一些其他的有用信息，会提升学习的效率，毕竟恒等式只能保证效率而不是提升效率，可能这就是残差网络的神奇之处。</p>
<hr>
<h2 id="Inception-网络"><a href="#Inception-网络" class="headerlink" title="Inception 网络"></a>Inception 网络</h2><p>与上述经典网络不同的是，Inceotion网络使用了1 $\times$ 1的filter，将多个特征求和便得到了二维的输出，1个这样的滤波器将维度压缩到二维，那么多个1 $\times$ 1 的filter便实现了对上一层输出channels的约减，降低数据维度。 </p>
<p><img data-src="/2019/02/10/computer-vision/5.png" alt></p>
<p>如上图所示，对前一层进行不同的卷积运算(same)后会有多个输出(不同滤波器看到的特征也不同)，将这些输出的结果和池化运算堆叠在一起，得到了这一层的输出，并且作为下一层的输入。不同的卷积结果堆叠在一起使得特征具有更深的维度，多个这样的模块堆叠在一起使得网络更深。</p>
<hr>
<p>残差网络，inception暂时没有实现代码，等到哪天参加破比赛需要这些的时候在补上吧。暂时没写这个代码的经验，写出来也无非是Ctrl C和Ctrl V，没有灵魂。</p>
<hr>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>C++踩坑记录：构造与析构函数</title>
    <url>/2021/07/21/constructor-and-destructor-with-inheritance/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我是练习时长一年的 <code>C++</code> 个人练习生，喜欢野指针、模板报错和未定义行为（undefined behavior）。之前在写设计模式的『工厂模式』时，一脚踩到了构造、继承和 <code>new</code> 组合起来的坑，现在也有时间来整理一下了。</p>
<a id="more"></a>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>众所周知：在创建对象时，防止有些成员没有被初始化导致不必要的错误，在创建对象的时候自动调用构造函数（无声明类型），完成成员的初始化。即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Class c <span class="comment">// 隐式，默认构造函数</span></span><br><span class="line">Class c = Class() <span class="comment">// 显示，默认构造函数</span></span><br><span class="line">Class c = Class(<span class="string">"name"</span>) <span class="comment">// 显示，非默认构造函数 </span></span><br><span class="line">Class* c = <span class="keyword">new</span> Class <span class="comment">// 隐式，默认构造函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数执行前，对象不存在</li>
<li>构造函数创建对象后，对象不能调用构造函数</li>
<li>类中如果不定义构造函数，编译器提供有默认的构造函数，无参数，也不执行任何额外的语句</li>
<li>如果提供非默认构造函数，没有默认构造函数将会出错。所以要定义一个不接受任何参数的构造函数，并为成员定义合理的值</li>
<li>一般而言，默认的构造函数是用来对所有类成员做隐式初始化的</li>
<li>自己定义的构造函数一般用使用列表初始化来初始化参数</li>
<li>通过构造函数对成员赋值，要优于通过函数为成员赋值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by default creator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    Stone(<span class="keyword">int</span> w, <span class="keyword">double</span> r) : weight&#123;w&#125;, radius&#123;r&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by custom creator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;radius &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 隐式，成员有默认值</span></span><br><span class="line">    Stone s1;</span><br><span class="line">    s1.showInfo();</span><br><span class="line">    <span class="comment">// 显式，通过列表初始化，为成员赋值</span></span><br><span class="line">    Stone s2 = Stone(<span class="number">12</span>, <span class="number">3.3</span>);</span><br><span class="line">    s2.showInfo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过构造函数实现的类型转换"><a href="#通过构造函数实现的类型转换" class="headerlink" title="通过构造函数实现的类型转换"></a>通过构造函数实现的类型转换</h2><p>观察以下的代码，我们发现 <code>Stone s2;s2 = 3.3;</code> 这样将一个 <code>double</code> 类型的数据赋值给类类型并没有出错，这是隐式类型转换，从参数类型到类类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by default creator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 都关闭</span></span><br><span class="line">    Stone(<span class="keyword">double</span> r) : radius&#123;r&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by parameter radius"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stone(<span class="keyword">int</span> w) : weight&#123;w&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by parameter weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;radius &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Stone s2;</span><br><span class="line">    s2 = <span class="number">3.3</span>;</span><br><span class="line">    s2.showInfo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为：接受一个参数的构造函数允许使用赋值语法来为对象赋值。<code>s2=3.3</code> 会创建 <code>Stock(double)</code> 临时对象，临时对象初始化后，逐成员赋值的方式复制到对象中，在几个构造函数中加入了 <code>cout &lt;&lt; this</code> 的语句，由对象的地址不同，可以判断该赋值语句额外生成了临时对象。</p>
<p>为了防止隐式转换带来的危险，可以使用关键字 <code>explicit</code> 关闭这一特性，这样就得显式完成参数类型到类类型的转换：<code>s = Stock(1.3)</code>；不过，得保证没有二义性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by default creator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 都关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Stone</span><span class="params">(<span class="keyword">double</span> r)</span> : radius</span>&#123;r&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by parameter radius"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Stone</span><span class="params">(<span class="keyword">int</span> w)</span> : weight</span>&#123;w&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by parameter weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;radius &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Stone s2;</span><br><span class="line">    s2 = Stone(<span class="number">3</span>);</span><br><span class="line">    s2.showInfo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，如果 <code>Stone(int w)</code> 没有被关闭，那么 <code>s2=3.3</code> 将调用这一构造函数。所以构造函数建议都加上 <code>explicit</code> 声明。</p>
<h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h2><p>派生类要注意的是：派生类被构造之前，通过调用一个基类的构造函数，创建基类完成基类数据成员的初始化；也就是说，基类对象在程序进入派生类构造函数之前被创建。那么，可以通过初始化列表传递给基类参数，不传递的话，调用基类的默认的构造函数，如下述程序中的：<code>Gem(){}:Stone()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This object was in address: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    Stone(<span class="keyword">int</span> w, <span class="keyword">double</span> r) : weight&#123;<span class="number">2</span>&#125;, radius&#123;r&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">    auto getRadius() -&gt; double &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gem</span> :</span> <span class="keyword">public</span> Stone &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Gem()&#123;&#125;;</span><br><span class="line">    Gem(<span class="keyword">double</span> p, <span class="keyword">int</span> w, <span class="keyword">double</span> r) : Stone(w, r), price&#123;p&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;getWeight() &lt;&lt; <span class="string">", Radius"</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;getRadius();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Gem g1; <span class="comment">// call default</span></span><br><span class="line">    Gem g2 = Gem(<span class="number">1300</span>, <span class="number">1</span>, <span class="number">2.3</span>); <span class="comment">// call custom </span></span><br><span class="line">    <span class="comment">// g.setWeight(130);</span></span><br><span class="line">    g2.show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先创建基类对象</li>
<li>派生类通过初始化列表（只能用在构造函数）将基类信息传递给基类的构造函数</li>
<li>派生类构造函数可以为派生类初始化新的成员</li>
</ul>
<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>对象过期时，程序会调用对象的析构函数完成一些清理工作，如释放变量开辟的空间等。如构造函数使用了 <code>new</code> 来申请空间，析构就需要 <code>delete</code> 来释放空间。如果没有特别声明析构函数，编译器会为类提供默认的析构函数，在对象作用域到期、被删除时自动被调用。</p>
<p>如 <code>stock1 = Stock()</code>，这种就申请了一个临时变量，变量消失时会调用析构函数。此外，这种局部变量放在栈区，先入后出，也就是，最后被申请的变量最先被释放。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This object was in address: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" Object was deleted."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Stone s1;</span><br><span class="line">        Stone s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承中的析构函数"><a href="#继承中的析构函数" class="headerlink" title="继承中的析构函数"></a>继承中的析构函数</h2><p>继承类比较容易理解，毕竟都学过面向对象。公有继承的时候，基类的公有成员也是派生类的共有成员；私有成员也是派生类的一部分，不过需要共有或保护方法来访问。但是但是但是，派生类和基类的析构函数之间，也是一个坑。在继承中：</p>
<ul>
<li>如果一个方法不是虚方法，那么将根据引用类型或指针类型选择执行的方法</li>
<li>如果一个方法是虚方法，将根据指针或引用指向对象的类型选择执行的方法</li>
</ul>
<p>在继承中，对象的销毁顺序和创建相反。创建时先创建基类，而后创建子类；销毁时，先调用子类的析构函数，而后自动调用基类的析构函数。因此，对于基类而言，建议将析构函数写成虚方法。如果析构不是虚方法，对于以下情况，只有基类的析构被调用；如果析构是虚方法，子类、基类的析构方法都被调用。可以尝试删除下述代码的 <code>virtual</code> 来观察结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This object was in address: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    Stone(<span class="keyword">int</span> w, <span class="keyword">double</span> r) : weight&#123;<span class="number">2</span>&#125;, radius&#123;r&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">    auto getRadius() -&gt; double &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stone class was deleted."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gem</span> :</span> <span class="keyword">public</span> Stone &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Gem() &#123;&#125;;</span><br><span class="line">    Gem(<span class="keyword">double</span> p, <span class="keyword">int</span> w, <span class="keyword">double</span> r) : Stone(w, r), price&#123;p&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;getWeight() &lt;&lt; <span class="string">", Radius"</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;getRadius();</span><br><span class="line">    &#125;</span><br><span class="line">    ~Gem() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Gem class was deleted."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Stone* s1 = <span class="keyword">new</span> Gem(<span class="number">2.3</span>, <span class="number">2</span>, <span class="number">3.2</span>);</span><br><span class="line">    <span class="keyword">delete</span> s1;</span><br><span class="line">    <span class="comment">// Gem* g1 = new Gem(2.3, 2, 1.2);</span></span><br><span class="line">    <span class="comment">// delete g1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>大概常见的坑在上面都记录好了，来看一段我写的危险的程序（我大概抽象了一下），覆盖了：野指针和为定义行为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()&#123;</span><br><span class="line">        <span class="keyword">delete</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">int</span>* b = a.create();</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>每次调用 create 都会 new 一次，但只 delete 了一次。</li>
<li>如果没有调用 create 直接析构，未定义行为</li>
<li>如果 b 持有了 a.create() 的指针，然后 a 提前析构，那么 b 是野指针</li>
<li>delete b 是没必要的。这样会 double free，也是未定义行为</li>
<li>上述代码没有区分类里面 new 且 返回的东西要在哪删除合适</li>
<li>可以让类来管理这一个 new，修改一下 create 的实现或者干脆在构造 new，在析构 delete</li>
</ol>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++函数进阶：内联、重载和模板</title>
    <url>/2021/07/18/cpp-advanced-function/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++ 细节逐步填坑中，还有几个大坑预计 8 月前结束。普通的函数没啥意思了，本文涉及函数的进阶使用，包括：函数的默认参数、内联函数、函数重载和函数模板。</p>
<a id="more"></a>
<h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><p>也就是某些教材上常说的函数声明，如果没有函数原型，那么函数首次使用前出现的整个函数定义充当了函数原型。函数由三部分组成：</p>
<ul>
<li>函数原型，约定好返回值的类型与接受参数的类型。这就描述了函数到编译器的接口，将参数类型和数量提前告知编译器。这样当函数的返回值放到某个寄存器时，编译器也知道检索多少个字节来解释返回值。如果不告知函数原型，<code>main</code> 函数的编译只能终止然后去寻找函数原型，这样会导致效率不高，甚至有些文件没有搜索的权限，这样会报错。而 <code>C++</code> 的编程风格，习惯将 <code>main</code> 函数放在前面，这样更需要函数原型。</li>
<li>函数定义，函数头 + 函数体，实现完整的函数功能。</li>
<li>函数调用，主函数调用子函数完成功能。</li>
</ul>
<p>因此，函数原型有以下的作用：</p>
<ul>
<li>正确处理函数的返回值</li>
<li>检查参数的数目、类型是否正确；如果不正确，尽可能转换为正确类型</li>
</ul>
<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>常规函数和内联函数的<strong>主要区别</strong>不在于编写方式不同，更多的是程序组合到程序中的方式不同。</p>
<ul>
<li><p>对于普通函数而言，程序在执行到函数调用指令时，存储当前指令的地址（保护现场），将函数参数复制到堆栈帧，跳转到子函数起始的内存地址，执行子函数，执行的临时变量放入堆栈帧。执行完毕后，跳回指令被保存的地址处（恢复现场），继续往下执行。使用子函数会造成来回的记录和跳转，造成一定的开销。</p>
</li>
<li><p>内联函数会代替函数调用，内联函数直接被插入到主函数中，这样就无需跳转而是顺序执行。执行速度快，但是需要更大的内存。</p>
</li>
</ul>
<blockquote>
<p>如果函数执行的时间远大于跳转时间，则内联函数的意义不大；如果代码执行时间很短，且需要多次调用，那么内联调用会节省很多时间；如果节省的时间所占执行的时间并不大，或者很少调用，则不需要内联函数。注意，内联函数不能递归。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a&#123;<span class="number">12.3</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="built_in">sqrt</span>(a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p>这个倒是不难，就是为一些参数提供默认值。如果一个参数有默认值，那么，它右边的参数必须也要有默认值，且赋值的时候不允许跳过。按照 <code>main</code> 函数放前面这样的编程风格来试一下，默认值在函数原型中提供，函数定义不需要，否则报错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span> a=<span class="number">1</span>, <span class="keyword">int</span> b=<span class="number">2</span>, <span class="keyword">int</span> c=<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d&#123;<span class="number">12</span>&#125;, e&#123;<span class="number">13</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">11</span>&#125;;</span><br><span class="line">    show_info(d, e, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="string">" "</span> &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>对于一个打印函数 <code>print</code> ，可能传入 <code>int</code> 类型的数据，也可能传入 <code>double</code> 类型的数据，这个时候就需要函数重载。函数重载的重点是函数的特征标，也就是函数的参数列表，也就是参数的数目、类型和排列顺序。比如可以这样重载：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> str, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> str, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a&#123;<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> b&#123;<span class="number">1.23</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"void"</span>;</span><br><span class="line">    print(str, <span class="number">1</span>);</span><br><span class="line">    print(a, <span class="number">1</span>);</span><br><span class="line">    print(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果调用函数出现了未匹配的类型，很可能错误，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a&#123;<span class="number">12</span>&#125;;</span><br><span class="line">print(a, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><code>double</code> 和 <code>int</code> 都可以接受 <code>unsigned int</code> 的参数，二义性的程序会导致错误。</p>
<h2 id="const-重载"><a href="#const-重载" class="headerlink" title="const 重载"></a>const 重载</h2><p><code>const</code> 可以构成重载，不过只能是指针，非指针不构成重载。这也很容易理解，对于非指针而言，<code>const</code> 或非 <code>const</code> 都不重要，因为原数据无法修改，因此不构成重载；指针则不一样，<code>const</code> 表示原数据或指针不修改，非 <code>const</code> 表示原数据或指针任意修改。这是两个含义的特征标，因此可以构成重载。而编译器根据实参是否为 <code>const</code> 来决定匹配的原型函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>* a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="string">"---"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="string">"==="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* a = &amp;p;</span><br><span class="line">    *a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* b = &amp;p;</span><br><span class="line">    print(a);</span><br><span class="line">    print(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>void print(const int* a)</code> 这样的函数，如果没有重载，那么这个函数是可以接收非 <code>const</code> 数据的。</p>
<blockquote>
<p>此外，对于没有任何参数的函数，且不希望函数修改任何变量，可以将 <code>const</code> 关键字放到函数括号的后面。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用重载"><a href="#引用重载" class="headerlink" title="引用重载"></a>引用重载</h2><p>引用无法构成重载，因为无论是否引用，都可以接收参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>&amp; x)</span></span></span><br></pre></td></tr></table></figure>
<p>但是引用加上 <code>const</code>，含义改变，就可以重载。而对于引用的重载，调用最为匹配的版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>&amp; x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 右值引用，没有的话就调用 print(const double&amp; x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>&amp;&amp; x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> x</span>&#123;<span class="number">33.3</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> y&#123;<span class="number">12.3</span>&#125;;</span><br><span class="line">print(x);      <span class="comment">// print(double&amp; x)</span></span><br><span class="line">print(y);      <span class="comment">// print(const double&amp; x)</span></span><br><span class="line">print(x + y);  <span class="comment">// print(double&amp;&amp; x)</span></span><br></pre></td></tr></table></figure>
<h2 id="如何实现重载"><a href="#如何实现重载" class="headerlink" title="如何实现重载"></a>如何实现重载</h2><p><code>C++</code> 通过名称修饰来跟踪重载函数，根据函数原型的函数特征标对函数进行加密。也就是根据特征标对函数进行编码，在函数上添加一组符号后，函数换了个名字作为自己的内部表示，不同特征标的函数名也不一样，不过使用者看不到这一层。具体如何修饰，这取决于编译器。</p>
<p>重载诱人，但使用时一定要注意类型，只有用相同的形式处理不同类型的数据，才会考虑重载。</p>
<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>模板比重载还要更省事一点。使用泛型来定义函数，也就是，类型作为参数传递给模板代码，编译器生成指定类型的函数。也就是说，模板通过泛型（参数化类型）来解决任务。使用背景一般是：同一算法需要处理多种类型的参数。</p>
<p>重载也可以完成这些任务，比如说要交换两个同类型的数，<code>int, double, float, const, char, str, vector</code> 等等等等，重载可以，但是写很多遍会很累。</p>
<p>模板例子：使用 <code>template &lt;typename T&gt;</code> 来建立模板，编译器检查传入的类型参数，生成相应的函数以供执行。程序员看不到生成的代码，但代码确实被生成以及被使用。且最终生成的代码不包含模板，只包含为程序生成的实际代码。如下所示的模板，交换任意简单类型的数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a&#123;<span class="number">1.2</span>&#125;, b&#123;<span class="number">2.1</span>&#125;;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> c&#123;<span class="number">1</span>&#125;, d&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    swap(c, d);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">" "</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般而言，对不同类型使用相同算法会考虑模板。但是，不是所有类型用相同的算法都能实现，比如，对象、数组等会涉及深浅拷贝、地址等，并不像简单数据类型那样容易处理。</p>
<p>举个例子，以交换函数而言，如果是数值类型，就交换；如果是数组类型，交换前 2 个元素；如果是类，有的成员交换有的成员不交换。总之，模板具有局限性，判断相等时，数组不能直接用等号。所以编写的模板很可能无法处理某些类型，大概有两种解决方案：</p>
<ul>
<li>在类中重载运算符，如大小、相等的比较；</li>
<li>为特定类型提供具体化的模板定义</li>
</ul>
<p>但是这部分坑准备留在类的重载运算符、移动语义和深浅拷贝之后了，方便对比。</p>
<h2 id="模板重载"><a href="#模板重载" class="headerlink" title="模板重载"></a>模板重载</h2><p>如果重载模板，函数的特征标同样不能相同。注意，泛型并不是所有参数都得是模板参数类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T a[], T b[], <span class="keyword">int</span> i = <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a&#123;<span class="number">1.2</span>&#125;, b&#123;<span class="number">2.1</span>&#125;;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">4</span>] = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    swap(c, d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c[i] &lt;&lt; <span class="string">" &lt;=&gt; "</span> &lt;&lt; d[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T a[], T b[], <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    T t[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        t[j] = a[j];</span><br><span class="line">        a[j] = b[j];</span><br><span class="line">        b[j] = t[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板的发展"><a href="#模板的发展" class="headerlink" title="模板的发展"></a>模板的发展</h2><p>在 <code>C++98</code> 中，编写模板函数时会一个问题，不知道该声明为哪一种类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T1 x, T2 y)</span> </span>&#123;</span><br><span class="line">    z = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的 <code>z</code> 是什么类型呢？而 <code>C++11</code> 新增的关键字 <code>decltype</code> 提供了解决方案，按照给定的 <code>expression</code> 类型创建指定类型的变量，即 <code>decltype (x) y</code>，<code>y</code> 和 <code>x</code> 同类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x&#123;<span class="number">12.3</span>&#125;;</span><br><span class="line">    <span class="keyword">decltype</span> (x) y;</span><br><span class="line">    <span class="comment">// d</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(y).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么上述模板代码就有了解决方案。而 <code>decltype (expr) var</code> 为确定 <code>var</code> 的类型，遍历一个核对表，只要有一项匹配，那么类型确定完毕，不用在判断后面的。</p>
<ol>
<li><code>expr</code> 是一个没有括号标识符，那么 <code>var</code> 与 <code>expr</code> 相同；</li>
<li><code>expr</code> 是一个函数，<code>var</code> 与函数返回值类型相同；</li>
<li>如果 <code>expr</code> 是一个左值，<code>var</code> 为 <code>expr</code> 类型的引用，以 <code>double</code> 为例， <code>decltype ((x)) y</code>，<code>y</code> 就是 <code>double</code> 类型的引用；</li>
<li>如果不满足以上，那么 <code>expr</code> 与 <code>var</code> 同类型，如 <code>int&amp; x, int&amp; y, decltype (x+y) z</code>，<code>z</code> 是 <code>int</code> 类型，不是引用类型；</li>
</ol>
<p>但是尽管解决了函数中对变量类型的赋值，但是没有解决模板返回值的问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">? gt (T1 x, T2 y)</span><br></pre></td></tr></table></figure>
<p>函数的返回值类型和 <code>T1</code> 和 <code>T2</code> 相关，但是要运算后才知道。但是返回值区域， <code>x,y</code> 还不在作用域内就无法使用，这就成了先有鸡还是先有蛋的问题，那么如何提前知道运算结果的类型呢？即使在函数内部知道了返回值类型，也没办法反馈到函数的声明中。</p>
<p>这个可以通过后置返回值类型 (tailing return type) 可以实现，写法：<code>auto f1(int x, float y) -&gt; double</code>，对应到函数声明，写法如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto f1(T1 x, T2 y) -&gt; decltype(x + y)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++数据结构篇『四』容器适配器：栈、队列与优先级队列</title>
    <url>/2019/06/03/container-adaptor/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>容器适配器是依赖顺序容器的受限版本，处理特殊情况。如：</p>
<ul>
<li>stack：栈，后入先出</li>
<li>queue，队列，先入先出</li>
<li>priority_queue，优先级队列，元素出队顺序取决于优先级</li>
</ul>
<a id="more"></a>
<h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>栈是一种先入先出的数据结构，可以很好的利用这一特性解决问题。常用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="comment">// 压栈</span></span><br><span class="line">s.push(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 查看栈顶元素</span></span><br><span class="line">s.top()</span><br><span class="line"><span class="comment">// 弹栈</span></span><br><span class="line">s.pop()</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>Given some segments of rope, you are supposed to chain them into one rope. Each time you may only fold two segments into loops and chain them into one piece, as shown by the figure. The resulting chain will be treated as another segment of rope and can be folded again. After each chaining, the lengths of the original two segments will be halved.</p>
<p>Your job is to make the longest possible rope out of $N$ given segments.</p>
<p><strong>Input Specification:</strong></p>
<p>Each input file contains one test case. For each case, the first line gives a positive integer $N (2≤N≤10^​4)$. Then $N$ positive integer lengths of the segments are given in the next line, separated by spaces. All the integers are no more than $10^4$.</p>
<p><strong>Output Specification:</strong></p>
<p>For each case, print in a line the length of the longest possible rope that can be made by the given segments. The result must be rounded to the nearest integer that is no greater than the maximum length.</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">10 15 12 3 4 13 1 15</span><br></pre></td></tr></table></figure>
<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure>
<h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>题目大意很简单，两个绳子对折后成为一个新的绳子，这个新的绳子对折后和另外一个对折的绳子组成新的绳子，求最终绳子能有多长。使用栈这种结构会比vector插入删除元素要快上一倍。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">float</span>&gt; arr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        arr.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(arr.begin(), arr.end(), cmp);</span><br><span class="line">    <span class="keyword">float</span> temp, temp1, temp2;</span><br><span class="line">    <span class="built_in">stack</span> &lt;<span class="keyword">float</span>&gt; s;</span><br><span class="line">    <span class="comment">// 按照降序压栈 先折短的 在折长的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); i++)</span><br><span class="line">        s.push(arr[i]);</span><br><span class="line">    <span class="keyword">while</span> (s.size() != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取两个栈顶元素</span></span><br><span class="line">        temp1 = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        temp2 = s.top();</span><br><span class="line">        temp = temp1 / <span class="number">2</span> + temp2 / <span class="number">2</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="comment">// 压入对折后的长度</span></span><br><span class="line">        s.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">floor</span>(s.top());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有其他栈的应用，如『<a href="http://localhost:4000/2020/03/28/stack-pop-sequence/" target="_blank" rel="noopener">判断元素入栈出栈顺序</a>』</p>
<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><p>区别于<code>deque</code>，只能在队首取出元素，只能在队尾加入元素；不能在队首加入元素，不能在队尾删除元素。常用操作为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回队首第一个元素</span></span><br><span class="line">front()</span><br><span class="line"><span class="comment">// 返回队尾最后一个元素</span></span><br><span class="line">back()</span><br><span class="line"><span class="comment">// 队尾添加元素</span></span><br><span class="line">push()</span><br><span class="line"><span class="comment">// 队首删除元素</span></span><br><span class="line">pop()</span><br><span class="line"><span class="comment">// 大小</span></span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="comment">// 是否为空</span></span><br><span class="line">empty()</span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line">swap()</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，<code>queue</code>没有迭代器，只能通过队首、队尾的操作访问元素，但<code>deque</code>有。</p>
<h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><p>优先级队列，同<code>queue</code>的使用，需要先引入头文件<code>#include&lt;queue&gt;</code>才能使用。计算机专业的人可能经常听到『优先级队列』这个词汇，尤其是在操作系统中。按照元素的优先级，决定对其进行的操作，是调用，还是继续等待。这里来直接看一个题目。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Suppose a bank has $K$ windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. All the customers have to wait in line behind the yellow line, until it is his/her turn to be served and there is a window available. It is assumed that no window can be occupied by a single customer for more than 1 hour.</p>
<p>Now given the arriving time $T$ and the processing time $P$ of each customer, you are supposed to tell the average waiting time of all the customers.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 2 numbers: $N (≤10^4$) - the total number of customers, and $K (≤100)$ - the number of windows. Then $N$ lines follow, each contains 2 times: <code>HH:MM:SS</code> - the arriving time, and <code>P</code> - the processing time in minutes of a customer. Here <code>HH</code> is in the range [00, 23], <code>MM</code> and <code>SS</code> are both in [00, 59]. It is assumed that no two customers arrives at the same time.</p>
<p>Notice that the bank opens from 08:00 to 17:00. Anyone arrives early will have to wait in line till 08:00, and anyone comes too late (at or after 17:00:01) will not be served nor counted into the average.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the average waiting time of all the customers, in minutes and accurate up to 1 decimal place.</p>
<h2 id="求解-1"><a href="#求解-1" class="headerlink" title="求解"></a>求解</h2><p>首先创建一个优先级队列，因为这个几个窗口是处理完用户就可以处理下一个用户，用户早到早处理完就早走，所以优先级设置为小，即小的元素先出队。队列的数量就是窗口的个数。然后将用户的到达时间进行排序，逐步入队。</p>
<ul>
<li>若到达时有窗口空闲，直接入队</li>
<li>若到达时无窗口空闲，计算最少需要等待的时间，计算平均等待时间</li>
</ul>
<p>而判断是否有空闲的方法是：判断到达时间与队首元素的值，若大于，说明到达时间大于处理完的时间，说明有空闲，否则无空闲。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> come, time;</span><br><span class="line">&#125; p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(person p1, person p2)</span> </span>&#123; <span class="keyword">return</span> p1.come &lt; p2.come; &#125;</span><br><span class="line"><span class="keyword">int</span> n, k, cnt, total;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> hh, ss, mm, tt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d %d"</span>, &amp;hh, &amp;mm, &amp;ss, &amp;tt);</span><br><span class="line">        <span class="keyword">int</span> sum = hh * <span class="number">3600</span> + mm * <span class="number">60</span> + ss;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">61200</span>) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 处理的时间</span></span><br><span class="line">        p[++cnt].time = tt * <span class="number">60</span>;</span><br><span class="line">        <span class="comment">// 来的时间</span></span><br><span class="line">        p[cnt].come = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照来的时间排序</span></span><br><span class="line">    sort(p + <span class="number">1</span>, p + <span class="number">1</span> + cnt, cmp);</span><br><span class="line">    <span class="comment">// 优先级队列，类型，容器类型，小的先出队</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    <span class="comment">// k 个窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) </span><br><span class="line">        q.push(<span class="number">28800</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="comment">// 来的时候有空闲，丝滑处理，无需等待</span></span><br><span class="line">        <span class="keyword">if</span> (q.top() &lt;= p[i].come) &#123;</span><br><span class="line">            <span class="comment">// 压入截止时间</span></span><br><span class="line">            q.push(p[i].come + p[i].time);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 来的时候窗口有人 ，就是等待时间</span></span><br><span class="line">            total += q.top() - p[i].come;</span><br><span class="line">            <span class="comment">// 新的截止时间</span></span><br><span class="line">            q.push(q.top() + p[i].time);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (!cnt) ? <span class="built_in">printf</span>(<span class="string">"0.0\n"</span>) : <span class="built_in">printf</span>(<span class="string">"%.1lf"</span>, ((<span class="keyword">double</span>)total/<span class="number">60.0</span>)/(<span class="keyword">double</span>) cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序队列，小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列，大顶堆</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 的名称空间</title>
    <url>/2021/06/20/cpp-namespace/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前在学 C++ 的时候，第一个例子大概是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当时也没多想，<code>std</code> 这个东西是什么。后来在接触了其它库后，发现也需要 <code>std</code> 的配合使用，如 <code>std::sort()</code>。今日来仔细研究下名称空间这个东西。</p>
<a id="more"></a>
<p>先掏出 cplusplus.com 来看看 <code>&lt;iostream&gt;</code> 是什么东西，官方的定义如下：</p>
<blockquote>
<p>Header that defines the standard input/output stream objects. After C++11, including <code>&lt;iostream&gt;</code> automatically includes also <code>&lt;ios&gt;</code>, <code>&lt;streambuf&gt;</code>, <code>&lt;istream&gt;</code>, <code>&lt;ostream&gt;</code> and <code>&lt;iosfwd&gt;</code>.</p>
</blockquote>
<p>而对于 <code>std</code> 而言，<code>std</code> 是一个名称空间，<code>::</code> 是作用域解析运算符，<code>std::cout</code> 的意思就是使用 <code>std</code> 名称空间中的 <code>cout</code> 标识符，也就是这个对象。而这个对象的定义在 <code>&lt;iostream&gt;</code> 这个标准库文件中，所以要包含这个头文件，才能使用 <code>cout</code> 这个对象。</p>
<p>除此之外，C++ 标准库中的<strong>函数或对象</strong>都是在名称空间 <code>std</code> 中定义的，所以我们要使用标准函数库中的<strong>函数或对象</strong>都要使用 <code>std</code> 来限定。所以使用 <code>cout</code> 的时候要加上 <code>std::</code> 时，编译器就会明白我们调用的 <code>cout</code> 是名字空间 <code>std</code>中的 <code>cout</code>，而不是其它名称空间中的 <code>cout</code>。</p>
<ul>
<li><code>#include</code> 是预处理器编译指令，表示使用预处理器在主编译之前对源文件进行整理。这里并不需要任何指令调用预处理器，编译时自动调用执行。这里的意思就是将 <code>iostream</code> 文件中的内容添加到程序中，即合成为一个新文件。这里的用途就是，在源文件被编译之前，替换或添加文本，这也是典型的一种预处理器操作。</li>
<li><code>using namespcec std</code> 是编译指令，如果是 <code>#include &lt;xxx.h&gt;</code> 则不需要 <code>using</code> 编译指令，因为老式的头文件没有使用名称空间。新头文件使用了 <code>std</code> 名称空间，标准库的类、函数、变量是 C++ 编译器的标准组件，被放到了 <code>std</code> 空间中。</li>
</ul>
<p>但是，尽量不要使用 <code>using namespace std</code>，这句话的意思是告诉编辑器我们将要使用空间 <code>std</code> 中的函数或者对象。或者说，能不用就不用，能在大括号里面用就不要在外面用，尤其是在 <code>.h</code> 等头文件中。幻想一下，你写的 <code>.h</code> 文件被其它人使用，你的名字空间和他人的名字空间不一样，但名字空间下面的函数名一样，就会导致冲突。跟 <code>python</code> 中写 <code>from numpy import *</code> 一个道理。</p>
<h1 id="自定义名称空间"><a href="#自定义名称空间" class="headerlink" title="自定义名称空间"></a>自定义名称空间</h1><p>名称空间提供了一个声明名称的区域，而可以通过作用域解析运算符 <code>::</code> 访问其中的名称。如下是一种简单的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mylib/show_info.h 文件下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 名称空间</span></span><br><span class="line"><span class="keyword">namespace</span> std1 &#123;</span><br><span class="line">    <span class="comment">// 名称</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cout</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cout</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"second"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp 文件下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mylib/show_info.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="using-声明与编译指令"><a href="#using-声明与编译指令" class="headerlink" title="using 声明与编译指令"></a>using 声明与编译指令</h2><p>有的时候并不希望每次使用名称时都进行限定，所以 <code>C++</code> 提供了两种机制，<code>using</code> 声明使得特定的名称可用，<code>using</code> 编译指令使名称空间中的所有名称可用，两者都可以简化名称空间中名称的使用，也都会增加名称冲突的可能性。</p>
<p>对于 <code>using</code> 声明而言，将指定的的名称添加到声明区域，使其可用。如下所示的代码：</p>
<ul>
<li>在声明的作用域内，不能在声明其它同名变量；</li>
<li>屏蔽全局同名变量。除用户定义的名称空间外，还存在一个全局名称空间，全局变量在这里面。同 <code>C++</code> 的局部变量会屏蔽全局变量一样，名称空间也是如此，但两个名称空间中的同名变量并不会冲突。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 冲突</span></span><br><span class="line">    <span class="comment">// int a;</span></span><br><span class="line">    <span class="keyword">using</span> test::a;</span><br><span class="line">    <span class="comment">// 冲突</span></span><br><span class="line">    <span class="comment">// int a;</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 12</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>using</code> 编译指令而言，会使所有名称可用，包括可能不会使用的名称。如下所示的代码：</p>
<ul>
<li><code>test::a</code> 位于局部名称空间，不会影响全局变量；</li>
<li>局部同名变量会屏蔽名称空间里的变量和全局变量。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局名称空间</span></span><br><span class="line"><span class="comment">// using namespace test;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 编译指令</span></span><br><span class="line">    <span class="comment">// 局部名称空间</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> test;</span><br><span class="line">    <span class="comment">// 不冲突</span></span><br><span class="line">    <span class="keyword">int</span> a&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 全局变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 名称空间的变量</span></span><br><span class="line">    test::a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; test::a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下就是，当名称空间和声明区域定义了相同的名称：</p>
<ol>
<li><code>using</code> 声明导入时，会冲突；</li>
<li><code>using</code> 编译指令导入时，局部名称会屏蔽名称空间里面的名称，且没有警告。</li>
</ol>
<p>因此，使用 <code>using</code> 声明会更加安全，编译指令可能会掩盖一些同名变量。此外，还有一些其它要注意的点：</p>
<ul>
<li>名称空间可以嵌套，但最好加上限定，表明这个名称的来源；</li>
<li>以函数为例，名称空间里面的函数的声明和定义要在同一名称空间内；</li>
<li>如果函数被重载，那么一个 <code>using</code> 声明将导入所有版本；</li>
<li><p>对于未命名的名称空间，不能显式使用 <code>using</code>，不能在名称空间之外的文件使用名称空间中的名称。这可以作为<strong>链接性为内部静态变量的替代品</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 名称空间中的 a</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当名称空间很长时，可以简化名称空间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MEF = math::element::fire;</span><br><span class="line"><span class="keyword">using</span> MEF::flame;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>交叉熵优缺点分析</title>
    <url>/2021/04/02/cross-entropy/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>继上次了解完<a href="https://muyuuuu.github.io/2020/05/09/entropy/">信息熵</a>后，没想到在对抗训练中又回到了损失函数的分析上。<code>torch</code>实现的有点迷惑，正好趁这次机会，连着代码和公式好好推导下。这种损失的优缺点日后会放上来，主要取决论文进度。</p>
<a id="more"></a>
<h1 id="一个简单实例"><a href="#一个简单实例" class="headerlink" title="一个简单实例"></a>一个简单实例</h1><p>交叉熵的公式定义耳熟能详了：</p>
<p>\begin{equation}\label{ce}<br>H(p,q) = -\sum_{x\in X} p(x) \log q(x)<br>\end{equation}</p>
<p>这里带入一个实例算一下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example of calculating cross entropy</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log2</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate cross entropy</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_entropy</span><span class="params">(p, q)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> -sum([p[i] * log2(q[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(p))])</span><br><span class="line"></span><br><span class="line"><span class="comment"># define data</span></span><br><span class="line">p = [<span class="number">0.10</span>, <span class="number">0.40</span>, <span class="number">0.50</span>]</span><br><span class="line">q = [<span class="number">0.80</span>, <span class="number">0.15</span>, <span class="number">0.05</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate cross entropy H(P, Q)</span></span><br><span class="line">ce_pq = cross_entropy(p, q)</span><br><span class="line">print(<span class="string">'H(P, Q): %.3f bits'</span> % ce_pq)  <span class="comment"># H(P, Q): 3.288 bits</span></span><br><span class="line"><span class="comment"># calculate cross entropy H(Q, P)</span></span><br><span class="line">ce_qp = cross_entropy(q, p)</span><br><span class="line">print(<span class="string">'H(Q, P): %.3f bits'</span> % ce_qp)  <span class="comment"># H(Q, P): 2.906 bits</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 bit 的信息差异</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，$H(p,q) \neq H(q,p)$。那么再来看深度学习中的定义，其实都一样，只是深度学习中要求真实标签不能是 $\log$ 那一项，因为 $\log$ 的定义域不能取 0。</p>
<p>\begin{equation}<br>H = -\sum_{c=1}^M y \log \hat{y}<br>\end{equation}</p>
<p>其中，$y$ 是真实的标签，$M$ 是类别数量，$\hat{y}$ 是自己预测的结果。如果是三分类问题，假设 $y=[1,0,0]$，$\hat{y}=[0.4,0.1,0.5]$，那么此时的交叉熵是 $-\log 0.4$。<strong>因为其它标签取值是 0，即不参与运算</strong>，换句话说，交叉熵的损失只取决于被正确分类的概率，具体缺陷可以公式推导一下。带入上述代码，得到一致的结果。</p>
<h1 id="torch-实现"><a href="#torch-实现" class="headerlink" title="torch 实现"></a>torch 实现</h1><p>用过 tensorflow 和 keras 之后，愈发的发现 pytorch 真好用。<code>torch</code> 实现的交叉熵有一点需要注意，是通过 <code>logsoftmaax + NLLLoss</code> 实现的，实际代码中要注意这里，不要操作失误。 </p>
<ol>
<li>当获取网络的输出后，这里设网络的输出是 $O$，那么直接将 $O$ 扔进 <code>logsoftmax</code> 为交叉熵做准备，不需要激活。相当于计算公式 $\eqref{ce}$ 中的 $\log$ 那一项。</li>
<li>而后 <code>logsoftmax</code> 的输出进入 <code>NLLLoss</code>，计算真正的交叉熵损失。计算方法为，如果是三分类的任务，<code>logsoftmax</code> 的输出是 $-0.5,-0.1,-0.4$，如果当前类别是第一个类，那么损失就是 0.5，具体原因参考上述公式推导。</li>
</ol>
<p>如果你感觉哪里错了，可以看文末的参考链接中，有人用各种方法试验了 <code>torch</code> 的交叉熵，验证了 <code>torch</code> 的实现是正确的。</p>
<h1 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h1><ol>
<li>优点：对于 softmax 函数，常用的 MSE 误差越大，下降越慢。但交叉熵能很好改善这个问题，当误差较大时，梯度也大，下降的较快；也避免了某些情况下激活函数进入饱和区，梯度消失的问题。详情参考文末的公式推导。</li>
<li>缺点：论文要用，等哪天论文尘埃落定，我在回来填坑。<del>你可以手推公式，推着推着就发现了。</del></li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://ml-cheatsheet.readthedocs.io/en/latest/loss_functions.html" target="_blank" rel="noopener">交叉熵定义</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/159477597" target="_blank" rel="noopener">torch 交叉熵代码验证</a></li>
<li><a href="https://byjiang.com/2017/07/16/Cross_Entropy_Cost_Function/" target="_blank" rel="noopener">交叉熵优点及公式推导</a></li>
</ol>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 多线程</title>
    <url>/2021/08/12/cpp-thread-safe/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>rush 项目的时候，有些地方可以并行化，可以借助 C++ 的多线程来加速程序的执行。多线程的基本概念在一年前整过了，这里只是来看一下 C++ 的多线程该怎么写，顺便查漏补缺。</p>
<a id="more"></a>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>在多线程进入 C++ 标准之前，人们使用 C++ 编写多线程的程序，只能依赖操作系统提供的 API。比如在 Linux 环境下就只能使用 pthread 库实现多线程，因此也一直被诟病。但有了 C++11 的 <code>std::thread</code> 以后，可以通过标准库在语言层面编写多线程程序了，直接的好处就是多线程程序的跨平台移植提供了便利。但是在编译的时候需要注意链接平台相关的线程库，如 <code>g++ demo.cpp -lpthread -o test.o</code>。</p>
<h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::thread t&#123;show_info, s&#125;;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上述程序为例，来详细的剖析一下多线程期间到底发生了什么：</p>
<ol>
<li>首先引入头文件 <code>thread</code>，在这个头文件中，C++ 11 提供了创建、管理线程的类和方法；</li>
<li>使用 <code>std::thread</code> 创建线程，并通过列表初始化传入函数名作为构造函数的参数。传入的函数会作为子线程的入口函数，也就是说，当子线程准备就绪之后，就会开始执行这个入口函数。由于函数名表示函数的地址，子线程可以快捷的找到函数地址进而执行。<blockquote>
<p>我们知道，每个程序都有一个入口。当程序被装载到内存，处于系统态完成一些初始化的工作之后，控制权就转交给程序入口，并以此为标志进入用户态，这是一个程序的开始。同样地，线程也需要有「开始」的地方。作为线程入口的函数，就是线程函数，也就是例子中的 show_info。线程函数必须在启动线程之前，就准备好，否则线程去执行什么呢？并在线程初始化后立即执行。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
</blockquote>
</li>
<li>当线程函数返回时，线程也就随之终止了，上述程序中使用 <code>join</code> 衔接方法确保主线程在子线程退出之后才退出，因为主线程会阻塞住，直到该子线程退出为止。如果程序员没有显式的说明线程结束该如何处理，那么线程对象在被销毁时调用的析构函数中，会调用 <code>std::terminate()</code> 函数，销毁当前对象。如果程序写多了，应该不至于犯主线程退出子线程还没结束的低级错误。</li>
</ol>
<h2 id="detach"><a href="#detach" class="headerlink" title="detach"></a>detach</h2><p>前面说过线程的 <code>join</code> 会阻塞调用线程，可以使用 <code>detach</code> 来避免，但一定要做好控制：避免主线程退出子线程还没结束的低级错误。一个 cppreference 官网的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">independentThread</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Starting concurrent thread.\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exiting concurrent thread.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCaller</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Starting thread caller.\n"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(independentThread)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exiting thread caller.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    threadCaller();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Starting thread caller.</span></span><br><span class="line"><span class="comment">// Starting concurrent thread.</span></span><br><span class="line"><span class="comment">// Exiting thread caller.</span></span><br><span class="line"><span class="comment">// Exiting concurrent thread.</span></span><br></pre></td></tr></table></figure>
<h1 id="可调用类型"><a href="#可调用类型" class="headerlink" title="可调用类型"></a>可调用类型</h1><p>在创建线程对象时，传入的参数不仅是可被调用执行的函数，类的对象如果能被调用，也是可以作为线程对象的参数，用于构造函数初始化线程对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">()</span></span>=<span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> a)</span> : cnt</span>&#123;a&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;cnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread t&#123;Task&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为要调用对象，所以重载了 <code>()</code> 运算符，不然线程不知道去哪个地址执行。此外，构造函数传入的是一个类类型的对象，所以对象会被拷贝到线程的存储空间，而后再开始执行。因此，<strong>类必须做好足够的拷贝控制</strong>，不然将出现难以调试的 bug，<del>我大概只知道深浅拷贝，等有时间了去看下移动语义</del>。</p>
<p>当然，不重载 <code>()</code> 运算符，选择类中的函数执行也是可以的，不过需要注意以下两点：</p>
<ul>
<li>必须显式地使用函数指针，作为 <code>std::thread</code> 构造函数的第一个参数；知道执行哪个函数。</li>
<li>非静态成员函数的第一个参数，实际上是类实例的指针。所以在创建线程时，需要显式地填入这个参数；知道执行的函数在哪个对象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">()</span></span>=<span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> t)</span> : a</span>&#123;t&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::thread t&#123;&amp;A::show_info, &amp;a&#125;;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他要注意的数据类型"><a href="#其他要注意的数据类型" class="headerlink" title="其他要注意的数据类型"></a>其他要注意的数据类型</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>如果子线程函数的参数是引用类型，也需要格外注意。由于子线程的数据是主线程的拷贝，因此子线程函数得到的拷贝实际是「线程存储空间中的拷贝的引用」，并不是主线程中的变量，应该使用 <code>std::ref()</code> 来生成正确的引用绑定，否则会报错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::thread t&#123;show_info, <span class="built_in">std</span>::ref(s)&#125;;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>右值引用和移动语义等我后期开坑了。</del></p>
<h1 id="锁与线程安全"><a href="#锁与线程安全" class="headerlink" title="锁与线程安全"></a>锁与线程安全</h1><p>众所周知，<del>写代码的人都学过操作系统，学过操作系统都知道线程同步</del>。线程同步一般有三种机制：互斥量、信号量和条件变量，这三者到底什么已经在<a href="https://muyuuuu.github.io/2021/02/19/process-synchronization/">这篇博客</a>中详细的描写过了，所以不再多说。不过当时是用 C 语言写的，现在来了解下 C++ 的写法。</p>
<h2 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123;</span><br><span class="line">        mtx.lock();</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1</span>));</span><br><span class="line">        counter++;</span><br><span class="line">        mtx.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(increase, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(increase, <span class="number">100</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"counter:"</span> &lt;&lt; counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>引入 <code>mutex</code> 头文件，创建 <code>std::mutex</code> 对象 <code>mtx</code></li>
<li>对于 <code>mtx</code> 对象，任意时刻最多允许一个线程对其进行上锁，上锁后操作变量，就不会出错</li>
<li><code>mtx.try_lock()</code> 是尝试上锁，如果上锁不成功，当前线程不阻塞</li>
<li>在用完锁之后一定记得释放锁，否则会发生死锁现象</li>
</ol>
<h2 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h2><p>为了避免 <code>mutex</code> 忘记解锁等情况，可以使用 <code>std::lock_guard</code>，<a href="https://en.cppreference.com/w/cpp/thread/lock_guard" target="_blank" rel="noopener">这个类</a>只有构造函数和析构函数，搭配 <code>mutex</code> 使用，在创建这个对象时传入锁，调用锁的 <code>lock</code> 函数；变量销毁会调用析构函数，此时调用锁的 <code>unlock</code> 函数，这也就是传说中的 RAII 机制 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p>
<p>如下述程序 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> ，避免一个线程意外退出没来得及释放锁，导致另一个线程无法获取资源而死锁。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase_proxy</span><span class="params">(<span class="keyword">int</span> time, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"throw excption...."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前线程休眠1毫秒</span></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1</span>));</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> time, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        increase_proxy(time, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt; <span class="string">", "</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(increase, <span class="number">100</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(increase, <span class="number">100</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"counter:"</span> &lt;&lt; counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lock-guard-与-adopt-lock"><a href="#lock-guard-与-adopt-lock" class="headerlink" title="lock_guard 与 adopt_lock"></a>lock_guard 与 adopt_lock</h2><p>还有一种为了防止死锁的方式是一次性申请所有临界资源的互斥量，只有申请到才能进行之后的操作，而 <code>std::lock</code> 提供了这种实现 <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>。此外，为了防止没有锁定或提前释放互斥量导致危险，可以使用 <code>lock_guard</code> 并传入 <code>std::adopt_lock</code>，前者保证当变量销毁时释放互斥量，后者保证线程已经上锁成功时不再调用 <code>lock()</code> 函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bank_account</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bank_account</span><span class="params">(<span class="keyword">int</span> balance)</span> : <span class="title">balance</span><span class="params">(balance)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> balance;</span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(bank_account &amp;from, bank_account &amp;to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// avoid deadlock in case of self transfer</span></span><br><span class="line">    <span class="keyword">if</span>(&amp;from == &amp;to) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    <span class="comment">// lock both mutexes without deadlock</span></span><br><span class="line">    <span class="built_in">std</span>::lock(from.m, to.m);</span><br><span class="line">    <span class="comment">// make sure both already-locked mutexes are unlocked at the end of scope</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock1</span><span class="params">(from.m, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock2</span><span class="params">(to.m, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    from.balance -= amount;</span><br><span class="line">    to.balance += amount;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">bank_account <span class="title">my_account</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">bank_account <span class="title">your_account</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(transfer, <span class="built_in">std</span>::ref(my_account), <span class="built_in">std</span>::ref(your_account), <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(transfer, <span class="built_in">std</span>::ref(your_account), <span class="built_in">std</span>::ref(my_account), <span class="number">5</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 <code>adopt_lock</code> 之外，还有 <code>try_to_lock</code>，<code>defer_lock</code>，他们都有不同的应用场景，还可以配合使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_block</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//unique_lock有多组构造函数, 这里std::defer_lock不设置锁状态</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">my_lock</span> <span class="params">(mtx, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">//尝试加锁, 如果加锁成功则执行</span></span><br><span class="line">    <span class="comment">//(适合定时执行一个job的场景, 一个线程执行就可以, 可以用更新时间戳辅助)</span></span><br><span class="line">    <span class="keyword">if</span>(my_lock.try_lock()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他锁的内容实在是太多了，还有时间锁、递归锁、<code>lock_unique</code>，读写锁的 <code>shared_lock</code> 等等，等哪天用到在整理这些，这里只整理最简单的，详情可以参考 cppreference <sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>。</p>
<h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p>如果按照之前 <code>C</code> 语言的写法，条件变量需要注意的是 <code>wait</code> 那边的判断一定是 <code>while</code> 循环。<a href="https://blog.7rule.com/2018/11/24/thread.html" target="_blank" rel="noopener"><code>C</code> 语言风格的代码</a>。</p>
<p>当然，如果按照 <code>C++</code> 的写法，我们发现条件变量的 <code>wait</code> 方法有<a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait" target="_blank" rel="noopener">两个参数</a>，第二个参数用于接受一个变量，如果继续等待，那么那个变量的取值是 <code>false</code>，如果不需等待，那么那个变量返回 <code>true</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex g_mutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable g_cond;</span><br><span class="line"><span class="keyword">int</span>  g_i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> g_running = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>; </span><br><span class="line">      ++g_i;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"plus g_i by func thread "</span> </span><br><span class="line">                &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待被唤醒</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"wait for exit"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  g_cond.wait(lock, [=] &#123;<span class="keyword">return</span> g_running;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func thread exit"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(ThreadFunc, n)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">      ++g_i;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"plus g_i by main thread "</span> </span><br><span class="line">                &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 唤醒</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">    g_running = <span class="literal">true</span>;</span><br><span class="line">    g_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  t1.join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g_i = "</span> &lt;&lt; g_i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plus g_i by func thread 140476623930944</span><br><span class="line">plus g_i by func thread 140476623930944</span><br><span class="line">wait for exit // 表示子线程等待唤醒</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">func thread exit // 子线程被唤醒</span><br><span class="line">g_i = 200</span><br></pre></td></tr></table></figure>
<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>因为一开始我也不知道该怎么去写信号量，所以打开了万能的搜索引擎，看到了关于 C++ 不支持信号量这样的东西 <sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>。如果想实现信号量，可以通过互斥量和条件变量来实现。而关于信号量和互斥量的区别，在<a href="https://muyuuuu.github.io/2021/02/19/process-synchronization/">这篇文章</a>中已经写明了。那么来实现一个信号量的类 <sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::mutex mutex_;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable cv_;</span><br><span class="line">  <span class="keyword">int</span> count_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> count = <span class="number">0</span>)</span> : <span class="title">count_</span><span class="params">(count)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    ++count_;</span><br><span class="line">    cv_.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="comment">// 第二个参数，如果返回 false 继续等待, 如果为 true，可以继续申请资源</span></span><br><span class="line">    cv_.wait(lock, [=] &#123; <span class="keyword">return</span> count_ &gt; <span class="number">0</span>; &#125;);</span><br><span class="line">    --count_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">FormatTimeNow</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">time_t</span> now_c = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(now);</span><br><span class="line">  <span class="built_in">std</span>::tm* now_tm = <span class="built_in">std</span>::localtime(&amp;now_c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">std</span>::strftime(buf, <span class="keyword">sizeof</span>(buf), format, now_tm);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Semaphore <span class="title">g_semaphore</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// 防止同时抢占输出资源</span></span><br><span class="line"><span class="built_in">std</span>::mutex g_io_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  g_semaphore.Wait();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::thread::id thread_id = <span class="built_in">std</span>::this_thread::get_id();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> now = FormatTimeNow(<span class="string">"%H:%M:%S"</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_io_mutex)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; thread_id &lt;&lt; <span class="string">": wait succeeded"</span> </span><br><span class="line">              &lt;&lt; <span class="string">" ("</span> &lt;&lt; now &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Sleep 1 second to simulate data processing.</span></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  g_semaphore.Signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    v.emplace_back(&amp;Worker);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::thread&amp; t : v) &#123;</span><br><span class="line">    t.join();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>信号量的值为 3，表示能同时申请 3 个资源</li>
<li>当一个线程申请资源后，即执行了 <code>wait</code> 操作，<code>count_</code> 取值递减，表示有一个资源被占用</li>
<li>当 <code>count_</code> 取值小于 0 时，调用条件变量的 <code>wait</code> 方法，当先线程等待有了资源被唤醒</li>
<li>当一个线程释放资源后，执行了 <code>signal</code> 操作，<code>count_</code> 取值递增，表示有一个资源被释放，并执行 <code>notify_one</code> 方法，即唤醒一个等待的线程</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://liam.page/2017/05/16/first-step-on-multithread-programming-of-cxx/" target="_blank" rel="noopener">线程函数</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zhuanlan.zhihu.com/p/34660259" target="_blank" rel="noopener">RAII机制</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zhuanlan.zhihu.com/p/91062516" target="_blank" rel="noopener">线程异常退出导致死锁</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://en.cppreference.com/w/cpp/thread/lock" target="_blank" rel="noopener">std::lock申请多个互斥量</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;"><a href="https://en.cppreference.com/w/cpp/thread/lock_tag_t" target="_blank" rel="noopener">cppreference_lock</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.boost.org/doc/libs/1_31_0/libs/thread/doc/faq.html" target="_blank" rel="noopener">C++不支持信号量</a></span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;"><a href="https://segmentfault.com/a/1190000006818772" target="_blank" rel="noopener">信号量实现</a></span><a href="#fnref:7" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2019/06/26/datastructure/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算机网络的坑还没有填完，于是我决定开个新坑。<br>二刷完了数据结构，来一个粗暴的整理。<br>高能慎入，只是简单的总结，并没有复杂的推导过程和代码。</p>
<a id="more"></a>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>程序设计 = 算法 + 数据结构。<br><code>数据</code>：描述事物的符号，可以输出计算机并处理。<br><code>数据元素</code>：组成数据的有意义的基本单位。人群中的数据元素就是人。<br><code>数据项</code>：描述数据元素的最小单位，不可切分。<br><code>数据对象</code>：性质相同的数据元素的结合，是数据的子集。<br><code>数据结构</code>：相互之间存在一种或多种特定关系的数据元素的集合。<br><code>数据类型</code>：性质相同的值的集合及定义在上面的操作。<br><code>抽象数据类型</code>：一个数学模型及在上面的操作。</p>
<p>逻辑结构面向问题，物理结构面向计算机</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>图、树、集合、线性结构。线性结构中常用的为：队列、栈、线性表。</p>
<h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p><code>顺序存储</code>：如数组，逻辑关系和物理关系对应。</p>
<p><code>链式存储</code>：逻辑关系和物理关系无关，逻辑相邻，物理不相邻。靠存储单元中的指针指向下一个地址。</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><p><code>输入输出</code>：可以没有输入，但至少有一个输出<br><code>有穷性</code>：可接受的时间内求解<br><code>确定性</code>：对于任何输入或相同输入，得到唯一确定的解<br><code>可行性</code>：有限步骤内求解问题</p>
<h2 id="算法的目标"><a href="#算法的目标" class="headerlink" title="算法的目标"></a>算法的目标</h2><p><code>正确性</code>：算法的输出是正确的，通常用数学的方法证明<br><code>可读性</code>：通俗易懂<br><code>健壮性</code>：面临任何极端输入，都能得到确定的输出<br><code>时间存储</code>：算法执行时间快，需要的存储空间少</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>算法的渐进增长取决于最高项，执行次数$T(n)$是关于问题规模$n$的函数，$T(n)=O(f(n))$，增长率和$f(n)$相同，称为渐进时间复杂度，也叫时间复杂度，只保留最高项，去除常熟和系数。</p>
<script type="math/tex; mode=display">1<\log_n<n\log_n<n^2<n^3<2^n<n!<n^n</script><p>最坏情况的时间复杂度是算法的保证，代码中辅助存储空间的空间复杂度一律为$O(1)$。</p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>零个或多个相同类型的数据元素组成的有限序列（一个数据元素可以包括多个数据项）。</p>
<p><code>顺序结构</code>：存取为$O(1)$，不能为逻辑关系的增加设置额外的存储空间。插入与删除为$O(n)$，主要是元素的移动。难以确定容量，可能会造成内存空间的碎片。</p>
<p><code>链式结构</code>：头指针指向下一个元素，最后节点的指针为空。存取的复杂度为$O(n)$，并不知道元素的位置在哪里，插入删除的时间复杂都为$O(1)$。整表的删除与创建，头插入，尾插入，需要借助两个指针。</p>
<p><code>静态链表</code>：数组表示链式线性表。使用数组式结构体，每个数组有两个值，一个表示本节点的值，一个表示下一个节点在数组中的位置。</p>
<p><code>循环链表</code>：尾指针指向头指针。</p>
<p><code>双向链表</code>：节点加入前驱后继。</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>也属于线性表，只能在表尾进行插入和删除，表尾也是栈顶。顺序存储使用数组，链式存储使用指针，结构体存储指向自己的指针和值。</p>
<p>两栈共享空间，当两个栈顶指针重合时栈溢出。</p>
<p>栈的应用，递归。递归易懂，但是迭代不用占用额外的存储空间。</p>
<p><code>递归</code>, 每次递归都会产生调用栈，不在可执行文件中，在执行时创建。调用栈所在的段为<code>堆栈段</code>，有自己的大小不能越界访问，否则为段错误。每次递归会在<code>调用栈</code>里增加一个栈帧，越界后的错误为栈溢出。</p>
<p><code>后缀表达式的应用</code>：也称为逆波兰表达式，Reverse Polish Notation。无括号表达式。数字压栈，遇到操作符取出来，后者操作前者。</p>
<p><code>中缀表达式转后缀</code>：是正常的小学算术的四则运算。1.数字直接输出。2.遇到<code>)</code>，输出遇到第一个<code>(</code>之间所有的符号。3.<code>(</code>直接压栈。4.后来者优先级高则压栈，优先级低，弹两个。完成转后缀表达式。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>一端进，一端出，先进先出。如操作系统的任务序列，键盘输入到记事本的显示同样为队列。简单的顺序存储会造成存储资源的浪费，循环队列可以对空白位置利用。位置计算<code>(rear+1)%QueueSize==front</code>。链式结构同样，先进先出，包括了指针与值。</p>
<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><p>零个字符或多个字符组成的有限序列，序列表明了元素的前驱后继的关系。<br><code>子串的位置</code>：子串对应到主串中，第一个字符的位置。<br><code>顺序存储</code>：”\0”表示结束，不计入长度。<br><code>链式存储</code>：一个节点可以存储多个字符。<br><code>朴素匹配</code>：最好的复杂度为$O(1)$，平均复杂度为$O(m+n)$，最坏为$O((n-m+1)\cdot m)$<br><code>KMP匹配</code>： 两个步骤，根据字符串中重复元素计算<code>next</code>数组，根据<code>next</code>数组计算字串中$j$的位置。主串中的$i$不回溯提高效率。<br>计算<code>next</code>方法：$next[1]=0,next[j]=max\{k|p_{k+1}=p_{j-k+1}\}$，其余情况为1。时间复杂度为$O(m+n)$。在许多部分匹配下能体现优势。</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一对多的层次关系，有限集合，结点$n\geq 0$。根节点下的子树没有交集，不构成环。</p>
<p><code>节点的度</code>：节点拥有孩子的数量称为节点的<code>度</code>。所有节点中最大的度为树的<code>度</code>。度为0是叶子节点或，度不为0的非根节点是分支节点。<br><code>树的深度</code>：根在第一层，根的孩子是第二层，依次类推到树中的最大层，得到树的深度。<br><code>森林</code>：多个不相交的树的结合。<br><code>节点的关系</code>：节点的子树称为节点的孩子，节点是子树的父亲。</p>
<p>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</p>
<p><code>存储方式</code>：树的表示方法多种多样，如一个域存数值，或者一个域存指向父亲的指针，或者一个域指向多个孩子节点，或者有几个孩子就有几个域，然后指针指过去。实现方法多种多样，需要根据实际情况加以调整。</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二又树（Binary Tree）是$n(n\geq 0)$个结点的有限集合，该集合或者为空集（称为空二叉树）。<br>或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。<br>不存在度大于2的节点，左右子树的顺序不能任意交换，交换后不是相同的二叉树，严重区分左右。</p>
<p><code>五种形态</code>：1.空二叉树。2.只有一个节点。3.只有左子树。4.只有右子树。5.左右子树都有。</p>
<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><p><code>斜二叉树</code>：只有左二叉树或只有右二叉树。<br><code>满二叉树</code>：所有分支节点都存在左子树和右子树。所有叶子节点在同一层。同深度的二叉树中，满二叉树的节点数最多。非叶节点度数必须为2。<br><code>完全二叉树</code>：从上到下，从左到右开始编号，和满二叉树完全对应。叶子节点在最下两层。最下层的叶子在左边。不存在只有右孩子而不存在左孩子的情况。</p>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p><code>1.</code>二叉树的第$i$层至多有$2^{i-1}$个节点。<br><code>2.</code>深度为$k$的二叉树之多有$2^k-1$个节点，等比序列求和。<br><code>3.</code>二叉树中，终端节点的数量等于节点为2的数量+1。<br><code>4.</code>具有$n$个节点的完全二叉树的深度为$\lfloor \log_2 n\rfloor+1$。<br><code>5.</code>完全二叉树中，从1开始编号，节点乘以2是左节点，乘以2在加1是右节点。</p>
<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p>二叉树的遍历（traversing binary tree）是指从根结点出发，接照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。<br><code>前序遍历</code>：先根节点，然后左子树，然后右子树。<br><code>中序遍历</code>：先左子树，然后根节点，然后右子树。<br><code>后序遍历</code>：先左子树，然后右子树，然后根节点。<br><code>层序遍历</code>：先上后下，先左后右。</p>
<p><code>线索化二叉树</code>：以某种顺序遍历二叉树，在两端的指针域使得节点直接指向遍历顺序的前驱后继，将二叉树变为线索化二叉树，按照指针的顺序遍历则得到了双向链表。用于经常访问节点的前驱后继时使用。</p>
<h2 id="树、森林、二叉树的转换"><a href="#树、森林、二叉树的转换" class="headerlink" title="树、森林、二叉树的转换"></a>树、森林、二叉树的转换</h2><p><code>树到二叉树</code>：兄弟节点之间加入连线。去除父节点与所有有孩子的连线。<br><code>森林到二叉树</code>：每个树转为二叉树。右边的树作为左边树的右孩子插入。<br><code>二叉树转为树</code>：父亲节点与所有的右孩子连线。去除原来的父节点与孩子节点的连线。<br><code>二叉树转森林</code>：从根节点开始，删除与右子树的连线。以删除后右子树的根开始，再删除与右子树的连线。得到多个独立的二叉树，这些二叉树在转树。</p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>带权路径长度最小的二叉树。距离的计算为：从根节点出发(不包括根节点，不带权时包括分支节点，带权时不包括)，达到目标节点的路径长度是经过的节点的数量。如果带有权值就乘上。哈夫曼树的二叉树路径最小。<br>哈夫曼树生成过程，挑选权重最小的两个节点组成新节点。新节点在和其余最小的节点组成新节点，以此类推。<br>哈夫曼编码可以实现文件压缩，按照频率实现哈夫曼树，左0右1。保证一个编码不是另一个编码的前缀。</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><p>顶点集合不为空，但有穷，以及顶点之间的边。表示为$G=(V,E)$，$V$表示顶点集合，$E$表示顶点之间边的结合。边表示的是顶点之间的逻辑关系。<br>顶点之间没有方向称为无向边。顶点$v_1$到$v_2$有方向，称为弧，$v_1$是弧尾，$v_2$是弧头。无向边用圆括号记录，弧使用尖括号记录，&lt;弧尾，弧头&gt;。<br><code>简单图</code>：不存在重复的边，不存在自己指向自己的边。<br><code>无向完全图</code>：任意的两个顶点都存在边。共$n\times (n+1)/2$条边。<br><code>有向完全图</code>：任意两点之间存在两条方向相反的弧。共$n\times (n+1)$条边。<br><code>稀疏图</code>：边比较少。反之称为稠密图。<br><code>网</code>：带权图通常称为网。<br><code>子图</code>：对于$G’=(V’,E’)$和$G=(V,E)$有$V’\in V,E’\in E$，称为$G’$是$G$的子图。<br><code>图与顶点之间的关系</code>：无向图中，顶点$v$的度是与顶点$v$相关联的边的数目，边的数量是度数和的一半。有向图中，入度是顶点作为弧头的数量，出度反之，出度=入读=边的数量。<br>路径长度是路径上边的数量。<br>路径中顶点不重复称为简单路径，或者简单环。<br><code>连通图</code>：任意两个顶点是联通的。<br><code>极大连通子图</code>：连通的子图，含有极大顶点数和依赖这些顶点的边。也成为<code>连通分量</code>。<br><code>强连通图</code>：有向图中任意两点存在路径，强连通分量计为其子图。<br><code>生成树</code>：连通图的极小连通子图。含有全部$n$个顶点，足以构成$n-1$条边的树。<br><code>有向树</code>：一个顶点没有入度，其余顶点入度是1。<br><code>有向图的生成森林</code>：若干有向树，全部顶点，若干弧。</p>
<hr>
<p><code>存储结构</code>：顶点的邻接点之间不存在次序关系。对于邻接矩阵，矩阵的两个维度都是顶点，以1表示边存在，0表示不存在。是一个对角线为零的对称矩阵，行列可求度。有向图的邻接矩阵中，对角线为0，$\infty$表示不存在。邻接矩阵的时间复杂度为$O(n^2+n+e)$，初始化，读边，读点。<br>降低时间复杂的的操作为<code>邻接表</code>，无论是有向图还是无向图，存储方式都是从顶点出发，一个指针域指向下一个节点。时间复杂度为$O(n+e)$，读点，插边。</p>
<h2 id="图的结构"><a href="#图的结构" class="headerlink" title="图的结构"></a>图的结构</h2><p>图的遍历指每个节点仅仅被访问一次。深度优先和广度优先，是一个递归的过程。<br>最小生成树算法：Prim：$O(n^2)$，Krsukal：$O(e\log e)$。<br><code>图的拓扑序列</code>：顶点是事件的开始，弧为优先序列，表示为<code>AOV</code>网，将有向图构造为拓扑序列。顺序不存在回路，描述活动的制约关系。<br>边上有权表示为<code>AOE</code>网，无条件制约，但是求路径的权重最大或最小，如网络最大流问题。（建立反向路径）。</p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p><code>查找表</code>：是同一类型的数据元素构成的集合，一主关键字区分，查找后对应的关键字相等。<br><code>静态查找</code>：只查找，不删除也不插入。<br><code>动态查找</code>：可以考虑改变数据元素的关系改善查找性能。<br>线性表的查找$O(n)$，折半查找$O(\log n)$。<br><code>索引</code>：将关键字与对应的记录关联，索引项可以构成线性结构。<br><code>稠密索引</code>：索引等于数据规模的长度。<br><code>分块索引</code>：块内无序，块间有序，用于数据库，复杂度$O(\sqrt n)$。<br><code>倒排索引</code>：属性值决定记录的位置，用于搜索引擎。<br><code>二叉排序树</code>：中序遍历有序，左子树小于根，右子树大于根。查找时按顺序查找即可，插入时按顺序插入，删除时叶节点直接删除，只有左子树或右子树则子承父业，左右子树都存在时，中序遍历寻找删除节点的直接前驱与后继，代替原来的节点。<br><code>平衡二叉树</code>：平衡因子为BF，左子树深度减去右子树深度即可得到。平衡因子绝对值大于1，用于频繁的插入与删除，插入、删除、查找均为$O(\log n)$。旋转调整时均以失衡点下一个点为中心。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>左左</th>
<th>右右</th>
<th>右左</th>
<th>左右</th>
</tr>
</thead>
<tbody>
<tr>
<td>右旋</td>
<td>左旋</td>
<td>右旋，左旋</td>
<td>左旋，右旋</td>
</tr>
</tbody>
</table>
</div>
<h2 id="多路查找树"><a href="#多路查找树" class="headerlink" title="多路查找树"></a>多路查找树</h2><p><code>2-3树</code>：每个节点有两三个孩子。二节点，一个元素，两个孩子或者没有孩子（左小右大，不能只有一个孩子）。一个三节点，一小一大两个元素，三个孩子或没有孩子。插入与删除的时候，可以有单个叶节点。空树插入为二节点，在插入为三节点。删除时三节点拆分，或者二节点上移。看情况讨论，极为复杂。<br><code>2-3-4树</code>：4节点三个元素，只有四个孩子或者没有孩子。<br><code>B树</code>：平衡的多路查找树，节点最大的孩子数目为B树的阶，非叶节点至少两个孩子。每个非根的分支节点$k$个元素和$k-1$个孩子，每个叶节点有$k-1$个元素，所有叶子节点位于同一层。减少了访问数据块的次数，即IO次数，提高了性能。<br><code>B+树</code>：弥补了B树的缺陷，中序遍历防止多次遍历根节点。所有叶子节点接在一起，即根节点在叶节点中再次出现，自小到大排列好，查找高效$[18,+\infty)$，插入与删除都在叶节点。（因为根节点已经下来了）。</p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>也叫哈希。存储位置=f（关键字），对应的存储空间称为哈希表，数据元素没有逻辑关系。适合存储与查找，需要考虑关键字的长度，函数需要的时间，是否分布均匀。函数要求计算简单，可以处理冲突，散列地址分布均匀，如平方取中，数字分析。面临冲突时线性探测或者链式解决。查找的复杂度为$O(1)$。</p>
<p>散列表的平均查找长度取决于填充因子，填入个数除以总长度，不取决于填入元素的总长度。</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>稳定排序：排序之前$r_1$先于$r_2$，在排序之后$r_1$仍然先于$r_2$。</p>
<p>给个不错的链接：<a href="https://hit-alibaba.github.io/interview/basic/algo/Sorting.html" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/basic/algo/Sorting.html</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>稳定排序</th>
<th>不稳定排序</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序 $O(n^2 )$</td>
<td>快速排序 $O(n\log n)$</td>
</tr>
<tr>
<td>插入排序 $O(n^2 )$</td>
<td>堆排序 $O(n \log n)$</td>
</tr>
<tr>
<td>桶排序 $O ( n ) $</td>
<td>希尔排序 $O(n \log n)$</td>
</tr>
<tr>
<td>归并排序 $O(n \log n)$</td>
<td>选择排序 $O( n^2 )$</td>
</tr>
</tbody>
</table>
</div>
<p>文字的过程，让思考沉淀。</p>
<hr>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>基于数据分布的对抗防御和攻击</title>
    <url>/2021/09/07/data-dis-attack-defense/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在做对抗训练的时候，我时常在想一个问题：PGD、CW 这些攻击算法都会设置迭代步长和阈值，如果模型固定、参数固定，那么每次生成的对抗样本也会是一样的。如果使用 min-max 的方式进行对抗训练，那么模型可能会只认识在某一设置下的数据，如果面对新的分布攻击样本，如 ZOO, UAP, Deepfool 等，岂不是不能很好的防御？</p>
<p>这就又会回到小样本问题，总不能对所有的攻击算法在不同阈值下都生成对抗样本，而应该生成分布尽可能广泛的对抗样。既然提到生成，就不得不考虑 GAN，所以搜了些相关论文，并作整理。注意，所有论文我没看代码，所以不评价好与坏，在不久的将来如果我要发论文，肯定还会做对比算法，到时候回来评价各个算法。未完待续。</p>
<a id="more"></a>
<h1 id="advFlow"><a href="#advFlow" class="headerlink" title="advFlow"></a>advFlow</h1><p>AdvFlow: Inconspicuous Black-box Adversarial Attacks using Normalizing Flows, NIPS 2020。</p>
<p>这篇论文提出使用 normal flow 模型来生成对抗样本实现内部的 max。使得生成的对抗样本能围绕在干净样本附近，生成的对抗扰动能捕获图片信息，换句话说，可以根据图片信息来生成对抗扰动。</p>
<p><img data-src="https://z3.ax1x.com/2021/09/07/hozhMq.png" alt></p>
<p>首先预训练一个神经网络 $f$，这个网络是可逆的：</p>
<ul>
<li>输入为一随机分布 $z$，而后产生 $x$;</li>
<li>输入为干净样本 $x$，输入是随机分布 $z$</li>
</ul>
<p>整个流程如下：（这篇论文的 github 提供了 gif 来描述这个流程）</p>
<p>输入干净样本，经过 $f^{-1}$ 得到均值和方差下的噪音，将噪音再次经过 $f$ 得到对抗样本，将对抗样本输入目标模型，使用损失来更新均值和方差。以此来实现对抗训练。其中的损失、网络细节我没有看。</p>
<h1 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h1><p>Adversarial Distributional Training for Robust Deep Learning, NIPS 2020。</p>
<p>这篇论文和我的关注点一样，果然发顶会手要快。作者认为：对抗训练可不可以理解为数据增强？单个攻击算法并不能代表全部的对抗样本，所以作者提出了 ADT，通过增加熵正则化项，来获取潜在的分布在干净样本周围的对抗样本。以此来作为内部最大化，好的攻击算法才能产生更好的鲁棒性。</p>
<p>由于单个攻击算法不能覆盖全部的扰动，为了避免这个问题，应该找到干净样本附近的对抗样本的分布，而不是单纯的找到一个对抗样本。</p>
<p><img data-src="https://z3.ax1x.com/2021/09/07/hTCI1J.png" alt></p>
<p>如上图所示，蓝色点是 PGD 产生的对抗样本，黄色点是 ADT 产生的对抗样本。为了使对抗样本的分布具有多样性，增加了熵作为模型损失的一部分，众所周知，熵能衡量系统的稳定性，熵越大越不稳定。也就是，对抗样本的产生方式为：</p>
<p>\begin{equation}<br>E[L(f(x+\delta), y)] + \lambda H(p(\delta))<br>\end{equation}</p>
<p>$\delta$ 是对抗扰动，由高斯噪音分布并经过 $\text{tanh}$ 函数映射而来。相对于单个攻击算法，上述公式能更好的探索对抗扰动的分布。</p>
<h1 id="AGAT"><a href="#AGAT" class="headerlink" title="AGAT"></a>AGAT</h1><p>Attribute-Guided Adversarial Training for Robustness to Natural Perturbations，发表在 AAAI 2021。</p>
<p>在许多情况下，并不能获得全部的对抗样本，如果预测的对抗样本和训练的对抗样本没有来自同一分布，就会导致鲁棒性的下降。所以本文提出的对抗训练算法中，在内部最大化时，操纵图像属性空间的变化，这样训练出来的模型更具鲁棒性。</p>
<p>这里的属性空间是：翻转算一个属性空间，缩放算一个属性空间，颜色变化又算另一个属性空间。</p>
<p>本文使用的扰动是自然扰动，如图片尺寸和颜色的改变；缩放、旋转、腐蚀等。传统攻击算法的扰动有时会不满足 $\Vert x-x’ \Vert \leq \epsilon$ 的限制，且 $\epsilon$ 太大太小都不好，太小了没扰动效果，太大了图像会失真。但是本文的算法能有效的处理自然的扰动，使用 DNN 来生成扰动（看后文的意思是，输入图像，输出对抗样本）。</p>
<p><strong>这篇论文好多话写的我也不明所以</strong>，只能说大概流程是：前 N 个 epoch 训练干净样本，后面几个 epoch 训练对数据以迭代的形式进行扰动增强，而扰动增强这里我感觉很玄学。损失为最小化图像的分类损失、以及最大化干净样本与对抗样本在隐层的差异，以及通过 $L_2$ 范数限制扰动 $\alpha$ 的范围。</p>
<h1 id="advGAN"><a href="#advGAN" class="headerlink" title="advGAN"></a>advGAN</h1><p>Generating Adversarial Examples with Adversarial Networks，发表在 IJCAI 2018，使用 GAN 来生成对抗样本。</p>
<p>通过 GAN 来生成围绕着原始实例的高质量扰动来产生对抗样本，判别器来把关生成图像的质量。</p>
<p><img data-src="https://z3.ax1x.com/2021/09/08/hbA4bQ.png" alt></p>
<p>这个图已经把论文的含义表达的差不多了，思路也是简洁明了。输入原始图像，生成扰动并叠加至干净样本。和我最开始的构思一样，可惜被别人发表了。损失函数由三部分组成，一部分是对抗样本的分类损失，一部分是 GAN 的生成和判别损失，一部分是对抗扰动的范围损失，希望扰动范围越大越好。</p>
<h1 id="advGAN-1"><a href="#advGAN-1" class="headerlink" title="advGAN++"></a>advGAN++</h1><p>AdvGAN++ : Harnessing latent layers for adversary generation 发表在 ICCV 2019，是基于 advGAN 的改进，之前的 advGAN 是读取全部图像生成对抗扰动，这篇论文发现读取图像的隐层表示生成的对抗扰动会更好，就这样改进了一下。</p>
<p><img data-src="https://z3.ax1x.com/2021/09/08/hbEcdJ.png" alt></p>
<h1 id="RobGAN"><a href="#RobGAN" class="headerlink" title="RobGAN"></a>RobGAN</h1><p>Rob-GAN: Generator, Discriminator, and Adversarial Attacker，发表在 CVPR 2018。</p>
<p>这篇论文从另一个角度结合了 GAN 和对抗训练，将生成器融入对抗训练，提升判别器的鲁棒性；对抗训练使得 GAN 更快的收敛，并得到更好的生成器，两者互益。这篇论文的出发点同上：生成器生成分布更广阔的数据，使分类器在不可见数据集上获取更好的鲁棒性。</p>
<p><img data-src="https://z3.ax1x.com/2021/09/18/41SOfK.png" alt></p>
<p>对于 WGAN 的判别器而言，需要判别对抗样本和生成器的虚假样本，所以损失就是使这两者的分类误差达到最小，这里需要注意的是，虚假样本也要加上对抗扰动。</p>
<p>对于鲁棒性差的 GAN 而言，它虽然 smarter 但是 weaker，如下图所示：</p>
<p><img data-src="https://z3.ax1x.com/2021/09/18/41phNt.png" alt></p>
<p>在鲁棒的区域，能有效的抵御攻击而不会错分类。论文给出了一些证明，由于生成网络的任务是欺骗判别器，如果判别器不够鲁棒，那么只需要一点点的更新就可以欺骗判别器。如果判别器鲁棒，那么得到的生成器也会更好。</p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>遥感图像分割，类别不平衡损失为何失效了？</title>
    <url>/2022/04/04/deal-unbalance-label/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>去年寒假接到了一个遥感图像语义分割的任务，存在着严重的类别不平衡问题。当时想着使用经典的类别不平衡损失 focal loss 和 dice loss 解决一下，但是效果不升反降，甚至不如传统的交叉熵损失函数。</p>
<p>而且我在 github 上搜类似的项目，也都不推荐使用这些 loss。但是在 mmseg 的文档中，我们又发现 dice loss 有明显的提升，来冷静分析一下这是为什么。本文默认读者了解 focal loss 和 dice loss，因此不会对损失函数进行讲解。</p>
<a id="more"></a>
<p>其实我也不是第一次遇到这种经典损失函数失效的现象，之前 triplet loss 也频频失效，一度上了我的黑名单。关于 trilet loss 何时失效以及为什么 and 如何解决，可以参考之前的文章，<a href="https://muyuuuu.github.io/2022/03/24/E-commerce-Search-Recall/">如何更好的提取文本表示</a>。但是我们需要知道的是，失效分两种情况，一种是实现错误，一种是不适用于当前场景。</p>
<h1 id="focal-loss"><a href="#focal-loss" class="headerlink" title="focal loss"></a>focal loss</h1><p>focal loss 是目标检测领域中很经典的存在，focal loss 和 retinanet 发在同一篇论文，我看源程序，<strong>发现在实现上有一些小细节是网上常见博客不曾提及的</strong>。我们知道基于 anchor 生成检测框时，会有大量的无效检测框，这些框和真实目标毫不相交，这就导致了样本不平衡的问题。而 focal loss 的解决方案也是简单粗暴，使用 $\alpha$ 控制正负样本不平衡问题，使用 $\gamma$ 控制难易样本的区分。</p>
<p>在实现中，作者将与真实目标框 IoU 大于 0.5 的视为正样本，IoU 小于 0.4 的视为负样本，还有介于两者之间模棱两可的模糊样本。将所有的预测结果和真实标签计算损失，我们希望正样本的分类结果接近 1，其余样本接近 0，因此有严重的类别不平衡问题，于是使用了 focal loss 进行缓解。但是在反向传播的时候，<strong>并不是所有预测结果都要反向传播</strong>，而是对损失进行筛选，只回传正样本部分的损失，其余损失不考虑。</p>
<p>不然那么多负样本在那里，假设有 10000 个预测结果，只有 10 个真实目标，我就算输出 10000 个 0 损失也不会低，但是检测不到目标，俗称模型坍塌。因此源程序中做了这样的处理。</p>
<p>那么为什么语义分割的时候失效了呢？看完程序我大概给出我的猜测（目前实在没有精力做消融实验），我看了一些语义分割经典仓库中 focal loss 的实现，发现了一个问题。假设分割时的图像大小是 $512\times 512$，那么这就有将近 27 万个预测结果，遗憾的是，这些全部参与了反向传播。尤其是遥感领域的图像分割，目标区域小，背景占据大部分面积，前景目标的面积占比很小时，这就导致了模型坍塌的问题：模型把所有像素点预测为背景，损失不低，但结果无效。</p>
<p>因此，一个简单的解决方案就是：像 retinanet 一样，并不是所有的预测结果都参与反向传播。只需按照真实标签，只选择前景区域所在位置的损失，而忽略掉大部分背景区域的损失。而我遇到的原因也是这样，smp 的实现是全部反向传播，<del>提交个 PR 吧</del>。而 mmseg 的实现则是取消其他类别的影响。</p>
<h2 id="focal-程序实现"><a href="#focal-程序实现" class="headerlink" title="focal 程序实现"></a>focal 程序实现</h2><ul>
<li><a href="https://github.com/yhenon/pytorch-retinanet/blob/master/retinanet/losses.py#L120-L123" target="_blank" rel="noopener">retinanet 实现</a></li>
<li><a href="https://github.com/qubvel/segmentation_models.pytorch/blob/master/segmentation_models_pytorch/losses/_functional.py#L70-L96" target="_blank" rel="noopener">smp 实现，没有处理</a></li>
<li><a href="https://github.com/open-mmlab/mmcv/blob/master/mmcv/ops/csrc/common/cuda/sigmoid_focal_loss_cuda_kernel.cuh#L32-L33" target="_blank" rel="noopener">mmseg 实现</a></li>
</ul>
<h1 id="dice-loss"><a href="#dice-loss" class="headerlink" title="dice loss"></a>dice loss</h1><p>dice loss 很神奇，可以说是为语义分割而诞生的。因为交叉熵定义的是分类损失，评估衡量结果时却用 mIoU，也就是优化目标和期望目标不一致，所以 dice loss 以类似 IoU 损失的想法优化目标。dice loss 的一个形式如下：</p>
<p>\begin{equation}<br>L=1-\frac{2I+\epsilon}{U+\epsilon}<br>\end{equation}</p>
<p>$I$ 表示预测结果和真实标签的交集，$U$ 表示两者的并集。而程序实现也非常简单，交集两者求乘积，并集两者求和即可。</p>
<p>我们以二分类为例，假设模型最后的逻辑输出为 $x$，预测输出 $\hat{y}=\text{sigmoid}(x)$。于是：</p>
<p>\begin{equation}<br>\hat{y}=\frac{1}{1+e^{-x}} \quad \frac{d\hat{y}}{dx}=\hat{y}(1-\hat{y})<br>\end{equation}</p>
<p>我们设真实标签为 $t$，那么 dice loss 为：</p>
<p>\begin{equation}\label{dice}<br>L=1-\frac{2t\hat{y}+\epsilon}{t+\hat{y}+\epsilon}<br>\end{equation}</p>
<p>对 $\hat{y}$ 求一个偏导：</p>
<p>\begin{equation}\label{grad}<br>\frac{dL}{d\hat{y}}=-\frac{2t(t+\hat{y}+\epsilon)-2t\hat{y}-\epsilon}{(t+\hat{y}+\epsilon)^2}<br>\end{equation}</p>
<p>画出这个损失和梯度的图像：</p>
<p><img data-src="https://s1.ax1x.com/2022/04/05/qOwNPH.png" alt></p>
<p>这也就解释了为什么 dice 训练损失不稳定的原因，当 $t=0$ 的时候，虽然损失很大，但更新网络时对应的梯度为 0。损失值不稳定还可以理解，但是如果 $\hat{y}$ 预测结果也很小时，梯度会飞升。那为什么推荐和 CE 一起使用呢？看上图就可以知道，$t=0$ 的部分没有梯度。那为什么还是结果十分不好呢？继续往下看。</p>
<h2 id="dice-loss-与不平衡问题"><a href="#dice-loss-与不平衡问题" class="headerlink" title="dice loss 与不平衡问题"></a>dice loss 与不平衡问题</h2><p>我们可以观察到 dice loss 不管图片有多大，固定大小的正样本的区域计算的 loss 是一样的，对网络起到的监督贡献不会随着图片的大小而变化。而 ce loss 会公平处理正负样本，当出现正样本占比较小时，就会被更多的负样本淹没。</p>
<p>而 mmseg 给出这两个损失的比例是 1（CE）：3（dice），我也天真的用了这个比例。通过上面的分析，为了平衡样本，这个比例应该是目标面积和背景面积的比值。但是，我的数据集有多个类，每个类的面积占比跨度很大，也就是正负样本的梯度难以平衡，我十分不建议使用这个 loss，真的。</p>
<h2 id="dice-loss-画图程序"><a href="#dice-loss-画图程序" class="headerlink" title="dice loss 画图程序"></a>dice loss 画图程序</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_y</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial</span><span class="params">(y, t=<span class="number">0</span>)</span>:</span></span><br><span class="line">    f1 = <span class="number">-2</span>*t*(t+y+eps) +<span class="number">2</span>*t*y+eps</span><br><span class="line">    f2 = (t+y+eps) **<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> f1 / f2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">"ggplot"</span>)</span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">12</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-20</span>, <span class="number">20</span>, <span class="number">1000</span>)</span><br><span class="line">y = get_y(x)</span><br><span class="line">y0 = partial_0(y, t=<span class="number">0</span>)</span><br><span class="line">y1 = partial_1(y, t=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ax1.plot(y, y0)</span><br><span class="line">ax1.set_title(<span class="string">r"$t=0$"</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">r"$\hat&#123;y&#125;$"</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">r"Gradient"</span>)</span><br><span class="line"></span><br><span class="line">ax2.plot(y, y1)</span><br><span class="line">ax2.set_title(<span class="string">r"$t=1$"</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">r"$\hat&#123;y&#125;$"</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">r"Gradient"</span>)</span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">"1.png"</span>, bbox_inches=<span class="string">"tight"</span>, dpi=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我使用 mmseg 的 focal loss，结果要比 smp 的 focal loss 好很多，验证了我的猜想。此外需要注意的是，focal loss 能处理类别不平衡和正负样本不平衡，而 dice loss 只能处理正负样本不平衡。</p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>降低算法时间复杂度，以图数据处理为例</title>
    <url>/2020/08/11/decrease-time-complexity-when-process-graph/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>鲁迅有云：能用的程序不等于好的程序（他没说过）。在近期处理图数据时，经常性的要遍历边和点，这就很容易造成高时间复杂度的算法。且，当数据在一万左右时，复杂度$O(n^2)$的算法根本跑不动，在中等规模的服务器上也会卡死。</p>
<p>在不断的写程序中，降时间复杂度降出了经验，遂整理如下。我也发现了，我不喜欢写XX快速入门之类的文章，比如翻译<code>pytorch</code>的文档写一下<code>pytorch</code>快速入门的文章，的确很吸引流量，但我不喜欢，更喜欢整理自己的经验。</p>
<a id="more"></a>
<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><ol>
<li>以处理图数据为例，尤其是需要不断遍历边和点的场景；</li>
<li>没有真实的代码，全部是伪代码；（直接放工程代码会很大，从工程里摘出对应代码来仍然是伪代码）</li>
<li>虽然是处理图数据，但依然能适应其他场景。如果你想借鉴思想，不妨看一下，如果不想看，现在退出即可。</li>
</ol>
<h1 id="借助数据结构"><a href="#借助数据结构" class="headerlink" title="借助数据结构"></a>借助数据结构</h1><p>众所周知，图的节点是有度的，这里我们以无向图为例。假设，此时在做图数据的融合，将邻接链表相同的节点视为双胞胎节点融合在一起。此时最明显的哦优化就是借助桶排序，因为邻接链表相同，则节点的度必然相同。按照节点度进行分类，能有效降低复杂度。</p>
<p>假设只融合度数在$[2, 64]$之间的节点。首先，创建基数为 2 到 64 的桶。并按照节点的度，将节点放到对应桶中，即节点度为2就放到基数为2的桶，节点度为16就放到基数为16的桶。这里一切正常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创造节点度的桶</span></span><br><span class="line">radix = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">67</span>)]</span><br><span class="line"><span class="comment"># 按照是否被访问选取节点, 并按照度数放入桶</span></span><br><span class="line"><span class="keyword">for</span> ver <span class="keyword">in</span> graph.vertices():</span><br><span class="line">    <span class="comment"># 取节点索引</span></span><br><span class="line">    ver_idx = graph.vertex_index[ver]</span><br><span class="line">    <span class="comment"># 按照是否被访问和节点的度进行筛选</span></span><br><span class="line">    degree = len(graph.get_all_neighbors(ver_idx))</span><br><span class="line">    <span class="keyword">if</span> visited[ver_idx] == <span class="literal">False</span> <span class="keyword">and</span> degree &gt;= <span class="number">2</span> <span class="keyword">and</span> degree &lt;= <span class="number">64</span>:</span><br><span class="line">        <span class="comment"># 添加节点的索引</span></span><br><span class="line">        radix[degree].append(ver_idx)</span><br></pre></td></tr></table></figure>
<p>一般思路，在每个桶内，节点的度是相同的。这时候只需要遍历桶，计算桶内每个节点的邻接链表，若邻接链表相同，则融合。此时便是创建一个字典，以节点的索引为 key，以邻接链表为 value。之后遍历桶生成字典，在遍历字典的 value ，相同则融合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照桶内的邻接列表进行融合</span></span><br><span class="line"><span class="keyword">for</span> bucket <span class="keyword">in</span> radix:</span><br><span class="line">    <span class="comment"># 两个以上的节点才能融合</span></span><br><span class="line">    <span class="keyword">if</span> len(bucket) &gt;= <span class="number">2</span>:</span><br><span class="line">        <span class="comment"># 相反，由项找索引，不然时间复杂度太高</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> bucket:</span><br><span class="line">            <span class="comment"># 按照索引取节点</span></span><br><span class="line">            <span class="comment"># 集合的意思是取消元素顺序的影响，不然顺序会影响判断是否相等 </span></span><br><span class="line">            <span class="comment"># str保证可哈稀</span></span><br><span class="line">            adj_list[i].append(set(graph.get_out_neighbors(i)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 邻接列表相同的进行融合</span></span><br><span class="line">        <span class="comment"># （这里我实在不知道怎么写了，于是暴力循环了）</span></span><br><span class="line">        <span class="comment"># 复杂度太高，大图测试直接卡死</span></span><br><span class="line">        <span class="keyword">for</span> key1 <span class="keyword">in</span> adj_list.keys():</span><br><span class="line">            <span class="keyword">for</span> key2 <span class="keyword">in</span> adj_list.keys():</span><br><span class="line">                <span class="keyword">if</span> key1 != key2 <span class="keyword">and</span> adj_list[key1] == adj_list[key2]:</span><br><span class="line">                    <span class="keyword">if</span> visited[key1] == <span class="literal">False</span> <span class="keyword">and</span> visited[key2] == <span class="literal">False</span>:</span><br><span class="line">                        visited[key1] = visited[key2] = <span class="literal">True</span></span><br><span class="line">                        M[key1], M[key2] = key2, key1</span><br></pre></td></tr></table></figure>
<p>如上代码，直接遍历一个桶内部的邻接列表并判断是否相等，复杂度为$O(n^2+n)$。思路很正常，但这种写法实在愚蠢。如果我们换种思路，在字典中，以邻接列表为 key，以节点的索引为 value 呢？那么当两个节点的邻接列表相同时，节点的索引会自动放到字典对应 key 的 value 中，这样就省去了比较的过程。此时时间复杂度为$O(n^2)$。（radix代表基数是 2 到 64 的桶，取值是常数，故计算复杂度时忽略最外层循环）。由此可见，不用额外的数据结构，仅需要简单的变换，就能将时间复杂度从$O(n^2+n)$降低到$O(n^2)$。但实际中这样的点很少，即融合的<code>for</code>循环可以视为$O(1)$，所以算法的执行时间和$O(n)$复杂度的算法相似。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照桶内的邻接列表进行融合</span></span><br><span class="line"><span class="keyword">for</span> bucket <span class="keyword">in</span> radix:</span><br><span class="line">    <span class="comment"># 两个以上的节点才能融合</span></span><br><span class="line">    <span class="keyword">if</span> len(bucket) &gt;= <span class="number">2</span>:</span><br><span class="line">        <span class="comment"># 相反，由项找索引，不然时间复杂度太高</span></span><br><span class="line">        adj_reverse = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> bucket:</span><br><span class="line">            <span class="comment"># 按照索引取节点</span></span><br><span class="line">            <span class="comment"># 集合的意思是取消元素顺序的影响，不然顺序会影响判断是否相等 </span></span><br><span class="line">            <span class="comment"># str保证可哈稀</span></span><br><span class="line">            adj_reverse[str(set(graph.get_out_neighbors(i)))].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 以邻接列表为键，节点索引为 values</span></span><br><span class="line">        <span class="keyword">for</span> values <span class="keyword">in</span> adj_reverse.values():</span><br><span class="line">            <span class="keyword">if</span> len(values) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(values) - <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">                    ver1, ver2 = values[i], values[i+<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> visited[ver1] == <span class="literal">False</span> <span class="keyword">and</span> visited[ver2] == <span class="literal">False</span>:</span><br><span class="line">                        visited[ver1] = visited[ver2] = <span class="literal">True</span></span><br><span class="line">                        M[ver1], M[ver2] = ver2, ver1</span><br></pre></td></tr></table></figure>
<p>其实这个优化的并不所最好的，另一个是，但涉及的问题背景太深了，直接拿出来怕读者看不懂，就用这个例子凑合了。</p>
<h1 id="好的逻辑"><a href="#好的逻辑" class="headerlink" title="好的逻辑"></a>好的逻辑</h1><p>问题描述：此时我们要生成一个图的 k 跳邻接信息，即常见的邻接矩阵是一跳信息。二跳信息就是隔着一个节点还能相邻，那么邻接矩阵中，这两个节点对应的索引取值为 1。可以直接看图，节点 1 和节点 5 就是二跳连接，<code>adj[1][5] = 1</code>，这个意思。假设我们要找三跳信息。</p>
<p><img data-src="/2020/08/11/decrease-time-complexity-when-process-graph/graph.png" alt></p>
<p>在 <code>networkx</code> 这个包中，判断两个节点是否有路径的方式是使用最短路径，如没有最短路径，这两个节点当然不存在路径，最短路径的复杂度为$O(V+E)$，$V$是节点的数量，$E$是边的数量。伪代码就是<code>has_path(node1, node2)</code>。那么，此时最粗暴的算法来了，遍历节点，若两个节点之间的最短路径等于 3 ，就在邻接矩阵中置为 1。时间复杂度$O(V^2(V+E))$的伪代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> node1 <span class="keyword">in</span> graph.vertices():</span><br><span class="line">    <span class="keyword">for</span> node2 <span class="keyword">in</span> graph.vertices():</span><br><span class="line">        <span class="keyword">if</span> has_path(node1, node2) == <span class="number">3</span>:</span><br><span class="line">            adj[node1, node2] = adj[node2, node1] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>真实数据测试：运行时间 19.098s，图节点数是94，边数是1554。</p>
<p>只要我们稍微打开 <code>API</code> 查询一下，就能知道有 <code>shortes_distance</code> 这种函数，即在时间复杂度$O(V+E)$内求出一个节点到其他所有节点的最短路径，在借助 <code>np.where</code> 或 <code>np.isin</code> 就很容易降低复杂度了，一份$O(V(V+E))$的伪代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> graph.nodes():</span><br><span class="line">    arr = shortest_distance(node)</span><br><span class="line">    mask = np.where(arr == target)</span><br><span class="line">    <span class="keyword">for</span> row, col <span class="keyword">in</span> mask:</span><br><span class="line">        adj[row][col] = adj[col][row] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>真实数据测试：运行时间 0.139s，图节点数是94，边数是1554。</p>
<p>那么在冷静分析一下，很多孤立节点并不是我们所需要的，取度数大的节点进行融合，几乎能覆盖图中全部的数据，因为图中大部分点会和度数大的点有联系。那么，我们对图节点按度数排序（堆排的复杂度为 $\log n$），取出前 $\log v$ 个节点，计算他们和图中节点的 $k$ 跳信息。伪代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">node = sort_by(graph.nodes.degree)[:logv]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> node:</span><br><span class="line">    arr = shortest_distance(node)</span><br><span class="line">    mask = np.where(arr == target)</span><br><span class="line">    <span class="keyword">for</span> row, col <span class="keyword">in</span> mask:</span><br><span class="line">        adj[row][col] = adj[col][row] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>此时算法的时间复杂度是 $O(\log V(V+E))$。一般而言，$E$比$V$大，算法计算时间更取决于 $E$ 的大小。实际数据：运行时间 0.039s，图节点数是94，边数是1554。</p>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>分治枚举</title>
    <url>/2022/04/04/divide-conquer-enumerate/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之后的日子，大概会放缓刷题的脚步进行简单的整理，因为有些题目是有规律的，需要做号总结和整理，不能刷一个忘一个。<strong>今日总结：题目要求返回所有结果，且能找到分界点分解为子问题的，都可以套用分治枚举算法。</strong></p>
<a id="more"></a>
<h1 id="分治算法枚举"><a href="#分治算法枚举" class="headerlink" title="分治算法枚举"></a>分治算法枚举</h1><p>众所周知，枚举是个技术活，如何合理的枚举所有结果、避免重复和剪枝，并没有想象的那么简单。而分治枚举就是，通过将原问题分割为多个子问题，多个子问题的解<strong>排列组合</strong>能产生多种答案，我们收集多种答案并返回。</p>
<p>对于此类问题，我们需要确定三个东西：分界点，递归函数，如何排列组合。这样，给定一个分界点，我们把问题分解为左侧问题和右侧问题，两者答案的组合就是当前分界点对应的所有结果。然后再移动分界点，得到其他所有结果即可。此外，再分割得到子问题并求解时，需要设置 base case 用于退出递归。</p>
<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a>96. 不同的二叉搜索树</h2><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。如下的示例，3 个节点能组成 5 种二叉树。</p>
<p><img data-src="/2022/04/04/divide-conquer-enumerate/1.jpg" alt></p>
<p>那我们考虑给出那三个东西：</p>
<ol>
<li>分界节点，以不同的值作为根节点，遍历所有的情况</li>
<li>既然有了根节点，就需要构建左子树。定义一个函数，返回某子树对应的情况，也就能得到分界点左子树有多少情况，同理得到右子树的排列组合</li>
<li>而左子树和右子树的乘积就是当前根节点对应的结果</li>
</ol>
<p>我们定义一个函数，函数有两个参数，这两个参数是子树的取值范围，因此，退出递归的 base case 就是子树的左侧值大于右侧值，此时返回 1，因为表示调用者的结果是 1，不能再划分为子问题了。函数的返回值是这种取值范围下，有多少结果。我们写出程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">tmp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        memo = tmp;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[l<span class="number">-1</span>][r<span class="number">-1</span>] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[l<span class="number">-1</span>][r<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = build(l, i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> b = build(i + <span class="number">1</span>, r);</span><br><span class="line">            <span class="comment">// 累积所有的结果</span></span><br><span class="line">            memo[l<span class="number">-1</span>][r<span class="number">-1</span>] += a*b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[l<span class="number">-1</span>][r<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>memo</code> 起到剪枝的效果。</p>
<h2 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a>95. 不同的二叉搜索树 II</h2><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。如下的示例，3 个节点能组成 5 种二叉树。</p>
<p><img data-src="/2022/04/04/divide-conquer-enumerate/1.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br></pre></td></tr></table></figure>
<p>同上一题，既然要给出所有的子树结果，那么此时就不需要计数，而是需要创建子树。同样以根节点的取值为分界点，统计出所有可能的左子树，统计出所有可能的右子树，上一题为结果相加，那么这个题目需要对左右子树的结果进行排列组合。因为这题不会超时，因此没有设置剪枝。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> leftTree = build(l, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> rightTree = build(i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 创建子树，等价于上一题的相加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : leftTree) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> b : rightTree) &#123;</span><br><span class="line">                TreeNode* node = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                node-&gt;left = a;</span><br><span class="line">                node-&gt;right = b;</span><br><span class="line">                res.emplace_back(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="241-为运算表达式设计优先级"><a href="#241-为运算表达式设计优先级" class="headerlink" title="241. 为运算表达式设计优先级"></a>241. 为运算表达式设计优先级</h2><p>给你一个由数字和运算符组成的字符串 expession ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：expression = &quot;2*3-4*5&quot;</span><br><span class="line">输出：[-34,-14,-10,-10,10]</span><br><span class="line">解释：</span><br><span class="line">(2*(3-(4*5))) = -34 </span><br><span class="line">((2*3)-(4*5)) = -14 </span><br><span class="line">((2*(3-4))*5) = -10 </span><br><span class="line">(2*((3-4)*5)) = -10 </span><br><span class="line">(((2*3)-4)*5) = 10</span><br></pre></td></tr></table></figure>
<p>最开始我以为这是回溯，后来发现不是，因此总结出一个规律：<strong>题目要求返回所有结果，且能找到分界点分解为子问题的，都可以套用分治枚举算法</strong>。对于这个题而言，运算符就是分界点，然后枚举左侧和右侧有几种结果即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(<span class="built_in">string</span> expression)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expression[i] == <span class="string">'-'</span> || expression[i] == <span class="string">'*'</span> || expression[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            <span class="comment">// 分治，左侧有几种结果</span></span><br><span class="line">            <span class="keyword">auto</span> res1 = diffWaysToCompute(expression.substr(<span class="number">0</span>, i));</span><br><span class="line">            <span class="keyword">auto</span> res2 = diffWaysToCompute(expression.substr(i + <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 枚举所有结果，并追加，和第一题的 += 一样</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it1 : res1) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it2 : res2) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (expression[i] == <span class="string">'-'</span>)</span><br><span class="line">                        res.push_back(it1 - it2);</span><br><span class="line">                    <span class="keyword">if</span> (expression[i] == <span class="string">'+'</span>)</span><br><span class="line">                        res.push_back(it1 + it2);</span><br><span class="line">                    <span class="keyword">if</span> (expression[i] == <span class="string">'*'</span>)</span><br><span class="line">                        res.push_back(it1 * it2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;stoi(expression)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>大学计算机：数字化基础</title>
    <url>/2020/08/05/digital-foundation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在可预见的未来，我应该不会再去接触计算机底层的知识了。但这毕竟是我的专业课，开一个新坑，做此笔记，留作日后回忆。如标题所见，这应该是大学计算机基础课，不会涉及很深的内容，浅尝辄止。但我盲猜一手很多人不会计算机基础，因为众多大学的计算机基础课程基本等于 word 和 excel 教学，暗自庆幸我们当初讲的是命令行。</p>
<p>我对不起我的本科教师，计组、计网和数据库讲的多好，可我考完就忘了。老师也说过，这都不会千万别说我教过你。还是趁开学前补一补，下一次和底层的计算机知识相见就不知道什么时候了。 </p>
<a id="more"></a>
<p>我尝试了很多上传 pdf 的方法，目前这个是最好的（参考了<a href="https://www.longyating.com/hexo%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/" target="_blank" rel="noopener">小龙童靴的一篇文章</a>）。等以后探索到新方法在改进显示吧。</p>
<div class="pdfobject-container" data-target="./数字化基础.pdf" data-height="500px"></div>
]]></content>
      <tags>
        <tag>Computer</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划问题系列</title>
    <url>/2020/04/11/dynamic-programming/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>实在没兴趣去新开一个标签或分类，就准备把刷题期间遇到的所有动态规划问题放在这里了。还是老样子，思路分析，算法求解，代码实现。但动态规划问题多种多样，我暂时遇到的也不是很多，愿本文能一直保持收录。</p>
<a id="more"></a>
<h1 id="上楼梯问题"><a href="#上楼梯问题" class="headerlink" title="上楼梯问题"></a>上楼梯问题</h1><p>这也许是最经典的动态规划问题，想必很多人都遇到过：一共十层楼梯，一次可以走一个阶梯，两个阶梯或三个阶梯。问走完十层阶梯有几种方法。那么走一百层楼梯有多少种方法呢？</p>
<p>求解方案：在第七、第八、第九层楼梯时，可以到达第十层，那么到达第十层的方案数量就取决于到达第七、第八、第九层的方案数量，以此类推至最开始的第一层。代码如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 走 100 层楼梯</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>; dp[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= num; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 第8层的方案取决于5、6、7层的方案</span></span><br><span class="line">    <span class="comment">// 依次递归类推到第三层开始</span></span><br><span class="line">    dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>] + dp[i<span class="number">-3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[num] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="楼梯坏了"><a href="#楼梯坏了" class="headerlink" title="楼梯坏了"></a>楼梯坏了</h2><p>​假设此时的部分楼梯坏了不能走，那么一共有几种走法呢？输入数据共两行，第一行包含两个自然数 $n (1≤n≤100)$ 和 $k (0≤k&lt;n)$，第二行包含 $k$ 个自然数 $X_i$ $(1≤X_i≤n)$，数字之间用一个空格隔开，表示损坏的台阶的序号（从楼梯底部到楼梯顶部，台阶序号依次为 $1$ 到 $n$）。</p>
<p>​输出数据仅包含一个整数，表示所有可行走法的总数。当有的楼梯坏了，又该怎么走呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> method = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// N表示有N个楼梯</span></span><br><span class="line">    <span class="keyword">if</span> (n == N)&#123;</span><br><span class="line">        method ++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当还没有走到终点且楼梯能走时</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; N &amp;&amp; !bad[n])&#123;</span><br><span class="line">        <span class="comment">// 有这么多种走法</span></span><br><span class="line">        up(n + <span class="number">1</span>);</span><br><span class="line">        up(n + <span class="number">2</span>);</span><br><span class="line">        up(n + <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="comment">// 记录坏的楼梯 </span></span><br><span class="line">        bad[a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从第一个阶梯开始走</span></span><br><span class="line">    up(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; method;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="和最大的子序列"><a href="#和最大的子序列" class="headerlink" title="和最大的子序列"></a>和最大的子序列</h1><p>这也是一个比较经典的问题，对于给定的$k$个元素的序列，求其中的一个连续的子序列，使子序列的所有元素相加的和最大。示例如下：</p>
<ul>
<li>Sample input: -10 1 3 4 -2 6 </li>
<li>Sample output:  12 1 6 （第一个数是最大和，第二个和第三个是起始位置和终止为止）</li>
</ul>
<p>​甲级1007 。<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168" target="_blank" rel="noopener">Maximum Subsequence Sum</a></p>
<p>对于此类问题，因为随时可能在相加的过程中出现负数，且负数后面可能还有更大的正数。因此，可能拿不准何时继续加，何时放弃。因为对于-9， 10这样的序列，应该继续向后加，因为加到10相当于赚了1；但对于-9， 1这样的序列，到-9时就该放弃，后面的1没有加的必要。所以应该从以下两个角度出发，考虑元素的取舍问题：</p>
<ol>
<li>记录元素的累积和，作为判断取舍的标准；</li>
<li>如果累积和小于零，就放弃当前元素，考虑下一个元素；</li>
<li>如果累积和大于上一次的和，就开始标记左右边界，此时左右边界内的元素和是最大的；</li>
<li>累积和小于上一次的和但大于零，相当于加了一个负数，此时仍然继续向后加，但不标记左右边界。一来可以继续探索后面的元素是否能更大，二来保证之前左右边界内的元素和是最大的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入序列元素</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">-1</span>; </span><br><span class="line"><span class="comment">// 可能全是0，所以不能 int sum = 0; 判断sum &lt;= 0。</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对于和加一次后开始减小，无关紧要，因为下一个可能会更大</span></span><br><span class="line">    <span class="comment">// 如 3 -2 6。所以和减小的情况不予考虑 </span></span><br><span class="line">    temp = temp + v[i];</span><br><span class="line">    <span class="comment">// 和小于0，就重新开始左定位</span></span><br><span class="line">    <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)         </span><br><span class="line">    &#123;</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        flag = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 和大于之前的和，开始标记，越加越小不予考虑</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (temp &gt; sum)   </span><br><span class="line">    &#123;</span><br><span class="line">        sum = temp;</span><br><span class="line">        left = flag;</span><br><span class="line">        right = i;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; v[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="string">" "</span> &lt;&lt; v[left] &lt;&lt; <span class="string">" "</span> &lt;&lt; v[right];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="和为固定值的子序列"><a href="#和为固定值的子序列" class="headerlink" title="和为固定值的子序列"></a>和为固定值的子序列</h2><p>和上文类似，只是增加了额外的要求。大概意思是：给定一个序列，求序列中连续的子序列，使子序列的和为目标值，或者子序列的和大于目标值，但与目标值的相差最小。即此时不要求和最大，而是增加了目标值这样一个范围。<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805439202443264" target="_blank" rel="noopener">甲级1044</a>。</p>
<p>举例说明：对于序列3, 2, 1, 5, 4, 6, 8, 7，当要求的目标值为15时，有三种选择方法：</p>
<ol>
<li>from the position 1 to 5 (with values 3 + 2 + 1 + 5 + 4 = 15).</li>
<li>from the position 4 to 6 (with values 5 + 4 + 6 = 15).</li>
<li>from the position 7 to 8 (with values 8 + 7 = 15).</li>
</ol>
<p>对于序列2 4 5 7 9，当目标值为13时，有两种选择方法：</p>
<ol>
<li>from the position 2 to 4 (with values 5 + 7 + 9 = 21).</li>
<li>from the position 4 to 5 (with values 7 + 9 = 16).</li>
</ol>
<p>思路如下：还没研究明白，改日吧。</p>
<h1 id="对称子串问题"><a href="#对称子串问题" class="headerlink" title="对称子串问题"></a>对称子串问题</h1><p>给定一个字符串，求其中包含的最长的对称子串的长度。如<code>0000000</code>的长度是7(7个0)，<code>baaq</code>的长度是2(两个a)，<code>Is PAT&amp;TAP symmetric?</code>的长度是11(s PAT$TAP s这个字符串是对称的)。即将问题归纳为：给定的字符串中是否含有对称字符串？如果有，长度是多少？<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805446102073344" target="_blank" rel="noopener">甲级1040</a>。分析：</p>
<ol>
<li>设立数组$dp[i][j]$，其取值只有0和1，表示$s[i]$到$s[j]$所表示的字串是否是回文字串。如当s[2] == s[4]时，d[2][4] == 1，否则为0。</li>
<li><p>那么很容易得出：单个长度的字符串肯定是对称的，长度为1；字符串中有两个连续的字符，肯定有对称字符串，且此时长度为2。如序列<code>daaq</code>，有两个连续的<code>a</code>，所以含有对称的字符串<code>aa</code>，且长度为2。这是最简单的情况。​首先初始化$dp[i][i] = 1, dp[i][i+1]$，把长度为1和2的都初始化好，然后在判断长度为3一直到长度为$N$。这是边界情况，判断方程为：$dp[i][i] = 1$, $dp[i][i+1] = (s[i] == s[i+1]) ? 1 : 0$，初始化部分程序下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">getline(<span class="built_in">cin</span>, s);</span><br><span class="line"><span class="keyword">int</span> len = s.length(), ans = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 初始化长度为2的序列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; len - <span class="number">1</span> &amp;&amp; s[i] == s[i+<span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当存在连续的字符时，对称字符的长度最小为2</span></span><br><span class="line">        ans = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在判断完长度为2的子串后，下一步要判断长度为3的字串。因此初始化步长$L=3$，且步长逐逐渐增加。要判断的左边界字符为s[i]，右边界字符为s[j]，且$i$从0开始一直递增，$j$的取值为$i+L-1$。</p>
</li>
<li>当$s[i] != s[j]$ 时，$dp[i][j] = 0$，表示[i, j]中的子串不是对称的；</li>
<li>当$s[i] == s[j]$ 时，$dp[i][j] = dp[i+1][j-1]$，当前子串对称与否的情况取决于上次的子串是否对称，得到递推方程。如果上次的小子串s[i+1][j-1]对称，那么这次的大子串s[i][j]也对称，将对称字串的长度赋值为$L$。即本次的状态取决于上次的状态，以此类推。而最开始的情况$dp[i][i] = 1, dp[i][i+1]$已经初始化。</li>
</ol>
<p>​因为$i, j$按照从小到大的顺序来枚举，因此必须保证更新$dp[i][j]$的时候$dp[i+1][j-1]$已经被计算过。因此第一遍先计算长度为1和长度为2的字串，第三遍将长度为3的子串的$dp$的值全部求出，第四遍通过第三遍结果计算出长度为4的子串的$dp$的值，这样就可以避免状态无法转移的问题。这部分伪代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> L = <span class="number">3</span>; L &lt;= len; L++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + L - <span class="number">1</span> &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + L <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            ans = L;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了防止看官头晕，这里以字符串<code>Is PAT&amp;TAP symmetric?</code>为例：</p>
<ol>
<li>初始化$dp[i][i] = 1$，ans = 1；</li>
<li>L = 3, i = 5, j = 7 时，s[5] == s[7]均为T，且根据第一次的状态d[6][6] = 1，得到此时ans为3，并将d[5][7]赋值为1，求的对称子串为<code>T&amp;T</code>；</li>
<li>L = 5, i = 4, j = 8 时，s[4] == s[8]均为A，且根据上一次的状态d[5][7] = 1，得到此时ans为5，并将d[4][8]赋值为1，求得对称子串为<code>AT$TA</code>；</li>
<li>以此标准类推即可。由小的子串逐步扩大到大的子串，当前子串计算完毕后更改当前状态，因为下一状态取决于当前状态，逐步类推，完整代码如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    getline(<span class="built_in">cin</span>, s);</span><br><span class="line">    <span class="keyword">int</span> len = s.length(), ans = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始化长度为2的序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; len - <span class="number">1</span> &amp;&amp; s[i] == s[i+<span class="number">1</span>]) </span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 当存在连续的字符时，对称字符的长度最小为2</span></span><br><span class="line">            ans = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// i-&gt;j的差距为3,4,5逐渐递增，先算小的，保证计算大的时候小的已经更新</span></span><br><span class="line">    <span class="comment">// 即计算d[i][j] 时候，d[i+1][j-1]需要已经更新</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> L = <span class="number">3</span>; L &lt;= len; L++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + L - <span class="number">1</span> &lt; len; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + L <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                ans = L;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>更通俗的理解熵</title>
    <url>/2020/05/09/entropy/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时至今日，早已忘记高中化学里面的熵代表什么，还好化学里的熵和我要研究的熵并非同一性质。在进坑DL中，遇到了许多和熵有关的概念，于是今天就彻底来扒一扒熵的有关概念和常用领域。包括：</p>
<ol>
<li>什么是熵</li>
<li>条件熵</li>
<li>KL散度</li>
<li>交叉熵</li>
</ol>
<p>注：本篇文章默认读者有一定的求期望、计算联合概率分布、计算条件概率分布和知道什么是概率密度的基础知识。</p>
<a id="more"></a>
<h1 id="什么是熵"><a href="#什么是熵" class="headerlink" title="什么是熵"></a>什么是熵</h1><p>首先，仅需要知道熵能够衡量信息的不确定性即可。一条信息的价值和他的不确定性有密切的关系，如：明天下雨的概率是1%和明天下雨的概率是99%这两条信息的价值是不一样的。不清楚事物的不确定性时，决策时出错的概率就越大；相反，通过自己逐步抽丝剥茧搞清了一个事物的本质，那么他的不确定性就为0，决策就不可能出错。那么如何衡量事物的不确定性呢？答案就是熵。</p>
<p>假设此时有32个盒子，31个盒子里是白球，1个盒子里是黑球。假设让人<strong>用二分法</strong>来猜测黑球在哪个盒子里，猜一次1块钱，只需要5次就能猜中$(\log_232=5)$，那么这个信息值5块钱。当然信息的不确定性不能用钱来衡量，香农给出的定义是：<br>\begin{equation}<br>H = -(p_1\log p_1 + p_2\log p_2 + \cdots+p_n\log p_n), n=32<br>\end{equation}</p>
<p>$p_i$为黑球在第$i$个盒子里的概率，$H$即为信息熵，且此时的熵恰好为5。在通俗一点，对于一个随机变量$X$，它的熵定义如下：</p>
<p>\begin{equation}<br>H = \sum_{x\in X}P(x)\log P(x)<br>\end{equation}</p>
<p>在通俗一点，对于序列<code>0, 0, 0, 1, 1, 1</code>，它的熵为2，单位是bit，因为序列里不是1就是0，2，即需要几个bit能够表示序列的全部的信息。所以也可以得到<strong>变量的不确定性越大，熵也就越大</strong>这样的结论。</p>
<h1 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h1><p>信息的作用在于消除不确定性，根据相关的信息来减少另外信息的不确定性。如：A想明天邀请B来做客，但不知道B有没有时间，此时的信息由不确定性因素，但A此时得到了一条消息：B出门旅游了，那么A就不必在明天邀请B反而可以去做一些别的事情。</p>
<p>这就是利用其他信息来减少不确定性，知道的相关信息越多，一件事的不确定性就越小。那么如何用数学语言描述呢？</p>
<p>假设两个随机变量$X, Y$，$X$是我们了解的，可以根据$X$的分布来求出$X$的熵：</p>
<p>\begin{equation}<br>H(X) = -\sum_{x\in X}P(x)\log P(x)<br>\end{equation}</p>
<p>而此时恰好知道$X,Y$的联合分布$p(x,y)$和条件概率分布$p(x|y)$，定义$X$在$Y$下的熵为：</p>
<p>\begin{equation}<br>H(X|Y) = -\sum_{x\in X, y \in Y}P(x, y)\log P(x|y)<br>\end{equation}</p>
<p>此时便可以得到互信息$I(X;Y)$:</p>
<p>\begin{equation}<br>H(X)-H(X|Y) = I(X;Y) = H(Y)-H(Y|X) = H(X)+H(Y)-H(X,Y)<br>\end{equation}</p>
<p>\begin{equation}<br>I(X;Y) = \sum_{x\in X, y\in Y}P(x,y)\log{\frac{P(x,y)}{P(x)P(y)}}<br>\end{equation}</p>
<p>互信息一定是大于等于0，当互信息为0时，表明$\frac{P(x,y)}{P(x)P(y)} = 1$，此时$P(x,y)=P(x)P(y)$，表明了随机变量$X,Y$相互独立。可见，只有两个信息相关时，才可以有效降低当前信息的不确定性。如明天是否下雨这个信息和小明今晚出去购物这两条信息是没有任何相关性的，他们的互信息为0。</p>
<p>借鉴这个思路，在2019年美国大学生数学建模竞赛的C题中，成功分析了主要是哪些人群在吸毒，合理提出建议。即吸毒人口的熵减去各种身份吸毒人口的熵，单亲家庭、残疾人员等，得到互信息，互信息越大，说明相关性越高，互信息越小则说明两者完全无关。</p>
<h1 id="KL散度"><a href="#KL散度" class="headerlink" title="KL散度"></a>KL散度</h1><p>KL 散度可以用来衡量两个分布的差异。在深度学习中，我们经常会将一个复杂的分布用一个简单的近似分布来代替。KL 散度可以帮助我们测量在选择一个近似分布时丢失的信息量。</p>
<p>对于离散型随机变量$X$，假设原概率分布为$P(x)$，近似概率分布为$Q(x)$，则使用 KL 散度衡量这两个分布的差异：</p>
<p>\begin{equation}<br>KL(P||Q)=\sum_{x\in X}P(x)\log \Big( \frac{P(x)}{Q(x)}\Big)<br>\end{equation}</p>
<p>对于$P(x)/Q(x)$这一项，可以理解为如果我们使用 $Q$ 的编码来表示 $P$ 额外所需的编码长度。当然，也许你一眼就看出来了，这不就是在求期望嘛，改写一下看起来更直观：</p>
<p>\begin{equation}<br>KL(P||Q)=E_{x\sim P}\Big[ \log (P(x)/Q(x)) \Big]<br>\end{equation}</p>
<p>对于连续型变量，我们对概率密度函数求积分即可(假设随机变量$X$的取值范围是$[-\infty, +\infty]$)：</p>
<p>\begin{equation}<br>KL(P||Q)=\int_{-\infty}^{+\infty}p(x)\log{\frac{p(x)}{q(x)}}dx<br>\end{equation}</p>
<h1 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h1><p>交叉熵(也有人叫相对熵)也可以用来衡量两个分布的差异。以离散型变量 $x$ 为例，交叉熵$H(P,Q)$的定义如下：</p>
<p>\begin{equation}<br>H(P,Q)=-\sum_{x\in X} P(x)\log Q(x)<br>\end{equation}</p>
<p>当然也可以写成期望的形式：$-E_{x\sim P}\log Q(x)$，也许你善于观察，肯快发现了交叉熵与KL散的联系(公式推导较为简单，不在展示)：</p>
<p>\begin{equation}<br>H(P,Q) = H(P) + KL(P||Q)<br>\end{equation}</p>
<p>在机器学习评价两个分布之间的差异时，由于分布 $P$ 会是给定的（如测试样本的标签值），所以此时 KL 散度和交叉熵的作用其实是一样的，而且因为交叉熵少算一项，更加简单，所以选择交叉熵会更好。交叉熵也有以下的性质：</p>
<ol>
<li>对于两个完全相同的函数，它们的交叉熵等于零。</li>
<li>交叉熵越大，两个函数差异越大；反之，交叉熵越小，两个函数差异越小。</li>
</ol>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>也许说了一大堆你还是不明白，那么在这里举例说明。</p>
<h2 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h2><p>还是那个例子，32个箱子，31个箱子里是白球，1个箱子里是黑球，你用二分法去摸球，直到摸到黑球位置，此时摸球次数的随机变量$X$为：</p>
<script type="math/tex; mode=display">H(X)=-32\times \frac{1}{32} \times \log_2(\frac{1}{32})=5</script><h2 id="条件熵-1"><a href="#条件熵-1" class="headerlink" title="条件熵"></a>条件熵</h2><p>根据以下的表格，对于第一列上班族，上班族的随机变量为$X$，且1表示上班，那么上班族的熵$H(X)=0.589$。对于第二列上班族的年龄，年龄在区间内$[0,20]$为0，年龄在区间$[20, 100]$内为1，那么年龄这列的熵$H(Y)$为0.589。互信息$I(X;Y)$(自行手动按照公式计算即可)为0.42，表明两者上班的人和上班的人的年龄之间有一定的相关性。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>上班族$X$</th>
<th>上班族的年龄$Y$</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>站在巨人的肩膀上。</p>
<ol>
<li>《数学之美(第二版)》第六章：信息的度量和作用</li>
<li>互信息公式推导：<a href="https://www.cnblogs.com/gatherstars/p/6004075.html" target="_blank" rel="noopener">https://www.cnblogs.com/gatherstars/p/6004075.html</a></li>
<li>KL散度与交叉熵：<a href="https://www.cnblogs.com/wuliytTaotao/p/9713038.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuliytTaotao/p/9713038.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测篇：目标检测快速训练与推理框架</title>
    <url>/2021/05/03/fast-train-eval-platform-fasterrcnn-torch/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最早在天池玩耍的时候接触到了目标检测。当时真的啥都不知道，头铁，一点点的开坑造轮子。后来再看前几名开源的程序，发现有很多库可以使用，切图，目标检测等，比如数据增强、目标检测都有现成的工具箱。所以想着，就先用调库的形式写一个简单的 <code>baseline</code>，下一个任务直接用现成的代码，省点事，所以写了一个这样的简单的平台。</p>
<a id="more"></a>
<p>注意：</p>
<ul>
<li>本文调库，且只针对 <code>COCO</code> 数据集。</li>
<li>平台很简单很简单，我不想写的太复杂。原因是：复杂的代码容易让使用者头晕，其次，如果真的要改形如损失函数等细节，调库肯定满足不了，这时候就要自己写。但平台应该足够抽象和简单，只是用来观察初步效果，不应该包含这些复杂的东西。<strong>对修改封闭，对扩展开放。</strong></li>
<li>因为这次接的任务涉及到了对抗样本，所以后期肯定要改损失函数，到时候在写针对细节的程序。</li>
</ul>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">torch             1.7.1+cu92</span><br><span class="line">torchvision       0.8.2+cu92</span><br><span class="line">pycocotools       2.0.2</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/muyuuuu/Faster-RCNN-COCO" target="_blank" rel="noopener">https://github.com/muyuuuu/Faster-RCNN-COCO</a></p>
<ul>
<li><code>preprocess</code> 文件夹，这俩代码都是单独执行的<ul>
<li><code>mean-std.py</code>，计算样本三通道的均值与方差，用于数据标准化</li>
<li><code>reconstruct-anno.py</code>，重构 <code>json</code>，支持多个 <code>batchsize</code></li>
</ul>
</li>
<li><code>model</code> 文件夹<ul>
<li><code>data_helper.py</code>，加载数据</li>
<li><code>engine.py</code>，训练与推理的具体过程</li>
<li><code>eval.py</code>，推理程序，<code>python eval.py</code> 执行</li>
<li><code>model.py</code>，模型</li>
<li><code>train.py</code>，训练程序，<code>python train.py</code> 执行</li>
<li><code>utils.py</code>，保存、加载模型和写入日志</li>
</ul>
</li>
</ul>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>首先，掏出 <code>torchvision</code>，找到其实现的 <code>fasterrcnn_resnet50_fpn</code> 模型。查看其源程序：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fasterrcnn_resnet50_fpn</span><span class="params">(pretrained=False, progress=True,</span></span></span><br><span class="line"><span class="function"><span class="params">                            num_classes=<span class="number">91</span>, pretrained_backbone=True,</span></span></span><br><span class="line"><span class="function"><span class="params">                            trainable_backbone_layers=None, **kwargs)</span>:</span></span><br><span class="line">    trainable_backbone_layers = _validate_trainable_layers(</span><br><span class="line">        pretrained <span class="keyword">or</span> pretrained_backbone, trainable_backbone_layers, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pretrained:</span><br><span class="line">        <span class="comment"># no need to download the backbone if pretrained is set</span></span><br><span class="line">        pretrained_backbone = <span class="literal">False</span></span><br><span class="line">    backbone = resnet_fpn_backbone(<span class="string">'resnet50'</span>, pretrained_backbone, </span><br><span class="line">    trainable_layers=trainable_backbone_layers)</span><br><span class="line">    model = FasterRCNN(backbone, num_classes, **kwargs)</span><br><span class="line">    <span class="keyword">if</span> pretrained:</span><br><span class="line">        state_dict = load_state_dict_from_url(</span><br><span class="line">            model_urls[<span class="string">'fasterrcnn_resnet50_fpn_coco'</span>],</span><br><span class="line">            progress=progress)</span><br><span class="line">        model.load_state_dict(state_dict)</span><br><span class="line">        overwrite_eps(model, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pretrained</code> 取值为 <code>False</code> 的情况下，<code>pretrained_backbone</code> 取值会为 <code>True</code>，会返回在 <code>ImageNet</code> 上预训练的 backbone；<code>pretrained</code> 取值为 <code>True</code> 的情况下，<code>pretrained_backbone</code> 取值会为 <code>False</code>，将会返回一个在 <code>COCO train2017</code> 上预训练的模型；而无论如何，<code>backbone</code> 是使用了 <code>FPN</code> 机制的。</li>
<li><code>num_classes</code> 设置成自己需要检测的类的数量，<strong>注意多一个背景类</strong>；</li>
<li>观察 <code>**kwargs</code> 参数，传给了 <code>FasterRCNN</code>，所以追踪这个类，发现它能设置很多参数 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> ，比如 <code>anchor</code> 的大小和比例。这个时候对原始数据 <code>EDA</code> 一下，设置合适的参数就可以了；</li>
</ul>
<p>此时创建模型的程序为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.models.detection <span class="keyword">as</span> td</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model</span><span class="params">(num_class)</span>:</span></span><br><span class="line">    anchor_sizes = ((<span class="number">64</span>, ), (<span class="number">128</span>, ), (<span class="number">256</span>, ), (<span class="number">512</span>, ), (<span class="number">1024</span>, ))</span><br><span class="line">    aspect_ratios = ((<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>), ) * len(anchor_sizes)</span><br><span class="line">    rpn_anchor_generator = td.anchor_utils.AnchorGenerator(</span><br><span class="line">        anchor_sizes, aspect_ratios)</span><br><span class="line">    <span class="comment"># https://github.com/pytorch/vision/blob/master/torchvision/models/detection/faster_rcnn.py</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># faster rcnn，网络会再次对 图像数据进行重定义尺寸</span></span><br><span class="line">    <span class="comment"># https://github.com/pytorch/vision/blob/c2ab0c59f42babf9ad01aa616cd8a901daac86dd/torchvision/models/detection/transform.py#L64</span></span><br><span class="line">    detector = td.fasterrcnn_resnet50_fpn(</span><br><span class="line">        rpn_anchor_generator=rpn_anchor_generator, pretrained=<span class="literal">True</span>)</span><br><span class="line">    num_classes = num_class</span><br><span class="line">    <span class="comment"># ROI head 是 backbone 后，预测盒子和类别的位置</span></span><br><span class="line">    <span class="comment"># box_predictor 是 FastRCNNPredictor 类，cls_score 是类别分类器</span></span><br><span class="line">    <span class="comment"># in_features 是模型的输入特征</span></span><br><span class="line">    <span class="comment"># https://github.com/pytorch/vision/blob/5339e63148304ce32fd1cbd1e8bb74ea79458691/torchvision/models/detection/faster_rcnn.py#L263-L276</span></span><br><span class="line">    in_features = detector.roi_heads.box_predictor.cls_score.in_features</span><br><span class="line">    <span class="comment"># 设置要预测的新的分类数</span></span><br><span class="line">    detector.roi_heads.box_predictor = td.faster_rcnn.FastRCNNPredictor(</span><br><span class="line">        in_features, num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> detector</span><br></pre></td></tr></table></figure>
<h1 id="数据制作"><a href="#数据制作" class="headerlink" title="数据制作"></a>数据制作</h1><p>之前头铁自己写库解析 <code>anno_json</code> 去制作数据集，后来发现有它人最好的第三方工具，直接 <code>pip install pycocotools</code> 上车。然后去写自己的 <code>dataloader</code> 类就好了。注意，在构造函数中，只初始化一些工具，不要加载数据，否则会内存溢出；将数据加载推迟到 <code>__getitem__</code> 方法中，反正者里面只拿一小部分的数据。此时的核心代码为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pycocotools.coco <span class="keyword">import</span> COCO</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">train_data_set</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, image_dir, anno_path)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.image_dir = image_dir</span><br><span class="line">        <span class="comment"># COCO api class that loads COCO annotation file and prepare data structures</span></span><br><span class="line">        self.coco = COCO(anno_path)</span><br><span class="line">        <span class="comment"># 获取 image 的 id，字典转为 list</span></span><br><span class="line">        self.ids = list(self.coco.imgs.keys())</span><br><span class="line">        self.transform = transforms.Compose([</span><br><span class="line">            <span class="keyword">lambda</span> x: Image.open(x).convert(<span class="string">'RGB'</span>),</span><br><span class="line">            transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">            transforms.ToTensor(),</span><br><span class="line">            <span class="comment"># transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225))</span></span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据集很大时，要在 getitem 中获取</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">        <span class="comment"># 某个图片的 id</span></span><br><span class="line">        img_id = self.ids[idx]</span><br><span class="line">        <span class="comment"># 图片路径</span></span><br><span class="line">        path = self.image_dir + self.coco.loadImgs(img_id)[<span class="number">0</span>][<span class="string">'file_name'</span>]</span><br><span class="line">        <span class="comment"># 获取图片的 annotations 的 id</span></span><br><span class="line">        ann_ids = self.coco.getAnnIds(imgIds=img_id)</span><br><span class="line">        <span class="comment"># 根据 annotations 的 id 获取 annotions</span></span><br><span class="line">        target = self.coco.loadAnns(ann_ids)</span><br><span class="line">        <span class="keyword">return</span> self.transform(path), target</span><br></pre></td></tr></table></figure>
<p>但是，还没结束，这里还要改一些 <code>key</code>，因为提供的 <code>json</code> 文件中，目标区域的名字是 <code>bbox</code>，但 <code>FasterRCNN</code> 要求的 <code>key</code> 是 <code>boxes</code>。所以，这部分修改也在数据加载里面完成。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> target:</span><br><span class="line">    v = &#123;&#125;</span><br><span class="line">    v[<span class="string">'boxes'</span>] = d.pop(<span class="string">'bbox'</span>)</span><br><span class="line">    d[<span class="string">'boxes'</span>] = v[<span class="string">'boxes'</span>]</span><br><span class="line">    x = []</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> v[<span class="string">'boxes'</span>]:</span><br><span class="line">        x.append(y)</span><br><span class="line">    x[<span class="number">2</span>], x[<span class="number">3</span>] = x[<span class="number">0</span>] + x[<span class="number">2</span>], x[<span class="number">1</span>] + x[<span class="number">3</span>]</span><br><span class="line">    d[<span class="string">'boxes'</span>] = torch.tensor(x, dtype=torch.float32)</span><br><span class="line">    v = &#123;&#125;</span><br><span class="line">    v[<span class="string">'labels'</span>] = d.pop(<span class="string">'category_id'</span>)</span><br><span class="line">    d[<span class="string">'labels'</span>] = torch.tensor(v[<span class="string">'labels'</span>] - <span class="number">1</span>, dtype=torch.int64)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pycocotools</code> 做出来的 <code>boxes</code> 是一个列表，列表的每个元素是张量；但我们需要的是张量，张量的尺寸是 <code>[1, 4]</code>，所以有了上面的修改；此次任务不涉及 <code>mask</code>，所以没有考虑 <code>segementation</code> 的修改；</li>
<li>如果遇到 AssertionError: target boxes must of float type 此类错误，直接打开源代码：</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">floating_point_types = (torch.float, torch.double, torch.half)</span><br><span class="line"><span class="keyword">assert</span> t[<span class="string">"boxes"</span>].dtype <span class="keyword">in</span> floating_point_types, <span class="string">'target boxes must of float type'</span></span><br><span class="line"><span class="keyword">assert</span> t[<span class="string">"labels"</span>].dtype == torch.int64, <span class="string">'target labels must of int64 type'</span></span><br></pre></td></tr></table></figure>
<p>一目了然，这并不是说 boxes 是浮点数，而是说，张量中的元素应该是 <code>torch.float32, torch.float64, torch.float16</code> 类型的，创建张量的时候要加上这个参数；</p>
<ul>
<li>如果遇到 ValueError: All bounding boxes should have positive height and width. 错误，并不是说盒子里面出现的负数，而是说，FasterRCNN 希望看到 <code>[xmin, ymin, xmax, ymax]</code> 这样的数据，而你传入的是 <code>[xmin, ymin, width, height]</code> 这样的数据。但在后面 <code>torchvision</code> 中修复了这个问题 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</li>
<li>如果遇到 sampled_pos_inds_subset = torch.where(labels &gt; 0)[0] CUDA error: device-side assert triggered 这样的错误，也不要慌。有两种解决方案，选一个就好。<ul>
<li>这里出错的原因很简单，数据提供的类是从 1 开始编号的，假设是 <code>label = [1，2，3]</code>；在预测时，正确的标签是 3，但程序中 <code>label[3]</code> 会出错，所以，将标签改为 <code>[0,1,2]</code> 就可以了。</li>
<li>传入训练模型时，增加背景类。这里看自己，如果需要背景类，就第二种方案；如果不需要背景类，就第一种方案。</li>
</ul>
</li>
<li>而如果要追求多个 <code>batchsize</code>，只能重构 <code>json</code>，此部分程序在 <code>github</code> 中给出。</li>
</ul>
<h1 id="训练与推理"><a href="#训练与推理" class="headerlink" title="训练与推理"></a>训练与推理</h1><p>首先来看官方提供训练的例子（注意这个例子在某些版本上不一定能跑通）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">model = torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=<span class="literal">True</span>)</span><br><span class="line">images, boxes = torch.rand(<span class="number">4</span>, <span class="number">3</span>, <span class="number">600</span>, <span class="number">1200</span>), torch.rand(<span class="number">4</span>, <span class="number">11</span>, <span class="number">4</span>)</span><br><span class="line">labels = torch.randint(<span class="number">1</span>, <span class="number">91</span>, (<span class="number">4</span>, <span class="number">11</span>))</span><br><span class="line">images = list(image <span class="keyword">for</span> image <span class="keyword">in</span> images)</span><br><span class="line">targets = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(images)):</span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    d[<span class="string">'boxes'</span>] = boxes[i]</span><br><span class="line">    d[<span class="string">'labels'</span>] = labels[i]</span><br><span class="line">    targets.append(d)</span><br><span class="line">output = model(images, targets)</span><br><span class="line"><span class="comment"># For inference</span></span><br><span class="line">model.eval()</span><br><span class="line">x = [torch.rand(<span class="number">3</span>, <span class="number">300</span>, <span class="number">400</span>), torch.rand(<span class="number">3</span>, <span class="number">500</span>, <span class="number">400</span>)]</span><br><span class="line">predictions = model(x)</span><br></pre></td></tr></table></figure>
<p>所以，训练的时候，把 image 和 target 转成列表并输入就可以了。注意，列表中的每个元素的类型必须和模型参数的类型一致，别忘了 <code>to(device)</code>。我把最终训练和推理的程序放到 <code>engine</code> 程序中了：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_fn</span><span class="params">(train_dataloader, detector, optimizer, device, epoch, scheduler)</span>:</span></span><br><span class="line">    detector.train()</span><br><span class="line">    loss_value = <span class="number">0</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> images, target <span class="keyword">in</span> tqdm(train_dataloader):</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        images = list(image.to(device) <span class="keyword">for</span> image <span class="keyword">in</span> images)</span><br><span class="line">        <span class="comment"># it's key:value for t in targets.items</span></span><br><span class="line">        <span class="comment"># This is the format the fasterrcnn expects for targets</span></span><br><span class="line">        targets = []</span><br><span class="line">        <span class="keyword">for</span> l, b <span class="keyword">in</span> zip(target[<span class="string">'labels'</span>], target[<span class="string">'boxes'</span>]):</span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            d[<span class="string">'labels'</span>] = l.view(<span class="number">-1</span>).to(device)</span><br><span class="line">            d[<span class="string">'boxes'</span>] = b.view(<span class="number">-1</span>, <span class="number">4</span>).to(device)</span><br><span class="line">            targets.append(d)</span><br><span class="line">        loss_dict = detector(images, targets)</span><br><span class="line">        losses = sum(loss <span class="keyword">for</span> loss <span class="keyword">in</span> loss_dict.values())</span><br><span class="line">        loss_value = losses.item()</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        losses.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        scheduler.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 训练数据过大，训练一部分就保存模型</span></span><br><span class="line">        <span class="keyword">if</span> cnt % <span class="number">1000</span> == <span class="number">999</span>:</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            utils.save_checkpoint_state(<span class="string">"model_tmp.pth"</span>, epoch, detector,</span><br><span class="line">                                        optimizer, scheduler)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loss_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(val_dataloader, detector, device)</span>:</span></span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> images, image_names <span class="keyword">in</span> tqdm(val_dataloader):</span><br><span class="line">        images = list(image.to(device) <span class="keyword">for</span> image <span class="keyword">in</span> images)</span><br><span class="line">        model_time = time.time()</span><br><span class="line">        outputs = detector(images)</span><br><span class="line">        model_time = time.time() - model_time</span><br><span class="line">        <span class="keyword">for</span> i, image <span class="keyword">in</span> enumerate(images):</span><br><span class="line">            boxes = (outputs[i][<span class="string">"boxes"</span>].data.cpu().numpy().tolist())</span><br><span class="line">            scores = outputs[i][<span class="string">"scores"</span>].data.cpu().numpy()</span><br><span class="line">            labels = outputs[i][<span class="string">"labels"</span>].data.cpu().numpy()</span><br><span class="line">            image_id = image_names[i]</span><br><span class="line">            <span class="keyword">for</span> b, s, l <span class="keyword">in</span> zip(boxes, scores, labels):</span><br><span class="line">                <span class="keyword">if</span> s &gt; <span class="number">0.5</span>:</span><br><span class="line">                    result = &#123;</span><br><span class="line">                        <span class="string">"image_id"</span>: image_id,</span><br><span class="line">                        <span class="string">"boxes"</span>: b,</span><br><span class="line">                        <span class="string">"scores"</span>: s.astype(float),</span><br><span class="line">                        <span class="string">"labels"</span>: l.astype(float),</span><br><span class="line">                    &#125;</span><br><span class="line">                    results.append(result)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>
<h1 id="预测无输出"><a href="#预测无输出" class="headerlink" title="预测无输出"></a>预测无输出</h1><p>在推理时，网络对所有图片的输出都是：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="string">'boxes'</span>: tensor([], size=(<span class="number">0</span>, <span class="number">4</span>)),</span><br><span class="line">  <span class="string">'labels'</span>: tensor([], dtype=torch.int64),</span><br><span class="line">  <span class="string">'scores'</span>: tensor([])&#125;]</span><br></pre></td></tr></table></figure>
<p>这个 <code>bug</code> 当时我也佷头疼，翻遍了全网，总结下可能导致此类错误的原因吧：</p>
<ul>
<li>类别数目没有加一，也就是没有考虑背景类。这个解决方案在上面已经给出。传入训练模型时，增加一个背景类</li>
<li><code>pretrained=False</code>。当时是我考虑少了，以为 <code>pretrained=False</code>的情况下，毕竟模型的 backbone 是经过预训练的，以为能应付简单的目标检测，后来发现是我草率了；<code>pretrained=True</code>，不仅 backbone，整个模型都是预训练的，这样才能检测到目标。</li>
</ul>
<h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">https://github.com/pytorch/vision/blob/730c5e1eab130e2900c8e839ea08fa11f024516f/torchvision/models/detection/faster_rcnn.py#L23</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">https://github.com/pytorch/vision/issues/2740</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测篇：Faster R-CNN 系列</title>
    <url>/2021/04/28/faster-rcnn/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>又来开计算机视觉的坑了，<strong>这次一定做好整理和记录，包括算法内容和程序</strong>。做好训练、保存和推理的框架，下次需要的时候直接用。做目标检测的东西，于是决定从 Fast R-CNN 重头来过了。其中，Fast R-CNN 只有理论，Faster-RCNN 部分含有代码，不过会在下一篇博客了。</p>
<p>既然是目标检测，就需要做两件事情，目标在哪，目标是什么。对于目标在哪的问题，可以让网络生成一个目标框，目标框有四部分组成：$(x,y,w,h)$，表示物体的起始点坐标和框的宽度与高度；对于目标是什么的问题，就是传统神经网络的多分类问题了。</p>
<a id="more"></a>
<h1 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a>Fast R-CNN</h1><p>算法步骤与网络结构图<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>：</p>
<ol>
<li>首先使用 selective search 算法<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>搜索目标区域候选框，以下简称 SS 算法</li>
<li>将图像输入 backbone，一个超大规模的特征提取网络，得到一个特征图</li>
<li>将 SS 生成的候选框映射到特征图中，得到每个候选框的特征矩阵</li>
<li>将每个候选框的特征矩阵通过 ROI（region of interest）-pooling 层缩放到 $7\times 7$ 的矩阵</li>
<li>将矩阵展平，全连接，得到一系列的预测结果。包括预测概率和目标框，而后反向传播</li>
<li>这里需要注意的是，最后预测分类和预测目标边界框的两个全连接是<strong>并联</strong>的</li>
</ol>
<p><img data-src="https://z3.ax1x.com/2021/04/28/gP4CU1.png" alt></p>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>对于算法步骤 3，特征图映射问题。是为了减少计算量，不用为每个候选框单独计算特征矩阵；而是计算一个特征矩阵后，直接选择候选框的内容。选择方式也很简单，矩阵映射就行。</p>
<h3 id="正样本与负样本"><a href="#正样本与负样本" class="headerlink" title="正样本与负样本"></a>正样本与负样本</h3><p>训练期间，并没有训练全部候选框的特征矩阵，只使用了其中的一小部分，比如只训练 64 个。正样本，表示含有待检测目标；负样本，表示背景区域。选用负样本的原因是，要让网络能正确识别背景，并不是所有图片都含有目标。</p>
<ul>
<li>正样本：候选框与真实框的 IOU 大于 0.5，选择其中的一部分进入网络</li>
<li>负样本：候选框与真实框的 IOU 在 0.1 到 0.5 之间</li>
</ul>
<p>论文中还提到了对数据做增强，当然这些并不是重点。IOU（Intersection over Union）的意思是，图像的交除以图像的并。就是蓝色区域的面积除以绿色区域的面积。</p>
<p><img data-src="https://z3.ax1x.com/2021/04/28/gPHdIJ.png" alt></p>
<h3 id="ROI-pooling"><a href="#ROI-pooling" class="headerlink" title="ROI-pooling"></a>ROI-pooling</h3><p>ROI-pooling 层的目的在于，不限制输入图像的大小。因为 ROI 后面的全连接层肯定是固定到某一个特殊维度的，而每个候选框对应特征矩阵的大小也不一致，所以，需要使用 ROI-pooling 将不同大小的特征矩阵映射到同一大小。具体方法如下，算了如图吧，如对任意大小的特征矩阵映射为 $2\times2$的特征矩阵，取其中的最大值或平均值。$7\times7$ 也是同一个道理。</p>
<p><img data-src="https://z3.ax1x.com/2021/04/28/gPIzDg.png" alt></p>
<h3 id="预测输出与反向传播"><a href="#预测输出与反向传播" class="headerlink" title="预测输出与反向传播"></a>预测输出与反向传播</h3><p>先来看概率预测。因为含有负样本，因此网络要识别 $N$ 的类的话，网络输出的概率就是 $N+1$，多一个背景类。ROI-pooling 后，经过两个全连接得到特征向量。特征向量经过第一个<strong>并联</strong>的全连接，softmax 后输出标签概率；经过第二个<strong>并联</strong>的全连接，输出目标框的位置参数。</p>
<ul>
<li>对于第一个并联的全连接而言，只需要和真实标签进行交叉熵<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>即可，<strong>分类损失</strong>记为 $L_1$；</li>
</ul>
<p>接下来重点讲输出目标边界框的部分，如何使输出的目标框越来越接近真实的目标框呢？对于边界框回归器，也就是第二个并联的全连接，输出 <code>N+1</code> 个类别候选边界框的回归参数 $(d_x,d_y,d_w,d_h)$，共输出 $4(N+1)$ 个参数。我们设当前 SS 算法得到候选框的<strong>中心点坐标</strong>和宽高为 $(P_x,P_y,P_w,P_h)$，最终预测的边界框的参数 $(G_x, G_y, G_w, G_h)$ 为：</p>
<p>\begin{equation}<br>    \begin{aligned}<br>        G_x &amp;= P_wd_x + P_x \\<br>        G_y &amp;= P_hd_y + P_y \\<br>        G_w &amp;= P_w \exp{(d_w)} \\<br>        G_h &amp;= P_h \exp{(d_h)}<br>    \end{aligned}<br>\end{equation}</p>
<p>可视化一下得到的最终预测的坐标 $(G_x, G_y, G_w, G_h)$ ，也就是，红色框是之前的候选框 $(P_x,P_y,P_w,P_h)$；绿色框是标注的候选框；经过神经网络的输出 $(d_x,d_y,d_w,d_h)$ 后，移动到蓝色框位置，也就是 $(G_x, G_y, G_w, G_h)$。</p>
<p><img data-src="https://z3.ax1x.com/2021/04/28/gipoqA.png" alt></p>
<p>在计算完候选框之后，现在就要计算损失反向传播了。假设此时真实的类别标签是 $u$，第 $u$ 个类别的目标边界框的输出为 $(d_x^u,d_y^u,d_w^u,d_h^u)$，真实目标边界框的参数为 $(v_x,v_y,v_w,v_h)$。</p>
<p><strong>边界框损失</strong>的损失为：</p>
<p>\begin{equation}<br>    \begin{aligned}<br>    L_2 &amp;= \sum_{i\in{x,y,w,h}}\text{smooth}(t_i^u-v_i) \\<br>    \text{smooth}(x) &amp;=<br>        \begin{cases}<br>        0.5 x^2 &amp; |x| &lt; 1 \\<br>        |x| - 0.5 &amp; \text{other}<br>        \end{cases}<br>    \end{aligned}<br>\end{equation}</p>
<p>这个损失在绝对差值大于1时不求平方，可以避免梯度爆炸。大部分回归问题都可以适用，尤其是数值比较大的时候。此时，最终的损失函数为：</p>
<p>\begin{equation}<br>L = L_1 + \lambda[\mu\geq 1]L_2<br>\end{equation}</p>
<p>$[u\geq 1]$ 表示爱佛森括号，意思是，当 $u\geq 1$ 时，$[u\geq 1] = 1$，否则 $[u\geq 1] = 0$；$u=0$时，表示当前是背景，背景是没有边界框的，也就没有边界框回归损失这一项。$\lambda$ 是权重。好滴，Fast R-CNN 记录完毕。Faster RCNN 就相对简单点了，只是在 Fast R-CNN 的基础上使用 RPN 替换了 SS 算法。</p>
<h1 id="Faster-RCNN"><a href="#Faster-RCNN" class="headerlink" title="Faster-RCNN"></a>Faster-RCNN</h1><p>Faster-RCNN = Fast R-CNN + RPN<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> 结构，用 RPN 生成特征候选框，将生成的候选框投影到特征图上得到特征矩阵，即代替了之前的 SS 操作，也就是，让 RPN 网络自己去寻找哪里可能有目标。</p>
<p>RPN 网络，输入为 backbone 后的 features map，用于生成 region proposal，在 features map 上每个像素生成若干个 anchors（比如9个），随后通过 softmax 判断每个 anchor 是属于 foreground（目标）或者 background（背景），再利用边界框回归器修正，获得精确的 proposal 位置。（anchors 是固定的，全程不动）。</p>
<p>而后，Roi Pooling 层则利用 RPN 提供的 proposals 以及 backbone 后的 feature maps，提取 proposal feature 送入后续全连接网络，再之后的操作和 Fast R-CNN 就一样了。所以重点来看 RPN，网络结构如下。</p>
<p><img data-src="https://z3.ax1x.com/2021/04/28/gif0ER.png" alt></p>
<h2 id="RPN-网络"><a href="#RPN-网络" class="headerlink" title="RPN 网络"></a>RPN 网络</h2><p>在 backbone 得到特征图后，使用一个卷积核继续提纯，在 features map 上进行滑动，且通过 padding 保证滑动前的特征矩阵和滑动后的特征矩阵尺寸一致。每滑动到一个位置就生成一个一维向量，图中 256 的意思是 channel，所以单个卷积核会生成一个一维向量。</p>
<p>而后一维向量进入两个并联的卷积层，使用 $2k$ 个卷积核输出 $2k$ 个概率得分（背景概率和前景概率）；另外一边使用 $4k$ 个卷积核输出 $4k$ 个边界框参数。$k$ 是 <code>anchor box</code> 的数量，卷积核的大小都是 $1\times1$。注意，这是一步卷积就生成这么多参数。</p>
<p><img data-src="https://z3.ax1x.com/2021/04/29/gFDsDx.png" alt></p>
<h2 id="anchor-box"><a href="#anchor-box" class="headerlink" title="anchor box"></a>anchor box</h2><p>首先在特征图上进行卷积的时候，计算当前卷积窗口中心点对应原图哪个点，然后以原图为中心，生成 $k$ 个 anchor box，anchor box 是提前给定的大小和长宽比例。如下图所示，从特征图一步步映射到原图。anchor box 里可能有目标，也可能没有目标。其中，每个 anchor 的形状不一样，因为目标大小不一样，长宽比也不一样。</p>
<p><img data-src="https://z3.ax1x.com/2021/04/28/giTcxP.png" alt></p>
<p>前面讲过，每个 anchor 会生成 2 个概率分数和 4 个预测框参数。如对于概率分数，<code>[0.3, 0.7]</code> 表示有 0.3 的概率是背景，0.7 的概率是前景。对于同一目标，有 $k$ 个 anchor，就会有 $2k$ 个概率分数和 $4k$ 个边界框参数。而 anchor 的大小和比例是提前设置的，如 $128\times 128，256\times 256，512\times 512$ 大小，对应 anchor 的面积；比例一般是三种，<code>1:1, 1:2, 2:1</code>，对应 anchor 的长宽比。因此，每个位置，也就是每个滑动窗口，都有 9 个 anchor。</p>
<p>如果感受野（也就是特征图上的$3\times 3$，可能对应原图的 $200\times 200$）的大小小于 anchor box 的大小，不要惊讶，因为目标可能没在图片内。就像根据直觉，看到一个脑袋，也能猜出剩下的身子应该是多大。意思是可以通过一个小的感受野，预测一个大的物体的边界框。</p>
<p><img data-src="https://z3.ax1x.com/2021/04/28/gi7azq.jpg" alt></p>
<p>在特征图上滑动时，步长为1，padding 为 1。所以每个位置都会有 anchor，舍弃掉超出原图边界框的 anchor。利用 RPN，将 anchor 根据生成的边界框回归参数，调整称为候选框，用非极大值一致筛掉一部分候选框，得到最终的候选框。</p>
<h2 id="正负样本"><a href="#正负样本" class="headerlink" title="正负样本"></a>正负样本</h2><p>并不是全部 anchor 都要训练，比如可以采样 256 个样本去训练，正负样本的比例是 1:1。如果正样本不到 128，那么用负样本进行补充。</p>
<ul>
<li>正样本：候选边界框与真实框的 IOU 大于 0.7；如果没有，就取与真实边界框有最大的 IOU 作为正样本（因为可能只有一小部分相交）</li>
<li>负样本：与所有真实边界框的 IOU 低于 0.3</li>
</ul>
<h2 id="RPN-损失函数"><a href="#RPN-损失函数" class="headerlink" title="RPN 损失函数"></a>RPN 损失函数</h2><p>第一部分是类别损失，这里的类别只有两种，前景或背景。所以损失函数表示为：</p>
<p>\begin{equation}<br>L_1 = \frac{1}{N}\sum_i(p_i, p_i^*)<br>\end{equation}</p>
<p>当前目标为前景时，$p_i^\star$ 为1；为背景时，$p_i^\star$ 为 0。</p>
<p>边界框回归损失和之前的 Fast R-CNN 是一样的。如果是背景，没有边界框损失函数；如果是目标，就有边界框损失函数。</p>
<h2 id="Faster-RCNN-1"><a href="#Faster-RCNN-1" class="headerlink" title="Faster-RCNN"></a>Faster-RCNN</h2><p>把 RPN（目标区域选择） 与 Fast R-CNN（目标检测） 组合起来，就是最终的 Faster-RCNN。至于两个网络的 loss 如何训练，这就取决于代码了，我这就去开坑写程序。在论文中：</p>
<ul>
<li>RPN 和 Fast R-CNN 可以理解为互惠共赢的东西，所以不希望分开训练，这个是我个人的观点</li>
<li>交替训练，先训练 RPN，能找到区域后，微调 Fast R-CNN 后用于初始化 RPN 网络参数，如此循环迭代。具体过程为：<ul>
<li>训练 RPN 网络，采用 ImageNet 预训练的模型进行初始化，并进行微调</li>
<li>利用 RPN 生成 proposal，由 Fast R-CNN 训练一个单独的检测网络，该网络同样由 ImageNet 预训练模型进行初始化。此时，两个网络还未共享卷积层</li>
<li>用检测网络初始化 RPN 训练，固定共享的卷积层，只微调 RPN 独有的层，现在两个网络实现了卷积层共享</li>
<li>保持共享的卷积层固定，微调 Fast R-CNN 的全连接层。这样，两个网络共享相同的卷积层，构成一个统一的网络</li>
</ul>
</li>
<li>近似联合训练，RPN 和 Fast R-CNN 整合到一个网络里一起训练。前向传递生成 region proposal，在训练 Fast R-CNN 检测器将这看作是固定的、预计算的 proposal。反向传播像往常一样进行，其中对于共享层，组合来自 RPN 损失和 Fast R-CNN 损失的反向传播信号。这个解决方案很容易实现。但是这个解决方案忽略了关于 proposal 边界框的坐标的导数，因此是近似的。由 RPN 预测的边界框也是输入的参数，Fast R-CNN 中的 RoI 池化层接受卷积特征以及预测的边界框作为输入，所以理论上有效的反向传播求解器也应该包括关于边界框坐标的梯度。在上述近似联合训练中，这些梯度被忽略。</li>
</ul>
<h1 id="Faster-RCNN-源码阅读"><a href="#Faster-RCNN-源码阅读" class="headerlink" title="Faster RCNN 源码阅读"></a>Faster RCNN 源码阅读</h1><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p>不读代码 <sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> 怎么能说自己学会了呢。读代码建议读别人注释好的，用代码建议用经得住时间检验的，比如 torch 或 mmdetection。</p>
<p>首先是模型的 backbone，这个没啥好说的，就是把 resnet 这样的网络筛掉最后一个分类层就得到了 backbone。之后模型就剩下 RPN 和 Head 两部分了，先来看 RPN。</p>
<p>RPN 由两部分组成，一部分是卷积之类的网络模型，一部分是 anchor 相关的东西。</p>
<ol>
<li>首先生成不同大小不同比例的 anchor，比如 3 种大小，3种比例，那么 anchor 的大小就是 $9\times 4$。 </li>
<li>之后是卷积模型，conv1 对特征图进行卷积，产生输出。loc 对输出进行卷积，得到位置参数，$9\times 4$ 大小的输出，9 是 anchors 的数量，4 表示 4 个位置参数。score 对输出进行卷积，得到 $9\times 2$ 大小的输出，因为只有前景和背景两个类。</li>
<li>最后是 proposal_layer，这个不是神经网络，只是单纯的选择 roi 区域，如何选择呢？生成布满特征图的 anchor,大概一万多个，然后遍历 RPN 的每一个输出（位置和分数）：基于 anchor 和 loc 生成候选框，参考公式 1。筛选掉溢出图像的候选框，过滤掉很小的候选框，选择出的分较高的候选框，在进行 nms 抑制，得到最终的候选框。</li>
</ol>
<p>Head 由两部分组成，一个是 ROI-Pooling，另一个是网络，输出分数和定位。将 RPN 得到的 roi 区域映射到特征图上，然后对他也征途进行 ROI-Pooling，取出对应的 roi，将 Pooling 后的结果送入后面的网络，计算位置和的分就可以了。</p>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>对于图片 RPN 生成的每一个候选区域，选出正负样本：</p>
<ol>
<li>计算 RPN 阶段生成的那一万多个 anchor 与真实目标框的 iou，选出与 anchor iou 最大的真实框 $a$、iou 值，在选择与每个真实框 iou 最大的 anchor $b$。然后遍历 $b$，将 $a$ 对应的 anchor 设置为 $b$，这样，至少保证每个真实框都存在对应的 anchor。</li>
<li>iou 小于阈值的设为负样本，大于阈值的设为正样本。</li>
<li>选择对应样本的盒子，并计算这个盒子对应 anchor 的偏移量，用于预测。</li>
<li>计算 RPN 的定位损失，筛选出正样本，计算位置损失；计算分类损失，单纯的判断有无目标。</li>
<li>将 RPN 得到的 roi 计算与真实框的 iou，选择与 roi 最对应的真实框，根据 iou 筛选正负样本</li>
<li>将保留下来的 roi 和 backbone 抽取的特征送入 Head，计算定位损失和分类损失</li>
</ol>
<h2 id="预测阶段"><a href="#预测阶段" class="headerlink" title="预测阶段"></a>预测阶段</h2><p>在得到网络的检测结果后，返回 Head 检测的框、得分以及 RPN 的检测框，利用classifier网络的预测结果对建议框进行调整获得预测框，将框归一化到 0-1 之间，筛选出分类概率大于阈值的框并进行非极大值抑制，得到最终的预测结果。</p>
<p>不得不说，代码量是真的大，如非必要场景，还是用别人写好的吧。</p>
<h1 id="扩展到-Cascade-RCNN"><a href="#扩展到-Cascade-RCNN" class="headerlink" title="扩展到 Cascade RCNN"></a>扩展到 Cascade RCNN</h1><p>至于经常听闻的 Cascade RCNN，只是 Faster RCNN 的一个变体，只是在 ROI head 预测部分增加了几个串联的网络，IOU 逐步提升，从不太 mismatch 的 0.5 开始，逐步提升目标框的质量。</p>
<ol>
<li>detector 在训练阶段和推理阶段面对的数据分布是不一样的，训练阶段 proposal 都是经过 IOU 采样的，正样本含有目标；推理阶段不知道哪个 proposal 为正样本，只能认为所有 proposal 都是正样本，但这样得到的 proposal 的 IOU 都很低，所以推理结果不太好；</li>
<li>如果使用低 IOU 重新训练网络，对噪音的识别较大；如果提高 IOU ，又会造成对正样本的过拟合；</li>
<li>所以可以在网络中使用不同的 IOU 逐步提纯。</li>
</ol>
<p>所以推荐几篇文章，就不详细解读了：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/112828052" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/112828052</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/161530664" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/161530664</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/42553957" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42553957</a></li>
<li><a href="https://linzhenyuyuchen.github.io/2019/12/05/Cascade-R-CNN/" target="_blank" rel="noopener">https://linzhenyuyuchen.github.io/2019/12/05/Cascade-R-CNN/</a> （个人认为写的最好）</li>
</ol>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zhuanlan.zhihu.com/p/39927488" target="_blank" rel="noopener">selective search 算法</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/pdf/1504.08083.pdf" target="_blank" rel="noopener">Fast R-CNN</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://muyuuuu.github.io/2021/04/02/cross-entropy/">交叉熵损失</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/abs/1506.01497" target="_blank" rel="noopener">Faster RCNN</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/bubbliiiing/faster-rcnn-pytorch" target="_blank" rel="noopener">pytorch 代码</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年左右小样本问题顶会论文笔记</title>
    <url>/2020/10/09/few-shot-paper-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一些论文的笔记，不会写的很详细，只会列出核心思想和我认为的优缺点，miniImageNet中5-way，1-shot的准确率，不会详细解读每一篇论文。</p>
<ol>
<li>Meta-Transfer Learning for Few-Shot Learning, CVPR, 2019</li>
<li>Adaptive Cross-Modal Few-shot Learning, NIPS, 2020</li>
<li>Meta-Learning of Neural Architectures for Few-Shot Learning, CVPR, 2020</li>
<li>Charting the Right Manifold: Manifold Mixup for Few-shot Learning, IEEE(WACV), 2020</li>
<li>A BASELINE FOR FEW-SHOT IMAGE CLASSIFICATION, ICL, 2020</li>
<li>Zero and Few Shot Learning with Semantic Feature Synthesis and Competitive Learning, IEEE transactions on pattern analysis and machine intelligence, 2020</li>
</ol>
<p><strong>Warning：</strong>优缺点仅代表个人意见。</p>
<a id="more"></a>
<h1 id="第一篇"><a href="#第一篇" class="headerlink" title="第一篇"></a>第一篇</h1><blockquote>
<p>Meta-Transfer Learning for Few-Shot Learning, CVPR, 2019</p>
</blockquote>
<h2 id="准确率"><a href="#准确率" class="headerlink" title="准确率"></a>准确率</h2><p>$61.2\pm1.8\%$。</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ol>
<li>迁移学习获取预先的知识，将已有的知识用到小样本中；</li>
<li>对于表现很差的查询数据，进行反复训练。就像高中那会儿，整理错题本并反复做错题一个道理。</li>
</ol>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>类似错题本的想法，通过错误和困难来学习到更好的网络。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>引用论文原话：</p>
<blockquote>
<p>Specifically, for a particular few-shot dataset, we merge all-class data $D$ for pretraining. There are totally 64 classes in the training split of $D$ and each class contains 600 samples used to pre-train a 64-class classifier.</p>
<p>“pre”means pre-trained for a single classificationtask using all training datapoints.</p>
</blockquote>
<p>意思是，对于一个具体任务。提前把任务中的所有样本都训练了一遍获取了知识，然后又用训练好的经验去做同一个任务的小样本问题。</p>
<p>个人感觉这并不是很好的处理小样本的方式。利用迁移学习无可厚非，但，知识应该来源于其他领域，而非目标领域。对目标领域预训练获取知识后，就不叫小样本了。所以我感觉论文里提到的$SS$操作并没有什么用处，完全是前期经验好，也没继续去做实验来验证我的想法。</p>
<h1 id="第二篇"><a href="#第二篇" class="headerlink" title="第二篇"></a>第二篇</h1><blockquote>
<p>Adaptive Cross-Modal Few-shot Learning, 2019, NIPS</p>
</blockquote>
<h2 id="准确率-1"><a href="#准确率-1" class="headerlink" title="准确率"></a>准确率</h2><p>$65.3\pm0.49\%$。</p>
<h2 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h2><p>在图像分类问题中，图像本身带有视觉信息。当视觉模态的信息很少时，可以尝试利用语义模态的信息。利用 GloVe 获得词嵌入矩阵，这样就能得到标签的语义表示。于模态对齐相反的是，将数据的视觉信息和语义表示同时扔进两个网络，语义的网络学习得到一个参数$\lambda$，将语义空间的表示和视觉空间的表示进行线性加权，得到最后的结果：</p>
<p>\begin{equation}<br>    \lambda \textbf{p}_c + (1-\lambda) \textbf{w}_c<br>\end{equation}</p>
<h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li>这是一种通用的方法，并不涉及网络结构的设计，因此这种方法可以扩展到任何基于度量的小样本学习方法中。</li>
<li>通过参数$\lambda$的学习，能自适应的结合视觉模态和语义模态。当图片样本多时，语义模态的权重就少，当图片样本少时，语义模态的权重就大。</li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>暂时想不到，个人认为是这些论文里思想最好的。</p>
<h1 id="第三篇"><a href="#第三篇" class="headerlink" title="第三篇"></a>第三篇</h1><blockquote>
<p>Meta-Learning of Neural Architectures for Few-Shot Learning, CVPR, 2020</p>
</blockquote>
<h2 id="准确率-2"><a href="#准确率-2" class="headerlink" title="准确率"></a>准确率</h2><p>$61.7\pm0.3\%$</p>
<h2 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h2><p>个人对 NAS(neural architecture search) 不太熟，但愿我没理解错。NAS 的方法中有一类是基于梯度下降来调整网络结构的，而 meta-learning 中也有基于梯度下降来调整网络参数的。那么以 meta-learning 为框架，在训练数据的时候同时对这两者进行梯度下降，学到最后的网络结构和参数。</p>
<p>然后如果没看错：后面的章节应该是调节 softmax 的方式，使得网络中节点边之间的权重（DARTS算法）快速的向 0 或 1靠近，避免网络结构难以训练时需要重新训练 meta-learning 的参数。实在对 NAS 不太熟，但愿没理解错。</p>
<h2 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h2><p>和 NAS 结合了起来，但，总感觉偏应用。</p>
<h1 id="第四篇"><a href="#第四篇" class="headerlink" title="第四篇"></a>第四篇</h1><blockquote>
<p>Charting the Right Manifold: Manifold Mixup for Few-shot Learning, IEEE, MACV, 2020</p>
</blockquote>
<h2 id="准确率-3"><a href="#准确率-3" class="headerlink" title="准确率"></a>准确率</h2><p>$64.93\pm0.18\%$</p>
<h2 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h2><p>该论文设计的算法的目标就是在迁移学习的第一个阶段(即训练模型$f$的参数), 能够学习到一个模型, 该模型能够学习到丰富的, 通用的, 有意义的特征表示, 对数据分布的微小变化具有鲁棒性.</p>
<p>使用了自监督学习的方法, 来首先学习到一个丰富, 通用, 有意义的特征表示(特征流形). 使用了两个辅助任务(可以任选其一): rotation和exemplar. (表现为损失函数)。我的理解: 特征流形就是一个特征空间, 这个特征空间中的特征向量是低维的, 没有冗余, 丰富的, 表示强。使用正则化技术(流形混合(manifold mixup)), 通过插值法实现的, 原理: 使决策边界更加光滑, 每个类的数据表示在一个更低的维度空间, 可以泛化到新任务中.</p>
<h1 id="第五篇"><a href="#第五篇" class="headerlink" title="第五篇"></a>第五篇</h1><blockquote>
<p>A BASELINE FOR FEW-SHOT IMAGE CLASSIFICATION, ICL, 2020</p>
</blockquote>
<h2 id="准确率-4"><a href="#准确率-4" class="headerlink" title="准确率"></a>准确率</h2><p>$68.11\%$</p>
<h2 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h2><p>对经过标准交叉熵损失训练的深度网络进行微调，是进行少量学习的坚实基础。如果对它们进行超导地微调，它的性能将优于标准数据集中具有相同超参数的最新技术。传统交叉熵：</p>
<p>\begin{equation}<br>    \theta^*(D_s)=\arg\min_\theta\frac{1}{N_s}\sum_{(s,y)\in D_s} -\log p_\theta(y|x)<br>\end{equation}</p>
<p>其中$D_s$代表训练集，$N_s$表示训练集中数据量。传导式微调：假设有一个查询样本$(x,y)$属于$D_q$，<br>\begin{equation}<br>    \theta^*=\arg\min_\theta\frac{1}{N_s}\sum_{(s,y)\in D_s} -\log p_\theta(y|x)+\frac{1}{N_q}\sum_{(x,y)\in D_q} H(p_\theta(\cdot|x))<br>\end{equation}<br>其中，$H$代表香农熵，作为损失函数的正则化项。</p>
<h1 id="第六篇"><a href="#第六篇" class="headerlink" title="第六篇"></a>第六篇</h1><blockquote>
<p>Zero and Few Shot Learning with Semantic Feature Synthesis and Competitive Learning, IEEE transactions on pattern analysis and machine intelligence, 2020</p>
</blockquote>
<h2 id="准确率-5"><a href="#准确率-5" class="headerlink" title="准确率"></a>准确率</h2><p>$62.28\pm0.13\%$</p>
<h2 id="核心思想-5"><a href="#核心思想-5" class="headerlink" title="核心思想"></a>核心思想</h2><p>通过两个方法来进行零样本学习，即: unseen classes 数据合成和健壮的投影函数学习。通过一定的策略从seen classes 数据生成 unseen classes 数据， 然后通过投影函数模型来最好的利用合成的unseen classes数据。</p>
<ol>
<li>合成的特征向量不能被认为属于第 $j$ 个unseen class. 也就是说, 生成的样本比较混乱. 不能正确归类。</li>
<li>BPL(竞争双向投影学习): 进行label correction. 所谓的竞争就是每个合成的样本应该更接近更可能的 unseen class centre, 同时原理次好的(候选的)unseen class centre。 所谓双向是指loss既有正向的(从语义空间投影到特征空间)又有反向(从特征空间投影到语义空间)的投影误差。</li>
</ol>
]]></content>
      <tags>
        <tag>PaperNote</tag>
      </tags>
  </entry>
  <entry>
    <title>《摆渡人》读后感</title>
    <url>/2018/11/18/ferryman-reaction/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>I exist because you need me.——The reaction of Ferryman.</strong></p>
<p><img data-src="/2018/11/18/ferryman-reaction/5.png" alt></p>
<a id="more"></a>
<p>摆渡人的绝大部分故事发生在恶魔出没的荒原，充满着恐怖与肃杀的气氛，但是还是选择了一种以放松和浪漫为主题的图片，之后道出原因。</p>
<p>一年半以前，在某个无聊的课上看完了《摆渡人》，也就是上册。然后在书店看到了《摆渡人2》，也就买了回来看故事的续集。</p>
<p>第一本的故事的主题：<strong>I exist because you need me</strong>。如果生命是一条孤独的河流，谁会是你的摆渡人？这是写在封面上的一句话，人生而孤独，那么摆渡人，真的能够渡化谁吗？留个悬念。</p>
<p>故事的主人公迪伦父母已离婚，她决定逃课坐火车到他父亲身边，再在火车穿越隧道的过程中发生车祸死了过去。而每个人死后，都会有一个摆渡人出场，去带领死去的人前往另一个世界。崔斯坦，则是故事里的摆渡人，引导迪伦穿过荒原，但是在荒原上有恶魔出没，专门靠吃死去的人来填饱肚子。摆渡人的任务就是保护死去的人免遭恶魔毒手。他说，“我告诉他们真相，然后把他们送到他们要去的地方。</p>
<p>他们两个在随时可能被恶魔抓走的荒原中行走，因恶魔的存在荒原也危机四伏，在平原、在山野、在湖中和恶魔打过多次交到后，这俩孩子也经历了多次的生离死别，不知不觉中相知、相爱，然而但是，命运从最开始就决定了他们两个的道路是<del>不同</del>的。</p>
<p>迪伦是普通人，穿越荒原后走入了新的世界；而崔斯坦是摆渡人，需要接受新的任务，去引导下一个灵魂。他们纵然深深地爱着对方，却无法相守。在新的世界，不甘放弃的迪伦重新返回荒原，一个人。如果停留在新世界，不能和心爱的人一起；那么就往回走，返回荒原寻找崔斯坦，但是向后走的路从来没有人走过，但可能是唯一有希望和爱的人在一起的路。如果这样孤注一掷，特别是，在这条路上，崔斯坦依然无恙，更冒险的是，自己押注了性命。这次没有摆渡人的陪伴，我很佩服迪伦的勇气，而且，失败的话，她也就放弃了新的生命，这股勇气和坚持，我想，真的很强大。</p>
<p><img data-src="/2018/11/18/ferryman-reaction/2.png" alt></p>
<p>她独自一个人面对一群恶魔只为了寻找崔斯坦，在返回的路上日夜煎熬。最终，迪伦着崔斯坦从荒野来到了人类世界，并且找回了自己的生命。然后一起回到她当初出事的那段隧道里，最后崔斯坦的那句 ：  <strong>“我在这里”</strong>  升华了这本书。</p>
<blockquote>
<p>再次重逢后，为了能一直在一起，面对未知的未来，再多的恐惧无所畏惧，只要能牵着你的手一直走一下去就好了。我知道你需要我，所以我会一直在你身边。最后做到了许多原以为不可能对事情，因为你需要，所以我在这里，一直在这里。</p>
</blockquote>
<p>或许爱情不需要太多动听的语言，只需要简单的动作和简短的话语就足够温暖人心，“我在这里”，多么美好的四个字，看到最后的我心都即将融化，害怕的时候有人牵着你的手，无助的时候有人会一直在你的身边，有时候一个眼神就能够传递所有美好，至少孤独感没有那么强烈，真好。想起了曲婉婷的某首歌：又是你的面孔，带给我是相容；又是你的问候，带给我是感动。</p>
<p>这是我只读了第一本书的感受，以为只是一本描写冒险和爱情的小说；直到看了第二本才发现是自己<strong>庸俗</strong>了。下文解答一下自己的理解，也解释下上文说的悬念。</p>
<hr>
<p>第二本书的描写手法和第一本大体一样，整体的情节是崔斯坦和迪伦来到了人类世界，此时迪伦成为了崔斯坦的摆渡人而角色互换，生活在一起睡在一起吃在一起的一直照顾着崔斯坦，而迪伦离婚的父母也重归于好，完美的结局。</p>
<p>当然中间穿插了小插曲，崔斯坦来到人类世界时不小心在荒原和人类世界之间打开了一个破洞，恶魔趁机来到了人类世界，另一个暗恋崔斯坦的摆渡人苏珊娜也来到了人类世界，他们因违反了规则迫不得已要去把那个破洞补上，而自私的摆渡人苏珊娜受到了惩罚，崔斯坦最后留在了人类世界。</p>
<p>还是个<del>爱情故事</del>的完美结局？冷静分析了一波，似乎不是。这本书给我最大的触动，不是迪伦和崔斯坦的爱情和勇气，而是让我思考，如果我在这一刻死去，那么我最遗憾的事情是什么？或者，我在2016年就已经死了，我这两年来的经历也不过是在荒原上的摆渡，遇到的人或事也不过是书中的摆渡人、安全屋、恶魔，而终点在哪里？</p>
<p><img data-src="/2018/11/18/ferryman-reaction/4.png" alt></p>
<p>在我年轻的时候，也许沉迷于游戏，也许心死于幼稚的爱情，也许整日碌碌无为，这样，其实多年前心就已经死了，活下来的也不过是没有灵魂的肉体。然后一个孤独的心灵开始自己穿越荒原，也许一天穿越完毕，也许一年才能穿越完，也许十年也不能穿越完。</p>
<p>而在时间的路上任何人都可以是摆渡人，也可以是恶魔，而终究去往何方，不管是遵从书本中作者的含义还是思维的符合常识，最终去往的地方终究由自己决定。自私的人中会死去，勇敢的人会留下来。</p>
<p>也许最终摆渡成功，又会为当初的任性无知付出沉重的代价，也就是第二本书的主题：重返荒原，去弥补当初的过失，书中写出的需要弥补的过失就是去炸毁那个漏洞。真实世界呢？比如年轻时候发誓将生命献给爱情，比如埋葬学业献身于游戏等，当然在实际生活中，摆渡的过程中没有死，也不可能会死，因为会发现，<code>沉重的代价下青春替你抵了命</code>。如果幸运，那就找回了自己的灵魂，心还透明就能继续折射希望；如果不幸运，青春替你抵命后还有更多美好的东西去替你抵命。</p>
<p>年轻时，发誓把生命一切都签给爱情，后来你没有死，青春替你低了命。</p>
<p>和读过的其他书也一样，比如《一个人的朝圣》，比如《荒野猎人》，比如《雨王亨德森》，比如《一怒之下DH劳伦斯的决斗》，还比如《牧羊少年奇幻之旅》。无论如何朝圣，儿子已经死去不能复生，猎人最终也没有复仇成功，亨德森也没有找到有效的治疗药物，没有决斗的结果，牧羊少年找到了其他的宝藏……身带主角光环的他们还是获得了圆满结局，不是身体上的旅行——穿越荒原，各种各样的荒原，更多的是心灵的历练，而最终摆渡到何方，还是取决于自己。</p>
<p><img data-src="/2018/11/18/ferryman-reaction/3.png" alt></p>
<p>这不是灵魂鬼怪魔幻之事，这就是我们每个人的故事。我们都是正待摆渡的灵魂，<strong>各色各样</strong>。</p>
<p>当然我们也是保护灵魂的摆渡人，在爱一个人的时，我们强大，担负责任，安慰着爱人的灵魂，引导他做一个全新的自己。那时的我们如同崔斯坦般，是温柔的模样，有宽大的臂膀。</p>
<p>也许我们还是荒原中湖水里漂浮的魔鬼，侵蚀那些不够坚强脆弱的灵魂。</p>
<p>当然，书的结局就正如初阳一般晴朗，引导无数的摆渡人，也是被灵魂们渡化，感知着美好人世间的情感，这一切都是因为有爱。</p>
<hr>
]]></content>
      <tags>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>弹性光网络选路和频谱分配问题建模</title>
    <url>/2021/02/16/flexible-fiber-optic-network-schedule/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本博客来自于某课程的大作业。按照我之前建模的习惯，会直接『元胞自动机』设置规则直接模拟；但是却看到了通过优化来建立模型的做法。前者是基于规则的模拟，后者是凸规划问题下的求解。对于获得的解而言，在理论上还是后者更好一些，毕竟存在最优解。</p>
<a id="more"></a>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img data-src="https://s3.ax1x.com/2021/02/16/ycY8iD.png" alt></p>
<p>在上图中，一个网络中含有多个节点，如：交换机、路由等设备。当网络中的业务仅仅需要从各自源结点到达各自目的结点传输一定的数据时，利用这个网络就能实现数据传输的目的。该网络具有以下特性：</p>
<ol>
<li>网络节点之间有通信链路作为连接，称为边；</li>
<li>网络中的每条边有多个频隙，每条边上频隙数目一样，且每个频隙具有相同的容量，即每条边传输的数据量是一样的；</li>
<li>一个频隙在同一时刻只能在执行单个任务，即：结点2和结点5之间的边上的1,2,3号频隙有任务时，不能再将该频隙分配给其他业务；</li>
<li>频隙连续且一致，即：<ol>
<li>连续：数据包占用的频隙是相连的，是1,2,3这样的频隙，不能是1,3,4这样的频隙；</li>
<li>一致：数据包在第一条边上的频隙是1,2,3，经过节点转发，进入下一条边时，占用的频隙仍然是1,2,3。</li>
</ol>
</li>
</ol>
<p>当网络中有一批业务时，需要一个节点（源节点）向网络中的另一个节点（目的节点）传输一定量的数据（业务），我们需要做哪些工作？试建立数学模型解决此问题。</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>建立的模型应至少解决以下两个问题：</p>
<ol>
<li>为每条业务选择一条路径；</li>
<li>在每条路径中为任务分配频隙；</li>
</ol>
<p>但需要在解决以上问题的基础上，需要达到占用带宽最小等目标，因此需要建立优化模型解决此问题。</p>
<h1 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h1><ul>
<li>$N$，网络中节点数量，节点编号为1到$N$</li>
<li>$v_i$，网络中第$i$个节点$(1\leqslant i\leqslant N)$</li>
<li>$E$，网络中边的集合</li>
<li>$e_{ij}$，网络中起始点为$i$，目标点为$j$的边</li>
<li>$F$，网络链路中频隙数量，频隙编号为1到$F$</li>
<li>$M$，需要实现的任务数量</li>
<li>$A$，业务请求集合：$\{A_1, A_2, \cdots, A_M\}$</li>
<li>$A_k$，第$k$个业务，$A_k=\{s_k, t_k, b_k\},(1\leqslant k \leqslant M)$</li>
<li>$s_k$，第$k$个业务的起始节点$(1\leqslant s_k \leqslant N)$</li>
<li>$t_k$，第$k$个业务中的目的节点$(1\leqslant t_k \leqslant N)$</li>
<li>$b_k$，第$k$个业务中需要占用的频隙数$(1\leqslant b_k \leqslant F)$</li>
</ul>
<h1 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h1><p>考虑到理论模型与实际工程中存在的误差，基于以下假设来简化模型的建立：</p>
<ol>
<li>假设链路在多次使用和传输了大量数据后，链路并不会因老化而产生性能损耗。即频繁使用不影响链路的传输速率和传输量，传输速率和传输数据量始终保持恒定；</li>
<li>假设按编号顺序依次分配任务所需占用的频隙，除保护频隙外无空余频隙。举例说明：当一条链路有10条频隙时，第一个任务占用5个频隙，则分配1-5号频隙，而不是3-7号等不按顺序编号的频隙；第二个任务也占用此条链路时，若其需要占用3条频隙，考虑到保护频隙，第二个任务将占用7-9号频隙，而不是选用8-10号等产生空余频隙的方案。</li>
</ol>
<h1 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h1><h2 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h2><p>在光纤网实现传输数据的任务中，应从时间和成本两个方便考虑。以时间角度出发，应尽可能快的完成传输任务；从成本角度出发，使用的资源尽可能的少且均衡，即不能频繁使用一条链路，而其余链路一直处于空闲状态。而在本次建立的模型中，为简化优化目标的复杂性，将时间因素转换为约束条件，即尽可能的减少传输时间作为约束条件。</p>
<p>从成本角度出发，首先考虑尽可能减少使用带宽资源这一目标，以减少带宽的使用。以$F_{ij}$表示链路$e_{ij}$上被占用的最大频隙号。则此时的优化目标为：</p>
<p>\begin{equation}<br>    \min\Bigl(\max_{e_{ij}\in E}(F_{ij})\Bigr)<br>\end{equation}</p>
<p>而在实际工程中频繁使用同一条链路，势必因负担过大而造成性能损耗。应均匀的使用所有链路，避免某些链路一直处于空闲状态。因此针对均衡使用链路资源这一目标，以$D_{ij}$表示起点为$i$，终点为$j$的链路$e_{ij}$的使用次数。计算所有链路使用次数的方差，使方差最小作为第二个优化目标：</p>
<p>\begin{equation}<br>    \min\Bigl(\text{Var}_{(i,j)\in E}(D_{ij})\Bigr)<br>\end{equation}<br>其中，$\text{Var}$表示求方差。</p>
<p>如网络中有两组任务，第一组任务：从$v_i(1\leqslant i \leqslant N)$节点出发，到$v_j(1\leqslant j \leqslant N)$节点，需要占用路径中的全部频隙；第二组任务：仍然从$v_i(1\leqslant i \leqslant N)$节点出发，仍然到达$v_j(1\leqslant j \leqslant N)$节点，同样需要占中路径中的全部频隙。此时，两组任务的执行必须有先后的顺序关系。所以路径中涉及的链路必然会被多次使用，故第二个优化目标具有一定的合理性。综上所述，优化目标为：</p>
<p>\begin{equation}<br>  \min\Bigl(\max_{e_{ij}\in E}(F_{ij})+\text{Var}_{(i,j)\in E}(D_{ij})\Bigr)<br>\end{equation}</p>
<h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><p>如果只是简单的设置节点之间的转发规则，当满足条件时转发数据。此类基于规则的贪心算法只能寻找到问题的可行解，甚至不是局部最优解，或容易陷入局部最优解而非全局最优解。因此，应该建立约束条件，在约束条件下借助优化算法寻找目标函数的优化解，如借助遗传算法、粒子群算法等。但需要注意的是，因为优化目标和约束条件本身具备的复杂性，此类算法不能保证一定能寻找到问题的最优解，求得的解往往是局部最优解。</p>
<p>根据问题描述，应考虑以下4个约束条件：</p>
<ol>
<li>起始节点和目标节点之间的路径是相通的；</li>
<li>对于一个任务，要分配连续的频隙；</li>
<li>一条链路中使用的频隙数要小于链路允许的最大频隙数；</li>
<li>一个频隙在同一时刻只能执行一组任务，不能有多个任务同时使用一条频隙。</li>
</ol>
<h3 id="路径可行性约束"><a href="#路径可行性约束" class="headerlink" title="路径可行性约束"></a>路径可行性约束</h3><p>业务$A_k(\forall A_k\in A)$的起始节点和目标节点之间的路径应该是相通的。设$P_k=\{P_k^1, P_k^2, \cdots, P_k^{N_k}\}$为起始节点和目的节点之间可行的路径集合，$N_k$表示可行路径的数量。$x_k^q$为布尔变量，当选择第$q$条路径时，其值为1；若不选择第$q$条路径，$x_k^q$的取值为0，且只能选择一条路径。</p>
<p>考虑到应该尽可能快的完成传输任务，对于每一个任务$k$，即当源节点到目标节点有多条路径时，应选择传输速率最快的路径。综合考虑两者，列出约束条件：</p>
<p>\begin{equation}<br>    \sum_{1=1}^{N_k}x_k^q=1,x_k^q=\min\{t(P_k^1), t(P_k^2), \cdots, t(P_k^{N_k})\},\forall A_k \in A<br>    \label{time}<br>\end{equation}</p>
<p>其中，$t(P_k^i)$表示单位大小的数据在路径$P_k^i(1\leqslant i \leqslant N_k)$上传输的时间。</p>
<h3 id="频隙连续性约束"><a href="#频隙连续性约束" class="headerlink" title="频隙连续性约束"></a>频隙连续性约束</h3><p>设$f_k^q(ij)$为任务$A_k$在路径$Q_k^q$中的链路$e_{ij}$上可用的起始频隙编号，则$(1\leqslant f_k^q(ij) \leqslant F)$。若在此链路中分配该任务，应保证该任务占用的频隙号是连续的。因此，从$f_k^q(ij)$开始，按编号顺序连续分配其他频隙，应保证分配的频隙数和任务$A_k$需要的频隙数$b_k$相等。列出约束条件：</p>
<p>\begin{equation}<br>    \sum_{p=f_k^q(ij)}^{f_k^q(ij)+b_k-1}H_{qp}=b_k,\forall e_{ij}\in Q_k^q<br>\end{equation}<br>其中，$H_{qj}$为布尔变量，取值为0或1。当路径$Q_k^q$中的频隙$p$被选择时，取值为1，否则取值为0，以此来满足分配的频隙数和所需的频隙数相等的约束。需要注意的是，路径$Q_k^q$中的所有链路$e_{ij}$应该均满足这一约束。</p>
<h3 id="频隙数与任务不重叠约束"><a href="#频隙数与任务不重叠约束" class="headerlink" title="频隙数与任务不重叠约束"></a>频隙数与任务不重叠约束</h3><p>因为变量$f_k^q(ij)$表示路径$Q_k^q$允许任务$k$的起始频隙编号，所以并不会存在同一时刻一个频隙内有多个任务重叠的情况，如下图所示。在左图中，一条链路中共有$F$个频隙，一个任务已经占用了$n$个频隙。若之后的任务若使用此条链路，则允许的起始频隙号$f_k^q(ij)=n+1$。在右图中，若链路尚未被使用，则允许的起始频隙号$f_k^q(ij)=1$。</p>
<p><img data-src="https://s3.ax1x.com/2021/02/16/yctjjs.png" alt></p>
<p>因此当有多个任务使用同一条链路时，对于之后进入的任务，允许使用的起始频隙号会自动增加，因此避免了同一时刻多任务重叠在一个频隙内的错误情况。但对于可行路径$Q_k^q$中的所有链路$e_{ij}$，要满足使用频隙数不小于最大频隙数的约束，列出约束条件：</p>
<p>\begin{equation}<br>    f_k^q(ij)+b_k-1 \leqslant F, \forall A_k \in A, \forall e_{ij} \in E<br>\end{equation}</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>因此，得到的最终优化模型为：<br>\begin{align}\notag<br>&amp;\min\Bigl(\max_{e_{ij}\in E}(F_{ij})+\text{Var}_{(i,j)\in E}(D_{ij})\Bigr) \\<br>&amp;\text{s.t.}\quad<br>\begin{cases}<br>\displaystyle{\sum_{1=1}^{N_k}x_k^q=1,x_k^q=\min\{t(P_k^1), t(P_k^2), \cdots, t(P_k^{N_k})\}}\\<br>\displaystyle{\sum_{p=f_k^q(ij)}^{f_k^q(ij)+b_k-1}H_{qp}=b_k,\forall e_{ij}\in Q_k^q} \\<br>\displaystyle{f_k^q(ij)+b_k-1 \leqslant F, \forall A_k \in A, \forall e_{ij} \in E}<br>\end{cases}<br>\end{align}</p>
<h1 id="灵敏性分析"><a href="#灵敏性分析" class="headerlink" title="灵敏性分析"></a>灵敏性分析</h1><h2 id="链路老化带来的问题"><a href="#链路老化带来的问题" class="headerlink" title="链路老化带来的问题"></a>链路老化带来的问题</h2><p>模型假设了链路在多次使用和传输大量数据后，链路并不会因老化而产生性能损耗，即在频繁使用的情况下，链路的传输速率和传输数据量始终保持恒定。但在实际工程的使用中，这一假设并不成立，链路会受到天气、人为、电磁场等影响，因而产生不可避免的老化与损耗。</p>
<p>假设某一时刻链路因老化，传输数据量受到影响，对比进行分析。举例说明：针对大小相同的数据量，新链路用5条频隙就能传输完毕，而老化的链路则需要8条链路来传输。此时，只需要对链路老化程度进行监测，或通过历史数据建立链路老化程度与链路使用次数$D_{ij}$的关系函数（$i$为一条链路的起点，$j$为一条链路的终点，$ij$相邻）。举例说明此关系函数的含义：当链路的使用次数达到$B$次后，需要增加$C$条频隙来传输单位大小的数据量。之后通过软件更改任务$A_k$中$b_k$的大小即可，例如将5改成8，而不需要修改建立的模型。</p>
<p>当链路的传输速率也受到影响时，会对路径可行性约束中的时间函数$t(x)$带来影响，从而影响最短路径的选择。同上需要建立传输单位数据的时间与链路使用次数$D_{ij}$的关系函数（$i$为一条链路的起点，$j$为一条链路的终点，$ij$相邻）。举例说明此关系函数的含义：当链路的使用次数达到$B$次后，传输单位大小数据量将减慢$g$倍。此时，因为速率减慢，在模型中的路径可行性约束中，公式\eqref{time}中路径$x_k^q$的选择将会受到影响。但只会影响路径选择的结果，而不用重新建立模型。</p>
<p>综上所述，在去除模型假设的情况下，建立的优化模型具有一定的稳定性。</p>
]]></content>
      <tags>
        <tag>Modeling</tag>
      </tags>
  </entry>
  <entry>
    <title>一种求目标函数最优值的方法（填充函数法</title>
    <url>/2020/12/19/filled-function/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在本科建模学优化的时候，老师说复杂情况下不可能求出目标函数的最优解，用优化解代替就可以了，当时我还信了。直到研究生『工程优化』学了<strong>填充函数法</strong>，才知道在『多决策变量、单目标函数』的复杂情况下，理论上是可以求出目标函数的最优值的。</p>
<p>而对于『多决策变量、多目标优化』的问题中，还是进化算法等方法较为实用。以遗传算法为例，直接一波种群撒到可行域中，这样会比传统方法便捷一些。</p>
<a id="more"></a>
<h1 id="填充函数定义"><a href="#填充函数定义" class="headerlink" title="填充函数定义"></a>填充函数定义</h1><p>在难以直接求解$\min f(x)$时，我们可以使用填充函数法。</p>
<p>假设，$f(x)$在$R^n$中连续可微，且在可行域内有有限个极值点，所以每一个极值点都是孤立的。设 $x_k^\ast$ 是目前得到的 $f(x)$ 的一个局部极小点。在此处构造一个新的函数$p(x,x_k^\ast)$，称为填充函数。填充函数应具有的性质如下：</p>
<ul>
<li>$x_k^\ast$是填充函数的一个局部极大点；</li>
<li>目标值大于$f(x_k^\ast)$的区域，填充函数没有驻点；</li>
<li>目标值小于$f(x_k^\ast)$的区域，存在一点是填充函数的极小点；</li>
</ul>
<p>用数学语言描述：</p>
<ul>
<li>$x_k^\ast$是$p(x,x_k^\ast)$的严格极大点；</li>
<li>$\forall x \in \Omega_1,\nabla p(x,x_k^\ast)\neq 0$，$\Omega_1=\{x\in \Omega | f(x) &gt; f(x_k^\ast),x\neq x_k^\ast\}$，$\Omega$为可行域；</li>
<li>若$\Omega_2=\{x\in\Omega|f(x)&lt;f(x_k^\ast),x\in\Omega\}$非空，则存在一点$x_k’\in\Omega_2$，它是$p(x,x_k^\ast)$的局部最小点。</li>
</ul>
<p>则称$p(x,x_k^\ast)$是$f(x)$在$x_k^\ast$处的一个填充函数。画图如下，蓝色为函数图象，红色为填充函数图象。</p>
<p><img data-src="https://static01.imgkr.com/temp/65b961a32fcf4540827b803ed573e924.png" alt></p>
<h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ol>
<li>第$k$次迭代：求$f(x)$一个局部极小点$x_k^\ast$；</li>
<li>构造$x_k^\ast$处的填充函数$P(x,x_k^\ast)$，求填充函数的极小点$x_k’$。根据前述条件，此时该点对$f(x)$而言，是比$x_k^\ast$更好的点，它在$f(x)$一个更深的谷里；</li>
<li>以$x_k’$为初始点，对$f(x)$求极小点得$x_{k+1}^\ast$，此点比$x_k^\ast$位于$f(x)$更深的谷里。令$k=k+1$，转Step2。</li>
</ol>
<p>这样逐步迭代，直到函数再也没有局部最小点。如上图第二次迭代后的结果：<br><img data-src="https://static01.imgkr.com/temp/1593a692f0cf405e9747b1593238c173.png" alt></p>
<h1 id="Q函数"><a href="#Q函数" class="headerlink" title="Q函数"></a>Q函数</h1><p>一种只有一个参数的填充函数是（$a$是参数）：</p>
<p>\begin{equation}<br>Q(x,a)=-(f(x)-f(x_k^\ast))\exp\Bigl(x-x_k^\ast\Bigr)^2<br>\end{equation}</p>
<p>证明：略。</p>
]]></content>
      <tags>
        <tag>Modeling</tag>
      </tags>
  </entry>
  <entry>
    <title>《怦然心动》</title>
    <url>/2020/08/26/flipped/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>七夕杀狗之际，也为了缓解开学前的焦虑，看了部电影，叫《怦然心动》，原名为《Flipped》。不得不说太甜了，<del>我在床上扭动的像个蛆</del>，一个猛男居然差点失声尖叫出来。说好了上年纪了怕受刺激，不看爱情电影。可谁能抵挡这种没有狗血剧情，没有霸道总裁的简单纯洁青春恋爱剧呢？</p>
<p><img data-src="/2020/08/26/flipped/1.jpg" alt></p>
<a id="more"></a>
<p>上面的图片，不知道你们看了有没有感觉。作为一个男生，一眼过去的确有当初初恋的感觉，放佛又回到了那个情窦初开的夏天。青春期还都是学生，没有化妆，没有首饰；素颜朝天笑的很纯洁，微风拂过掀起的长发，双眸似泉，笑起来也是那么牵动暗恋者的心弦。当初最美的场景，不就是阳光下，走廊里，你的侧脸吗。微风拂过，刘海微微飞扬，头发没有染色没有拉直，就一个简单的马尾辫，多美。</p>
<p>青春期的感情纯洁没有杂质，喜欢就是喜欢，甚至可能说不出来为什么。一身简单的白校服或者素衣；一个简单的学生头，毛寸或者马尾辫；一举一动一颦一笑，周身散发出的那种青春气息，是这个阶段的恋爱所独有的。</p>
<p>就像那天路过唐山，看到几个学生，穿着高中校服，一脸的年轻稚嫩，阳光下的笑又显得那么舒服和惬意，还在青春的孩子的确让人羡慕。过了那个年纪，就难以找回难以遇到那种感觉了，珍贵的回忆还是留藏在心底吧。不像狗血电影里，那么炫美的服装，那么放松的环境。这部电影里和大多学生的现实生活，没有怀孕没有多角恋，没有打架也没有癌症，就简单的卷子、纸条、见面打个招呼，下课开个玩笑，就这么简单，符合所有的初恋幻想。</p>
<p>而在这部电影中，把情窦初开时的情绪、举动；做错事被识破后的转移话题；就是忍不住的盯着对方看，想看对方却又不敢有眼神直视的交流，那种心理状态，描写的淋漓尽致，生动形象。引起了我的共鸣，不然我也不至于差点失声尖叫。电影里描写的青少年恋爱，也符合所有人读书时的青春吧。喜欢又不好意思明说捅破的纯真感觉，没有捅破却又看见你和别人聊得很来的吃醋心理，如果你真的动过心，就应该知道我在说啥，不可思议与甜蜜。</p>
<p>我想说，我青春期懵懂的恋爱，或者说就是暗恋，和这部电影一模一样。唯一不一样的地方就是，当时不知道怎么处理和面对，就没了下文。</p>
<p><img data-src="/2020/08/26/flipped/3.jpg" alt></p>
<p>或者说，如果我有男主那样的外祖父该多好。我的父亲和电影男主的父亲也很相像，自以为是，看重自己的家庭地位不允许别人和他那样说话。我从小没接收到好的家庭教育，耳濡目染的是对家人的贬低和抱怨，他可以贬低和抱怨家人哪里不好，一件事能说上好几次都不停歇，但别人不能说他一次。以至于发现我说话没用之后，我提的建议都是被<strong>我说不行就不行，没有为什么</strong>驳回；遇到和她们想法不同的情况，就一直按她们的想法说来说去，从不考虑我的意见，偶尔情况是连打带骂，所以我懒的在家里多说一句话。对，你没听错，我在家里就是一句话都不说的状态，童年期间留下阴影了，真的没法改。我现在还在说这些，说明我还在阴影里没有出来。</p>
<blockquote>
<p>举个真实的例子：跟家长聊天得控制在 几个字 这个数量级的，不然就是在跟自己找麻烦，解释一下还得说更多的话，有更多的麻烦。<br>我爸：保研能跨专业吗？<br>我：能。<br>我爸：肯定不能！保研不可能跨专业，必须得是原来的专业！怎么能随便换专业呢？<br>我的想法：你参与过还是我参与过？这玩意确实能啊，身边好多人都跨专业保送了，学校都允许跨专业你为啥不允许？你不认同我的想法还问我干啥？<br>我嘴上的回答：恩，不能。</p>
</blockquote>
<p>于是从小我也沾上了这种恶习，抱怨、自卑、悲观和对别人从不停止的抱怨，以自我为中心而不关注别人的感受，一度以为自己的想法就是别人的感受。在为人处世上，因自身的性格缺陷吃了很多的亏，也导致了现在的我性格孤僻。<strong>可见一个孩子的家庭教育有多么重要，理应受到和学校教育一样的同等重视。</strong>虽然很多杀人犯的确是童年不完整，但好在我没有走偏。但付出的代价是要用一生去治愈童年，为此，我的确因性格问题失去了很多。所以我只能慢慢改正。</p>
<p>我也观察过很多人，家庭教育好的孩子往往能在关键时刻取得更好的成绩，一般的孩子会受到心理因素的困扰和影响，做出错误的选择。也许你以为没啥，但在每次抉择前，都因冲动、不理性、自负、自卑等先天不良影响做出错误的决定，错误的决定还会继续影响之后的发展。之后继续选错，继续影响……滚雪球式的负担会让人更加喘不过气，直到被最后一根稻草压死。而一群键盘侠就会过来批评你，多大点事？你为什么连这都经历不了？</p>
<p>你别说别人家的孩子都没事，就你有事？你太矫情了，是你不行。朋友，新世纪了，素质教育不必棍棒教育好么？况且，别人是别人，我是我。经历不同秉性不同，我不知道别人怎么想的，别人也不知道我怎么想的。所以我不能评价别人，别人也不能评价我。所以我至今都好奇，当初那些人，为啥动不动就来批评我？</p>
<p>如果你真的想站在道德制高点，以自己的看法为中心，身边两三个朋友的行为就能代表全世界的看法，想指责我或别人两句。我给你指条明路，世上有一种病叫抑郁症，称为精神癌症。每个患者都知道抑郁症对自己和家人都不好，都在配合治疗。她们也都是精神出了问题，想法和行为不是正常人能理解和接受的，但在家人、同学的陪伴和药物的治疗下还没治好。希望你能站在道德高地，依靠自己的认知和想法，借助键盘去批评她们：哪里做的不好，应该怎么做，去治愈她们。你会为世界医学贡献巨大的力量，病人少花钱，世界多一份和平，没准今年诺贝尔医学、经济奖什么的都是你的。</p>
<p>所以，对那些不了解你，哪怕是了解了你的行为，动不动就劝你要看开，要放下，要向前看的人，离她们远一点。一是她们情商低；二是她们看问题太片面了，容易带有色眼睛；三是打雷的时候别一起被劈了（选自郭德纲的话：你刚被捅了一刀，血还哗哗的，别人就来劝你，啊～你要看开，向前看，要放下，你死不死）。</p>
<p>扯远了，回到我青春期的恋爱，做一个总结。<a href="https://muyuuuu.github.io/2019/06/08/DuanWu/">更多回忆在这里</a>。</p>
<p>我高中的情况是这样的，认识一个女孩。当时和那个女孩关联了QQ号，全班也知道我们的关系。她和我交往的时候一直和她的两个前男友有联系，可能高中放假不容易，谁还没个前任，想想就算了。但总有几个奇葩，在凌晨四点或者深夜给她发消息说：“心里难受，不舒服，看到了回一下”（同班同学干的，原话，我居然和这种人是同学）；甚至体育课认识的一个男生晚上也发消息：“心情烦闷，在么，聊一聊”；还有绿茶男一直给她传纸条：“那个男生真差劲啊，都不让你和别的男生接近，你也太不容易了。不像我，我就不会这样，我会更大度。”之类的，没错，同班同学干这种事，男生这样真的恶心。后来我才知道这种行为叫绿茶，起源于<a href="https://zh.wikipedia.org/wiki/%E7%BB%BF%E8%8C%B6%E5%A9%8A" target="_blank" rel="noopener">绿茶婊</a>。重点是：她来者不拒。我当时没截图聊天信息，高中也没手机，不能给纸条拍照。不然我真的拍下来，让别人看看这种同学的品行。</p>
<p>我确实没法接受，感觉分担给我的精力就少了，你也可以理解为我心胸狭窄，我绝对接受；她感觉没啥，每次都因为这个事情，她要么哄我要么大吵一架。因为每次都是我主动挑事的，所以同学一直骂我，动不动就说我两句之类的，说我多愁善感、说我管的太宽、说我事真多之类，我寻思我们经历了啥你也不知道啊，道德制高点就那么舒服？毕业后就赶紧删好友了，她们习惯站在道德制高点了，<strong>离她们远一点</strong>。</p>
<p>后来同学聊天，那群骂我的人也不见得多高尚，路走的有多好。大学也没见她们多努力，可能忙着在道德制高点批评人呢吧，混的还不如我，瞬间就开心了，<del>我好黑暗</del>。</p>
<p>虽然当初分开始难受，发了很多难受的说说，然后果不其然我又他娘的挨骂了，说我作之类的。以至于后来我说XXX事物不好要挨骂；哪怕我说两天不去图书馆学习了，要去图书馆学习也要挨骂。可能在那些人眼里，他们做不到的事情，理所当然的认为我也做不到。果然是站在道德制高点的人，看法和结论都以自我和身边两三个人为中心。</p>
<p>不过早点分开也好，三观不同，也不是一个世界，省得在一起相互折磨。后来是那个女孩和那个绿茶男在一起了，想想就开心。男的不靠谱，女的也不靠谱，双方在长相、身高、学历、性格、品行等方面都比较对等，甚至那俩都像个街头上混社会的，物以类聚人以群分吧。</p>
<p>每一个选择都会留下遗憾，所以不必后悔。好在我解脱了，大学每天忙自己的事情，可开心了。能从一个电影扯上这么多，不愧是我。</p>
<h1 id="超美海报"><a href="#超美海报" class="headerlink" title="超美海报"></a>超美海报</h1><p><img data-src="/2020/08/26/flipped/2.jpg" alt></p>
]]></content>
      <tags>
        <tag>Movie</tag>
      </tags>
  </entry>
  <entry>
    <title>走着走着，花就开了</title>
    <url>/2019/03/15/flower/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p align="center">--------------------------------------------原谅我的直男拍照--------------------------------------------</p>

<p><img data-src="/2019/03/15/flower/1.jpg" width="80%" height="50%"></p>
<a id="more"></a>
<div class="note info"><p>背景是学校在给树剪枝，就随手捡了个树枝回来，捡回来的时候的确还是个光秃秃的树枝。</p></div>

<div class="note info"><p>回来就随手把它扔在了水瓶里，今日在看，那些花儿已然傲然开放。</p></div>

<div class="note info"><p>这大概就是传说中的无心插柳柳成荫吧。</p></div>

<div class="note success"><p>可是，花有重开日，人无再少年呢。</p></div>

<div class="note default"><p>青春易逝，韶光难回，恰同学少年，还当继续前行。</p></div>

<hr>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器与生成器</title>
    <url>/2020/07/23/generator-and-iterator/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大约第三次看迭代器和生成器了，之前一直看得云里雾里，今天还是来彻底了断下。</p>
<a id="more"></a>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>先区分下容易搞混的一些概念：</p>
<ul>
<li>迭代器是一种对象，如<code>iter(f)</code>后，可以<code>next()</code>来读取下一个元素；</li>
<li>迭代是一种操作，如<code>for</code>循环访问列表元素；操作存储数据的容器，获取其中的元素，可以理解为迭代；</li>
<li>可迭代是对象的一种特性，如字典、列表和字符串等；</li>
<li>迭代器协议指的是类需要包含一个特殊方法，该方法能返回一个能够逐个访问容器内所有元素的迭代器，则该容器类实现了迭代器协议。</li>
</ul>
<p>来看一段简单的代码，一个类提供了<code>__iter()__</code>方法，该方法能返回一个能逐步访问类中所有元素的迭代器，实现了迭代器协议。（单独的列表不是迭代器，只是列表支持迭代器协议罢了）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># __iter__ 方法支持迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._value = value</span><br><span class="line">        self._children = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Node(&#123;!r&#125;)'</span>.format(self._value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self._children.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将迭代请求传递给内部的 _children 属性。</span></span><br><span class="line">    <span class="comment"># 调用 _childrem.__iter__() 方法来返回对应的迭代器对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._children)</span><br><span class="line"></span><br><span class="line">root = Node(<span class="number">0</span>)</span><br><span class="line">child1 = Node(<span class="number">1</span>)</span><br><span class="line">child2 = Node(<span class="number">2</span>)</span><br><span class="line">root.add_child(child1)</span><br><span class="line">root.add_child(child2)</span><br><span class="line"><span class="comment"># Outputs Node(1), Node(2)</span></span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> root:</span><br><span class="line">    print(ch)</span><br></pre></td></tr></table></figure>
<p>如果一个类想被用于<code>for ... in</code>循环，类似<code>list</code>或<code>tuple</code>那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象。然后<code>Python</code>的<code>for</code>循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。</p>
<p>我们以斐波那契数列为例，写一个<code>Fib</code>类，可以作用于<code>for</code>循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始化两个计数器a，b</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例本身就是迭代对象，故返回自己</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 计算下一个值</span></span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="comment"># 退出循环的条件 </span></span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>: </span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="comment"># 返回下一个值</span></span><br><span class="line">        <span class="keyword">return</span> self.a </span><br><span class="line"></span><br><span class="line">a = Fib()</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> a:</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>
<p>此外，我们还可以反向迭代，但要求对象的大小预先可以确定或者对象实现了 <code>__reversed__()</code> 的特殊方法（<code>__reversed__()</code>方法的实现见下文的生成器）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对象的大小可预先确定或者对象实现了 __reversed__() 的特殊方法</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> reversed(a):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p>如果两者都不符合，那必须先将对象转换为一个列表。要注意的是如果可迭代对象元素很多的话，将其预先转换为一个列表要消耗大量的内存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'somefile'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> reversed(list(f)):</span><br><span class="line">    print(line, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><ul>
<li>生成器函数是一种特殊的函数；</li>
<li>如果一个函数包含 <code>yield</code> 表达式，那么它是一个生成器函数；调用它会返回一个特殊的迭代器，称为生成器。</li>
<li>即将普通函数的<code>return</code>换成了<code>yield</code>，仅在访问时有返回值，节省空间。</li>
</ul>
<p>但与普通函数不同的是，生成器函数返回的生成器只能用于迭代操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    print(<span class="string">'Done'</span>)</span><br><span class="line"></span><br><span class="line">a = countdown(<span class="number">6</span>)</span><br><span class="line"><span class="comment"># 一旦生成器函数返回退出，迭代终止</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>现在假设，我们建立一个函数，这个函数会返回一个巨大的列表，而我们需要逐个访问。那么，如果函数生产列表中的每一个元素都需要耗费非常多的时间，或者生成所有元素需要等待很长时间，且，操作列表时会浪费巨大的内存。但使用 <code>yield</code> 把函数变成一个生成器函数，每次只产生一个元素，就能节省很多时间和空间的开销了。</p>
<p>通过<code>yield</code>关键字实现一个支持反向迭代的类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start)</span>:</span></span><br><span class="line">        self.start = start</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Forward iterator</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = self.start</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Reverse iterator</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n &lt;= self.start:</span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向迭代</span></span><br><span class="line"><span class="keyword">for</span> rr <span class="keyword">in</span> reversed(Countdown(<span class="number">3</span>)):</span><br><span class="line">    print(rr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正向迭代</span></span><br><span class="line"><span class="keyword">for</span> rr <span class="keyword">in</span> Countdown(<span class="number">3</span>):</span><br><span class="line">    print(rr)</span><br></pre></td></tr></table></figure>
<p>如果说，需要在生成器函数中访问其他属性时，可以将它实现为一个类，将生成器函数放到<code>__iter()__</code>方法中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器暴露外部状态给用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linehistory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text, histlen=<span class="number">3</span>)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.history = deque(maxlen=histlen)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 索引从 1 开始</span></span><br><span class="line">        <span class="keyword">for</span> lineno, line <span class="keyword">in</span> enumerate(self.text, <span class="number">1</span>):</span><br><span class="line">            self.history.append((lineno, line))</span><br><span class="line">            <span class="keyword">yield</span> line</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.history.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'demo.py'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 创建一个实例对象，可以访问内部属性值</span></span><br><span class="line">    lines = linehistory(f)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="comment"># 创建实例对象后，于可以访问内部属性值， 比如 history 属性或者是 clear() 方法。</span></span><br><span class="line">        <span class="keyword">for</span> lineno, hline <span class="keyword">in</span> lines.history:</span><br><span class="line">            print(<span class="string">'&#123;&#125;:&#123;&#125;'</span>.format(lineno, hline), end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在迭代操作时不使用for循环语句，那么你得先调用 iter() 函数</span></span><br><span class="line">f = open(<span class="string">'demo.py'</span>)</span><br><span class="line">lines = linehistory(f)</span><br><span class="line">t = iter(lines)</span><br><span class="line">print(next(t))</span><br></pre></td></tr></table></figure>
<p>常见的还有<code>yield from</code>关键字，关键字后的参数是一个可迭代对象，可以简单理解为如下的替换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">from</span> x</span><br><span class="line"><span class="comment"># 等价</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">    <span class="comment"># process</span></span><br></pre></td></tr></table></figure>
<h1 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h1><p>迭代器的访问是一个重点，但偏向程序设计的技巧，与本文的主要内容有所偏离，所以不过多概述。但其中的一些方法如<code>zip, enumerate</code>等是真的常用，当面临复杂的迭代问题时，如：</p>
<ul>
<li>想快速的迭代不同类型的容器；</li>
<li>迭代器的切片访问；</li>
<li>想输出所有迭代结果的排列组合；</li>
<li>将一个嵌套的序列展开为单个序列，如<code>[1, 2, [3, 4, [5, 6], 7], 8]</code>到<code>[1, 2, 3, 4, 5, 6, 7, 8]</code>；</li>
<li>想同时迭代多个容器。</li>
</ul>
<p>可以参考<code>python</code>的<code>itertools</code>库，真的实用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>站在巨人的肩膀上，我们能更好的前行。</p>
<ol>
<li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/chapters/p04_iterators_and_generators.html" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/chapters/p04_iterators_and_generators.html</a></li>
<li><a href="https://liam.page/2017/06/30/understanding-yield-in-python/" target="_blank" rel="noopener">https://liam.page/2017/06/30/understanding-yield-in-python/</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017590712115904" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017590712115904</a></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Git与Github的使用</title>
    <url>/2019/11/16/git-use/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>突如其来的兴趣，想把自己写的一些看着不错的代码放到github上，供大家一起交流与分享。毕竟自己之前只会<code>git clone</code>。</p>
<p>今日更新的原因是：居然发现专业的好多人不会使用<code>Git</code>和<code>Github</code>，尽管他们大一就开始写代码，写的很好，但不会使用<code>Git</code>就很离谱，我还在怀疑他们的项目是如何交流and编写的，遂整理常用的<code>Git</code>和<code>Github</code>方法到此。</p>
<p>要声明的是：本文的目标并非对<code>Git</code>和<code>Github</code>一无所知的小白，纯小白看了本文更加会一头雾水。而是有一定的<code>Git</code>和<code>Github</code>使用经验。适用于：说是小白吧，但有点意思，说是精通吧，但又差点意思。</p>
<a id="more"></a>
<p>前提是自己已经安装了<code>Git</code>并测试可以使用，安装方法略。</p>
<h1 id="日前"><a href="#日前" class="headerlink" title="日前"></a>日前</h1><h2 id="第一次创建"><a href="#第一次创建" class="headerlink" title="第一次创建"></a>第一次创建</h2><p>首先需要在<code>Github</code>上完成的工作，新建一个仓库，不建议勾选初始化<code>README.md</code>文件和创建<code>LICENSE</code>等选项，因为这会和本地的仓库造成冲突。假设我新建的仓库名称为：A Beautiful PyQt5 Interface.</p>
<p>首先: 创建某个文件夹，里面放上想要提交上去的文件. <code>git init</code> 完成初始化.<br>其次: <code>git add .</code> 添加所有文件，这个时候可以随意的插入readme文件<br>然后: <code>git commit -m &quot;code by LanLing&quot;</code> 添加代码的描述信息<br>之后: <code>git remote add origin https://github.com/muyuuuu/A-Beautiful-PyQt5-Interface.git</code> 不要忘记 <code>.git</code><br>最后: <code>git push -u origin master</code> 完成提交</p>
<h2 id="以后的更新"><a href="#以后的更新" class="headerlink" title="以后的更新"></a>以后的更新</h2><p>cd 到对应的文件夹</p>
<p><code>git add .</code><br><code>git commit -m &#39;include some information&#39;</code> 增加修改信息，一定要修改，否则会失效<br><code>git push</code> 即可完成修改</p>
<h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p><a href="https://github.com/muyuuuu/A-Beautiful-PyQt5-Interface" target="_blank" rel="noopener">https://github.com/muyuuuu/A-Beautiful-PyQt5-Interface</a></p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>可能这只是暂时的用法，至少目前我还分不清branch还有master的概念，也没有和其他人一起开发大项目的经验，日后可能会作出改变，甚至是一些观念，多走几步看看。就像昨天我还不会用git，但是今天来看，上述的命令我已经记住和熟练使用了。谁知道呢。</p>
<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>今日，仔细研读了一番<code>Git</code>的使用方法(<del>人傻就要多学习</del>)，又有了新的收获，遂整理如下(指令的速查手册)。当然，多动手实践才是硬道理。<strong>纸上得来终觉浅，绝知此事要躬行。</strong></p>
<p><code>Github</code>是<code>Git</code>托管的一种网页端的服务，<code>Git</code>是一种版本管理神器，即使不用<code>Github</code>，也可以考虑使用<code>Git</code>管理自己的代码和文件。管理的好处？太多了：</p>
<ul>
<li>是不是遇到过文件忽然丢失，想恢复但恢复不了？<code>Git</code>管理起来就没这个烦恼；</li>
<li>毫不容易实现了一个功能，老师却要一个月前的代码，好不容易删除改好了老师又要一个月后的代码。<code>Git</code>就可以自由穿梭在任何时间点，复原任何时间段的文件。</li>
</ul>
<h1 id="Git-常用指令"><a href="#Git-常用指令" class="headerlink" title="Git 常用指令"></a>Git 常用指令</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li><code>git init</code> 初始化本地仓库，生成<code>.git</code>文件，存储管理当前目录的数据。</li>
<li><code>git status</code> 查看仓库状态，没有可提交文件或未追踪<code>(untracked)</code>文件。</li>
<li><code>git add</code> 可加文件名或<code>git add .</code> 添加全部文件到暂存区，此时不再显示未追踪文件。</li>
<li><code>git commit -m &quot;comment&quot;</code> 提交修改，而后显示没有可提交文件的状态。或<code>git commit</code>，打开编辑器(操作类似<code>vim</code>)修改添加内容，<code>#</code>为注释，所以内容不要写在<code>#</code> 后面。会生成<code>commit</code>的<code>hashvalue</code>。</li>
<li><code>git log</code> 查看提交日志，包括提交时间，提交作者，联系方式和介绍。也可以<code>git log --pretty=short</code>显示简单信息。也可<code>git log filename</code> 也可以查看指定文件的日志。<code>git log -p</code> 查看本次提交与上次提交的区别，<code>git log -p filename</code> 可查看对应文件的前后区别。</li>
<li><code>git diff</code> 查看当前目录和最新提交之间的差别。在<code>git add .</code>后，<code>git diff</code>显示当前目录和暂存区(<code>.git</code>)的差别，但没有差别。所以此时查看与上一次提交的区别时：<code>git diff HEAD</code>，这里的<code>HEAD</code>是指向当前分支的最新一次提交的指针。</li>
</ul>
<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><p>用于完成多人开发的并行作业。分支应该集中实现单一主题和功能，除此之外不进行任何作业。即使创建的分支在开发的过程中遇到了BUG，也应该创建新的分支修正。</p>
<ul>
<li><code>git branch</code>显示分支列表，<code>*</code>后面为此时所处的分支。默认为<code>master</code>主干分支，没有开发到一半的代码，可随时让人查看。</li>
<li><code>git branch test</code> 创建<code>test</code>分支。</li>
<li><code>git checkout test</code> 切换到<code>test</code>分支，在<code>test</code>分支中修改的内容不会显示在<code>master</code>分支中。</li>
<li><code>git merge</code>合并分支。假设子分支的功能开发完毕，切换到主分支，<code>git merge --no-ff branchname</code>创建合并提交，而后输入提交的信息即可。</li>
<li><code>git log --graph</code> 以图表的形式查看分支的合并情况。</li>
<li>当有俩个分支时，主分支有<code>test.md</code>文件，子分支也有<code>test.md</code>文件，这两个文件不同。虽然操作不影响，但在合并分支时会发生冲突，需要手动处理冲突文件然后才能合并。</li>
</ul>
<h2 id="更改提交"><a href="#更改提交" class="headerlink" title="更改提交"></a>更改提交</h2><ul>
<li><code>git reset</code> 回溯历史版本。借助分散仓库(每个人都可以<code>fork</code>，修改自己的仓库不会影响他人的仓库)的优势，可以不影响其他仓库的前提下对历史版本进行操作。根据累计提交的历史记录，可根据目标时间点的哈希值回溯到指定状态，<code>git reset --hard hashvalue</code></li>
<li><code>git reflog</code>推进历史。即发现回溯过头，可以用<code>git reflog</code>查看操作日志，找出历史时间点的哈希值，<code>git reset --hard hashvalue</code>即可。就像给定一个时间机器的各个时间点，可自由穿梭。这些时间点来源于每次的<code>git commit</code>。</li>
<li><code>git commit --amend</code>，修改上次提交的内容。如第一次<code>commit</code>时<code>commen</code>填写错误，执行本命令即可。</li>
<li><code>git rebase -i</code> 压缩历史，第一次<code>git commit</code>提交功能代码，第二次<code>git commit</code>修改了其中文件的错别字等小错误。将修改的提交和上次提交的两次提交合并为一次提交，此时<code>git rebase -i HEAD~2</code>会选定当前分支最新提交和上次提交，删除第二次<code>commit</code>的哈希值，保存并退出。此时第二次提交从历史中抹去，第一次提交的哈希值也会更改。（然后<code>git push -f origin master</code>，<code>origin</code>代表远程仓库标识名，<code>master</code>表示要推送的分支）</li>
</ul>
<h2 id="远程仓库使用"><a href="#远程仓库使用" class="headerlink" title="远程仓库使用"></a>远程仓库使用</h2><p><code>Github</code>是<code>Git</code>托管的一种服务，将本地的<code>Git</code>仓库在远程展示。</p>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><ol>
<li>首先在<code>Github</code>上创建仓库；</li>
<li><code>git remote add origin ....</code>设置为本地仓库的远程仓库，并将远程仓库的名称设置为<code>origin</code>；</li>
<li><code>git push -u origin master</code>，将当前分支的内容推送给远程仓库<code>origin</code>的<code>master</code>分支，<code>-u</code>参数会使在将来<code>git pull</code>时，本地仓库的当前分支可以直接获取<code>origin</code>的<code>master</code>分支内容，不必费力的设置参数。</li>
<li><code>git push -u origin branch-test</code>，推送<code>branch-test</code>分支。</li>
</ol>
<h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><ol>
<li><code>git clone</code> 获取远程仓库，默认处于<code>master</code>分支，将<code>origin</code>设置为远程仓库的标志符；</li>
<li><code>git pull</code> 克隆后可以拉取远程仓库<code>master</code>分支的最新内容；</li>
<li><code>git branch -a</code>查看本地仓库和远程仓库的所有分支；</li>
<li><code>git checkout -b branch-test origin/branch-test</code> 获取远程仓库的子分支，<code>-b</code>为创建本地分支的名称，<code>origin/branch-test</code>为分支来源。</li>
<li>用户A切换到<code>branch-test</code>分支完成工作后，<code>git push</code>即可推送子分支。</li>
<li>用户B可以<code>git pull origin branch-test</code>获取对应分支在远程仓库的最新内容，这样用户A,B就完成了协同开发。如果两人修改同一部分的源代码，为减少冲突的发生，应该频繁的<code>push</code>和<code>pull</code>。</li>
</ol>
<h1 id="Github-使用"><a href="#Github-使用" class="headerlink" title="Github 使用"></a>Github 使用</h1><ul>
<li>搜索窗口：输入代码片段或用户，就能搜索到与之相关的信息(也可在<code>Github</code>上整体搜寻)。</li>
<li><code>Gist</code>：一些没必要录入仓库的小代码，展示小的<code>Demo</code>。</li>
<li><code>Stars</code>：类似点赞。</li>
</ul>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>首先打开任意的仓库。</p>
<h3 id="上侧"><a href="#上侧" class="headerlink" title="上侧"></a>上侧</h3><p><img data-src="/2019/11/16/git-use/1.png" alt></p>
<ul>
<li><code>star</code>：仓库的点赞人数；</li>
<li><code>watch</code>：该仓库的相关信息会在<code>All activity</code>中显示；</li>
<li><code>Fork</code>：<code>Pull request</code>相关，之后叙述。</li>
<li><code>Code</code>：展示代码。</li>
<li><code>Issue</code>：用于<code>bug</code>报告、功能添加、方向讨论等，<code>pull request</code>时也会创建<code>Issue</code>。</li>
<li><code>Pull request</code>：<code>Github</code>重要功能，代码修改和功能讨论都可以在这里进行。</li>
<li><code>wiki</code>：创建页面，通过<code>markdown</code>语法编写软件的使用文档等。</li>
<li><code>insights</code>：透视，查看仓库的开发程度和活跃程度等。</li>
<li><code>settings</code>：设置仓库，私有共有、删除仓库等。</li>
</ul>
<h3 id="下侧"><a href="#下侧" class="headerlink" title="下侧"></a>下侧</h3><p><img data-src="/2019/11/16/git-use/2.png" alt></p>
<ul>
<li><code>commits</code>：提交次数和提交历史均可查看。</li>
<li><code>branches</code>：查看仓库的分支列表。</li>
<li><code>releases</code>：对归档的文档添加标签，也可提供可用的软件。</li>
<li><code>contributors</code>：对仓库进行提交的程序员的名单，<code>pull request</code>且被采纳。</li>
<li><code>create new file</code>：网页端创建文件和添加。</li>
<li><code>clone or download</code>：克隆或者复制，克隆时建议使用<code>SSH</code>协议，此时克隆到本地的仓库会和远程仓库的<code>master</code>分支内容保持一致。</li>
</ul>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>关于<code>Github</code>仓库内相关文件的操作，打开仓库中的任意一个文件即可。</p>
<p><img data-src="/2019/11/16/git-use/3.png" alt></p>
<ul>
<li><code>raw</code>：直接在浏览器显示内容，对应的<code>URL</code>可通过<code>HTTPS</code>协议下载。</li>
<li><code>Blame</code>：能够按行显示提交的信息。</li>
<li><code>History</code>：查看文件的历史提交信息。</li>
<li>后面的三个按钮，电脑是表示在客户端打开的意思，<code>edit</code>是编辑的文件的意思，最后一个<code>delete</code>是删除当前文件的意思。</li>
<li>在仓库页面按下<code>t</code>键，输入想要的文件名，可快速查找。</li>
<li>在文件的<code>URL</code>后添加<code>#L10~L15</code>的标志，会高亮代码的第10到第15行，方便交流代码。</li>
</ul>
<h3 id="查看区别"><a href="#查看区别" class="headerlink" title="查看区别"></a>查看区别</h3><p>如果差别过大则不会列出所有区别，某种意义上<code>Github</code>是一款优秀的源代码查看器。</p>
<ul>
<li>查看两个分支的区别：将分支名加入对应的<code>URL</code>里即可，<code>/compare/4-stable...3-stable</code>；</li>
<li>查看与几天前的区别：<code>/compare/master@{7.day.ago}...master</code>，<code>day, year, month, week</code>都可以；</li>
<li>查看与指定日期的区别：<code>/compare/master@{2013-01-01}...master</code>。</li>
</ul>
<h2 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h2><p>跟踪<code>BUG</code>和讨论的专区。用于：</p>
<ul>
<li>发现软件的<code>BUG</code>并报告；</li>
<li>有事情想找软件的作者进行询问，如：如何实现XXX功能；</li>
<li><strong>事先列出今后准备开发的任务</strong>；</li>
</ul>
<p>其编辑为常用的<code>MarkDown</code>语法，上传图片和文件直接拖入即可，在管理软件开发也有独特的应用：</p>
<ul>
<li>对仓库有读写权限的可以给每一个<code>Issue</code>添加标签，便于管理；</li>
<li>添加里程碑(<code>milestones</code>)，距离下一个版本还有几个<code>Issue</code>待解决。</li>
</ul>
<p>而在有些专门的仓库中，在提交<code>Issue</code>时会有专门的模板，此时在仓库的根目录下添加<code>CONTRIBUTING.md</code>即可，用于规范问题的提问方法。也支持<code>Tarklist</code>等独有语法生成复选列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 任务进度</span><br><span class="line">- [ ] 完成前端</span><br><span class="line">- [x] 完成数据库</span><br><span class="line">- [ ] 发布</span><br></pre></td></tr></table></figure>
<ul>
<li>且可以选中一句话，然后按击<code>r</code>即可完成引用。</li>
<li>输入<code>:</code>号，还可以输入表情。</li>
</ul>
<h3 id="通过commit操作Issue"><a href="#通过commit操作Issue" class="headerlink" title="通过commit操作Issue"></a>通过commit操作Issue</h3><p><img data-src="/2019/11/16/git-use/4.png" alt></p>
<p>只需要在<code>commit</code>按照特定格式描述信息，就可以使用<code>bug</code>追踪系统对<code>Issue</code>进行操作。如，首先手动<code>new</code>一个<code>issue</code>，然后记住他的编号，这里假设编号为<code>12</code>。在<code>12</code>这个<code>issue</code>里，输入的大致内容为完成数据的存储功能。那么在编写完数据存储功能后，有两种操作<code>issue</code>的用法：</p>
<ul>
<li><code>git commit -m &quot;add subfuntion: select file type when save data #12&quot;</code>，这样在评论中添加<code>issue</code>的编号后，会在<code>issue</code>中添加对应的描述。</li>
<li><code>git commit - m &quot;fix #12&quot;</code>，会自动关闭<code>12</code>这个<code>issue</code>，这样就可以利用<code>issue</code>驱动项目的开发。</li>
</ul>
<h2 id="pull-request"><a href="#pull-request" class="headerlink" title="pull request"></a>pull request</h2><p>用户修改代码后向对方仓库发送请求接纳的功能，也是<code>Github</code>的核心功能。</p>
<ul>
<li>可以获取<code>diff</code>和<code>patch</code>格式的文件来处理<code>pull request</code>，此时在<code>URL</code>的末尾添加<code>.diff</code>和<code>.patch</code>即可。</li>
<li>在<code>URL</code>末尾添加<code>?w=1</code>可以不显示空格的差别。</li>
<li>将鼠标移动到代码左侧的<code>+</code>号，点击，可以对具体的一行代码添加注释。（查看每次的提交也可以这样）<br><img data-src="/2019/11/16/git-use/8.png" alt></li>
</ul>
<h2 id="wiki"><a href="#wiki" class="headerlink" title="wiki"></a>wiki</h2><p>使用简单语法编写文档，<code>new page</code>按钮可以创建新的标签页，也可在页面中的底部和侧部创建侧边栏。<br><img data-src="/2019/11/16/git-use/5.png" alt></p>
<h2 id="insights"><a href="#insights" class="headerlink" title="insights"></a>insights</h2><p>体现开发的活跃度。</p>
<ul>
<li><code>pulse</code>：多少人在开发，有多少<code>issue</code>，有多少<code>pull requests</code>一目了然；</li>
<li><code>contributors</code>：这个仓库的开发有多少参与者；</li>
<li><code>community</code>：社区文件，包括一个项目必有的7个部分；</li>
<li><code>traffic</code>：有多少人浏览了这个项目，有多少人<code>clone</code>了这个项目；<img data-src="/2019/11/16/git-use/6.png" alt></li>
<li><code>commits</code>：提交历史；</li>
<li><code>code frequency</code>：该仓库的代码增加量或者删除量</li>
<li><code>network</code>：以图表的形式显示包括<code>clone</code>仓库在内的所有分支的提交，看出每个人的工作。</li>
<li><code>fork</code>：有多少人<code>fork</code>了你的代码。</li>
</ul>
<h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h2><p><img data-src="/2019/11/16/git-use/7.png" alt></p>
<ul>
<li><code>settings</code>：设置仓库的默认分支。</li>
<li><code>features</code>：可以移除<code>issue</code>等选项，则这个仓库的<code>issue</code>将无法启用。</li>
<li><code>danger zone</code>：删除仓库等危险操作。</li>
<li><code>collaborators</code>：合作者，邀请他人一起开发。如果是<code>organization</code>，可以创建<code>team</code>对整个团队赋予权限。</li>
<li><code>webhooks</code>：添加钩子，让<code>github</code>仓库与其他服务集成。</li>
</ul>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><ul>
<li><code>issue</code>里面的消息不想继续接收可以点击<code>unsubscribe</code>。</li>
<li><code>notification</code>里面的消息不想继续接收可以点击扩音器那个标志。</li>
<li><code>github pages</code> 搭建博客。</li>
<li><code>github API</code>：<code>Web</code>开发者难免调用的。</li>
<li><code>github Enterprise</code>：无法将代码开源，但又想用<code>github</code>的团队可以考虑。</li>
</ul>
]]></content>
      <tags>
        <tag>Computer</tag>
      </tags>
  </entry>
  <entry>
    <title>优化梯度函数</title>
    <url>/2019/02/20/gradient-function/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>优化器这种东西之前从来不去接触，以为是很高深莫测的东西。直到今天自己去亲自探测才发现，恩，其实也不是不能接受。从统计学中的加权移动平均出发列举经受时间考验的优化器，和时间序列有异曲同工之妙，探求一下优化器的神奇之处。</p>
<p><img data-src="/2019/02/20/gradient-function/opt1.gif" alt></p>
<a id="more"></a>
<p>本文收录内容：</p>
<ul>
<li>加权移动平均</li>
<li>梯度消失与梯度爆炸</li>
<li><strong>Adam，SGD，RMSprop，momentum，</strong>学习率衰减</li>
<li>简单的<strong>Tensorflow</strong>实现</li>
</ul>
<p>这可能是我目前接触到的，变通和利用已有的知识进行问题转换较为成功的案例。对了，关于一些专业名词，比如<strong>eproch，batch</strong>，学习率等，可以来这里查阅：<a href="https://developers.google.cn/machine-learning/crash-course/glossary?hl=zh-CN#logit" target="_blank" rel="noopener">机器学习查阅手册</a></p>
<hr>
<h2 id="学习率衰减"><a href="#学习率衰减" class="headerlink" title="学习率衰减"></a>学习率衰减</h2><p>普及一下随机梯度下降<strong>SGD</strong>就是，没使用一个样本就对网络权重更新一次，因为一个样本过于片面，所以导致成本函数在最小值附近徘徊但是很难收敛。</p>
<p>为什么难以收敛呢，这是学习率$\alpha$的原因，因为刚开始和最后结束$\alpha$是一直不变的，后期只要以$\alpha$学习了噪音数据，那么终究会导致函数值不够收敛，总是震荡。</p>
<p>所以，可以通过某种方式，规定在后期的$\alpha$会越来越小，也就是在后期能学习到的经验逐渐减少，强迫网络收敛。实现方式多种多样，举个栗子：</p>
<script type="math/tex; mode=display">\alpha=\frac{\alpha_0}{1+\mathrm{DecaryRate}\times \mathrm{eproch}}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.compile(optimizer=tf.train.MomentumOptimizer(</span><br><span class="line">                            learning_rate=<span class="number">0.01</span>,</span><br><span class="line">                            decay=<span class="number">0.9</span></span><br><span class="line">                            use_locking=<span class="literal">False</span>,</span><br><span class="line">                            name=<span class="string">'Momentum'</span>,</span><br><span class="line">                            use_nesterov=<span class="literal">False</span>),</span><br><span class="line">              loss=<span class="string">'sparse_categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure>
<p>实际上，在多位特征输入的情况下，很慢出现局部最优点的情况，出现局部最优就是函数为凸函数，而假设有<strong>100</strong>个特征(算比较少的了)，每个特征同时出现局部最优，此处出现局部最优解的概率为$2^{-100}$。</p>
<p>所以，更需要在意的是本文开头动画中马鞍面的处理。这个时候就需要一些强大的梯度函数来处理复杂情况了。</p>
<h2 id="加权移动平均"><a href="#加权移动平均" class="headerlink" title="加权移动平均"></a>加权移动平均</h2><p>给出加权移动平均的公式：</p>
<script type="math/tex; mode=display">v_n=\beta V_{n-1}+(1-\beta)x_n,v_0=0</script><p>$x_n$是第$n$个数值，$v_n$是第$n$个的平均值，$\beta$是对前面数值的学习情况，因为设置初始值为0，前期的函数数值会偏低，不过这点误差可以接受。来看下图，首先产生一堆随机数，然后用不同的$\beta$去求随机数的平均值。</p>
<p><img data-src="/2019/02/20/gradient-function/1.png" alt></p>
<p>我们发现，当$\beta$过大的时候(0.98)，学习的趋势呈现出了随机性，而$\beta$太小时(0.5)，学习的趋势呈现出了滞后性，也就是对前面的信息学的慢，反应也慢。选择一个合适的$\beta$(0.9)，就能很好的描述出数据的平均走势。而接下来的优化器，也很大程度借鉴了这个观念。</p>
<h3 id="python实现："><a href="#python实现：" class="headerlink" title="python实现："></a>python实现：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">date = <span class="number">365</span></span><br><span class="line">x = np.linspace(<span class="number">-1</span>, <span class="number">1</span>, date)</span><br><span class="line">x = x.reshape(date, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 噪音数据</span></span><br><span class="line">noise = <span class="number">0.1</span> * np.random.randn(date)</span><br><span class="line">noise = noise.reshape(date, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 产生随机函数</span></span><br><span class="line">y = - x * x + noise + <span class="number">1</span></span><br><span class="line"><span class="comment"># 加权移动平均函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight__move_average</span><span class="params">(beta, date, y_value)</span>:</span></span><br><span class="line"></span><br><span class="line">    v = [<span class="number">0</span>] * date</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">1</span>, date):</span><br><span class="line">        v[i] = beta * v[i - <span class="number">1</span>] + (<span class="number">1</span> - beta) * y_value[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">y_beta1 = weight__move_average(<span class="number">0.90</span>, <span class="number">365</span>, y)</span><br><span class="line">y_beta2 = weight__move_average(<span class="number">0.98</span>, <span class="number">365</span>, y)</span><br><span class="line">y_beta3 = weight__move_average(<span class="number">0.50</span>, <span class="number">365</span>, y)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot(x, y, label=<span class="string">'data'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'upper left'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.plot(x, y_beta1, label = <span class="string">'0.9'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'upper left'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">plt.plot(x, y_beta2, label = <span class="string">'0.98'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'upper left'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">plt.plot(x, y_beta3, label = <span class="string">'0.5'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'upper left'</span>)</span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">'test.png'</span>, dpi = <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Momentum动量梯度下降"><a href="#Momentum动量梯度下降" class="headerlink" title="Momentum动量梯度下降"></a>Momentum动量梯度下降</h2><p>实际上，在使用<strong>batch</strong>输入时，因为存在噪音所以每时刻的梯度可能是一个乱七八糟的向量，就和上图的随机数一样。</p>
<p>但是更希望不学习乱七八糟的随机数，而是减少乱七八糟的震荡，描绘大体的趋势即可，这个时候，就可以借鉴上文的移动加权平均函数，对梯度也做这样的处理。</p>
<script type="math/tex; mode=display">V_w=\beta V_{w-1}+(1-\beta)w,V_0=0</script><script type="math/tex; mode=display">w=w-\alpha V_w</script><h3 id="Tensorflow实现"><a href="#Tensorflow实现" class="headerlink" title="Tensorflow实现"></a>Tensorflow实现</h3><p>实际上，tensorflow里面并没有上面的$1-\beta$这一项，tensorflow中的源码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accumulation = momentum * accumulation + gradient</span><br><span class="line">variable -= learning_rate * accumulation</span><br></pre></td></tr></table></figure></p>
<p>创建动量梯度下降优化器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">model = keras.Sequential([</span><br><span class="line">    keras.layers.Flatten(input_shape=(<span class="number">28</span>, <span class="number">28</span>)),</span><br><span class="line">    keras.layers.Dense(<span class="number">128</span>, activation=tf.nn.relu),</span><br><span class="line">    keras.layers.Dense(<span class="number">10</span>, activation=tf.nn.softmax)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">beta = <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line">model.compile(optimizer=tf.train.MomentumOptimizer(</span><br><span class="line">                            learning_rate=<span class="number">0.01</span>,</span><br><span class="line">                            momentum=beta,</span><br><span class="line">                            use_locking=<span class="literal">False</span>,</span><br><span class="line">                            name=<span class="string">'Momentum'</span>,</span><br><span class="line">                            use_nesterov=<span class="literal">False</span>),</span><br><span class="line">              loss=<span class="string">'sparse_categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h2><p>为了下文的简便，这里先将上面的$v_w$暂时更换为$s_w$。同上，<strong>RMSprop</strong>只是在<strong>momentum</strong>的基础上改进了一点点：</p>
<script type="math/tex; mode=display">s_w=\beta_2S_{w-1}+(1-\beta_2)w^2</script><script type="math/tex; mode=display">w=w-\alpha\frac{w}{\sqrt{s_w}}</script><p>在上面的两个式子中，我们发现当$w$很大时，$s_w$也会很大，当$w$很小时，$s_w$也会很小，这就保持了在$w$更新时较为平稳，减缓不恰当的摆动。</p>
<h3 id="Tensorflow简单实现"><a href="#Tensorflow简单实现" class="headerlink" title="Tensorflow简单实现"></a>Tensorflow简单实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">beta2 = <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line">model.compile(optimizer=tf.train.RMSPropOptimizer(</span><br><span class="line">                            learning_rate=<span class="number">0.1</span>,</span><br><span class="line">                            momentum=beta2,</span><br><span class="line">                            epsilon=<span class="number">1e-10</span>,),</span><br><span class="line">              loss=<span class="string">'sparse_categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Adam优化器"><a href="#Adam优化器" class="headerlink" title="Adam优化器"></a>Adam优化器</h2><p>其实，把<strong>momentum</strong>和<strong>RMSprop</strong>整合一下爱，就得到了Adam优化器：</p>
<p>首先初始化：</p>
<script type="math/tex; mode=display">v_w=0,s_w=0,v_b=0,s_b=0</script><p>然后加权移动平均：</p>
<script type="math/tex; mode=display">v_w=\beta_1v_{dw-1}+(1-\beta_1)w \qquad v_b=\beta_1v_{b-1}+(1-\beta_1)b</script><script type="math/tex; mode=display">s_w=\beta_2s_{dw-1}+(1-\beta_2)w^2 \qquad s_b=\beta_2s_{b-1}+(1-\beta_2)b^2</script><p>根据学习率对参数进行刷新：</p>
<script type="math/tex; mode=display">w=w-\alpha \frac{v_w}{\sqrt{s_w}} \qquad b=b-\alpha \frac{v_b}{\sqrt{s_b}}</script><h3 id="简单的Tensorflow实现"><a href="#简单的Tensorflow实现" class="headerlink" title="简单的Tensorflow实现"></a>简单的Tensorflow实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.compile(optimizer=tf.train.AdamOptimizer(),</span><br><span class="line">              loss=<span class="string">'sparse_categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过这几天的整理，生动形象的诠释了什么叫先看懂数学原理再来抄代码，不然代码的参数，含义都看不懂，<strong>Ctrl c</strong>和<strong>Ctrl v</strong>来的代码没有灵魂，无非是某些培训机构让你快速入门的盈利工具。</p>
<p>实在是不能再折腾这些乱七八糟的了，得赶紧看高数了，不然考不上研究生了刺激。</p>
<p>其实还有某些网络的调控方案，梯度消失梯度爆炸的问题，简单描述一下吧。</p>
<p>在调教网络的时候最好不要先调一些玄学的参数，而是先看看训练误差，测试误差是否达标，训练误差高就换网络提强特，测试误差高就对网络正则化。如果训练集和测试集来源不同，最好还是取测试集一部分并入训练集，毕竟是在训练集上训练网络的。而且还有观察判别错误的数据，分析原因。至少要知道哪里出问题了，然后对症下药。</p>
<p>梯度消失和梯度爆炸，就是在网络长时间的传播过程中出现的参数巨大或参数无限接近于零的情况，这个时候参数会出现巨大的变动或者几乎不变的情况。如何避免呢？一个是有效的初始权重，使得权重在1附近，毕竟$1\times 1=1$，或者，对权重的正则化，对权重的剪枝将梯度值限制在某范围内，使用<strong>relu</strong>激活函数，毕竟这个函数的激活范围导数恒等于1。</p>
<hr>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>图问题中的搜索算法</title>
    <url>/2020/02/26/graph-algorithm-search/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在面临一个搜索问题时，如找出一个矩阵中不一样的元素，可能大多人和我想的一样：几层for循环，变量自增继续访问下一个。看着简单，但是，当问题逐渐复杂，如搜索出矩阵中的元素，要求是这个元素和周围的元素不一样，要求相差超过某个阈值，此时在用for循环去写，遍历元素和元素周围的元素，便显得不够明智。</p>
<p>在搜索算法中，常用的为深度优先和广度优先。但是题目很少去单纯的考察搜索算法，搜索经常会和树、图的遍历一起使用，于是决定来总结一下图中的搜索算法，二叉树或多叉树中的搜索算法日后再说。</p>
<a id="more"></a>
<h1 id="深度优先与广度优先"><a href="#深度优先与广度优先" class="headerlink" title="深度优先与广度优先"></a>深度优先与广度优先</h1><p>深度优先和广度优先有共同点：图的遍历指每个节点仅仅被访问一次，都是一个递归的过程。</p>
<p>深度优先指：先遍历孩子结点，在考虑兄弟节点，即先往深了去搜；广度优先指：先遍历兄弟节点，在考虑孩子节点，即先往广了去搜。如下图所示，<code>1</code>为起始顶点，深度优先(DFS)的遍历顺序是：<code>1, 4, 3, 7, 5, 6, 2</code>：广度优先(BFS)的遍历顺序是：<code>1, 4, 2, 3, 5, 7, 6</code>。如果这是一张旅游景点的地图，你可以和你的小伙伴说，我们是深度优先玩呢，还是广度优先玩呢。</p>
<p><img data-src="/2020/02/26/graph-algorithm-search/1.png" alt></p>
<h1 id="二维搜索"><a href="#二维搜索" class="headerlink" title="二维搜索"></a>二维搜索</h1><p>来一个实际题目(PAT乙级1068)：要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。输入第一行给出三个正整数，分别是 $M$ 和 $N(\leq 1000)$，即图像的分辨率；以及 TOL，是所求像素点与相邻点的颜色差阈值，色差超过 TOL 的点才被考虑。随后 $N$行，每行给出$M$个像素的颜色值，范围在$[0,2^{24}]$内。</p>
<p>在一行中按照 <code>(x, y): color</code> 的格式输出所求像素点的位置以及颜色值，其中位置 <code>x</code> 和 <code>y</code> 分别是该像素在图像矩阵中的列、行编号（从 1 开始编号）。如果这样的点不唯一，则输出 <code>Not Unique</code>；如果这样的点不存在，则输出 <code>Not Exist</code>。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 6 200</span><br><span class="line">0 	 0 	  0 	   0	    0 	     0 	      0        0</span><br><span class="line">65280 	 65280    65280    16711479 65280    65280    65280    65280</span><br><span class="line">16711479 65280    65280    65280    16711680 65280    65280    65280</span><br><span class="line">65280 	 65280    65280    65280    65280    65280    165280   165280</span><br><span class="line">65280 	 65280 	  16777015 65280    65280    165280   65480    165280</span><br><span class="line">16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(5, 3): 16711680</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul>
<li>我们可以知道，在二维搜索中，除边界元素外，一个元素有八个临界点，可以通过当前元素下标的$\pm 1, \pm 0$来访问；</li>
<li>此时定义周围8个元素的访问方式：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>题目要求独一无二，所以设立<code>map</code>，记录每个元素出现的次数，超过1则不考虑；</li>
<li>因为此题并不是严格意义上的图，而是二维矩阵，且遍历的元素之间没有相关性，即不一定要根据当前元素才能找到下一个元素。(这里理解不了参考下文的三维搜索，下文的三维搜索元素间具有相关性，即搜索到一个元素，才能搜索下一个元素)，元素的搜索没有因果关系，所以遍历图可以考虑 for 循环，而没必要使用<code>bfs</code>或者<code>dfs</code>；</li>
<li>更多解释参考代码注释。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m, n, tol;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义方向</span></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 8 个方向的遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">        <span class="comment">// x 方向</span></span><br><span class="line">        <span class="keyword">int</span> tx = i + dir[k][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// y 方向</span></span><br><span class="line">        <span class="keyword">int</span> ty = j + dir[k][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 不满足条件则直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; m &amp;&amp; v[i][j] - v[tx][ty] &gt;= <span class="number">0</span> - tol &amp;&amp; v[i][j] - v[tx][ty] &lt;= tol) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;m, &amp;n, &amp;tol);</span><br><span class="line">    v.resize(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i][j]);</span><br><span class="line">            <span class="comment">// 独一无二，出现一个元素标记加一，加到2则不考虑</span></span><br><span class="line">            mapp[v[i][j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="comment">// 判读是否独一无二 且 满足要求</span></span><br><span class="line">            <span class="keyword">if</span> (mapp[v[i][j]] == <span class="number">1</span> &amp;&amp; judge(i, j) == <span class="literal">true</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                x = i + <span class="number">1</span>;</span><br><span class="line">                y = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(%d, %d): %d"</span>, y, x, v[x<span class="number">-1</span>][y<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Exist"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Unique"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/liuchuo/PAT/tree/master/BasicLevel_C%2B%2B" target="_blank" rel="noopener">柳神的代码, 1068</a></p>
<h1 id="三维搜索（BFS）"><a href="#三维搜索（BFS）" class="headerlink" title="三维搜索（BFS）"></a>三维搜索（BFS）</h1><p>如果此时把搜索维度上升到三维空间，又该如何处理呢？先看题目(PAT 甲级 1091)：</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>One important factor to identify acute stroke (急性脑卒中) is the volume of the stroke core. Given the results of image analysis in which the core regions are identified in each MRI slice, your job is to calculate the volume of the stroke core.</p>
<p>Each input file contains one test case. For each case, the first line contains 4 positive integers: $M, N, L$ and $T$, where $M$ and $N$ are the sizes of each slice (i.e. pixels of a slice are in an $M×N$ matrix, and the maximum resolution is 1286 by 128); $L (≤60)$ is the number of slices of a brain; and $T$ is the integer threshold (i.e. if the volume of a connected core is less than T, then that core must not be counted).</p>
<p>Then $L$ slices are given. Each slice is represented by an $M×N$ matrix of 0’s and 1’s, where 1 represents a pixel of stroke, and 0 means normal. Since the thickness of a slice is a constant, we only have to count the number of 1’s to obtain the volume. However, there might be several separated core regions in a brain, and only those with their volumes no less than $T$ are counted. Two pixels are <strong>connected</strong> and hence belong to the same region if they share a common side.</p>
<p>For each case, output in a line the total volume of the stroke core.</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 5 2</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">1 0 1 1</span><br><span class="line">0 1 0 0</span><br><span class="line">0 0 0 0</span><br><span class="line">1 0 1 1</span><br><span class="line">0 0 0 0</span><br><span class="line">0 0 0 0</span><br><span class="line">0 0 0 1</span><br><span class="line">0 0 0 1</span><br><span class="line">1 0 0 0</span><br></pre></td></tr></table></figure>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">26</span><br></pre></td></tr></table></figure>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><ul>
<li>题目的含义是：一共$L$个$M\times N$的切片，构成一个$M\times N \times L$的立方体，求这个立方体中数字为 1 连成的体积；</li>
<li>显然这是一个三维空间的搜索题目，需要在三维空间内寻找相连的 1 的数量，此时需要定义三个大方向：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> X[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;  <span class="comment">// M方向， -1表示回退方向</span></span><br><span class="line"><span class="keyword">int</span> Y[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;  <span class="comment">// N方向， 回退时坐标减少，而不是增加</span></span><br><span class="line"><span class="keyword">int</span> Z[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;  <span class="comment">// L方向</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果一个 1 已经被访问，需要将它标记为<code>true</code>，防止多次访问；</li>
<li>三维图的 1 相连的方式多种多样，需要根据当前的 1 ，寻找下一个 1 ，所以 for 循环此时不够用，需要考虑广度优先遍历或深度优先遍历；</li>
<li>更多题解参考程序注释。</li>
</ul>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, l, t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于判断方向</span></span><br><span class="line"><span class="keyword">int</span> X[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;  <span class="comment">// M方向， -1表示回退方向</span></span><br><span class="line"><span class="keyword">int</span> Y[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;  <span class="comment">// N方向， 回退时坐标减少，而不是增加</span></span><br><span class="line"><span class="keyword">int</span> Z[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;  <span class="comment">// L方向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1300</span>][<span class="number">130</span>][<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">1300</span>][<span class="number">130</span>][<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 超出边界， 搜索停止</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || z &lt; <span class="number">0</span> || z &gt;= l) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 无风险不访问，已经访问过不访问</span></span><br><span class="line">    <span class="keyword">if</span>(arr[x][y][z] == <span class="number">0</span> || visit[x][y][z] == <span class="literal">true</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 其余情况均访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    node temp;</span><br><span class="line">    <span class="comment">// 当前点的位置</span></span><br><span class="line">    temp.x = x, temp.y = y, temp.z = z;</span><br><span class="line">    <span class="comment">// 创建三维点的队列</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">    q.push(temp);</span><br><span class="line">    <span class="comment">// 当前点被访问</span></span><br><span class="line">    visit[x][y][z] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="comment">// 取出队首元素</span></span><br><span class="line">        node top = q.front();</span><br><span class="line">        <span class="comment">// 弹出队首元素</span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 有一个1, 体积++</span></span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="comment">// 六个方向开始寻找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tx = top.x + X[i];</span><br><span class="line">            <span class="keyword">int</span> ty = top.y + Y[i];</span><br><span class="line">            <span class="keyword">int</span> tz = top.z + Z[i];</span><br><span class="line">            <span class="keyword">if</span>(judge(tx, ty, tz)) &#123;</span><br><span class="line">                visit[tx][ty][tz] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 当前节点没有被访问，就按着之前的三个方向探索下一个节点</span></span><br><span class="line">                temp.x = tx, temp.y = ty, temp.z = tz;</span><br><span class="line">                <span class="comment">// 压入队列，只要压入队列在下次循环时 cnt++ 用于计算体积</span></span><br><span class="line">                q.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt;= t)</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;m, &amp;n, &amp;l, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                <span class="comment">// M x N L个，这样的维度</span></span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[j][k][i]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j][k][i] == <span class="number">1</span> &amp;&amp; visit[j][k][i] == <span class="literal">false</span>)</span><br><span class="line">                    ans += bfs(j, k, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/liuchuo/PAT/tree/master/AdvancedLevel_C%2B%2B" target="_blank" rel="noopener">柳神的代码, 1091</a></p>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>《了不起的盖茨比》读后感</title>
    <url>/2019/03/03/great-gatsby/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当初在上大学之前，终于摆脱了刷题的世界，也曾怒发冲冠的想去读读课外书。当初是对这些文学很感兴趣的，尤其是古诗词和小说的阅读，冥冥之中我总能感觉到作者想要表达的意图，意会不言传的感觉很爽。</p>
<p>现在想来，大学其实也读过一些书，不过随着时间的增长，读书的数量也随时间变化服从指数下降的分布规律。</p>
<p>不过还是要在百忙之中来拾起这个爱好，隔断时间写一本书的读后感，毕竟人不可偏科，缺少前辈在文字上的教诲是万万不行的。写一些自己的收获，和标准答案完全不同的想法。或许也是转移注意力吧，总比看那些浮躁的，没有营养的，低俗的娱乐视频要好得多，读读故事，修理修理自己的三观，没有浓郁的扯淡鸡汤，只是看看外面的世界。</p>
<a id="more"></a>
<h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>发生在20世纪20年代的美国，书中并没有交代太多的历史背景，但是了解故事总得从背景出发，不然没有味道。</p>
<p>那个时候是美国历史上一个短暂而特殊的时期，史称“喧嚣年代”，指的是第一次世界大战结束后，资本主义的蓬勃发展，让美国从农业文明迅速进人了工业化的现代社会。同时，在一战后期参战的美国，因没有受到战争的重创反而大发战争财。而且政府实施“自由放任”的经济政策，能使经济运作更有效率。这创造了奇迹般的“柯立芝繁荣时代”。所以，当时美国国内经济形势一片大好，交通、矿产、建筑业扩展迅速，电器、汽车制造业猛然倔起，给不少美国人的生活带来前所未有的舒适，导致一些投机家在这类赌博性行业中一夜之间成为暴发户。</p>
<p>财富的多少成了评判一个人成功与否的标准，人们开始了盲目地赚钱，赚“快”钱，赚更多的钱；追逐变富裕，变得更富裕，大概是书中想表达的美国梦吧，浮躁与迷失。同时，美国的享乐主义在美国大行其道，传统清教徒式的道德观念和宗教信仰所推崇的“勤劳节俭”等思想，逐渐被追求个人财富、享受物质生活等消费享乐主义所取代，美国正处在新旧交替的历史交叉口。似乎每个国家的发展都要经过这么一段浮夸的时代。</p>
<p><img data-src="/2019/03/03/great-gatsby/1.jpg" alt></p>
<hr>
<h2 id="故事大概"><a href="#故事大概" class="headerlink" title="故事大概"></a>故事大概</h2><p>虽然之前的考试中，写作文重述故事是要扣分的，但是，能重述故事表明自己真的了解故事的前因后果和经过，能锻炼自己的表达能力和理解能力，为什么不写写呢？</p>
<p>尼克从中西部故乡来到纽约，在他住所旁边正是本书主人公盖茨比的豪华宅第。故事现在开始发生了，主人公詹姆斯·卡兹本是北达科他州的一个贫穷的农家子弟，自幼梦想做个出人头地的大人物。经过一番努力，他终于步步高升，并更名为杰伊·盖茨比。他在一个军训营里任中尉时，爱上了南方的大家闺秀黛茜·费，黛茜对他也情有所钟。后来第一次世界大战爆发，盖茨比被调往欧洲。似是偶然却也是必然，黛茜因此和他分手，转而与一个出身于富豪家庭的纨绔子弟汤姆结了婚。可是当他戴着军功勋章在战争结束后从海外归来时，黛茜已沦为人妻。</p>
<p>盖茨比痛苦万分，他坚信是金钱让黛茜背叛了心灵的贞洁，于是立志要成为富翁，沉醉于爱情梦幻中的盖茨比艰苦创业，几年以后，由一个贫穷的军官奋斗成为百万富翁。他在黛茜府邸的对面建造起了一幢大厦，而这多年以来，吸引盖茨比的仅仅是黛西家的灯光，似乎是那心中唯一的白月光。盖茨比挥金如土，彻夜笙箫，每晚都在举行盛大的宴会，他这么多年的努力，只是想引起黛茜的注意，以挽回失去的爱情。</p>
<p>但是，此时他的生活已经混乱不堪，甚至自不知道丢失的东西到底是什么，纯洁的梦想早已被隐藏。也许会有一个漂亮的小姐姐突然出现，让他五年来的忠贞不渝一笔勾销。而黛茜婚后的生活并不幸福，因为汤姆另有情妇。物欲的满足并不能填补黛茜精神上的空虚。</p>
<p>他唯一的愿望是希望看到分别了五年的情人黛茜，当他们重逢时，盖茨比以为时光可以倒流，和旧情人继续重温旧梦。但是，在一次意外中，黛茜开车碾死了丈夫的情妇，丈夫嫁祸于盖茨比，盖茨比终于被害，最终彻底成为了牺牲品。盖茨比至死都没有发现黛茜脸上嘲弄的微笑，悲剧在于他把一切都献给了自己编织的美丽梦想，而黛茜作为他理想的化身，却只徒有美丽的躯壳。尽管黛茜早已移情别恋，尽管他清楚地听出“她的声音充满了金钱”，却仍不改初衷，固执地追求重温旧梦。人们在为盖茨比举行葬礼，黛茜居然没来送葬，和她丈夫此时却早已在欧洲旅行的路上。故事的叙述者尼克由此看透了上层社会有钱人和喧嚣、冷漠、空洞、虚假的大都市，离开纽约，回到了中西部的故乡。</p>
<p>此外，某一时刻曾怀疑那个年代，也许是作者可以描写，那时的人们是不是都在忙着挣钱，被钱蒙蔽双眼，夫妻结婚后却忙着偷情，有些匪夷所思。另外，书中的句子真的很优美，写的也很深刻，只可惜我弱鸡的文字功底表达不出作者的十分之一，这本书值得一读。</p>
<p><img data-src="/2019/03/03/great-gatsby/2.jpg" alt></p>
<hr>
<h2 id="特别的读后感"><a href="#特别的读后感" class="headerlink" title="特别的读后感"></a>特别的读后感</h2><p>标准答案是：揭露那个浮躁年代下浮躁的人，大概是想传递脚踏实地，不能被物质蒙蔽双眼，更要追求美好的心灵，坚定道德立场，回归淳朴的意思。</p>
<p>恕我直言，这层意思我真的没读出来，毕竟一千个人有一千个哈姆雷特。</p>
<ul>
<li>不要为之前失去的东西而奋斗，等一个不爱自己的人，不就是在机场等待一艘船吗？为了一个不切实际的幻想而付出这么多，幻想是虚无的，而在幻想之上的付出也会更加虚无。</li>
<li>在浮躁的内心伴随着虚幻的梦想，盖茨比出发了，当他走过漫漫长路，觉得梦想很近。也许他不知道的是，梦想早已落在他的身后，落在城市外广袤的大地上；即使始终追赶不上曾经的梦幻，没关系，明天会跑的更快，去等待某个美好的早晨。</li>
<li>不如回归现实，但还是对未来充满美好的幻想，纵使过去留不住，不如去追寻新的美好。如果盖茨比选择了结婚，选择了花时间去陪陪家人，选择不再势利，选择了对全世界都温柔，那又是什么结局呢？</li>
<li>想起了之前的一个故事，拿来对比一下。盖茨比是：为了你，我愿意放弃这个世界。另外：为了你，我愿意热爱这个世界。完全的两个境界，后者更美。后者把失去当作是对自己的勉励，是对过去的尊重，是对曾经美好的致敬。前者呢？为了一个虚无的过去而放弃现在，没有从过去的失败中吸取教训，或者说，黛西多年的陪伴全部打了水漂，之后还会有更多的人离开盖茨比，让失去的东西不是白白失去，要值得她曾经的陪伴，要变成更好的自己。路还长，没有从失去中摆脱出来，没有开始新生活，漂浮的心没有去寻找正确的做法。</li>
<li>认为和美国梦无关，毕竟钱是自己正儿八经挣来的，还不能让人有钱了吗？病的是心态。</li>
</ul>
<p><img data-src="/2019/03/03/great-gatsby/4.jpg" alt></p>
<p>另外，书的结尾是：</p>
<blockquote>
<p>于是我们奋力前进，却如同逆水行舟，注定要不停的退回过去。</p>
</blockquote>
<p>讲真，的确是全书的升华，也猜不太透作者的意思。退回过去是指寻找过去淳朴的内心？还是在一段旅程后，记得退回过去看看自己为什么出发？</p>
<p>我个人理解偏向后者吧，因为无论人怎么进化，即使是2000年前的过去，坚韧、顽强、淳朴、善良、友善都是做人的基本准则，这些融入血液里的东西没必要退回去寻找。</p>
<p>可能自己的初心，在浮躁的尘世中被迷失、被诱惑、被尘封（比如经济繁荣美国梦带来的副作用等不良后果吧），这个时候才是退回过去，唤醒初心的目的所在吧。</p>
<hr>
]]></content>
      <tags>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>一盆绿植</title>
    <url>/2020/06/13/green-plants/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="/2020/06/13/green-plants/1.jpg" width="60%" height="60%"></p>
<a id="more"></a>
<p>记得我高一下学期的时候，我坐在教室的最后一排，靠窗位置。我就把书桌上所有的书都搬到窗台，把窗台上的一盆绿栽放到书桌的右上角。</p>
<p>平时上课的时候，因为天生犯困，就站起来上课，把书摊开放在桌子上，低头看书记笔记的时候就能看到一抹绿色。</p>
<p>上自习的时候，在桌面的左上角放上卷子，不能多放，做哪篇就放哪篇，只放一张。然后在桌面的中下部分放几张草稿纸，边写边算。别问，文就是文科除了地理都是抄的。</p>
<p>整齐简约的桌面给人一种很清爽预约的感觉，也是在这个季节，初夏的闷热。听着窗外的脚叫和风刮树叶莎莎的声音，外加偶尔能感受到的凉风，能愉快的刷作业刷上三个晚自习，中学期间的快乐就是这么简单。那时候和后排的一群男生组团去食堂吃饭，下课一起说笑娱乐，晚自习的时候一起去问老师问题，还真是怀念。</p>
<p>奈何性格孤僻，很多人也没加好友，都联系不上了。或者说，只能是在那个环境下，我们才能是朋友，上了大学自由后，很多人的处事观念我实在不敢苟同。就如当年同学对我说，以后的我们不是一个世界。</p>
<p>今天出门也买了一盆绿栽，叫什么名字我也不知道。当时只问了店主，哪个绿植好养活，容易活下来。可高一是2013年，现在是2020年，七年前的事情了，高中毕业是四年前的事情。</p>
<p>我现在的工作环境已然发生了巨大变化，再也不是简单的草纸、笔和卷子。打字、写代码的时候旁边有绿植也不是什么坏事，算是调解自己的一种方式吧，就像站在现在去回忆当初幼稚的自己，也别有一番乐趣。</p>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>残存的高中回忆</title>
    <url>/2016/07/29/highschool/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我应该是有过高中生活的，虽然很不愿意承认这一点。</p>
<p>不知道当年为什么会如此的叛逆，会如此的浪费时间，也许我成了老师口中的反面教材吧。</p>
<p>想想也是，我的高中就是特别标准的反面教材，的确我没有认真学习。记得高二整天的盯着外面的天空发呆，高三自己去了最后一排的角落，还莫名其妙的，呵，当时年轻。后来老师不喜欢我，同学也不喜欢我，学习不好也不招人待见。</p>
<p>一颗浮躁的心，也没有一件成功的事，无非整日的吹牛与妄想。</p>
<a id="more"></a>
<h2 id="随便走走"><a href="#随便走走" class="headerlink" title="随便走走"></a>随便走走</h2><p>当初的操场和远方的山丘。<br><img data-src="/2016/07/29/highschool/1.jpeg" alt><br><img data-src="/2016/07/29/highschool/2.jpeg" alt><br><img data-src="/2016/07/29/highschool/3.jpeg" alt><br><img data-src="/2016/07/29/highschool/4.jpeg" alt><br><img data-src="/2016/07/29/highschool/5.jpeg" alt><br><img data-src="/2016/07/29/highschool/6.jpeg" alt><br><img data-src="/2016/07/29/highschool/7.jpeg" alt></p>
<h2 id="宁静的回忆"><a href="#宁静的回忆" class="headerlink" title="宁静的回忆"></a>宁静的回忆</h2><p><img data-src="/2016/07/29/highschool/8.jpeg" alt><br><img data-src="/2016/07/29/highschool/9.jpeg" alt><br><img data-src="/2016/07/29/highschool/10.jpeg" alt><br><img data-src="/2016/07/29/highschool/11.jpeg" alt><br><img data-src="/2016/07/29/highschool/12.jpeg" alt><br><img data-src="/2016/07/29/highschool/13.jpeg" alt><br><img data-src="/2016/07/29/highschool/14.jpeg" alt></p>
<h2 id="最后的平静"><a href="#最后的平静" class="headerlink" title="最后的平静"></a>最后的平静</h2><p><img data-src="/2016/07/29/highschool/15.jpeg" alt><br><img data-src="/2016/07/29/highschool/16.jpeg" alt><br><img data-src="/2016/07/29/highschool/17.jpeg" alt><br><img data-src="/2016/07/29/highschool/18.jpeg" alt></p>
<hr>
<p>年少时光已成往，留下一句诗，作为日后的回忆吧。</p>
<blockquote>
<p>昔日龌龊不足夸，今日放荡思无涯。</p>
</blockquote>
<p>对不起，对我当初的无知和莽撞感到十分的歉意，也许道歉已经来不及。</p>
<hr>
]]></content>
      <categories>
        <category>残存的高中回忆</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法笔记『一』哈希</title>
    <url>/2021/03/14/hash/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>每天一点点算法开始了，<del>为什么我就写不出很爽的代码</del>。今天被邀请去水了一场类似ACM的程序设计竞赛，他说是期末考试难度，结果那个难度……题目只做出了一半，剩下的实在是…….出题人的语文水平太差了，没交代清楚题要干什么，很多细节描述的模棱两可。如果你考我程序设计，我没问题；通过模糊的信息表达来考察语文理解能力就没意思了，为啥不多打几个字把问题交代清楚呢？<strong>为节省空间，本文压缩了某些代码，实际工程切勿模仿。</strong></p>
<a id="more"></a>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>哈希是一种典型的利用空间换时间的算法，通过申请大量的空间，来达到在$O(1)$的时间复杂度内快速查询元素的目的。如最简单的，假设输入序列是<code>0,1,2,3,4,5</code>，申请一个数组作为哈希表。那么此时的哈希计算公式就可以是：<code>H[i] = i % size</code>。<code>size</code>是哈希表的长度，或者说是数组的长度。那么0存储在0号位置，5存储在5号位置。元素插入哈希表和查询哈希表内元素都可以在内完成。</p>
<p>假设表长为5，如果要插入的序列是<code>0,2,4,7</code>，就不能用上面的映射公式了，因为<code>7%5 == 2%5</code>，也就是2号位置会存储2或7，导致了冲突(collision)。这个时候就需要用探测的方法来确定7该存在哪里，常用的方法有：<a href="https://en.wikipedia.org/wiki/Linear_probing" target="_blank" rel="noopener">线性探测法</a>、<a href="https://en.wikipedia.org/wiki/Quadratic_probing" target="_blank" rel="noopener">平方探测法</a>。</p>
<p>道理就是这么个道理，有很多方法可以实现哈希，如数组、map等。</p>
<h1 id="哈希插入"><a href="#哈希插入" class="headerlink" title="哈希插入"></a>哈希插入</h1><p>现在手动模拟一下用平方探测法（只考虑正数项）来模拟下哈希插入的过程。经验而言，哈希表的长度最好是素数。第一行中，首先输入表长，若表长不为素数，则增加表长转换为最近的素数，而后输入元素的数量$N$。在下一行输入$N$个数据，插入到哈希表中，并输出插入的位置；若无法插入，则输出<code>-</code>。</p>
<p>样例输入：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">10</span> <span class="number">6</span> <span class="number">4</span> <span class="number">15</span></span><br></pre></td></tr></table></figure></p>
<p>样例输出：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">4</span> -</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 申请这么长的数组作为哈希表</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10005&gt; arr;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="comment">// 判断是否为素数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= num; i++)</span><br><span class="line">        <span class="keyword">if</span>(num % i == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二次探测法插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="comment">// i 是步长，m 是表长</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = (a + i * i) % m;</span><br><span class="line">        <span class="comment">// 如果为空，插入，并输出索引位置</span></span><br><span class="line">        <span class="keyword">if</span> (arr[idx] == <span class="number">0</span>)&#123;</span><br><span class="line">            arr[idx] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; idx;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则表示插入失败</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 逐步叠加，找到素数的表长</span></span><br><span class="line">    <span class="keyword">while</span> (!isprime(m)) </span><br><span class="line">        m += <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 开始插入元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        insert(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h1><p>第二种常见应用是先把一个序列的元素插入到哈希表中；而后查询另一个序列的元素有没有在哈希表中，计算总共的查找次数。和上面不同的是，插入元素时不能单纯的将哈希表的数值设为1了，而应该是具体的数值，来看一个实例。在第一行输入三个数字，第一个数字是哈希表长度，和上述问题一样需要处理为素数；第二个为输入序列的长度$N$；第三为查询序列长度是$M$。第二行给出$N$个元素，用二次探测法插入到哈希表中，如果不能插入，打印插入失败信息；第三行给出$M$个元素，在哈希表中查询这些元素，记录查询次数。</p>
<p>输入样例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">10</span> <span class="number">6</span> <span class="number">4</span> <span class="number">15</span> <span class="number">11</span></span><br><span class="line"><span class="number">11</span> <span class="number">4</span> <span class="number">15</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>输出样例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span> cannot be inserted.</span><br><span class="line"><span class="number">2.5</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10005&gt; arr;</span><br><span class="line"><span class="keyword">int</span> size_, n, m;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span> (m % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size_; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = (val + i * i) % size_;</span><br><span class="line">        <span class="comment">// 插入元素为对应的数值</span></span><br><span class="line">        <span class="keyword">if</span> (arr[idx] == <span class="number">0</span>)&#123;</span><br><span class="line">            arr[idx] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">" cannot be inserted."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; size_ &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (!isPrime(size_))</span><br><span class="line">        size_ ++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; size_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">double</span> cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        insert(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size_; j++)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">int</span> idx = (t + j * j) % size_;</span><br><span class="line">            <span class="comment">// 如果和查询元素相等，表示查找到，退出</span></span><br><span class="line">            <span class="comment">// 如果查找为 0，表示序列中无此元素，查找结束，退出</span></span><br><span class="line">            <span class="keyword">if</span> (arr[idx] == t || arr[idx] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%0.1f"</span>, cnt / m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="哈希应用"><a href="#哈希应用" class="headerlink" title="哈希应用"></a>哈希应用</h1><p>哈希在算法领域还是很常见的一种技巧，有很高的应用价值。接下来看几道例题，比单纯的哈希插入、查找要有意思的多。</p>
<h2 id="映射唯一"><a href="#映射唯一" class="headerlink" title="映射唯一"></a>映射唯一</h2><p>一种最简单的实例，通过数组实现哈希。先给出一个整数$N$，随后给出$N$行的人员信息，格式为：<code>队伍编号-队员编号 成绩</code>，以队伍编号为单位，计算得分最多的单位。思路就是：以每个队伍的编号为数组的下标，下标对应的数组元素为队伍的分数。这里能这么做的原因是，在哈希的过程中，队伍编号是唯一的。</p>
<p>输入样例:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span><span class="number">-10</span> <span class="number">99</span></span><br><span class="line"><span class="number">11</span><span class="number">-5</span> <span class="number">87</span></span><br><span class="line"><span class="number">102</span><span class="number">-1</span> <span class="number">0</span></span><br><span class="line"><span class="number">102</span><span class="number">-3</span> <span class="number">100</span></span><br><span class="line"><span class="number">11</span><span class="number">-9</span> <span class="number">89</span></span><br><span class="line"><span class="number">3</span><span class="number">-2</span> <span class="number">61</span></span><br></pre></td></tr></table></figure></p>
<p>输出样例:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span> <span class="number">176</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 1005&gt; arr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, g, p, s, maxn&#123;<span class="number">-1</span>&#125;, id&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d-%d %d"</span>, &amp;g, &amp;p, &amp;s);</span><br><span class="line">        <span class="comment">// 队伍加分</span></span><br><span class="line">        arr[g] += s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出最大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1005</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; maxn)&#123;</span><br><span class="line">            maxn = arr[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; id &lt;&lt; <span class="string">" "</span> &lt;&lt; maxn;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map-实现哈希"><a href="#map-实现哈希" class="headerlink" title="map 实现哈希"></a>map 实现哈希</h2><p>map数据结构是什么请移步<a href="https://muyuuuu.github.io/2019/06/02/OJ-Cpp-cumulative/">此处</a>。假设开学要查抄学生携带的违规物品，输入第一行给出两个正整数$N$和$M$，分别是学生人数和需要被查缴的物品种类数。第二行给出$M$个需要被查缴的物品编号，其中编号为 4 位数字。随后$N$行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量$K$、以及$K$个物品的编号，顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）。</p>
<p>输入样例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2333</span> <span class="number">6666</span></span><br><span class="line">CYLL <span class="number">3</span> <span class="number">1234</span> <span class="number">2345</span> <span class="number">3456</span></span><br><span class="line">U <span class="number">4</span> <span class="number">9966</span> <span class="number">6666</span> <span class="number">8888</span> <span class="number">6666</span></span><br><span class="line">GG <span class="number">2</span> <span class="number">2333</span> <span class="number">7777</span></span><br><span class="line">JJ <span class="number">3</span> <span class="number">0012</span> <span class="number">6666</span> <span class="number">2333</span></span><br></pre></td></tr></table></figure></p>
<p>输出样例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">U: <span class="number">6666</span> <span class="number">6666</span></span><br><span class="line">GG: <span class="number">2333</span></span><br><span class="line">JJ: <span class="number">6666</span> <span class="number">2333</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, cnt1&#123;<span class="number">0</span>&#125;, cnt2&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">string</span> s, name;</span><br><span class="line">    <span class="comment">// 将违规物品映射为1</span></span><br><span class="line">    <span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; check;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        check[s] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name &gt;&gt; k;</span><br><span class="line">        <span class="keyword">int</span> flag&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="comment">// 如果查询到就说明违规，违规物品记录多次</span></span><br><span class="line">            <span class="keyword">if</span> (check[s] == <span class="number">1</span>)&#123;</span><br><span class="line">                cnt2++;</span><br><span class="line">                <span class="comment">// 只记录一次违规人数</span></span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">":"</span>;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    cnt1 ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt1 &lt;&lt; <span class="string">" "</span> &lt;&lt; cnt2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串过滤"><a href="#字符串过滤" class="headerlink" title="字符串过滤"></a>字符串过滤</h2><p>给定两个字符串，删除第一个字符串中所包含的第二个字符串的字符，实现两个字符串相减。如果每次输出字符都判断一下这个字符是否在第二个字符串中，复杂度约为$O(n^2)$，必然会超时。如果使用哈希，开辟一块内存空间，就能大规模减少时间复杂度到$O(n)$。</p>
<p>样例输入：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">They are students.</span><br><span class="line">aeiou</span><br></pre></td></tr></table></figure></p>
<p>样例输出：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Thy r stdnts.</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1, str2;</span><br><span class="line">    getline(<span class="built_in">cin</span>, str1);</span><br><span class="line">    getline(<span class="built_in">cin</span>, str2);</span><br><span class="line">    <span class="keyword">bool</span> flag[<span class="number">256</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="comment">// 遍历第一个字符串，全部设为 true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length(); i++)</span><br><span class="line">        flag[str1[i]] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 遍历第二个字符串，设为 false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str2.length(); i++)</span><br><span class="line">        flag[str2[i]] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 再次遍历第一个，只输出 true，false的会被屏蔽</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[str1[i]] == <span class="literal">true</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, str1[i]);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="减少计算量"><a href="#减少计算量" class="headerlink" title="减少计算量"></a>减少计算量</h2><p>$3n+1$猜想的步骤是：如果一个数是偶数，那将它除以2；如果一个数是奇数，那么将它乘以3后加1，经过有限步骤一定可以取值为1。为了节省计算，可以记录递推过程中遇到的每一个数。如计算$n=3$时，需要计算<code>3、5、8、4、2、1</code>，当下一次遇到<code>5、8、4、2</code>的时候，就不用计算了，可以直接判断得到结果。称<code>5、8、4、2</code>是3的覆盖数。我们称一个序列中的某几个数是关键数，如果这几个关键数不被其他数字所覆盖。现在给出一个序列，序列中元素的最大值为100，最小值为2，计算其中的关键数，并从大到小输出。</p>
<p>这就是一个典型的哈希问题，创建一个数组，以序列元素为数组的下标进行查询；数组的取值表示是否为关键数，这里设取值为1表示关键数。如果序列中的值对应数组元素的取值是1，则输出。因为序列中最大值为100，所以能设计的最大取值范围是99*3+1=298。凑个整，直接申请300大小的数组。那么来编写代码。</p>
<p>输入样例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">11</span></span><br></pre></td></tr></table></figure></p>
<p>输出样例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 300&gt; arr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, tmp, flag&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    v.resize(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        v[i] = tmp;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">                tmp = tmp * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">            tmp = tmp / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 如果已经是非关键数了，那么之后的肯定是非关键数</span></span><br><span class="line">            <span class="keyword">if</span> (arr[tmp] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 非关键数全部记录为 1</span></span><br><span class="line">            arr[tmp] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对序列从大到小排序</span></span><br><span class="line">    sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="comment">// 如果序列对应的哈希值不是1，那么就是非关键数，输出</span></span><br><span class="line">        <span class="keyword">if</span> (arr[v[i]] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; v[i];</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如果后续遇到了其他类型的不错题目，会继续追加到这里。</p>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>故乡云水</title>
    <url>/2015/02/20/home/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>故乡位于太行山脉脚下，地区70%都是山区，我也在这个山城小镇里生活了足足18年。</p>
<p>印象最深的只有了两次：</p>
<ul>
<li><p>一次是小时候，山间到处是花香，到处是鸟语，清澈的小溪随意的奔腾，那个时候天空很蓝，湖水很清。那个时候是小桥流水人家的生活，房子位于半山腰，山脚下就是小溪，溪水里有欢快的鱼儿，人们从山脚下饮水上山，水是能直接喝的，偶尔还能在水里发现几片花瓣，至少我小时候不知道什么是水垢，也不知道现代人喝水是要提前烧开的。</p>
</li>
<li><p>每当每月花儿盛开的时候，漫山遍野充满了赤橙黄蓝的颜色，鸟语生生伴随春雨阵阵，躲在屋檐下听雨的时光也一去不复回。还有花香，春风十里，十里都是沁人心脾的花香，空气也是甜的，后来闻惯了厚重的雾霾和都市气息，鼻子也不如以前。</p>
</li>
<li><p>每到夜晚就开始看星星，那是我见过最亮的星星，比现在看到的星星亮一百倍，小时候视力好，还能能看见惨淡的星河，飘来飘去的萤火虫，为宁静的夜色添加了动感的美丽。</p>
</li>
<li><p>另一次是冬季的大雪封山，雪花洋洋洒洒的落下，整个天地银装素裹，天地之间白茫茫一片，静的能听见自己的声音。</p>
</li>
</ul>
<p>那个时候没有相机，没有手机，也没有拍下一张照片，只留下了回不去的回忆，在柏油路和旅游业的践踏下，故乡早已不是故乡。</p>
<p>后来有了手机，拍下的也不是之前的故乡。故乡里的人们大多安分守己，无非种地与放羊，男人被认为是家里的支柱，女人被认为是传宗接代的工具，这的确是很早以前部分农村的真实写照。</p>
<p>好在我足够幸运接受了教育，成为了当地为数不多的学生。至少要走出大山，去看看外面的世界也好，开阔眼界。</p>
<a id="more"></a>
<hr>
<h2 id="雪景"><a href="#雪景" class="headerlink" title="雪景"></a>雪景</h2><p><img data-src="/2015/02/20/home/3.jpeg" alt><br><img data-src="/2015/02/20/home/4.jpeg" alt><br><img data-src="/2015/02/20/home/6.jpeg" alt><br><img data-src="/2015/02/20/home/7.jpeg" alt></p>
<hr>
<h2 id="清水"><a href="#清水" class="headerlink" title="清水"></a>清水</h2><p><img data-src="/2015/02/20/home/8.jpeg" alt><br><img data-src="/2015/02/20/home/9.jpeg" alt><br><img data-src="/2015/02/20/home/10.jpeg" alt></p>
<hr>
<h2 id="傲松"><a href="#傲松" class="headerlink" title="傲松"></a>傲松</h2><p><img data-src="/2015/02/20/home/13.jpeg" alt><br><img data-src="/2015/02/20/home/14.jpeg" alt><br><img data-src="/2015/02/20/home/15.jpeg" alt><br><img data-src="/2015/02/20/home/16.jpeg" alt><br><img data-src="/2015/02/20/home/17.jpeg" alt></p>
<hr>
<h2 id="深山"><a href="#深山" class="headerlink" title="深山"></a>深山</h2><p><img data-src="/2015/02/20/home/20.jpeg" alt><br><img data-src="/2015/02/20/home/21.jpeg" alt><br><img data-src="/2015/02/20/home/22.jpeg" alt><br><img data-src="/2015/02/20/home/23.jpeg" alt><br><img data-src="/2015/02/20/home/24.jpeg" alt><br><img data-src="/2015/02/20/home/26.jpeg" alt></p>
<hr>
]]></content>
      <categories>
        <category>故乡云水</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>华山自由行之一日游</title>
    <url>/2021/04/18/hua-shan-free-travel/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>人在西安，离华山近。不想清明或五一去下饺子，想着周内去一趟，反正离得近。事实证明这个选择是正确的，华山这么险峻的地方下饺子太危险了。接下来前面部分算是旅行攻略吧，包括路线、时间、穿衣和花费等，因本人是学生党，所以都是精打细算，没有过高消费；后一部分是风景照什么的。</p>
<p>这是我目前去过最接近地府的景点，我只能这么评价。</p>
<a id="more"></a>
<h1 id="时间与路线安排"><a href="#时间与路线安排" class="headerlink" title="时间与路线安排"></a>时间与路线安排</h1><p>因同行人是三个青壮年，所以体力充沛，没有选择索道。据网上查阅，腿路的起点是玉泉院，所以我们的起点也就是玉泉院了，<strong>北上西下，腿上索道下</strong>，一天内爬完了华山，五峰全部登顶，时间还很充裕。之后用加粗字体表示重要路标和时间节点。</p>
<ol>
<li>学校在<strong>西安</strong>，门口就是地铁，所以买的是从<strong>西安北到华山北</strong>最早的高铁，是 <strong>7:28</strong> 开车，<strong>8:00</strong> 到达。所以5点起床洗漱，6点赶第一班地铁，6点40到了<strong>西安北</strong>，等高铁途中使劲吃面包和火腿。（普通火车没有上午的，不考虑；大巴晕车，可能堵车；不考虑）。</li>
<li>出了<strong>华山北</strong>高铁站后，有免费公交或出租可以乘坐；因公交需要等待且可能等不到，所以选择了出租到<strong>玉泉院</strong>，因为这是腿路的起点，共计19元，大概八点半到的。翻过前面的寺院，网上预约门票耽误了一会儿，<strong>9:00</strong> 开始登山。（疫情原因，不能线下购买，只能线上购买，刷身份证进）</li>
<li>前面的路是人工修的，之后到<strong>第一关</strong>，后面的山路就意味着正式开始登山，大约走了一个小时，也就是 <strong>10:00</strong> 正式开始登山。我们每个人的配置是：四瓶水，我单独带了三瓶酸奶，这个配置下，爬完山还剩一瓶水，如果带的水不够，立刻在山下补充。吃的就是面包之类。</li>
<li>之后会到<strong>回心石</strong>，意思就是现在放弃还来得及；过了<strong>千尺幢</strong>，开弓没有回头箭了。</li>
<li>华山自古一条路，旁边就是万丈悬崖。选择纠结症的福音，只能按着路线走，累了就休息下，景点就拍照留念。我们的路线是： 北峰（<strong>12:00</strong> 登顶），东峰（<strong>15:00</strong> 登顶），中峰（<strong>15:00</strong> 登顶，这俩离得很近很近），南峰(<strong>16:00</strong> 登顶)，西峰（<strong>17:00</strong> 登顶），没有去鹞子翻身，长空栈道等阴间景点，太太太危险了。西峰逗留整顿了一会儿，坐索道下山了。</li>
<li>而后从<strong>西峰索道</strong>下山，西峰索道真的天下一绝，<del>我直接吓瘫在地上</del>，<strong>18:30</strong> 坐上了从西峰脚下去游客中心的大巴，七点到的游客中心。门口叫滴滴就行；门口的出租太黑了，不打表，直接要钱，很贵，反正我们当时是这样。</li>
<li>县城里吃了顿肉补一补，据当地人说那里的特产是大刀面，用铡刀做的，可惜没赶上；之后乘坐 <strong>21:17</strong> 的高铁从华山北回西安北了。</li>
</ol>
<h1 id="花费"><a href="#花费" class="headerlink" title="花费"></a>花费</h1><h2 id="必要消费"><a href="#必要消费" class="headerlink" title="必要消费"></a>必要消费</h2><ol>
<li>高铁单程是 54.5 元，往返 109 元</li>
<li>出租去玉泉院 19 元</li>
<li>门票，我们是旺季，是 160 元</li>
<li>西峰索道 140 元，腿路下山伤膝盖</li>
<li>下山大巴 40 元，二十公里山路呢，坐车吧</li>
<li>因为大巴的下车点不是玉泉院，所以去华山北出租是 10 元左右</li>
</ol>
<h2 id="其它消费"><a href="#其它消费" class="headerlink" title="其它消费"></a>其它消费</h2><ol>
<li>纪念品华山香石，苍龙岭后面，不是很坑，也就10元</li>
<li>吃的喝的，自己看着买吧</li>
</ol>
<h1 id="装备"><a href="#装备" class="headerlink" title="装备"></a>装备</h1><ol>
<li>我们是 4 月中旬去的，早晚天气很凉，尤其是汗水干了，风一吹，个人建议带冲锋衣。山顶有穿背心的，有穿羽绒服的，我就穿的一个外套加一件秋衣；秋裤自己看这穿吧，我穿了，同行的人没穿，都行。</li>
<li>帽子，我们那天有风，风还凉，吹的头疼。</li>
<li>护膝，下山极度伤膝盖，上山没事。如何选择护膝或该不该带护膝，请知乎搜索。</li>
<li>手套，我感觉不太必要。</li>
</ol>
<h1 id="其它注意事项"><a href="#其它注意事项" class="headerlink" title="其它注意事项"></a>其它注意事项</h1><ol>
<li>山路极度危险，不要着急，慢慢走。走路不看景，看景不走路。</li>
<li>在攀登危险的山路前，做好心里和体力准备，不然会佷仓促。上也上不去，还不能下去；后面的人还会催你，只能硬着头皮继续上。</li>
<li>不要在人极度拥挤的危险道路拍照，后面的人都没法走，但总有 SB 这么做，毕竟旅游的人越来越多，啥人都有。</li>
<li>珍爱生命，远离 SB，不要和爱表现、哗众取宠的人一起出去。在某个坡度为 90 度直角的阶梯上，我正拉着铁链往上走，一个 SB 为了在女生面前表现，猛的往外甩铁链，故意把身体甩到外侧，把我拉铁链的手也震开了，得亏另一个手拉着铁链，不然真的从 90 度的阶梯上摔下去了，那就祝你早日摔死吧。</li>
<li>山上厕所比较少，遇到厕所就去一趟。</li>
<li>华山以险峻著称，如果恐高，慎来此地。</li>
<li>山上围栏的铁链都比较结实，这个可以放心。</li>
<li>山顶能俯瞰到关中沃野，这在古代，我也得打一仗。</li>
<li><del>不要带女生或体力不太行的人去，女生可以带男朋友去看看他到底爱不爱你。</del></li>
<li>我常年锻炼，第二天醒来腿居然不疼。</li>
</ol>
<h1 id="一些照片-超清原图，流量预警"><a href="#一些照片-超清原图，流量预警" class="headerlink" title="一些照片(超清原图，流量预警)"></a>一些照片(超清原图，流量预警)</h1><p><img data-src="https://z3.ax1x.com/2021/04/18/cIKszV.jpg" alt></p>
<h2 id="俯瞰关中沃野"><a href="#俯瞰关中沃野" class="headerlink" title="俯瞰关中沃野"></a>俯瞰关中沃野</h2><p><img data-src="https://z3.ax1x.com/2021/04/18/cIKrR0.jpg" alt></p>
<h2 id="直上直下的路"><a href="#直上直下的路" class="headerlink" title="直上直下的路"></a>直上直下的路</h2><p><img data-src="https://z3.ax1x.com/2021/04/18/cIKBin.jpg" alt></p>
<p><img data-src="https://z3.ax1x.com/2021/04/18/cIKgLF.jpg" alt></p>
<p><img data-src="https://z3.ax1x.com/2021/04/18/cIKWdJ.jpg" alt></p>
<h2 id="中华龙脉"><a href="#中华龙脉" class="headerlink" title="中华龙脉"></a>中华龙脉</h2><p>据说韩愈在这里被吓哭了，路陡，旁边是悬崖。</p>
<p><img data-src="https://z3.ax1x.com/2021/04/18/cIKcsU.jpg" alt></p>
<h2 id="华山论剑"><a href="#华山论剑" class="headerlink" title="华山论剑"></a>华山论剑</h2><p><img data-src="https://z3.ax1x.com/2021/04/18/cIKRZ4.jpg" alt></p>
<h2 id="悬崖绝壁"><a href="#悬崖绝壁" class="headerlink" title="悬崖绝壁"></a>悬崖绝壁</h2><p><img data-src="https://z3.ax1x.com/2021/04/18/cIKwIs.jpg" alt></p>
]]></content>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>核函数</title>
    <url>/2020/09/18/kernel-trick/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>打开搜索引擎搜索核函数，都会发现 SVM 会一起出现。但是核函数是一种技巧，并不只限于 SVM。其实，核技巧是一个非常纯粹的数学方法，不应该一上来就扯上 SVM，也没必要。因为这个技巧不仅应用在SVM中，它解决了数据映射到高维空间之后点积的计算量过于复杂的问题。很多人啰啰嗦嗦说了一大堆，把原本很简单的东西搞的很复杂，甚至还在推 SVM 的公式，就像孔乙己问茴香豆的『茴』有几种写法一样的没意思。</p>
<a id="more"></a>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>支持向量机为了解决数据在低维度不容易线性分割的情况下，会通过某非线性变换 $\phi(x)$，将输入空间映射到高维特征空间。但是映射的维度会很高，为了降低计算复杂度，解决映射后可能产生的维度爆炸问题，我们在求解的时候引入了核技巧。所以，核技巧的应用场景不限于 SVM，而是：需要处理高维映射计算的问题。</p>
<p>给定两个向量 $x$ 和 $y$，我们的目标是要计算他们的内积 $\langle x,y\rangle $ 。如果原始空间内不可分，那么现在通过某种非线性变换把他们映射到某一个高维空间中去，那么映射后的向量就变成 $\phi(x)$和 $\phi(y)$，映射后的内积就变成 $\langle \phi(x),\phi(y)\rangle $。现在改如何计算映射后的内积呢？</p>
<p>传统方法是先计算映射后的向量 $\phi(x)$和 $\phi(y)$，然后再计算它俩的内积。但是这样做计算很复杂，因为映射到高维空间后的数据维度很高。一旦达到一万多维计算起来简直浪费时间。</p>
<p>于是，能不能在原始空间找到一个函数 $K(x,y)$ 使得 $K(x,y)=\langle \phi(x),\phi(y)\rangle $ 呢？如果这个函数存在，那么我们只需要在低维空间里计算函数的值即可，而不需要先把数据映射到高维空间，再通过复杂的计算求解映射后的内积了。</p>
<p>庆幸的是，这样的函数是存在的。这样一来计算的复杂度就大大降低了，这种简化计算的方法被称为核技巧（The Kernel Trick），而函数 $K(x,y)$ 就是核函数（Kernel Function）。这里我们选用高斯核函数，可以将原始维度映射到无穷维。</p>
<p>\begin{equation}<br>K(x,y)=\exp\Bigl(-\frac{||x-y||^2}{2\sigma^2}\Bigr)<br>\end{equation}</p>
<p>这种东西最好是去看官方文档，有人把高斯核函数中的范数写成了$|x-y|^2$，第三方博客一点都不注重细节，我半天没看懂还以为取绝对值，艹。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapping</span><span class="params">(x, y, sigma=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.exp(-np.linalg.norm((x-y), ord = <span class="number">2</span>) / <span class="number">2</span> / sigma ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">x_1 = np.random.random_sample((<span class="number">10</span>, <span class="number">1</span>))</span><br><span class="line">x_2 = np.random.random_sample((<span class="number">10</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">a = mapping(x_1, x_2)</span><br><span class="line"></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>核函数是个好东西，之前还写过用核函数去聚类的文章，欢迎观看：<a href="https://muyuuuu.github.io/2020/03/30/KDE-cluster/">https://muyuuuu.github.io/2020/03/30/KDE-cluster/</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>核技巧：<a href="http://www.fanyeong.com/2017/11/13/the-kernel-trick/" target="_blank" rel="noopener">http://www.fanyeong.com/2017/11/13/the-kernel-trick/</a></li>
<li>核函数：<a href="https://en.wikipedia.org/wiki/Radial_basis_function_kernel" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radial_basis_function_kernel</a></li>
<li>numpy求范数：<a href="http://liao.cpython.org/numpy11/" target="_blank" rel="noopener">http://liao.cpython.org/numpy11/</a></li>
</ol>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>一场梦</title>
    <url>/2020/07/29/junior-school-English-teacher/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>和初中英语老师最后一次见面是在高中毕业后，老师回来参加初中同学聚会，可就是那天出门我没带手机，老师说去了石家庄教书，寒暄了几句，问了问我考上了哪里，就告辞了。</p>
<p>今晨六点，梦到了她。她指责我说我太浮躁，从初中就浮躁，上了高中和大学更是不好好学习，态度一点都不认真，我本来应该咋样咋样，现在却咋样咋样，当着全班同学骂了我一顿，遂惊醒。</p>
<p>虽然我也快告别学生时代了，还是留此记录，我还差得很远。</p>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>《追风筝的人》——为你，千千万万遍</title>
    <url>/2019/03/10/kite-runner/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>虽然最近有较多的<code>deadline</code>，好像无形之中我要学习<code>java</code>和<code>汇编语言</code>，想想还是头疼，主要还是我懒。但是还是每周抽出点时间来干自己喜欢的事情，继续整理我的书记读后感。</p>
<p>说实话，自从开始读书以来，《追风筝的人》是我读过的最跌宕起伏、最动人心弦、最引人入胜的描写真实故事的小说，暂时没有之一。后来被拍成了电影，电影说实话我看过，跟书中的世界根本没法比，电影拍的太烂了，不及书本表达内涵的十分之一。</p>
<p>“为你，千千万万遍”，这句话写的实在是太帅了，是贯彻全书前半部分和后半部分的线索。当然这不是爱情，是描写的伙伴之间的情谊和对过去的忏悔。</p>
<a id="more"></a>
<h1 id="故事梗概"><a href="#故事梗概" class="headerlink" title="故事梗概"></a>故事梗概</h1><p>12岁的阿富汗富家少爷阿米尔与仆人哈桑情同手足。然而，在一场风筝比赛后，发生了一件悲惨不堪的事，阿米尔为自己的懦弱感到自责和痛苦，逼走了哈桑，不久，自己也跟随父亲逃往美国。</p>
<p>成年后的阿米尔始终无法原谅自己当年对哈桑的背叛。为了赎罪，阿米尔再度踏上暌违二十多年的故乡，希望能为不幸的好友尽最后一点心力，却发现已无法弥补，儿时的噩梦再度重演，阿米尔该如何抉择？</p>
<p>故事如此残忍而又美丽，作者以温暖细腻的笔法勾勒人性的本质与救赎，读来令人荡气回肠。</p>
<p><img data-src="/2019/03/10/kite-runner/3.jpg" alt></p>
<h1 id="故事叙述"><a href="#故事叙述" class="headerlink" title="故事叙述"></a>故事叙述</h1><p>故事很长很荡气回肠，做好准备。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li>为什么是风筝呢？按当地风俗，每年都会举办追风筝比赛，斗风筝的人用自己的风筝线将别人的风筝线切断之后，他的助手“追风筝的人”要去追到掉落的风筝，之后就可以拥有它作为战利品。阿米尔擅长在斗风筝时切断别人的风筝线，而哈桑则擅长追风筝，他不用看也总能知道风筝掉落的位置，然后追到战利品。</li>
<li>阿富汗普什图人和哈扎拉人的矛盾由来已久，身为普什图人的阿塞夫就认为哈扎拉人是劣等民族，只配居住在阿富汗中部山区的哈扎拉人聚居地哈扎拉贾特。</li>
<li>关于战争，无论正义或者邪恶，人民会陷入水深火热的生活死于非命，对人民和国家带来很大的变故，战争终究是残酷的，并非像无脑军事题材的电视剧中所展现的光鲜亮丽的外表下拿枪耍酷。</li>
</ul>
<h2 id="早期阿富汗的生活"><a href="#早期阿富汗的生活" class="headerlink" title="早期阿富汗的生活"></a>早期阿富汗的生活</h2><p>主人公阿米尔是一个富家少年；而他的童年好友，哈桑是父亲的仆人阿里的儿子。阿米尔和哈桑自幼一同长大，童年生活宁静愉快，二人经常一起参加喀布尔当地的斗风筝比赛，另外的童年生活还有阿米尔给哈桑在山坡上讲故事(哈桑是仆人的儿子，不识字)，大概是童年建立起来的友情吧。</p>
<p>阿塞夫是当地臭名昭著的恶霸少年，年纪比阿米尔和哈桑稍大，他嘲弄阿米尔与哈扎拉人作朋友。阿米尔缺少勇气，两个孩子和人打架时(种族歧视)也总是哈桑保护阿米尔，一次，阿塞夫准备攻击阿米尔，哈桑为了保护阿米尔，用弹弓与阿塞夫对峙，威胁要打瞎阿塞夫的眼睛，注意这个眼睛，后文还有。阿塞夫只得放弃，但他发誓要找机会报仇。</p>
<p>之后当地举行了盛大的斗风筝大赛。阿米尔在比赛中勇夺冠军，终于赢得了爸爸的赞赏。比赛结束时，哈桑跑去追赶最后一个掉落的风筝作为阿米尔的战利品，离开之前对阿米尔说：<center>“为你，千千万万遍。”</center><br>然而，哈桑找到风筝之后，却在小巷中遇到了阿塞夫，阿塞夫打伤了哈桑然后强奸了他(同性之间，并非异性)。阿米尔恰巧目睹了这一切，但因为害怕而没有挺身而出。</p>
<p>阿米尔知道如果自己没有带着战利品风筝回家，爸爸就不会为自己感到如此骄傲，于是没有站出来保护自己的朋友。他的内心充满负罪感，但又知道自己的怯懦会毁掉爸爸对他刚刚产生的好感，因此缄口不言，没有将自己看到的事情告诉任何人。之后，阿米尔由于内疚而无法面对哈桑，和他渐渐疏远。</p>
<p>经历了情感上的痛苦纠结之后，阿米尔认为如果能远离哈桑，生活将会轻松许多，之后还在殴打哈桑，但是哈桑毫无怨言，始终将阿米尔视为好朋友。他希望爸爸能解雇阿里和哈桑，但被爸爸严词拒绝。随后阿米尔在自己生日上陷害哈桑，把爸爸送他作生日礼物的手表和一些钱塞到了哈桑的床垫下，谎称是哈桑偷走，希望爸爸因此能赶走他。哈桑尽管已经知道自己是被陷害，但还是向爸爸承认是自己所为。</p>
<p>爸爸平时坚信没有比盗窃更十恶不赦的事情，却出人意料地原谅了哈桑。然而阿里和哈桑不顾爸爸的挽留，坚持要离开(估计是哈桑告诉了哈桑的父亲阿里)。阿米尔从此不用每天看到哈桑就想起自己的懦弱和背叛，但无法逃离阿里和哈桑在他心中留下的阴影。</p>
<p><img data-src="/2019/03/10/kite-runner/1.jpg" alt></p>
<h2 id="美国生活"><a href="#美国生活" class="headerlink" title="美国生活"></a>美国生活</h2><p>苏联军事入侵阿富汗后，爸爸带着阿米尔为躲避战乱逃往巴基斯坦，把家留给拉辛汗照看。逃亡途中，爸爸为了保护同车的妇女不被苏联士兵强奸，冒着生命危险挺身而出，他说这是一个男人的担当，的确我很佩服作为男人的勇气，所幸最终这两人都逃脱了危险。</p>
<p>父子二人最后辗转到了美国加利福尼亚州，在这里定居下来。爸爸在当地的一家加油站找到了工作，阿米尔也在高中毕业之后进入社区大学学习写作，最后成为了一名作家。阿米尔结识了索拉雅·塔赫里和她的一家，二人很快相恋。随后爸爸被诊断患有肺癌，病情恶化，已经不久于人世，但是还是在逝世前完成了阿米尔的心愿，拖着病重的身躯和塔赫里将军定下了这门亲事，书中的描写：父亲高大伟岸的身躯逐渐萎缩。</p>
<p>阿米尔和索拉雅结婚不久，爸爸就病逝了。阿米尔和索拉雅在旧金山定居下来，索拉雅哭着和阿米尔打电话，诉说了埋藏多年的心事：当年年轻不懂事和别人私奔的故事，但是阿米尔并没有介意，婚姻幸福美满，但是不幸的是，夫妇二人却患有不孕不育，无论怎么尝试都始终没有怀上自己的孩子。</p>
<p>阿米尔成为了一名成功的小说家。结婚十五年之后的2001年，阿米尔接到了拉辛汗打来的电话。拉辛汗已经重病在身，打电话给阿米尔要他赶到巴基斯坦。令人不解的是，拉辛汗对阿米尔说：这儿有再次成为好人的路。</p>
<p><img data-src="/2019/03/10/kite-runner/2.jpg" alt></p>
<h2 id="故事反转"><a href="#故事反转" class="headerlink" title="故事反转"></a>故事反转</h2><p>阿米尔也哭着和妻子诉说了埋藏多年的心事，对当年的懦弱和行为感动无比的后悔，妻子了解到丈夫当年的行为，也支持丈夫回到了战争中的阿富汗找到拉辛汗。此时阿里已经误触地雷身亡，而哈桑和妻子已经有了一个儿子索拉博，索拉博，名字的意思是当年阿米尔给哈桑讲述故事中的超级英雄，哈桑和他妻子为了保护阿米尔当年在阿富汗留下的房子挺身而出，被当街枪毙。</p>
<p>随后，拉辛汗告诉阿米尔自己把他找来的真正目的是希望他能救回在孤儿院生活的索拉博。阿米尔并不情愿，但拉辛汗向阿米尔吐露了自己隐藏已久的秘密，告诉他阿里其实不育，并非哈桑的生父，而哈桑是阿米尔爸爸的私生子，和阿米尔其实是同父异母的兄弟。</p>
<p>阿米尔被这一秘密震惊出发前往寻找索拉博。他了解到军官经常到孤儿院，给院长一些钱之后带走一个孩子，索拉博已经被首领带走。阿米尔到首领家中与他会面，才发现这个首领正是阿塞夫。阿塞夫把索拉博囚禁在家中，对他性侵犯，强迫他穿女装为他跳舞。阿塞夫同意阿米尔把索拉博带走，但必须要和阿米尔对打，获胜者才能带走索拉博。阿塞夫让随从人员离开，开始轻松殴打毫无搏击经验的阿米尔，不料打斗过程中，索拉博用弹弓打瞎了阿塞夫的左眼，恰好实现了哈桑多年前的威胁。</p>
<p>阿米尔带索拉博前往巴基斯坦，告诉索拉博自己打算把他带到美国，希望能收养他。然而阿米尔无法证明索拉博是孤儿，无法取得美国签证。阿米尔只得告诉索拉博自己需要暂时打破承诺，让索拉博到孤儿院再住一段时间，等相关文件完成之后就接他去美国。索拉博得知这个消息之后，出于对孤儿院的惧怕而选择割腕自杀，当时读到这里我还以为完蛋了，所幸被阿米尔及时救下。阿米尔最终通过人道主义签证成功将索拉博带回美国，然后收养了他。尽管阿米尔和妻子悉心的照顾，但索拉博却不再与阿米尔或索拉雅等任何人有交流。</p>
<p>直到2002年3月，阿米尔带索拉博去公园，回忆起了哈桑，于是他放起了风筝，向索拉博展示哈桑最擅长的斗风筝技艺，切断了别人的风筝线。故事最后，索拉博对阿米尔浅浅地微笑了一下，阿米尔却心花怒放，为索拉博去追赶掉落的风筝。跑去追赶风筝之前，他对索拉博说：<center>“为你，千千万万遍。”</center></p>
<p>故事到这里就结束了，书的结语是：祝各位的风筝飞的又高又远。虽然这本书是两年多以前所读(大一下学期，现在大三下学期)，但很多内容仍然历历在目。</p>
<p><img data-src="/2019/03/10/kite-runner/4.jpg" alt></p>
<h1 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h1><p>说实话每当读完一些内容，总会被书中的内容震撼到不知道说什么为好。这部小说的主题是友谊、背叛、罪恶感、救赎，并非阿富汗所特有，因此小说才能够跨越文化、种族、宗教和性别的差异，与各种不同背景的读者都能产生共鸣。</p>
<p>我不想产生上升到道德、做人、生活迷失的角度，因为这样感觉玷污了这本书。</p>
<p>哈桑则甘愿为阿米尔牺牲一切，甚至是生命，虽出身低微，却勤劳勇敢，朴实忠贞。他以一生兑现着对阿米尔少爷的忠诚，从小为他出头，为他被黑锅，为他追风筝，为他挣名声，就连洞悉了阿米尔的诬陷把戏后，仍然一声不吭的甘愿背负，最终还为守护阿米尔的房子而死去。虽卑微，没有太多文化，却无限完美的男孩儿形象，就像一个基督圣人一般的形象。</p>
<p>没有读过书的哈桑，或许讲不出什么经典的语句，但每一句质朴的话”为你千千万万遍”，都是他用一生兑现的承诺。</p>
<p>我常常在想，哈桑临死的那一刻是安然的么？是可以瞑目的么？书中没有讲，但我觉得他应该是安然的，因为以哈桑的性格，他在生命的最后一刻都坚守在了自己少爷家的祖宅前面，虽然那一刻，他的少爷可能已在千里之外享受这他的另一种人生，可能祖宅对他而言也没有那么的重要，但是，至少对于哈桑，他是重要的，也是这一生当中或许唯一的重要与守护。</p>
<p>说实话，读完之后让我觉得很压抑，甚至读到一半的时候已没有勇气继续去读。结局不应该是这种走向，至少是个我认为的团圆的结局。然而最终，那些人，要么已经去世了，要么快要去世了。</p>
<p>小说最后的风筝，我没太读懂究竟蕴含着什么含义。也许像译者说的，在这本感人至深的小说里面，风筝是象征性的，它既可以是亲情、友情、爱情，也可以是正直、善良、诚实，隐喻人格中必不可少的部分。</p>
<p>阿米尔是斗风筝的高手，却从未有一次去追过风筝，因为他不需要追，有他的哈桑为他去追，千千万万次。这一次，在他的后半生里，他第一次追风筝，为哈桑的儿子索拉博而追，对阿米尔来说，风筝隐喻他人格中必不可少的部分，只有追到了，他才能成为健全的人，成为他自我期许的阿米尔，才能对得起哈桑的那句：为你，千千万万遍！</p>
<p>我们可以相信，追回的不只是风筝，还有那许许多多承载浸透在风筝里的说了和没有说的过往，还有那许许多多完成了和未完成的心愿。</p>
<p>也许每个人心中都有一个风筝，无论它意味着什么，让我们勇敢的去追。</p>
<p>我可能表述的不到位，但是这本书写的真的很棒。</p>
<hr>
]]></content>
      <tags>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>正确打开LaTeX的姿势</title>
    <url>/2019/08/06/latex-feel-stonezeng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深夜睡不着开始刷博客看到Stone-Zeng的博客，写的真心很好呀。</p>
<p>然后今天醒来顺藤摸瓜的去看了看原文：$\LaTeX$ 的罪与罚。看了之后，这是何等的心浮气躁之人才能写出的文章。天下之大，放不下一张安静的书桌供你仔细读说明书吗？时间之长，有您写知乎吐槽的时间，看看文档，你提到的80%的问题都会解决。</p>
<p>完全未知的领域不看说明书就开始乱用，这不是Word动动鼠标就解决的。不看说明书就算了，遇到问题宛如无头苍蝇瞎折腾，东一榔头西一棒槌，模板不懂代码不懂就开始瞎改。还是不去看文档，你折腾起来的样子真像那谁。</p>
<p>$\LaTeX$是一门编程语言，在随便挑个编程语言如<code>Python</code>，任何人上手恐怕都会难免遇到错误吧。代码出错的语言不是好语言？不读想文档但我想解决问题，哪个语言能这样？恐怕是自然语言。<code>Java</code>的文档也不在少数吧，但是有人读有人会呀。不读文档，直接用别人代码，出错了就开始搜索，这种毒瘤观念，怕不是你写代码的样子也像那谁。</p>
<p>基础不牢，地动山摇。心浮气躁，邪魔乱道。要么仔细看，要么别看，这么糊弄，很浪费时间的。</p>
<a id="more"></a>
<h1 id="我的回答"><a href="#我的回答" class="headerlink" title="我的回答"></a>我的回答</h1><p>准备给他讲解$\LaTeX$的正确姿势，看评论区也是普遍：我不想学，我想直接抄，我想$\LaTeX$特别好用，我想要好模板交差，我还是不想学没必要学的态度，罢了罢了。宛如给一个人解释：买菜不用微积分，可为什么所有的大学都要开高等数学这门课一样。眼光不同，视野不同让我咋交流。</p>
<p>我只想说，要不您下次生病吃药也别看说明书了，直接吃吧，挺好的，别管一粒两粒一百粒药丸直接往嘴里塞。吃坏身体然后去怪设计药品的人太菜了设计不出好药，然后写一个知乎：论吃药的罪与罚，然后在评论区大家吃药五分钟，住院两星期的跟风。</p>
<p>不是设计药品的人不懂如何设计药品也没关系，吃药之前仔细看说明书就好了。不是开发者不懂 $\LaTeX$ 内部原理没关系，然而不看说明书就乱用，然后浪费你时间我只想说：真好。$\LaTeX$ 是一门编程语言不是Word，你学任何一门编程语言不都先看书然后一点一点敲代码嘛？写论文的编程语言就不是编程语言了？Word确实不用，要不你还是回Word吧，上手快还没不容易出错。</p>
<p>引用一个图片吧。</p>
<p><img data-src="/2019/08/06/latex-feel-stonezeng/1.jpg" alt></p>
<p>如果按你说的。想用一个东西直接百度别人的，出了问题就搜索，不怪自己怪开发者。那么我这种没学过Java的是不是可以说我精通Java，写代码之前直接抄别人的嘛，出了Error，我就去搜索解决嘛，只要遇到问题我也像你一样各种搜索，然后解决不了我也不去看Java经典的书从头学。就说Java的开发者不会开发嘛，搞的太难了，文档写的不好嘛，然后吐槽，再写一个Java的罪与罚是不是？（无意引战Java）。总结为三句话：反正我不会，反正我不学，出了错反正不能怪我，一定是开发者不会开发的问题。</p>
<p>我只想问一下，你生病了吃药之前看不看说明书的。等您下次不看说明书吃坏了再来吐槽一下。</p>
<p>若还是那个观念：我只想用它套模板写论文应付老师应付杂志社，没想学那么多东西。我想你的幼儿园、小学、初中、高中、大学、乃至硕博的老师都没有告诉你不劳而获的道理。$\LaTeX$ 是一门写论文的编程语言，但并不是你套模板且想不劳而获和不读说明书的理由。</p>
<h1 id="Liam-Huang前辈"><a href="#Liam-Huang前辈" class="headerlink" title="Liam-Huang前辈"></a>Liam-Huang前辈</h1><p>原文在这里：<a href="https://zhuanlan.zhihu.com/p/74815765" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/74815765</a></p>
<p>其实原文第一次出现在我面前就是 Zeng 在群里推送的。粗粗扫了一眼，唯一的感想就是：「这作者怕不是个友善度吧」。那么为啥咧？</p>
<p>私以为问题出在两个方面。</p>
<ul>
<li>智能手机时代 App 无需说明文档的熏陶之下，人们已经渐渐失去了「看说明书」的习惯。<strong>然后将一切不符合「我认为」的东西，归罪于「这东西不好」</strong>。——其实原文作者提出的绝大多数问题，花一个下午好好读读入门文档，都是能解决的。</li>
<li><strong>「我要我要我立即就要，不听不听我才不听」</strong>的功利心态。孩子醒醒，免费午餐和「捷径」最终都会害死你。——不限于 $\LaTeX$ 领域，适用于人生各个阶段各个领域。</li>
</ul>
<p>简而言之，你可以说它有这样那样的问题，不过前提是你以<strong>恰当</strong>的方式去了解了它。因为它有问题，而尝试掩盖和抹消「你自己」的问题，对这样<strong>自欺欺人</strong>的行为我们表示遗憾。</p>
<h1 id="李阿玲前辈"><a href="#李阿玲前辈" class="headerlink" title="李阿玲前辈"></a>李阿玲前辈</h1><p>原文在这里：<a href="https://zhuanlan.zhihu.com/p/74809700" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/74809700</a></p>
<p>对于$\LaTeX$，无论是用还是玩，这些年其实各种人都见识到了。有就想用这个搞个模版填上文字的。有纯粹是想玩的。有想研究一下排版软件的。</p>
<p><strong>这很正常。或者，甚至可以这样说：凭什么你想做成什么就真会做成什么？！</strong></p>
<p>Knuth的 $\TeX$ 他想了几个月改了几年。Lamport的$\LaTeX$ 也是弄了几年。这两位是<strong>图灵奖</strong>获得者的。凭什么你一两个小时就弄明白这俩东西？！这简直是对这两个人的智力上的侮辱。这种图灵得主顶级计算机大佬都没弄成您满意的东西，我还真希望您能弄出来，还弄的特别好，没准那年的图灵奖就是您的了，也算是为国争光。</p>
<p>一个人在没遇到一个需要超出自己理解力/智力上限的东西前，总会有一点自我感觉良好。比较之下，更恐怖的事就是：这个世界上，这种事物并不少。当然更恐慌的是，他还是个没有耐心的人。遇到问题没有耐心，使用上没耐心，提问上没耐心，最后想做的就是没做成。</p>
<p>不同的事物，经验不一定可迁移。Word里面点一点图标就能做到的事是不少。但是，很多人忽略了：点一点图标其实也不一定能把某些东西做对。而一旦想把这种经验迁移到$\LaTeX$里，那很可能能做对的事就是少数，做不出效果甚至做错的是多数。</p>
<p><strong>一把钥匙只能开符合这把钥匙的锁。当你碰到不同的锁的时候，就得换钥匙。没有别的办法。</strong></p>
<p>当然，人还要有耐心学习一个未知领域的事物。但是更应该有耐心承认自己的失败。但是，对于很多人来说，承认自己失败这一点太难了，承认自己有错误太难了。成年人的脸皮，比城墙厚，机关枪打不透的啊。</p>
<p>这会造成一个结果：把学不懂的东西认为是这个系统设计的问题。总之，锅不是自己的。挑错点评头头是道，一副专家面孔。</p>
<p>这种认识是一种特别具有直觉性的东西。我也会有，我很多时候也会有这种直觉。但是，直觉毕竟是容易产生误判。所以我自己再觉得XXX不对的时候会尝试证明出来。如果自己证明不出来，那就是自己的直觉有问题。</p>
<p>真正设计的有问题的东西，有。没有设计问题而理解有问题的东西，也有。</p>
<p>然而，对$\TeX$的批评大部分没到点子上，都可以回归为：吃药之前不看说说明书的心浮气躁。甚至可以说，最终级的对$\TeX$的批评，就是实现一个比$\TeX$好用的，排版效果不差，生态圈还大的软件作品。</p>
<p>可惜，现在还没有人做到。我写过一个版本的$\TeX$实现，但是我没什么想法。</p>
<p>或许是，他们很“聪明”，知道自己真做不出来。</p>
<h1 id="Stone-zeng的回答"><a href="#Stone-zeng的回答" class="headerlink" title="Stone-zeng的回答"></a>Stone-zeng的回答</h1><p>原文在这里：<a href="https://stone-zeng.github.io/2019-07-23-latex-crime-and-punishment/" target="_blank" rel="noopener">https://stone-zeng.github.io/2019-07-23-latex-crime-and-punishment/</a></p>
<p>你们啊，要……还是要提高自己的知识水平！我也给你们着急啊，真的。</p>
<p>这是我使用 $\LaTeX$ 的第三年，踩了很多坑后，我也开始有了对 $\LaTeX$ 的一些感悟。</p>
<p>不巧，这也是我使用 $\LaTeX$ 的第三年（从我 2015 年年底装 CTEX 套装开始算，四年不到），所以我也有「对 $\LaTeX$ 的一些感悟」。</p>
<h2 id="入门之前"><a href="#入门之前" class="headerlink" title="入门之前"></a>入门之前</h2><blockquote>
<p>在拥挤的办公桌前，面对 <code>doc</code> 文件夹下三千多个 PDF readme，我知道我这辈子都没办法做一个 $\LaTeX$ 科班生。然而，命运不会等人，我手中小小的报告，常常 24h 内就必须要飞到老师的邮箱中。</p>
</blockquote>
<p>比较不幸的是，大多数人用 $\LaTeX$ 都是被迫 / 半被迫的：你的老板可能并不会管你会不会用就直接把你逼上梁山，建模比赛别人都用我不用就没奖了（误）。但没有什么办法，<strong>24h 内掌握 $\LaTeX$ 就是不现实</strong>，至少得匀出几个礼拜到几个月的时间才能上手。既然知道「老板可能要我用一个之前没碰过的工具」，是不是应该提前预留一些学习时间呢？</p>
<blockquote>
<p>我也希望自己能做一个弄明白 $\LaTeX$ 的人。然而可惜的是，我或许永远无法将 $\LaTeX$ 看作一个「专业工具」，拿出钻研编译原理的劲儿来啃透 $\LaTeX$。</p>
<p>这或许是因为，在座的你我需要的无非是排个章节、插个图、上下标、来几行公式……我们需要一个能好好地把字母排列到理想位置的「效率软件」，而不是一个慢吞吞又挑三拣四难以融洽的「活祖宗」。</p>
</blockquote>
<p>这是很多人的困扰：我就是只要写个文章为什么要把 $\LaTeX$ 搞得这么清楚？此时可以类比如下问题：</p>
<ul>
<li>我只是写个 C 的 Hello world，怎么还要学命令行、学 Linux、学 Makefile、学 Git……？</li>
<li>我只是学计算机、学数学、学 xxx，为什么要会英语？</li>
<li>我一个理科生为什么要学语文？我一个文科生为什么要学数学？买菜又不用三角函数微积分解析几何……</li>
</ul>
<p>具体问题具体来说。不管你认不认可，(La)TEX 就是一个完备的编程语言，虽然你需要的可能只是「作为标记语言」的那一个子集。所以，准备上手之前，<strong>请务必认清楚自己的身份</strong>：</p>
<ol>
<li><p>我要按照模版写毕业论文、建模论文、期刊论文</p>
<p> 你需要找一些合适的入门材料，学习基本的语法。有模版<strong>请严格按照模版的说明操作</strong>，不要根据自己的喜好做任何修改（你的感觉与偏好在这个阶段极有可能是有问题的）。重点请放在文章的内容，而不是文章的格式。出现任何问题请找模版作者，没有必要试图自己解决。</p>
</li>
<li><p>我要记笔记、出试卷、写书</p>
<p> 同上，请先从入门开始。熟悉基本流程之后再放飞自我，刘海洋的《$\LaTeX$ 入门》可以备在手边随时翻阅。每天读两次《入门》，每次都有新收获。</p>
</li>
<li><p>我要系统学习排版知识，写模版、写宏包</p>
<p> 你可能确实要拿出「钻研编译原理的劲儿」。排版的水可能比你想象的还深，而 TEX 跟主流编程语言大相径庭也需要一些时间来掌握。Google、GitHub 和 StackExchange 将会是你的好朋友，以及，英语是必须的。</p>
</li>
<li><p>我要写世界上最好的排版引擎干掉 TEX</p>
<p> 请联系 @李阿玲。（逃</p>
</li>
<li><p>老板让我干什么我就干什么</p>
<p> 祝好运，不送。</p>
</li>
</ol>
<h2 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h2><p>知乎上老生常谈的问题，前辈们的回答可以认真读：</p>
<ul>
<li><a href="https://www.zhihu.com/question/268569440/answer/339239086" target="_blank" rel="noopener">如何在 1 小时内快速入手 $\LaTeX$？ - 刘海洋的回答</a></li>
<li><a href="https://www.zhihu.com/question/62943097/answer/203670095" target="_blank" rel="noopener">如何从零开始，入门 $\LaTeX$？ - 孟晨的回答</a></li>
<li>自学 $\LaTeX$ 可以读什么书入门？ - <a href="https://www.zhihu.com/question/26645810/answer/33515971" target="_blank" rel="noopener">刘海洋的回答</a>、<a href="https://www.zhihu.com/question/26645810/answer/33529115" target="_blank" rel="noopener">孟晨的回答</a></li>
</ul>
<p>当然也可以选择看下面的：</p>
<p>刚入门的头几步将会在很大程度上决定之后的路好不好走。不论是看了谭浩强的 C 语言，还是不知道从哪里找来的 $\LaTeX$ 教程，后果都是出现一堆稀奇古怪的问题，自己还找不到解决方法。所以，我们非常希望新手能够选择一些<strong>靠谱、合适</strong>的入门教材。</p>
<p>现在（2019 年 7 月），我们只推荐下面这些材料：</p>
<ul>
<li>一份（不太）简短的 $\LaTeX$ 2<em>ε</em> 介绍（lshort） <a href="http://mirrors.ctan.org/info/lshort/chinese/lshort-zh-cn.pdf" target="_blank" rel="noopener">[PDF]</a> <a href="https://github.com/CTeX-org/lshort-zh-cn" target="_blank" rel="noopener">[GitHub]</a></li>
<li>一份简短的安装 $\LaTeX$ 的介绍 <a href="https://github.com/OsbertWang/install_$\LaTeX$" target="_blank" rel="noopener">[GitHub]</a></li>
<li>刘海洋的《$\LaTeX$ 入门》（跳过 CTEX 套装的部分）</li>
</ul>
<p>lshort 强烈建议<strong>完整</strong>读一遍，普通文章排版所需要的几乎全部功能这里都包含了。找不到直接去《$\LaTeX$ 入门》的相关章节翻阅（当字典查）。其他网上的资料，wikibook 上的教程可以参考，知乎请认准那几位的回答，b 站鱼龙混杂谨慎使用，而 csdn、科学网博客、x 度文库请<strong>绝对不要看</strong>。</p>
<p>有人带自然很好，但请先判断他的水平。最简单的依据：如果他还在用 CTEX 套装，或 WinEdt 7.0 及以下，或代码里面出现了 <code>CJK</code> 环境，那么请立刻远离（当然，仅限 $\LaTeX$ 方面）。</p>
<p>发行版建议使用最新版 TEX Live（目前是 2019），或者在线使用 <a href="https://www.overleaf.com/" target="_blank" rel="noopener">Overleaf</a>。<strong>CTEX 套装绝对不要用</strong>。</p>
<p>最后一点提醒：如果你不小心学了假的 $\LaTeX$，建议回头重读一遍以上列出的入门材料。</p>
<h2 id="如何找模版"><a href="#如何找模版" class="headerlink" title="如何找模版"></a>如何找模版</h2><blockquote>
<p>为了写出符合学校要求的论文，谁都需要一个好用的模版，而不出意外地，我也是其中的一员。</p>
<ul>
<li>实验室的算法大神世豪搞了个模板用，折腾折腾，一编译，好使！</li>
<li>我拿来用，不好使，浪费了一两天时间。</li>
<li>实验室编码大神益达用了个模板，折腾折腾，编译一下，好使！</li>
<li>我换成他的，不好使，浪费了一两天时间。</li>
<li>我上 Github 下载了一个的 ZJUthesis</li>
<li>不好使，浪费了两三天吧。</li>
<li>换成另一个 github 上的 zju 模板，不好使。</li>
<li>这时候数学优化大神萝卜给我了一个师兄自用的模板。</li>
<li>我试了一下午，不好使。</li>
</ul>
</blockquote>
<p>怀疑你在黑 zju 然而我找不到证据……</p>
<p>首先，<strong>学长 / 学姐 / 大神 / 巨佬拷给你的模版几乎一定是不好用的</strong>。目前大多数高校的模版都挂在了 GitHub 上面，有些还发布在了 Overleaf 或者 CTAN 上面，请认准这些（半）官方渠道。（请问你会选择 <code>pip</code>、Anaconda，还是湿兄拷给你的 TensorFlow ？）</p>
<p>其次，GitHub 上面找模版，居然还去试了几个。没有经验可以告诉你一点经验：</p>
<ul>
<li>没有 README、LICENSE、<code>.gitignore</code> 的可以直接忽略（原文章居然吐槽了 LICENSE 这我还能说什么？）</li>
<li>Commit 很少，几个月内又没有什么更新，建议不要用</li>
<li>Issue 越多说明积累的问题越多，也就意味着用户越多，当然前提是作者要去处理 issue</li>
<li>Star、fork、watch 都很少的话请小心使用，不过也有可能是比较新的缘故</li>
<li>使用 <code>dtx</code> 作为源代码、有测试文件、用 ci 的模版往往更靠谱一些</li>
</ul>
<p>最后，下载下来觉得不好使。请问有看过模版的使用说明吗？有完全按照模版提供的编译说明来跑吗？这样再出现问题应该直接联系模版作者 or 跑去 GitHub 提 issue。一个靠谱的模版作者应当可以解决你的问题。</p>
<p>到此问题便得到了解决。我们可以总结一下：</p>
<ul>
<li><p>有问题请尽快整理出示例，向更有经验的人求助。一知半解 + 穷折腾很有可能会把问题代入死胡同。</p>
</li>
<li><p>一定要给出</p>
<p>  最小工作示例（MWE）：</p>
<ul>
<li>应当是一个<strong>完整</strong>的、在你的电脑上<strong>能编译</strong>的 $\LaTeX$文档</li>
<li>何为完整？以 <code>\documentclass</code> 开始，以 <code>\end{document}</code> 结束</li>
<li>在你电脑上的编译结果，应当能<strong>复现问题</strong>，或<strong>体现需求</strong></li>
<li>与复现问题和体现需求<strong>无关的代码应尽可能少</strong>，如各种宏包的加载、自定义的命令等</li>
<li>尝试更换为标准文档类（<code>article</code>、<code>ctexart</code>）等</li>
<li>如果复现问题需要其他文件（图片、<code>bib</code> 等），请把它们和 LaTEX 文档一起打包</li>
<li>对你的论文不感兴趣，如果你不变透漏论文代码我也不便帮你解决问题。</li>
</ul>
</li>
<li><p>给出 MWE 的过程就是 debug 的过程。这时需要进一步删掉无关代码，呈现问题原貌，此时可以：</p>
<ul>
<li>Print 大法好！TEX 的 <code>\show</code> 命令可以展示宏的内容，而 LaTEX3 还提供了更多的类似函数</li>
<li>一点点注释掉无关内容，二分法定位</li>
<li>插断点，实际上 <code>\show</code> 的时候编译会中止，我们常利用多个 <code>\show</code> 来定位 bug</li>
</ul>
</li>
</ul>
<h2 id="TEX-要面向现代化、面向世界、面向未来"><a href="#TEX-要面向现代化、面向世界、面向未来" class="headerlink" title="TEX 要面向现代化、面向世界、面向未来"></a>TEX 要面向现代化、面向世界、面向未来</h2><p>众所周知，(La)TEX 是一个很古老的东西，很多问题归根结底都源自于历史的局限。「新一代」的引擎 XETEX 和 LuaTEX 十多年前就进了 TEX Live，阿玲姐姐的那一个也指日可待。然而却还总有人试图靠 8-bit 引擎来解决 CJK 问题，对这样固步自封的行为我们表示遗憾。</p>
<p>语言方面，宏语言捉襟见肘的表达能力确实是一个问题。但 LaTEX3 也在逐渐成熟，二十多年积累下来的方方面面的经验使得它正在成为标准库一样的东西。当有了统一的框架，可以想见开发与使用都将变得更加容易。与此同时，ConTEXt 那边也在持续地尝试新的想法，对 variable fonts 和 color fonts 的支持 2017 年就已经做了。所以，在追赶潮流的能力上 TEX 丝毫不比那几家商业公司差多少（误）。</p>
<p>作为开发者，我们自然希望用户的使用门槛可以一降再降，遇到的坑也能够越来越少。不过，这都建立在用户自己有尝试、探索、讨论与交流的热情之上。遇到问题，只会无头苍蝇一样四处乱撞，或者阴阳怪气地嘲讽，我们只能提醒你：<strong>恐怕使用 Word 的能力你也没有</strong>。</p>
<p>bye</p>
<p>最后，其实Word用好了也不容易，入门门槛低，但是上限真的挺高的。对于本科生：我记得知乎上有人写了如何使用Word写科技论文。即使你用Word写过国赛论文写过美赛论文自以为能驾驭Word，其实还差的很远，我敢保证里面 70% 的操作不是常规操作，你没见过的， Word的上限还是挺高的。对于研究生：真的会 $\LaTeX$ 谁还用Word是吧。</p>
<hr>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX补充:有关参考文献大小写问题</title>
    <url>/2019/02/03/latex-supplement1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="参考文献中的大小写问题"><a href="#参考文献中的大小写问题" class="headerlink" title="参考文献中的大小写问题"></a>参考文献中的大小写问题</h1><div class="note success"><p>如果给定了指定的bst样式，比如选择plain或者IEEE或者ACM，此时可能会出现：原本的参考文献标题是大写，但是在论文中编程小写的情况，此时，并不算自己引用错误，而是格式要求，按要求来即可。</p></div>

<a id="more"></a>
<p>此处参考与感谢：</p>
<p><a href="https://github.com/CTeX-org/forum/issues/8" target="_blank" rel="noopener">https://github.com/CTeX-org/forum/issues/8</a></p>
<hr>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX补充:如何设置代码字体</title>
    <url>/2019/02/04/latex-supplement2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设置代码字体"><a href="#设置代码字体" class="headerlink" title="设置代码字体"></a>设置代码字体</h1><p><code>listings</code> 宏包的原作者觉得，不应该把字体的审美强加于用户，所以「裸用」<code>lstlisting</code> 环境列出代码，结果就是源代码会使用「正文字体」被显示出来。</p>
<p>很明显地，源代码使用了「正文字体」（看起来很像 Times New Roman Computer Modern Roman），虽然说是按字母对齐，但是极丑无比。这个「正文字体」本身是「比例字体」，也就是说每个字母宽度本来就是不一样的，例如 <code>m</code> 就会比较宽、<code>i</code> 就会比较窄。「比例字体」不适合用于源代码的抄录，所以强调了要设置「等宽字体」。</p>
<a id="more"></a>
<p>实话说，什么字体都不设置，直接在导言区写一句：<code>\lstset{basicstyle=\ttfamily}</code> 就是可以的。在这里面的 <code>\ttfamily</code> 就是在告诉 <code>lstlisting</code> 环境「给我用等宽字体来显示源代码」。</p>
<p>再次强调，<code>\setmainfont</code> 设置的是「正文字体」，<code>main</code> 对应「正文」，您都指定正文字体为 Courier 了，页眉页脚作为正文的一部分当然会变成 Courier 啊。想用 Courier，就要通过 <code>\setmonofont</code> 来声明，<code>mono</code> 对应「等宽」。<strong>注意两个命令的拼写是不一样的！</strong></p>
<p>我在这里给出一个同时设置正文字体与等宽字体的例子。重要的事情重复三遍：用了 <code>fontspec</code> 之后，<strong>不要再用传统字体包！不要再用传统字体包！不要再用传统字体包！</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 用 XeLaTeX 或 LuaLaTeX 编译</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;fontspec&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 以下设置正文字体为 Palatino 的克隆体</span></span><br><span class="line"><span class="tag">\<span class="name">setmainfont</span><span class="string">&#123;TeX Gyre Pagella&#125;</span></span></span><br><span class="line"><span class="comment">% 以下设置等宽字体为 Courier 的克隆体</span></span><br><span class="line"><span class="tag">\<span class="name">setmonofont</span><span class="string">&#123;TeX Gyre Cursor&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;listings&#125;</span></span></span><br><span class="line"><span class="comment">% 以下告诉 lstlisting 环境：我要用等宽字体列代码！</span></span><br><span class="line"><span class="tag">\<span class="name">lstset</span><span class="string">&#123;basicstyle=\ttfamily&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">section</span><span class="string">&#123;Hello, world!&#125;</span></span></span><br><span class="line"></span><br><span class="line">Hello, world! Would you like to see some code?</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;lstlisting&#125;</span></span></span><br><span class="line">Happy <span class="tag">\<span class="name">LaTeX</span><span class="string">&#123;&#125;</span></span>ing!</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;lstlisting&#125;</span></span></span><br><span class="line">See? Mono-spaced font for code and proportional font for body text.</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<p><img data-src="/2019/02/04/latex-supplement2/2.png" alt></p>
<p>此处参考与鸣谢：</p>
<p><a href="https://github.com/CTeX-org/forum/issues/7" target="_blank" rel="noopener">https://github.com/CTeX-org/forum/issues/7</a></p>
<hr>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX补充:中英文不同的字体设置</title>
    <url>/2019/03/02/latex-supplement3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为一个<code>Texer</code>，说实话对字体的设置掌握一直不是很好，今天又学习到了新姿势，分别设置中英文字体。</p>
<a id="more"></a>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="comment">% 英文字体配置部分</span></span><br><span class="line"><span class="tag">\<span class="name">setmainfont</span><span class="string">&#123;Source Serif Pro&#125;</span></span><span class="comment">%Times New Roman</span></span><br><span class="line"><span class="tag">\<span class="name">setsansfont</span><span class="string">&#123;Source Sans Pro&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">setmonofont</span><span class="string">&#123;Source Code Pro&#125;</span></span></span><br><span class="line"><span class="comment">% 中文字体配置部分</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;xeCJK&#125;</span></span><span class="comment">%中文字体</span></span><br><span class="line"><span class="tag">\<span class="name">setCJKmainfont</span><span class="string">&#123;宋体&#125;</span></span><span class="comment">%正文字体</span></span><br><span class="line"><span class="tag">\<span class="name">setCJKsansfont</span><span class="string">&#123;黑体&#125;</span></span><span class="comment">%无衬线字体</span></span><br><span class="line"><span class="tag">\<span class="name">setCJKmonofont</span><span class="string">&#123;楷体&#125;</span></span><span class="comment">%等宽字体</span></span><br><span class="line"><span class="tag">\<span class="name">setCJKfamilyfont</span><span class="string">&#123;boldsong&#125;</span><span class="string">&#123;Source Han Serif SC Heavy&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">  	中文测试</span><br><span class="line">  	</span><br><span class="line">  	English test</span><br><span class="line">  	</span><br><span class="line">  	<span class="tag">\<span class="name">sffamily</span></span> 无衬线字体</span><br><span class="line">  	</span><br><span class="line">  	<span class="tag">\<span class="name">ttfamily</span></span> 等宽字体</span><br><span class="line">  	</span><br><span class="line">  	<span class="tag">\<span class="name">sffamily</span></span> in English typing</span><br><span class="line">  	</span><br><span class="line">  	<span class="tag">\<span class="name">ttfamily</span></span> in English typing</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img data-src="/2019/03/02/latex-supplement3/1.png" alt></p>
<p>此处参考：</p>
<p><a href="https://camuseblog.top/2019-03-01-/TeX-Record/" target="_blank" rel="noopener">https://camuseblog.top/2019-03-01-/TeX-Record/</a></p>
<hr>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX补充:常用实惠小工具</title>
    <url>/2019/02/04/latex-supplement4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note success"><p>写 LaTeX 的时候排版表格是不是有想杀人的冲动？Ctex 发行版问题太多？数学符号不会写？参考文献管理太复杂？这里给出常用的实惠小工具，愉快的书写LaTeX 代码。</p></div>

<a id="more"></a>
<p>快速绘制表格：<br><a href="http://excel2latex.com/" target="_blank" rel="noopener">http://excel2latex.com/</a></p>
<p>LaTeX 中数学公式转图片：<br><a href="https://viereck.ch/latex-to-svg/" target="_blank" rel="noopener">https://viereck.ch/latex-to-svg/</a></p>
<p>LaTeX 中书写不认识的数学符号：<br><a href="http://detexify.kirelabs.org/classify.html?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">http://detexify.kirelabs.org/classify.html?tdsourcetag=s_pctim_aiomsg</a></p>
<p>在线编译LaTeX：<br><a href="https://www.overleaf.com/" target="_blank" rel="noopener">https://www.overleaf.com/</a></p>
<p>好用的编辑器？sublime，vscode，notepad++，看个人口味。如果是<code>vim</code>大佬当然不在乎这些。</p>
<p>带相关开发环境的编辑器？texstduio（相当不错），texmaker（用过一次，功能好弱鸡），winedit（垃圾中的战斗机，latex都不收费，一个破编辑器还好意思收费）</p>
<p>刺激的发行版（编译器）？我个人是使用texlive的，不用考虑自己安装宏包的麻烦。前期安装复杂，后期操作绝对省心。下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a></p>
<p>似乎看到了编程的两件套，编译器加编辑器或者IDE。</p>
<p>miktex只是听说过，会及时安装需要的包，前期省事可能后期麻烦。如果想学习，给个传送门：<br><a href="https://camuseblog.top/2019-03-02-/MiKTeX/" target="_blank" rel="noopener">https://camuseblog.top/2019-03-02-/MiKTeX/</a></p>
<p>miktex和texlive二选一即可，但是不要听任何老师和学长学姐的建议去安装<code>Ctex</code>，此发行版已经过时，近10年没人维护，到处是BUG，极其难用，正常代码都运行不了。</p>
<hr>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>双系统之间快速访问对方文件</title>
    <url>/2020/07/03/linux-windows-files-exchange/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实之前想整理一下 <code>Linux</code> 系统的使用技巧的，但想想还是算了，第一工程量大；第二，很多命令打多了也就记住了，这玩意还得靠熟练；第三，个人使用期间也时常维修各种驱动问题，时常换源，每次解决步骤也没有保留下来，电脑出错因人而异，修理方式也不尽相同，所以考虑再三就没有记录。随着使用时间的累计，相信各位会有一定的排查经验的。</p>
<a id="more"></a>
<p>目前在一块硬盘上装有<code>linux</code>系统和<code>windows</code>系统。双系统目前的分工是：<code>linux</code> 负责程序的开发，如 <code>Python， LaTeX，C++，Arduino</code>等，<code>windows</code>负责 <code>office</code> 等操作，如<code>word，excel，QQ</code>和腾讯会议等。</p>
<p>但在这期间遇到了一些麻烦，如写毕业论文的时候，在<code>linux</code>下写好的程序，需要在<code>windows</code>中使用<code>word</code>将程序添加到附录中。我一般的方法是将代码传到 <code>github</code>，利用 <code>github</code> 作为双系统之间文件交互的桥梁。退出<code>linux</code>，进入<code>windows</code>，打开<code>github</code>，粘贴代码到<code>word</code>中。如果需要修改代码，就要退出<code>windows</code>，进入<code>linux</code>，再来一个循环。</p>
<p>每次退出系统都需要重启电脑，实在是麻烦。今天无法忍受，决定研究下双系统如何快速访问对方的文件，即<code>linux</code>如何快速访问<code>windows</code>中的文件，<code>windows</code>如何快速访问<code>linux</code>中的文件。</p>
<h1 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h1><p><strong>挂载</strong>（mount）是指由操作系统使一个存储设备，诸如硬盘上的计算机文件和目录可供用户计算机文件系统访问的过程。这里有两个重点：第一是要有存储设备，第二个是计算机的文件系统能访问存储设备中的文件。</p>
<p>通俗而言，在<code>windows</code>系统下，将U盘插入<code>USB</code>接口，电脑打开U盘，这就叫挂载。在<code>linux</code>下，将存储设备接入到一个存在的目录上（目录不能为空），因为<code>linux</code>操作系统将所有的设备都看作文件，我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。</p>
<h1 id="linux访问windows文件"><a href="#linux访问windows文件" class="headerlink" title="linux访问windows文件"></a>linux访问windows文件</h1><p>既然知道了挂载的操作，那么就行动起来。首先通过<code>fdisk -l</code>来查看硬盘信息：<img data-src="/2020/07/03/linux-windows-files-exchange/2.png" alt></p>
<p>根据实际情况，我知道<code>/dev/nvme0n1p3</code>对应<code>windows</code>的<code>C</code>盘，<code>/dev/nvme0n1p4</code>对应<code>windows</code>的<code>D</code>盘，而我想看的数据在<code>C</code>盘，所以我们要挂载<code>/dev/nvme0n1p3</code>。</p>
<ol>
<li><p>首先创建挂载目录：<code>sudo mkdir /mnt/windows</code>；</p>
</li>
<li><p>之后开始挂载：<code>mount /dev/nvme0n1p3 /mnt/windows</code>；</p>
</li>
<li>然后 <code>cd /mnt/windows</code>，此时我们发现文件已经过来了，然后<code>cd Users/lanling/Desktop</code>就能查看<code>windows</code>桌面中的文件，需要拷贝仅需<code>cp</code>命令拷贝到某个路径即可，再也不用来回重启了。也印证了我所使用的计算机文件系统能访问<code>windows</code>中的文件。<img data-src="/2020/07/03/linux-windows-files-exchange/3.png" alt></li>
<li>需要注意的是，在使用完毕后需要解除挂载，命令为：<code>umount /mnt/windows</code>，另外不要在<code>/mnt/windows</code>文件夹下进行解除挂载，会提示错误，在其他位置解除挂载就可以了。<img data-src="/2020/07/03/linux-windows-files-exchange/1.png" alt></li>
</ol>
<h1 id="windows访问linux文件"><a href="#windows访问linux文件" class="headerlink" title="windows访问linux文件"></a>windows访问linux文件</h1><p>众所周知<code>windows</code>的命令行比较弱（本人不想安装<code>wsl</code>之类），所以决定下载个软件，搜寻了一番，还真有：名字叫做<a href="https://www.paragon-software.com/home/linuxfs-windows/" target="_blank" rel="noopener">Linux File Systems for Windows by Paragon Software</a>，软件使用就很简单了，打开，挂载，这里提示挂载到<code>E</code>盘。<img data-src="/2020/07/03/linux-windows-files-exchange/4.png" alt></p>
<p>然后去资源管理器中打开<code>E</code>盘，会看到<code>linux</code>中的各种文件，之后的操作就很轻松了。但是这个软件收费，且，会开机自己启动，还找不到设置的地方，感觉很流氓。</p>
<p>在相同易用程度下，我找到了个免费、不流氓的软件，叫<a href="https://www.diskinternals.com/linux-reader/" target="_blank" rel="noopener">Diskinternals Linux Reader</a>。操作极度简单，就不截图演示了。选择盘符，双击进去，找到自己想访问的文件，右键，保存到桌面即可。</p>
]]></content>
      <tags>
        <tag>Computer</tag>
      </tags>
  </entry>
  <entry>
    <title>关于停止更新博客的通知</title>
    <url>/2020/01/07/maintenance-blog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>放心，不久的将来会继续更新的。本来是说停止的，结果也没停止成功，算是维护吧。</p>
<p>停止更新的理由很简单，受之有愧啊。最近打开博客，看到每天的访问人数和访问量都在一百左右，对于我来说很大了。而有的文章的访问量在500+，可那篇文章我写的并不好，受之有愧；假设不是写的不好而是写错了，我将会耽误很多人的时间和精力，更加惭愧。如果哪些文章写错了，请来信声讨。</p>
<a id="more"></a>
<p>为啥不用某乎、某DN、某书和某聊天号？因为：</p>
<blockquote>
<ul>
<li>没技术门槛的东西谁都能乱写、瞎写，上古技术、复读、潦草的排版、错解占据了主流</li>
<li>现在公众好最常见的吸引眼球的手法：『举个例子，我这个朋友这样这样，我那个朋友那样那样』，很烦</li>
<li>终究是盈利工具，容易恰饭，最可耻的行为：借助某种情怀来忽悠非专业人士达到吸引流量的目的，如某通信技术。全文与技术无关，只是在刷消费者的情怀，并无一个专业人士对技术的解读与分析（也没人敢）。而我是理工科的学生，理性分析客观评价大于一切。</li>
</ul>
</blockquote>
<p>而新建博客的时候还是在大二末，知识储备不足，技术能力差，见识范围狭窄。以至于写出来的文章都很『年轻』，甚至有些许的错误。我翻了的当年写过的代码，这是哪个zz写出来的，哦，对了原来是我写的，已经不想承认那些代码是我写的了。</p>
<p>当时只是觉得搭博客很好玩，是自己技术的DIY，不是处处受限的第三方平台，能体现我是科班出身的，新鲜感十足，于是写了很多不太好的技术文章甚至还有很多愤青的东西，甚至还有错别字，暴露了我阅历的不足。正如开头所说，搭博客的初衷是好玩和DIY，也有写好几篇技术文章的想法，并无蹭流量和打广告等恰饭行为，于是停止更新也算预料之中的事情。</p>
<p>当然也感谢各位多年来的支持and不骂之恩，我也会越做越好and，等我有钱了可以办网页在线抽奖活动呀。</p>
<p><img data-src="/2020/01/07/maintenance-blog/6.jpg" alt></p>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>网络最大流问题</title>
    <url>/2018/12/13/max-flow/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很遗憾的是这里不给出算法的实现过程，但是我可以给个讲的不错的链接。<a href="https://blog.csdn.net/LiRewriter/article/details/78759337" target="_blank" rel="noopener">这里的最大流讲的不错</a></p>
<p>主要给出最大流的实现代码和应用背景，以及问题变化时的解决方案。</p>
<a id="more"></a>
<p>如果对本文有疑问或者想找男朋友，可以联系我，<a href="https://muyuuuu.github.io/about/">点击此处有我联系方式</a>。</p>
<p><img data-src="/2018/12/13/max-flow/1.png" alt></p>
<p><img data-src="/2018/12/13/max-flow/2.png" alt></p>
<p><img data-src="/2018/12/13/max-flow/3.png" alt></p>
<p><img data-src="/2018/12/13/max-flow/4.png" alt></p>
<p><img data-src="/2018/12/13/max-flow/5.png" alt></p>
<hr>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>代码写的太烂，放到网上容易影响他人，所以删除了，有空在补上吧。</p>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>两种最短路径</title>
    <url>/2018/11/24/min-path/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文收录了Dijkstra和floyd求解最短路径的算法实现。这两个算法建议看看算法导论这本书，网上乱七八糟的什么错误都敢往上写。</p>
<ul>
<li><p>Dijkstra类似贪心算法，从某个点出发不断的贪心，求得和其他点的最短路径。</p>
</li>
<li><p>Floyd为动态规划算法，不断的更新子问题，使得每两点之间的距离不断的减小。</p>
</li>
</ul>
<p>如果问题发生了变化，比如最短路径不唯一时，我想走顶点最少的路径；或者在两点之间，我想走那个顶点最少的路径，又该怎么转化呢？则称为最短路最小顶点问题，<del>本文也给出自己的解决方案</del>写的太烂，删除了。</p>
<a id="more"></a>
<p>如果对本文有疑问或者想找男朋友，可以联系我，<a href="https://muyuuuu.github.io/about/">点击此处有我联系方式</a>。</p>
<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_matrix</span><span class="params">(vex_num)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    随机图顶点矩阵生成器</span></span><br><span class="line"><span class="string">    输入：顶点个数，即矩阵维数</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    data_matrix =[</span><br><span class="line">                [<span class="number">0</span>, <span class="number">50</span>, sys.maxsize, <span class="number">40</span>, <span class="number">25</span>, <span class="number">10</span>], </span><br><span class="line">                [<span class="number">50</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">20</span>, sys.maxsize, <span class="number">25</span>], </span><br><span class="line">                [sys.maxsize, <span class="number">15</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>, sys.maxsize], </span><br><span class="line">                [<span class="number">40</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">25</span>],</span><br><span class="line">                [<span class="number">25</span>, sys.maxsize, <span class="number">20</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">55</span>], </span><br><span class="line">                [<span class="number">10</span>, <span class="number">25</span>, sys.maxsize, <span class="number">25</span>, <span class="number">55</span>, <span class="number">0</span>]</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data_matrix</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floyd</span><span class="params">(data_matrix, vex_num)</span>:</span></span><br><span class="line"></span><br><span class="line">    dist_matrix = data_matrix</span><br><span class="line">    path_matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]] * <span class="number">6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(vex_num):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(vex_num):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(vex_num):</span><br><span class="line">                temp = dist_matrix[i][k] + dist_matrix[k][j]</span><br><span class="line">                <span class="keyword">if</span> dist_matrix[i][j] &gt; temp:</span><br><span class="line">                    dist_matrix[i][j] = temp</span><br><span class="line">                    path_matrix[k][i] = path_matrix[i][j]</span><br><span class="line">    <span class="keyword">return</span> dist_matrix, path_matrix</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__  ==  <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    vex_num = <span class="number">6</span></span><br><span class="line">    data_matrix = random_matrix(vex_num)</span><br><span class="line">    dist_matrix , path_matrix = np.array(floyd(data_matrix, vex_num))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(vex_num):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(vex_num):</span><br><span class="line">            <span class="keyword">print</span> ( str(i) + <span class="string">'-----&gt;'</span> + str(j) + <span class="string">'  shortest_path distance is : '</span>, dist_matrix[i][j])</span><br><span class="line"></span><br><span class="line">    print(path_matrix)</span><br></pre></td></tr></table></figure>
<h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This is a program to illustrate the detail of dijkstra algorithm.</span></span><br><span class="line"><span class="comment"># 这里为了引入无穷大这个概念</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">adjacency_matrix = [</span><br><span class="line">                [<span class="number">0</span>, <span class="number">50</span>, sys.maxsize, <span class="number">40</span>, <span class="number">25</span>, <span class="number">10</span>], </span><br><span class="line">                [<span class="number">50</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">20</span>, sys.maxsize, <span class="number">25</span>], </span><br><span class="line">                [sys.maxsize, <span class="number">15</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>, sys.maxsize], </span><br><span class="line">                [<span class="number">40</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">25</span>],</span><br><span class="line">                [<span class="number">25</span>, sys.maxsize, <span class="number">20</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">55</span>], </span><br><span class="line">                [<span class="number">10</span>, <span class="number">25</span>, sys.maxsize, <span class="number">25</span>, <span class="number">55</span>, <span class="number">0</span>]</span><br><span class="line">            ]</span><br><span class="line">            </span><br><span class="line">node_number = len(adjacency_matrix[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#已经访问过的节点列表，0与1表示了有与无的概念，1表示访问过</span></span><br><span class="line">visited = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(node_number)]    </span><br><span class="line">visited[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#表示与起始点的距离</span></span><br><span class="line">want_node = <span class="number">0</span></span><br><span class="line">path = adjacency_matrix[want_node]    </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, node_number):</span><br><span class="line"></span><br><span class="line">    min_value_index = int()</span><br><span class="line">    mindis = sys.maxsize</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, node_number):</span><br><span class="line">        <span class="keyword">if</span> visited[j] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> path[j] &lt; mindis:</span><br><span class="line">            min_value_index = j</span><br><span class="line">            mindis = path[j]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每次更新最短</span></span><br><span class="line">    visited[min_value_index] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, node_number):</span><br><span class="line">        <span class="keyword">if</span> visited[j] == <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#如果新加入的点使得距离更短则刷新</span></span><br><span class="line">            <span class="keyword">if</span> path[j] &gt; path[min_value_index] + adjacency_matrix[min_value_index][j]:  </span><br><span class="line">                path[j] = path[min_value_index] + adjacency_matrix[min_value_index][j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(path)):</span><br><span class="line">    print(str(want_node) + <span class="string">' -&gt; '</span> + str(i) + <span class="string">' distance is : '</span> + str(path[i]))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2018/11/07/min-span-tree/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文收录内容：Kruskal和Prim两个算法，基于Python实现的<a href="https://en.wikipedia.org/wiki/Minimum_spanning_tree" target="_blank" rel="noopener">最小生成树</a>。</p>
<p>最小生成树的背景：$n$个村庄，每个村庄之间只能修一条路，如何使得总路径最短。</p>
<ul>
<li>Kruskal从最短的边开始寻找，避免回路，加入$n-1$条边后就是最小生成树。</li>
<li>Prim是从某个定点出发，定点加入点集$T$，选择与定点相邻距离最短的点加入$T$，并从$T$出发继续寻找，以此类推。</li>
</ul>
<a id="more"></a>
<p>如果对本文有疑问或者想找男朋友，可以联系我，<a href="https://muyuuuu.github.io/about/">点击此处有我联系方式</a>。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maps)</span>:</span></span><br><span class="line">        self.maps = maps</span><br><span class="line">        self.nodenum = self.get_nodenum()</span><br><span class="line">        self.edgenum = self.get_edgenum()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_nodenum</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.maps)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_edgenum</span><span class="params">(self)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.nodenum):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> self.maps[i][j] &gt; <span class="number">0</span> <span class="keyword">and</span> self.maps[i][j] &lt; <span class="number">9999</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kruskal</span><span class="params">(self)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> self.nodenum &lt;= <span class="number">0</span> <span class="keyword">or</span> self.edgenum &lt; self.nodenum<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        edge_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.nodenum):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, self.nodenum):</span><br><span class="line">                <span class="keyword">if</span> self.maps[i][j] &lt; <span class="number">9999</span>:</span><br><span class="line">                    <span class="comment">#按[begin, end, weight]形式加入边</span></span><br><span class="line">                    edge_list.append([i, j, self.maps[i][j]])</span><br><span class="line">        <span class="comment">#按照边的权重进行排序</span></span><br><span class="line">        edge_list.sort(key=<span class="keyword">lambda</span> a:a[<span class="number">2</span>])</span><br><span class="line">       <span class="comment"># 统计每个点有几个</span></span><br><span class="line">        group = [[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(self.nodenum)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edge_list:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(group)):</span><br><span class="line">                <span class="comment"># 边的起点</span></span><br><span class="line">                <span class="keyword">if</span> edge[<span class="number">0</span>] <span class="keyword">in</span> group[i]:</span><br><span class="line">                    m = i</span><br><span class="line">                <span class="comment"># 边的终点</span></span><br><span class="line">                <span class="keyword">if</span> edge[<span class="number">1</span>] <span class="keyword">in</span> group[i]:</span><br><span class="line">                    n = i</span><br><span class="line">            <span class="keyword">if</span> m != n:</span><br><span class="line">                res.append(edge)</span><br><span class="line">                group[n] = group[m] + group[n]</span><br><span class="line">                <span class="comment"># m点已经走过，清空，防止下次遍历</span></span><br><span class="line">                group[m] = []</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prim</span><span class="params">(self)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> self.nodenum &lt;= <span class="number">0</span> <span class="keyword">or</span> self.edgenum &lt; self.nodenum<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 初始第一个点</span></span><br><span class="line">        seleted_node = [<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 剩余的点</span></span><br><span class="line">        candidate_node = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, self.nodenum)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> len(candidate_node) &gt; <span class="number">0</span>:</span><br><span class="line">            begin, end, minweight = <span class="number">0</span>, <span class="number">0</span>, <span class="number">9999</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> seleted_node:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> candidate_node:</span><br><span class="line">                    <span class="keyword">if</span> self.maps[i][j] &lt; minweight:</span><br><span class="line">                        minweight = self.maps[i][j]</span><br><span class="line">                        begin = i</span><br><span class="line">                        end = j</span><br><span class="line">            res.append([begin, end, minweight])</span><br><span class="line">            <span class="comment"># 加入新的点</span></span><br><span class="line">            seleted_node.append(end)</span><br><span class="line">            <span class="comment"># 删除已添加的点</span></span><br><span class="line">            candidate_node.remove(end)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	maps = [</span><br><span class="line">	[<span class="number">0</span>, <span class="number">7</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">5</span>], </span><br><span class="line">	[<span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">100</span>], </span><br><span class="line">	[<span class="number">100</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">100</span>, <span class="number">4</span>],</span><br><span class="line">	[<span class="number">3</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">10</span>], </span><br><span class="line">	[<span class="number">100</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">4</span>], </span><br><span class="line">	[<span class="number">5</span>, <span class="number">100</span> ,<span class="number">4</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>]</span><br><span class="line">]	</span><br><span class="line"></span><br><span class="line">	graph = Graph(maps)</span><br><span class="line">	print(<span class="string">'邻接矩阵为\n%s'</span>%np.array(graph.maps))</span><br><span class="line">	print(<span class="string">'节点数据为%d，边数为%d\n'</span>%(graph.nodenum, graph.edgenum))</span><br><span class="line">	print(<span class="string">'---------------------Kruskal---------------------'</span>)</span><br><span class="line">	print(graph.kruskal())</span><br><span class="line">	print(<span class="string">'---------------------Prim------------------------'</span>)</span><br><span class="line">	print(graph.prim())</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>meta-learning 通俗入门</title>
    <url>/2020/09/20/meta-learning/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>又来做小样本问题了，别问，问就是我也不知道，方向换来换去的。我看过 Life long learning，深度学习的聚类，大规模图划分（我只是感觉这几年算法岗很内卷，泡沫化严重。不管什么专业的，都可以来搞计算机或智能，门槛低但要求高，甚至跨专业来的还认为撕代码没用，这个行业一言难尽。</p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Machine learning 中，我们的目标是定义一个神经网络，训练数据并获取输出，且希望输出的准确率很高，这可以简化为 $f(\text{data})=\hat{y}$，如下图所示：</p>
<p><img data-src="/2020/09/20/meta-learning/1.png" alt></p>
<p>而在 meta learning 中，则是让机器学会如何学习。假设现在有多个任务，第一个任务是猫狗分类，第二个任务是数字识别，以此类推就不一一举例了。meta learning 的目标就是让网络基于过去的任务获取学习技巧，并能快速应用到其他任务中。比如：分类中，知道猫和狗纹理不一样后，能快速学习出数字 1 和数字 3 不一样。（每一个任务都有一个模型，希望未来基于已有经验能学的更快更好）。在通俗一点，你学过 C++，那么再去学 java 就很快，有经验在那。</p>
<p>meta learning 的目标就是寻找一个 $F$，使得$F(\text{data})=f$，生成的 $f$ 是完成任务，$F$ 就表示其学习能力。</p>
<h1 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h1><p><img data-src="/2020/09/20/meta-learning/3.png" alt></p>
<p>如上图所示，灰白背景为整个 $F$，生成的结果为 $f$。其中：参数初始化、网络结构设计和参数的更新方法是 $F$ 可以学习的。最后得到每个任务的参数 $\theta$。比如 $\theta^1$ 用于第一个任务，$\theta^2$ 用于第二个任务。</p>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>那么如何评价 $F$ 的好坏呢？或者说，$F$ 的损失函数该如何写？这里采用简单的任务损失求和的形式来表示：</p>
<p>\begin{equation}<br>    L(F)=\sum_{i=1}^n l^n<br>\end{equation}</p>
<p>其中 $l^n$ 为第 $n$ 个任务的损失。（你可以自由发挥加点正则什么的），找到一个最好的 $F^{*}$，使得 $F^*=\arg\min_FL(F)$。</p>
<h2 id="训练与测试数据"><a href="#训练与测试数据" class="headerlink" title="训练与测试数据"></a>训练与测试数据</h2><ul>
<li>训练期间：在每个训练任务中，也就是上图的 Task 1, Task 2，每个任务都需要准备训练数据和测试数据。训练数据一般称为 Support set, 测试数据为 Query set。</li>
<li>测试期间：因为要考察的是 $F$ 的学习能力如何，所以测试的任务和训练的任务不同。</li>
</ul>
<h2 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h2><h3 id="MAML-方法"><a href="#MAML-方法" class="headerlink" title="MAML 方法"></a>MAML 方法</h3><p>这里仅仅以初始化参数为例，不介绍梯度下降的方法或机器自动调 NN 的结构。为避免混乱，先说明一些符号：</p>
<ul>
<li>$l^n$，第 $n$ 个任务的损失；</li>
<li>$\theta^n$，第 $n$ 个任务的参数；</li>
<li>$\phi$ 初始化参数；</li>
<li>$\hat{\theta}$ 所有任务的参数。</li>
</ul>
<p>首先列出损失函数：</p>
<p>\begin{equation}<br>L(\phi)=\sum_{i=1}^N l^n (\theta^n)<br>\end{equation}</p>
<p>初始化参数 $\phi$ 的更新方式为（全局）：</p>
<p>\begin{equation}<br>\phi_t = \phi_{t-1}-\eta \nabla_\phi L(\phi), \; \nabla_\phi L(\phi)=\sum_{i=1}^n\nabla_\phi l^n(\theta^n)<br>\end{equation}</p>
<p>其中，$\nabla_\phi l^n(\theta^n)$的展开式为：</p>
<p>\begin{bmatrix}<br>\partial l_1/\partial\phi_1 &amp; \partial l_2/\partial\phi_1 &amp; \ldots &amp; \partial l_n/\partial\phi_1\\<br>\partial l_1/\partial\phi_2 &amp; \partial l_2/\partial\phi_2 &amp; \ldots &amp; \partial l_n/\partial\phi_2\\<br>\partial l_1/\partial\phi_3 &amp; \partial l_2/\partial\phi_3 &amp; \ddots &amp; \partial l_n/\partial\phi_3\\<br>\partial l_1/\partial\phi_n &amp; \partial l_2/\partial\phi_n &amp; \ldots &amp; \partial l_n/\partial\phi_n\\<br>\end{bmatrix}</p>
<p>因为一个 $\phi$ 对应很多 $\theta$，所以由链式求偏导法则我们可以知道下图的关系式（以上面矩阵中单个元素为例，所以 $l$ 就不带任何角标了）：</p>
<p>\begin{equation}<br>\frac{\partial l}{\partial \phi_i} = \sum_{j}\frac{\partial l \partial \theta_j}{\partial \theta_j \partial \phi_i}<br>\end{equation}</p>
<p>而在每一个任务中，参数 $\theta$ 的更新方式为（单个任务）：</p>
<p>\begin{equation}<br>\theta_j=\phi_j-\epsilon\nabla_\phi l(\phi_j)=\phi_j-\epsilon\frac{\partial l(\phi_j)}{\partial \phi}<br>\end{equation}</p>
<p>所以：</p>
<p>\begin{cases}<br>\frac{\partial \theta_j}{\partial \phi_i}=-\epsilon\frac{\partial l(\phi)}{\partial \phi_i \partial \phi_j} \approx 0 &amp; i \neq j \\<br>\frac{\partial \theta_j}{\partial \phi_i}=1-\epsilon\frac{\partial l(\phi)}{\partial \phi_i \partial \phi_j} \approx 1 &amp; i = j<br>\end{cases}</p>
<p>取消第二项的二次微分时：</p>
<p>\begin{equation}<br>\frac{\partial l}{\partial \phi_i} \approx \frac{\partial l}{\partial \theta_i}<br>\end{equation}</p>
<p>以上公式是我看懂and抄下来，真佩服能手推公式的。这样，参数如何更新的就讲完了。MAML的主要目标也是更新参数。</p>
<p>但在 MAML 中，每个任务的网络的参数只更新一次，有以下优势：</p>
<ul>
<li>训练速度快；</li>
<li>逼迫网络一次达到很好的效果；</li>
<li>meta learning 的多任务学习常用于小样本，防止过拟合。</li>
</ul>
<p>来看一下 $\phi$ 的更新趋势：</p>
<p><img data-src="/2020/09/20/meta-learning/4.png" alt></p>
<p>采样 $m$ 个任务，第一次训练完毕得到参数 $\theta_1$，计算 $\theta_1$ 的梯度方向，将 $\phi_0$ 按照梯度方向更新至 $\phi_1$，之后的训练以此类推。</p>
<h3 id="Reptile-方法"><a href="#Reptile-方法" class="headerlink" title="Reptile 方法"></a>Reptile 方法</h3><p>和 MAML 方法类似，但有以下几个点不同：</p>
<ul>
<li>训练任务的网络可以更新多次，以 $k$ 次为例；</li>
<li>reptile 不再像 MAML 一样计算梯度（因此带来了工程性能的提升），而是直接用一个参数乘以meta网络与训练任务的网络参数的差来更新meta网络参数；（向最终的参数方向去更新）</li>
</ul>
<p><img data-src="/2020/09/20/meta-learning/5.png" alt></p>
<h1 id="基于测量的-meta-learning-网络结构"><a href="#基于测量的-meta-learning-网络结构" class="headerlink" title="基于测量的 meta learning 网络结构"></a>基于测量的 meta learning 网络结构</h1><p>这里设想，在之前的 meta learning 中，是 Support Set 先进入网络训练，而后测试集合进入网络并计算误差 $l$。最终多个 $l$ 相加而后反向传播。一个宏观的误差并不能使网络拉开同一组数据中 Support Set 和 Query Set 中不同类的样本的差距，只是用一个总误差更新初始化的参数。看如下的结构图：</p>
<p><img data-src="/2020/09/20/meta-learning/7.png" alt></p>
<p>将训练模块和预测模块放到一起，训练数据和测试数据同时进入，以此来达到区分一次训练数据中 Support Set 和 Query Set 的区别，更好的将不同的样本区分开。这里简单介绍两种网络，Siamese Network，Prototypical Network 和 Relatoin Network。</p>
<h2 id="Siamese-Network"><a href="#Siamese-Network" class="headerlink" title="Siamese Network"></a>Siamese Network</h2><p><img data-src="/2020/09/20/meta-learning/8.png" alt></p>
<p>在训练数据中引入一个类，测试数据只有一个类。经过可参数共享的 CNN 后得到嵌入表示，并计算测试数据和训练数据中每个类数据的相似性，以此来计算得分。若测试数据和训练数据中的某个样本属于同一类，则该单元的输出最高。举例说明：</p>
<p>训练数据为类别为1，测试数据的类别为3。那么相似性应该很低，输出的分数也低。如果是同一类，相似度高，输出的分数就高，这就是基于度量的 meta-learning。</p>
<p>其实就是计算的两个样本是否相似，可以看成一个二分类问题。同一类的样本距离近，不同类的样本远。与 AutoEncoder 的区别是，AutoEncoder 是尽可能的复原信息，而不是提取能作为区分的重要信息。</p>
<h2 id="Prototypical-Network"><a href="#Prototypical-Network" class="headerlink" title="Prototypical Network"></a>Prototypical Network</h2><p>和 Siamese 极为类似，只是输入的训练数据可以有多个类，而不只是限于一个。最后 softmax 一下，测试样本和训练样本属于同一类时，单元输出的值就打。举例说明：</p>
<p>输入数据是1，2，3，4，5这么多个类，每个类一个数据。测试数据的类别是 3。那么，第三个单元的输出最大，其他单元的输出较小。以此来计算相似度，拉开不同类样本在空间中的分布。</p>
<p>当然，这里是可以引入 Triplet loss 的，只需要在训练时加入额外的数据即可。此时训练的数据为：Train data, Untrain data, Test data。其中，Untrain data 就像训练 Word2Vec 时使用的无关词汇一样。这里轻描淡写了，Triplet loss 如何应用到 Siamese 中还请查询具体文章，比如<a href="https://zhuanlan.zhihu.com/p/68200241" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="Relation-Network"><a href="#Relation-Network" class="headerlink" title="Relation Network"></a>Relation Network</h2><p>之前的网络在计算相似度时可能都是使用 $\cos$ 等函数，而 Relation Network 中则使用一个网络来计算相似度。将测试数据的嵌入拼接到训练数据后面，一起进入计算相似性的网络，之后的操作就都一样了。</p>
<p><img data-src="/2020/09/20/meta-learning/9.png" alt></p>
<h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><h2 id="基于梯度"><a href="#基于梯度" class="headerlink" title="基于梯度"></a>基于梯度</h2><p>代码实现了 <a href="https://github.com/muyuuuu/Algorithm/tree/master/meta-learning/Gradient-based" target="_blank" rel="noopener">Reptileh和MAML</a>。很简单，只是简单的更新参数的方法，通过小样本采样来学习一个 $y=a\sin(x+b)$ 的函数。强烈建议看代码，看完代码后就知道meta learning 的工作原理了。结果如下（我就训练了几次，次数很少）：</p>
<p><img data-src="https://static01.imgkr.com/temp/f9c142375b0d4a46a32039144825a6e9.png" alt></p>
<h2 id="基于度量"><a href="#基于度量" class="headerlink" title="基于度量"></a>基于度量</h2><p>还没写好，最近课多。</p>
<h1 id="参考与推荐课程"><a href="#参考与推荐课程" class="headerlink" title="参考与推荐课程"></a>参考与推荐课程</h1><p>我也不知道我整理的好不好，能不能看懂。不过没关系，我可以推荐一些不错的课程。但恕我直言，看完课程后觉得自己学会了，但自己整理的时候还是发现啥都不会。『一学就会，一练就废』系列。</p>
<p>不错的讲解博客：<br><a href="https://wei-tianhao.github.io/blog/2019/09/17/meta-learning.html#lstm-meta-learner" target="_blank" rel="noopener">https://wei-tianhao.github.io/blog/2019/09/17/meta-learning.html#lstm-meta-learner</a></p>
<p>有人整理的李宏毅课程的pdf版，MAML后直接讲强化学习调网络结构：<br><a href="http://www.gwylab.com/pdf/note_meta-learning.pdf" target="_blank" rel="noopener">http://www.gwylab.com/pdf/note_meta-learning.pdf</a></p>
<p>不错的讲解博客：<br><a href="https://www.tensorinfinity.com/paper_191.html" target="_blank" rel="noopener">https://www.tensorinfinity.com/paper_191.html</a></p>
<p>李宏毅讲解 meta-learning 的课程：<br><a href="https://www.youtube.com/watch?v=EkAqYbpCYAc&amp;list=PLJV_el3uVTsOK_ZK5L0Iv_EQoL1JefRL4&amp;index=32" target="_blank" rel="noopener">https://www.youtube.com/watch?v=EkAqYbpCYAc&amp;list=PLJV_el3uVTsOK_ZK5L0Iv_EQoL1JefRL4&amp;index=32</a></p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统『一』：进程与线程</title>
    <url>/2020/03/16/multi-process-thread/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为一个程序员，我发现我不会写多进程和多线程的程序，实在羞愧，在赶完毕业设计后准备开一个多线程编程的坑。本文是我这种小白从无到有的学习收获，内容较多，还请耐心观看。因疫情原因没在学校，手头没有一本靠谱的《操作系统》的书籍，<del>大多东西为网上搜刮而来后整理，可能不严谨。</del>今天有空了回来填坑。</p>
<a id="more"></a>
<h1 id="从物理机开始"><a href="#从物理机开始" class="headerlink" title="从物理机开始"></a>从物理机开始</h1><p>本文以Linux操作为主，Windows操作不太了解。首先先从物理机出发，了解物理CPU、CPU的核、线程是什么概念。物理CPU指实际存在的CPU处理器，安装在PC主板或服务器上。首先查看物理CPU个数，查看电脑有几个CPU：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">'physical id'</span> /proc/CPUinfo | sort -u</span><br></pre></td></tr></table></figure>
<p>执行结果反馈如下：（后期解释为什么是12个id为0的记录）</p>
<p><img data-src="/2020/03/16/multi-process-thread/1.png" alt></p>
<p>其id均为0，表示我电脑有一个CPU（从0开始编号）。CPU中包含物理内核，比如多核CPU，单核CPU。这个多核或者单核已经集成在CPU内部了，那么来查看一下核心数量，就是买电脑的时候常听商家常说的4核CPU或者8核CPU：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">'core id'</span> /proc/CPUinfo | sort -u | wc -l</span><br></pre></td></tr></table></figure>
<p>我这里输出的结果为6,表示我的是6核CPU。同时，你在买电脑的时候听说过，6核12线程，4核8线程的CPU，那么，再看一下自己的电脑支持几个线程：（说了半天终于到线程了）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">'processor'</span> /proc/CPUinfo | sort -u | wc -l</span><br></pre></td></tr></table></figure>
<p>输出的结果是12，表示我的电脑的处理器是一个CPU，且是6核心12线程的。所谓的6核12线程，6核指的是物理核心。用Intel的超线程技术(HT， Hyper-threading)将物理核虚拟而成的逻辑处理单元，现在大部分的主机的CPU都在使用HT技术，用一个物理核模拟两个虚拟核，即每个核两个线程，总数为12线程。所以在操作系统看来是12个核，但实际是一个物理CPU中的6个物理内核虚拟出来的12个线程：</p>
<p><img data-src="/2020/03/16/multi-process-thread/1.png" alt></p>
<p>此时我们需要知道：<strong>一个核心只能同时执行一个线程</strong>。</p>
<h1 id="进程与线程的概念"><a href="#进程与线程的概念" class="headerlink" title="进程与线程的概念"></a>进程与线程的概念</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li>进程是操作系统的CPU调度和资源分配的单位，是执行中的程序，是一个程序在一个数据集上的一次执行。是程序的一个实例，程序的一次运行。包括代码段，当前活动（PC，当前要指向指令的地址；堆栈，函数参数、临时变量；数据，全局变量，处理的文件；堆，动态内存分配）；</li>
<li>程序是进程的代码部分。进程在内存，程序在外存。</li>
</ul>
<p>当写完一份程序，编译为二进制的可执行文件并执行时：可执行的.exe文件可以理解为一种程序，程序本身也是指令的集合，而进程才是程序(那些指令)的真正运行。程序本身不会运行，运行的程序叫进程。进程会标记程序要访问的地址、要执行的操作等，执行完毕后进程会被销毁。</p>
<p>若干进程有可能与同一个程序有关系，如<strong>循序和平行</strong>。进程<code>A</code>需要得到进程<code>B</code>的处理结果才能继续运行，所以进程<code>A</code>要等待进程<code>B</code>执行完，这叫<strong>循序</strong>；进程<code>C</code>和进程<code>D</code>没有关系，这俩可以同时进行，这叫<strong>平行</strong>。</p>
<p>举个生动的例子：某生产流水线，得先通过质量安检才能包装，所以质量检查和包装这两个进程不能同时进行，有明显的先后顺序，这叫<strong>循序</strong>；对于没有明显先后顺序的，比如电脑打开两个软件，一个负责聊天，一个负责放音乐，这两个进程毫不相干，所以同一时刻谁先执行谁后执行无所谓的，没有明显的先后顺序，这叫<strong>平行</strong>。</p>
<p>也许你会问：音乐软件和聊天软件这两个进程不是同一时刻在一起执行吗？其实不是的，计算机只能串行执行不同的进程，即执行进程<code>A</code>的时候不能执行进程<code>B</code>，所以同一时刻，计算机只能执行一个进程。你所谓的边听音乐边聊天，其实是计算机中断实现的。先执行聊天进程，在以极低的间隔切换到音乐进程，只是这个时间间隔短暂，短暂到肉眼无法察觉，你感受不到。<strong>所以宏观是并行的，微观是串行的。</strong></p>
<p>当系统内存在的多个进程的时候，操作系统会根据进程的优先级算法来决定先执行谁，后执行谁，<code>A</code>的优先级高，那就先执行<code>A</code>。确定进程的优先级有很多算法，详情参考《操作系统》。以我的电脑为例，启动系统，打开一堆软件，肯定不止12个进程，而多个进程以优先级的形式在仅12个核的CPU上轮番执行，保证系统的有条不紊。</p>
<p>进程也是线程的容器。每一个进程都有一个主线程，一个CPU核心在同一时刻只能执行一个线程。所以，最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也不可能只有一节车厢，多线程的出现就是为了提高效率。</p>
<p>总结一下：进程是操作系统进行资源（包括CPU、内存、磁盘IO等）分配的最小单位，而进程中的线程是CPU调度和分配的基本单位。我们打开的聊天工具，浏览器都是一个进程。进程可能有多个子任务，比如聊天工具要接受消息，发送消息，这些子任务就是线程。</p>
<p>而资源分配给进程，且不同进程之间不共享资源，线程共享所在进程的资源。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是操作系统调度和CPU执行的基本单位。它被包涵在进程之中，一条线程指的是进程中一个单一顺序的控制流，一个进程中可以有多个线程，每条线程并行执行不同的任务，线程的运行中需要使用计算机的内存资源和CPU。</p>
<p>同一进程中的多条线程将共享该进程中的全部系统资源，如访问数据、地址空间等等。但同一进程中的多个线程有各自的调用栈(call stack)，自己的寄存器环境(register context)，自己的线程本地存储(thread-local storage)。</p>
<p>在多核或多CPU，或支持HT的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。多核CPU在毕竟同一时刻跑多个任务，单核CPU同一时刻只能跑一个任务。</p>
<p>总结：进程是资源分配的最小单位，线程是CPU调度的最小单位。线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。更多区别：</p>
<ul>
<li>代码角度：进程包含线程，线程是进程中的一段代码；</li>
<li>资源角度：进程是资源分配的基本单位，线程得到的资源来自进程，共享使用；</li>
<li>调度角度：进程中的线程切换不会引起进程切换，线程是基本调度单位；</li>
<li>切换角度：进程切换代价大，线程切换代价小；</li>
<li>生命周期：进程撤销会撤销所有线程，线程撤销不会影响进程。</li>
</ul>
<h2 id="串行、并行、并发"><a href="#串行、并行、并发" class="headerlink" title="串行、并行、并发"></a>串行、并行、并发</h2><p>串行：多个任务，执行时一个执行完再执行另一个。比喻：吃完饭再看视频。</p>
<p>并发：多个线程在单个核心运行，同一时间一个线程运行，系统不停切换线程，看起来像同时运行，实际上是线程不停切换。比喻： 一会跑去厨房吃饭，一会跑去客厅看视频。</p>
<p>并行：每个线程分配给独立的核心，线程同时运行。比喻：一边吃饭一边看视频。</p>
<p>在了解完串行、并行、并发的概念后，可以更多的理解多进程和多线程了：</p>
<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><p>当你运行一个程序，你就启动了一个进程。在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多任务。</p>
<p>现代的操作系统几乎都是多任务操作系统，能够同时管理多个进程的运行。多任务带来的好处是明显的，比如你可以边听mp3边上网，与此同时甚至可以将下载的文档打印出来，而这些任务之间丝毫不会相互干扰。如果这些任务同时在一个核上运行，这就是<strong>并发</strong>，如果这些任务分配到了多个核心，这就是<strong>并行</strong>。</p>
<p>如何实现并发？详情参考《操作系统》，可以粗暴的理解为利用系统中断，根据优先级确定先执行谁。执行A，中断一下去执行B，执行一会儿B，在中断一下返回去执行A，如此循环往复。</p>
<p>并行运行的效率显然高于并发运行，所以在多CPU的计算机中，多任务的效率比较高。同理，如果在多CPU计算机中只运行一个进程(线程)，就不能发挥多CPU的优势。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>在计算机编程中，一个基本的概念就是同时对多个任务加以控制。许多程序设计问题都要求程序能够停下手头的工作，改为处理其他一些问题，再返回主进程。</p>
<p>最开始的时候，那些掌握机器低级语言的程序员编写一些<strong>中断服务例程</strong>，主进程的暂停是通过硬件级的中断实现的。尽管这是一种有用的方法，但编出的程序很难移植，由此造成了另一类的代价高昂问题。中断对那些实时性很强的任务来说是很有必要的。</p>
<p>但对于其他许多问题，只要求将问题划分进入<strong>独立运行</strong>的程序片断中，程序在逻辑意义上被分割为数个线程，并将数个线程分配给多个核，使整个程序能更迅速地响应用户的请求。多线程是为了同步完成多项任务，即在同一时间需要完成多项任务的时候实现的。假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入<strong>并行运算</strong>状态。</p>
<p>从程序设计语言的角度看，多线程操作最有价值的特性之一就是程序员不必关心到底使用了多少个处理器（处理器不够可以并发），可以创建100个线程一起来嘛。</p>
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>更新</title>
    <url>/2019/09/13/new/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>电脑裸机安装的linux，很多东西都大改。</p>
<p>比如之前没注意的python虚拟环境，这个时候也要去注意了。</p>
<p>然后换到新系统也是重新安装各种软件，有的软件没有linux版本。于是我又重新装回了Windows系统，双系统。毕竟毕业论文要求是用office 2010，怂，不敢开 $\LaTeX$。</p>
<p>Vim还用的不熟，暂时用vscode替代。看到大佬演示了一下vim的操作，确实有点眼馋，自己慢慢学吧。</p>
<p>linux上安装了hexo，没想到换了系统博客还活着，还有许多需要更新，博客排版也得大改，主要是改一些颜色、内容的配置，符合我的风格。</p>
<p>这几天和专业大佬在交流，我差的还很远，日常感觉自己是个文盲，有些知识也记忆模糊了，还有许多需要学习。短暂的几天放飞了自我，还没有值得停下的理由。</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>生活还是精致一点的好. –佚名</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<a id="more"></a>
<p>把该做好的做好就行了。</p>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫系列（三）——多进程爬虫</title>
    <url>/2020/03/18/multi-process/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>承接上文，实现多任务的方法一般有三种，今日来实现其中的一种：多进程爬虫。而剩余的多线程并发和协程暂时没时间搞了，一方面是要先学习下Python的yield和send如何使用，其次要准备毕设的中期答辩和被老师安排了去读源代码，日后会补上的。但仅仅是多进程，<strong>就将IO密集的任务从1153秒提升到了105秒</strong>，且极高的提升了资源利用率。</p>
<p>还有一点，本文的代码可能只适用于Next主题，但方法思路是通解，只要改改参数适应你的主题，代码同样能用。结果展示：<a href="https://muyuuuu.github.io/hot/">本站热门</a></p>
<a id="more"></a>
<h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><p>如果对爬虫不太了解，可以参考我之前的几篇文章。如果你计算机功底还不错，那么实现爬虫入门，完成简单的爬虫任务还是可以的：</p>
<ul>
<li><a href="https://muyuuuu.github.io/2019/02/24/school-start1/">爬虫入门</a></li>
<li><a href="https://muyuuuu.github.io/2020/01/11/resptile/">借助自动化测试的爬虫</a></li>
</ul>
<p>这次的爬取任务很简单，之前看到了别人博客有<strong>『热榜』</strong>这个东西，很是眼馋，查询了一下发现实现热榜这个东西得经过很多的配置，但是我懒不想配置。于是准备自己动手爬虫，爬取每篇博客的访问量，以此作为博客每排文章的热度，说干就干，开工。</p>
<h2 id="爬虫思路"><a href="#爬虫思路" class="headerlink" title="爬虫思路"></a>爬虫思路</h2><ol>
<li><p>本次爬虫需要request、BeautiulSoup和selenium联合使用，只有其中的一方完不成任务。</p>
</li>
<li><p>因为每篇博客的访问量并不在外部显示，必须点击到文章内部才难加载，所以，这次爬虫必须使用selenium控制浏览器模拟点击，之后进入对应网页，以此来获取不蒜子统计的浏览数量。</p>
</li>
<li><p>首先打开网页的根域名，按<code>F12</code>发现每篇文章的链接的类是<code>post-title-link</code>，以此来获取第一篇文章的名称，点击，进入第一篇博客。部分代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 寻找第一篇文章</span></span><br><span class="line">first_page = body.find(<span class="string">'a'</span>, &#123;<span class="string">'class'</span>, <span class="string">'post-title-link'</span>&#125;)</span><br><span class="line"><span class="comment"># 记录第一篇文章的标题</span></span><br><span class="line">first = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> first_page:</span><br><span class="line">    first = i</span><br><span class="line"><span class="comment"># 进入第一篇文章</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//a[contains(text(),'&#123;&#125;')]"</span>.format(first)).click()</span><br></pre></td></tr></table></figure>
</li>
<li><p>本来想的是，进入网页后，使用requests库直接请求，然后解析出不蒜子统计那个标签的数量。但是，requests网页后发现不蒜子标签下数量根本不显示。意思是，仅仅依靠requests和beautifulsoup的爬虫是爬取不到不蒜子统计的。</p>
</li>
<li><p>所以，还得靠selenium。再次按一下<code>F12</code>，发现不蒜子统计的id是<code>busuanzi_value_page_pv</code>。利用selenium的id定位法，定位到不蒜子统计元素，然后输出定位元素里的文本。部分代码如下所示：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">view = driver.find_element_by_id(<span class="string">"busuanzi_value_page_pv"</span>)</span><br><span class="line"><span class="comment"># num 就是每篇文章的访问量 </span></span><br><span class="line">num = int(view.text)</span><br></pre></td></tr></table></figure>
</li>
<li><p>而后，在每篇博客的末尾，都有指向下一篇博客的链接，点击既能进入下一篇博客。如下图所示：<img data-src="/2020/03/18/multi-process/1.jpg" alt></p>
</li>
<li><p>而selenium定位到链接的文字又很费劲，不如用selenium获取当前网页的URL，然后使用requests和beautifulsoup库跟去获取的URL，进一步解析出指向下一篇博客链接的文字。而后把解析出的文字传给selenium的链接定位法，让selenium按照文字去点击链接，进入下一篇博客。如此循环往复，直到最后一篇博客。</p>
</li>
<li><p>因某些博客的图片数量过多，导致加载过慢，如果5秒内加载不完，则直接进入下一篇文章。中间为防止爬虫过猛被屏蔽，其中使用了一些延时函数放缓进度。</p>
</li>
<li><p>最终的结果要把文章的名称、文章的网址和文章的访问量都记录下来。考虑使用字典这种结构，将文章名称和网址作为key，访问量作为value。</p>
</li>
<li><p>将字典保存为json文件，而后将json文件中的结果稍微清洗一下，做成markdown文件，放到博客里，热榜就做成了。</p>
</li>
<li><p>最后，对爬虫任务的整体时间进行记录，对比单进程和多进程的效率。</p>
</li>
</ol>
<h1 id="单进程"><a href="#单进程" class="headerlink" title="单进程"></a>单进程</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">home_url = <span class="string">"https://muyuuuu.github.io/"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 申请当前页面</span></span><br><span class="line">r = requests.get(home_url)</span><br><span class="line">soup = BeautifulSoup(r.text, <span class="string">"lxml"</span>)</span><br><span class="line">body = soup.body</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用selenium点开每个页面，统计访问人数和评论数</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">driver = webdriver.Chrome(executable_path=<span class="string">'/home/lanling/chromedriver_linux64/chromedriver'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录文章的数量</span></span><br><span class="line">article = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先进入第一页</span></span><br><span class="line"><span class="comment"># 打开网页</span></span><br><span class="line">driver.get(home_url)</span><br><span class="line"><span class="comment"># 寻找第一篇文章</span></span><br><span class="line">first_page = body.find(<span class="string">'a'</span>, &#123;<span class="string">'class'</span>, <span class="string">'post-title-link'</span>&#125;)</span><br><span class="line"><span class="comment"># 记录第一篇文章的标题</span></span><br><span class="line">first = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> first_page:</span><br><span class="line">    first = i</span><br><span class="line"><span class="comment"># 进入第一篇文章</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//a[contains(text(),'&#123;&#125;')]"</span>.format(first)).click()</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 记录浏览数</span></span><br><span class="line">dr = driver.find_element_by_id(<span class="string">"busuanzi_value_page_pv"</span>)</span><br><span class="line"><span class="comment"># 标题名和域名作为字典的 key</span></span><br><span class="line">string = <span class="string">"["</span> + first + <span class="string">"]"</span> + <span class="string">"("</span> + driver.current_url + <span class="string">")"</span></span><br><span class="line">article[string] = int(dr.text)</span><br><span class="line">print(article)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 而后点击 每篇博客末尾的指向下一篇文章的链接 直到遍历完所有文章</span></span><br><span class="line"><span class="comment"># 记录开始时间</span></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="comment"># 捕获当前的 url</span></span><br><span class="line">url = driver.current_url</span><br><span class="line">data = requests.get(url)</span><br><span class="line">data = BeautifulSoup(data.text, <span class="string">"lxml"</span>)</span><br><span class="line"><span class="comment"># 解析当前页面，获取下一页的按钮</span></span><br><span class="line">next = data.find(<span class="string">'div'</span>, &#123;<span class="string">'class'</span>:<span class="string">'post-nav-next post-nav-item'</span>&#125;)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> next:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 点击下一页的链接 进入 下一个网页</span></span><br><span class="line">        driver.find_element_by_link_text(next.text.strip()).click()</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        <span class="comment"># 查看浏览数，图片较多加载缓慢，5秒内加载不出来跳过</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            view = driver.find_element_by_id(<span class="string">"busuanzi_value_page_pv"</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># 获取当前页面的url</span></span><br><span class="line">        url = driver.current_url</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        data = requests.get(url)</span><br><span class="line">        <span class="comment"># 解析当前url</span></span><br><span class="line">        data = BeautifulSoup(data.text, <span class="string">"lxml"</span>)</span><br><span class="line">        <span class="comment"># 当前文章的标题和域名传入字典</span></span><br><span class="line">        string = <span class="string">"["</span> + data.title.text + <span class="string">"]"</span> + <span class="string">"("</span> + driver.current_url + <span class="string">")"</span></span><br><span class="line">        <span class="comment"># 如果没有加载到浏览数 就给一个负数</span></span><br><span class="line">        <span class="keyword">if</span> view.text == <span class="string">""</span>:</span><br><span class="line">            article[string] = <span class="number">-2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            article[string] = int(view.text)</span><br><span class="line">            print(string, int(view.text))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 寻找下一篇博客的链接名，然后点击，直到最后一篇文章。</span></span><br><span class="line">        next = data.find(<span class="string">'div'</span>, &#123;<span class="string">'class'</span>:<span class="string">'post-nav-next post-nav-item'</span>&#125;)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># 记录结束时间</span></span><br><span class="line">    end = time.time()</span><br><span class="line"></span><br><span class="line">print(end - start)</span><br><span class="line">driver.quit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将博客按访问数排序</span></span><br><span class="line">article_save = sorted(article.items(), key = <span class="keyword">lambda</span> item:item[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># encoding='utf-8'，用于确保写入中文不乱码</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data.json'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">    <span class="comment"># ensure_ascii=False，用于确保写入json的中文不发生乱码</span></span><br><span class="line">    json.dump(article_save,f_obj,ensure_ascii=<span class="literal">False</span>, indent=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>这个单进程的任务总共耗时<strong>1153</strong>秒左右（毕竟网络时延说不准），资源利用率很少，如下所示：<img data-src="/2020/03/18/multi-process/1.gif" alt></p>
<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><p>多进程仅需在单进程的代码上做一点改动即可：（如果你不懂多进程，请参考我的上一篇文章，<a href="https://muyuuuu.github.io/2020/03/16/multi-process-thread/">如何理解多进程</a>）</p>
<ol>
<li><p>首先统计一下博客有几页，就创建几个进程。比如，我的博客目前有14页，就创建14个进程：<img data-src="/2020/03/18/multi-process/2.jpg" alt></p>
</li>
<li><p>进程扔到一个进程池里，等待所有进程执行完毕即可。</p>
</li>
<li><p>多进程之间不共享变量，所以字典的创建方法需要更改。</p>
</li>
<li><p>同样，防止爬虫过猛，中间同样适用延时函数放缓进度。</p>
</li>
<li><p>记录多进程的耗时，与单进程对比。代码如下所示：</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">home_url = <span class="string">"https://muyuuuu.github.io/"</span></span><br><span class="line"></span><br><span class="line">r = requests.get(home_url)</span><br><span class="line">soup = BeautifulSoup(r.text, <span class="string">"lxml"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有几个页面就创建几个进程</span></span><br><span class="line">body = soup.body</span><br><span class="line">page_number = body.find(<span class="string">'nav'</span>, &#123;<span class="string">'class'</span> : <span class="string">'pagination'</span>&#125;)</span><br><span class="line">a = page_number.find_all(<span class="string">'a'</span>)</span><br><span class="line">max_page_number = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">        <span class="keyword">if</span> str(j).isdigit():</span><br><span class="line">            <span class="keyword">if</span> int(j) &gt; max_page_number:</span><br><span class="line">                max_page_number = int(j)</span><br><span class="line">print(max_page_number)</span><br><span class="line">process_num = max_page_number</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扔进进程池统一管理 并计时</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程的字典 </span></span><br><span class="line">article = multiprocessing.Manager().dict()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录每个进程爬几次，就是一个页面有几篇文章，我懒的爬取了，手动设置下</span></span><br><span class="line">per_page = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个进程的任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">respite_task</span><span class="params">(url_num)</span>:</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    sub_url = <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> url_num == <span class="number">0</span>:</span><br><span class="line">        sub_url = <span class="string">"https://muyuuuu.github.io/"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sub_url = <span class="string">"https://muyuuuu.github.io/page/"</span> + str(url_num) + <span class="string">"/"</span></span><br><span class="line">    <span class="comment"># 每个进程启动一个 driver</span></span><br><span class="line">    print(<span class="string">"here"</span>)</span><br><span class="line">    driver = webdriver.Chrome(executable_path=<span class="string">'/home/lanling/chromedriver_linux64/chromedriver'</span>)</span><br><span class="line">    driver.get(sub_url)</span><br><span class="line">    time.sleep(random.randint(<span class="number">2</span>, <span class="number">6</span>))</span><br><span class="line">    r = requests.get(sub_url)</span><br><span class="line">    soup = BeautifulSoup(r.text, <span class="string">"lxml"</span>)</span><br><span class="line">    body = soup.body</span><br><span class="line">    <span class="comment"># 寻找第一篇文章</span></span><br><span class="line">    first_page = body.find(<span class="string">'a'</span>, &#123;<span class="string">'class'</span>, <span class="string">'post-title-link'</span>&#125;)</span><br><span class="line">    <span class="comment"># 记录第一篇文章的标题</span></span><br><span class="line">    first = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> first_page:</span><br><span class="line">        first = i</span><br><span class="line">    <span class="comment"># 进入第一篇文章</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"//a[contains(text(),'&#123;&#125;')]"</span>.format(first)).click()</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 记录浏览数</span></span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        view = driver.find_element_by_id(<span class="string">"busuanzi_value_page_pv"</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 标题名和域名作为字典的 key</span></span><br><span class="line">    string = <span class="string">"["</span> + first + <span class="string">"]"</span> + <span class="string">"("</span> + driver.current_url + <span class="string">")"</span></span><br><span class="line">    <span class="comment"># 如果没有加载到浏览数 就给一个负数</span></span><br><span class="line">    <span class="keyword">if</span> view.text == <span class="string">""</span>:</span><br><span class="line">        article[string] = <span class="number">-2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        article[string] = int(view.text)</span><br><span class="line">        print(string, int(view.text))</span><br><span class="line">    <span class="comment"># 捕获当前的 url (已经进入了新页面)</span></span><br><span class="line">    url = driver.current_url</span><br><span class="line">    data = requests.get(url)</span><br><span class="line">    data = BeautifulSoup(data.text, <span class="string">"lxml"</span>)</span><br><span class="line">    <span class="comment"># 解析当前页面，获取下一页的按钮</span></span><br><span class="line">    next = data.find(<span class="string">'div'</span>, &#123;<span class="string">'class'</span>:<span class="string">'post-nav-next post-nav-item'</span>&#125;)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> next <span class="keyword">and</span> num &lt; per_page:</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 点击下一页的链接 进入 下一个网页</span></span><br><span class="line">            driver.find_element_by_link_text(next.text.strip()).click()</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">            <span class="comment"># 查看浏览数，图片较多加载缓慢，5秒内加载不出来跳过</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                view = driver.find_element_by_id(<span class="string">"busuanzi_value_page_pv"</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="comment"># 获取当前页面的url</span></span><br><span class="line">            url = driver.current_url</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            data = requests.get(url)</span><br><span class="line">            <span class="comment"># 解析当前url</span></span><br><span class="line">            data = BeautifulSoup(data.text, <span class="string">"lxml"</span>)</span><br><span class="line">            <span class="comment"># 当前文章的标题和域名传入字典</span></span><br><span class="line">            string = <span class="string">"["</span> + data.title.text + <span class="string">"]"</span> + <span class="string">"("</span> + driver.current_url + <span class="string">")"</span></span><br><span class="line">            <span class="comment"># 如果没有加载到浏览数 就给一个负数</span></span><br><span class="line">            <span class="keyword">if</span> view.text == <span class="string">""</span>:</span><br><span class="line">                article[string] = <span class="number">-2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                article[string] = int(view.text)</span><br><span class="line">                print(string, int(view.text))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 寻找下一篇博客的链接名，然后点击，直到最后一篇文章。</span></span><br><span class="line">            next = data.find(<span class="string">'div'</span>, &#123;<span class="string">'class'</span>:<span class="string">'post-nav-next post-nav-item'</span>&#125;)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        driver.quit()</span><br><span class="line">    </span><br><span class="line">p = Pool(process_num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (process_num + <span class="number">1</span>):</span><br><span class="line">    p.apply_async(respite_task, args=(i,))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'waitting for all subprocess done'</span>)</span><br><span class="line">start = time.time()</span><br><span class="line">p.close()</span><br><span class="line">p.join()</span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">'All subprocesses done costs &#123;&#125; seconds'</span>.format(end - start))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升序排列并保存</span></span><br><span class="line">article_save = sorted(article.items(), key = <span class="keyword">lambda</span> item:item[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># encoding='utf-8'，用于确保写入中文不乱码</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data_multiprocess.json'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">    <span class="comment"># ensure_ascii=False，用于确保写入json的中文不发生乱码</span></span><br><span class="line">    json.dump(article_save,f_obj,ensure_ascii=<span class="literal">False</span>, indent=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>最终的结果和单线程的结果保持一致，但仅仅用了<strong>105</strong>秒就执行完毕，足足提升了10倍。因为每个进程都有一个主线程，将主线程分配给多个核，所以导致了资源利用率比单线程要高的多：<img data-src="/2020/03/18/multi-process/2.gif" alt></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这好像不是传说中的并行计算，毕竟不是计算密集的任务，但这个几个进程的任务确实在并行执行，『知识就是力量』还是有道理的。</p>
]]></content>
      <tags>
        <tag>Resptile</tag>
      </tags>
  </entry>
  <entry>
    <title>大漠西北，塞上江南</title>
    <url>/2020/01/21/northwest/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录塞上西北的旅行，彻底颠覆了我对大西北的认知：不见祁连山上雪，错把甘州作江南。</p>
<ul>
<li>羌笛何须怨杨柳，春风不度玉门关。</li>
<li>秦时明月汉时关，万里长征人未还。</li>
<li>青海长云暗雪山，孤城遥望玉门关。</li>
<li>劝君更尽一杯酒，西出阳关无故人。</li>
</ul>
<p>不缺这么美的景，不缺这么美的诗词。</p>
<p><img data-src="/2020/01/21/northwest/1.jpg" alt></p>
<a id="more"></a>
<h1 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h1><ul>
<li>1月14日 西宁——塔尔寺——拉脊山——青海湖——茶卡镇（住宿）</li>
<li>1月15日 茶卡日出——茶卡盐湖——翡翠湖——大柴旦（住宿）</li>
<li>1月16日 大柴旦——南八仙雅丹——当金山——阿克塞——阳关——敦煌（住宿）</li>
<li>1月17日 敦煌——莫高窟——鸣沙山月牙泉——敦煌市（住宿）</li>
<li>1月18日 敦煌市——嘉峪关——张掖七彩丹霞（住宿）</li>
<li>1月19日 张掖七彩丹霞——祁连山——祁连山草原——岗什卡雪峰（远观）——西宁（不负责住宿）</li>
</ul>
<p>放几组综合照片欣赏下大西北的风光：</p>
<p>有秀丽壮阔的水景：</p>
<p><img data-src="/2020/01/21/northwest/2.jpg" alt></p>
<p>也有壮阔隔壁的荒凉：</p>
<p><img data-src="/2020/01/21/northwest/3.jpg" alt></p>
<p>西出阳关，大漠飞沙：</p>
<p><img data-src="/2020/01/21/northwest/4.jpg" alt></p>
<p>天气寒冷，在行往当金山（青海、西藏、新疆三省交界）的路上眼镜冻出霜花。过了当金山，也差不多进入了沙漠。</p>
<p><img data-src="/2020/01/21/northwest/100.jpg" alt><br><img data-src="/2020/01/21/northwest/22.jpg" alt></p>
<hr>
<p>分界线，以下多图，注意流量，大致的美景都概括在上方了，以下只是细节（一个景区的多个美景图，对于美景较多的景区，图片过多，单独成文，给出链接地址）。</p>
<h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><p>参观了塔尔寺，闻到了暗香盈袖的酥油茶，看到了信徒的虔诚，原来书上说的朝圣是真的。原以为电影电视剧里面的佛像都是电脑合成的，都是假的，直到看到寺内的壁画和雕像，真大开眼界，金碧辉煌，雄武壮阔，蔚为壮观，不输任何玄幻电影。</p>
<p><img data-src="/2020/01/21/northwest/9.jpg" alt><br><img data-src="/2020/01/21/northwest/6.jpg" alt><br><img data-src="/2020/01/21/northwest/7.jpg" alt><br><img data-src="/2020/01/21/northwest/8.jpg" alt></p>
<p>之后在海拔四千多米的拉脊山疯跑到呼吸困难（不太困难，宛如一块石头压着胸口喘不上气），后来发现是自己高原反应了（不太严重），同行的略微肥胖的人的反应很严重。路上一望无际的关山万里，还有高原地带的天然牧场，一马平川的一望无际；天苍苍，野茫茫，心旷神怡。</p>
<p><img data-src="/2020/01/21/northwest/12.jpg" alt><br><img data-src="/2020/01/21/northwest/11.jpg" alt><br><img data-src="/2020/01/21/northwest/13.jpg" alt><br><img data-src="/2020/01/21/northwest/10.jpg" alt></p>
<p>后来又到了四处无人的青海湖，因为是旅游淡季，四下无人，冰天一色，不愧是最大的内陆湖，也看到了标志性动物牦牛，还有天空飞翔的斑头雁。</p>
<p><img data-src="/2020/01/21/northwest/20.jpg" alt></p>
<p>晚上到了茶卡镇住宿，吃了牦牛火锅。老板很好，送了一壶枣茶，牦牛肉质鲜美，切的也很大块，大概每块肉有2-3毫米厚吧，估计也只有大西北可以这么豪爽的吃肉了，价格还很便宜。</p>
<p><img data-src="/2020/01/21/northwest/16.jpg" alt><br><img data-src="/2020/01/21/northwest/17.jpg" alt><br><img data-src="/2020/01/21/northwest/15.jpg" alt><br><img data-src="/2020/01/21/northwest/14.jpg" alt></p>
<h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><p>茶卡地区阴天，没看到传闻的天空之镜，遗憾。中午就近吃的羊肉汤，景区门口这个价格，那么多羊肉，真的实惠。</p>
<p><img data-src="/2020/01/21/northwest/18.jpg" alt></p>
<h1 id="翡翠湖"><a href="#翡翠湖" class="headerlink" title="翡翠湖"></a>翡翠湖</h1><p>当体特产 炕锅羊肉 是真的香。</p>
<p><img data-src="/2020/01/21/northwest/19.jpg" alt></p>
<h1 id="石油小镇"><a href="#石油小镇" class="headerlink" title="石油小镇"></a>石油小镇</h1><p>以下风景过于美丽，故单独成文。</p>
<p><a href="https://muyuuuu.github.io/2020/01/16/oiltown/">https://muyuuuu.github.io/2020/01/16/oiltown/</a></p>
<h1 id="西出阳关"><a href="#西出阳关" class="headerlink" title="西出阳关"></a>西出阳关</h1><p><a href="https://muyuuuu.github.io/2020/01/16/yangguan/">https://muyuuuu.github.io/2020/01/16/yangguan/</a></p>
<h1 id="莫高窟"><a href="#莫高窟" class="headerlink" title="莫高窟"></a>莫高窟</h1><p><a href="https://muyuuuu.github.io/2020/01/17/MoGaoGrottoes/">https://muyuuuu.github.io/2020/01/17/MoGaoGrottoes/</a></p>
<h1 id="大漠飞沙"><a href="#大漠飞沙" class="headerlink" title="大漠飞沙"></a>大漠飞沙</h1><p><a href="https://muyuuuu.github.io/2020/01/17/DunHuangDesert/">https://muyuuuu.github.io/2020/01/17/DunHuangDesert/</a></p>
<h1 id="七彩丹霞"><a href="#七彩丹霞" class="headerlink" title="七彩丹霞"></a>七彩丹霞</h1><p><a href="https://muyuuuu.github.io/2020/01/18/colorful-danxia/">https://muyuuuu.github.io/2020/01/18/colorful-danxia/</a></p>
<h1 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h1><p><img data-src="/2020/01/21/northwest/23.jpg" alt></p>
<p>哈尔滨的两位和河南的一位没来，准备去兰州，杭州的两位从张掖西坐车回家，剩下我俩穿过祁连山回到西宁，看到了祁连山内马儿和羊群在山上自由散漫的吃草，看到了远处可远观不可亵玩焉的雪山。</p>
<p>晚上在西宁吃了梦寐以求的烤羊腿，两人吃的四人餐，买了牦牛干和火车上的零食，回家火车上听着对铺的小姐姐弹着琵琶。</p>
<p><img data-src="/2020/01/21/northwest/30.jpg" alt></p>
<p>流水帐记录完毕，改天补照片。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如果人间有什么值得期待的美景的话，那么西北算一个。</p>
]]></content>
      <categories>
        <category>塞上西北行</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>荒野戈壁之石油小镇</title>
    <url>/2020/01/16/oiltown/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>话不多说，直接上图，只要天气好，处处是大片，不愧是众多电影的取景地。</p>
<p><img data-src="/2020/01/16/oiltown/48.jpg" alt></p>
<a id="more"></a>
<p><img data-src="/2020/01/16/oiltown/1.jpg" alt></p>
<p><img data-src="/2020/01/16/oiltown/3.jpg" alt></p>
<p><img data-src="/2020/01/16/oiltown/15.jpg" alt></p>
<p><img data-src="/2020/01/16/oiltown/28.jpg" alt></p>
<p><img data-src="/2020/01/16/oiltown/32.jpg" alt></p>
<p><img data-src="/2020/01/16/oiltown/38.jpg" alt></p>
<p><img data-src="/2020/01/16/oiltown/51.jpg" alt></p>
<p><img data-src="/2020/01/16/oiltown/52.jpg" alt></p>
]]></content>
      <categories>
        <category>塞上西北行</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测篇：数据预处理</title>
    <url>/2021/01/21/object-detection-data-preprocess/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>反正跑数据也要等待，不如来写几篇博客，这也是我第一次参加这样类型的比赛，做一下相关经验的总结。在天池的<a href="https://tianchi.aliyun.com/competition/entrance/531846/introduction?spm=5176.12281949.1003.10.493e2448TpgWkW" target="_blank" rel="noopener">2021广东工业智造创新大赛，智能算法赛：瓷砖表面瑕疵质检</a>中，提供了基础的 <code>json</code> 数据和文件，这里介绍三种预处理方式：</p>
<ol>
<li>普通数据制作 <code>COCO</code> 数据集</li>
<li>普通数据制作 <code>mask</code> 数据</li>
<li>因图片尺寸过大显存溢出，所以需要切割图片使得切割图片包含目标区域</li>
<li>自适应切割</li>
<li>类别平衡处理</li>
</ol>
<a id="more"></a>
<p>题目中，提供的 <code>json</code> 格式文件如下，即使在文件名相同的情况下，也是一个目标对应一条 <code>json</code> 数据。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"235_2_t20201127123021723_CAM2.jpg"</span>,</span><br><span class="line">    <span class="attr">"image_height"</span>: <span class="number">6000</span>,</span><br><span class="line">    <span class="attr">"image_width"</span>: <span class="number">8192</span>,</span><br><span class="line">    <span class="attr">"category"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"bbox"</span>: [</span><br><span class="line">        <span class="number">1655.06</span>,</span><br><span class="line">        <span class="number">1094.04</span>,</span><br><span class="line">        <span class="number">1663.06</span>,</span><br><span class="line">        <span class="number">1102.04</span></span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"235_2_t20201127123021723_CAM2.jpg"</span>,</span><br><span class="line">    <span class="attr">"image_height"</span>: <span class="number">6000</span>,</span><br><span class="line">    <span class="attr">"image_width"</span>: <span class="number">8192</span>,</span><br><span class="line">    <span class="attr">"category"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"bbox"</span>: [</span><br><span class="line">        <span class="number">1909.06</span>,</span><br><span class="line">        <span class="number">1379.04</span>,</span><br><span class="line">        <span class="number">1920.06</span>,</span><br><span class="line">        <span class="number">1388.04</span></span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h1 id="制作-COCO-数据集"><a href="#制作-COCO-数据集" class="headerlink" title="制作 COCO 数据集"></a>制作 COCO 数据集</h1><p><code>COCO</code> 数据集格式可以<a href="https://blog.yuxinzhao.top/coco-dataset-format/" target="_blank" rel="noopener">参考这里</a>。在真实训练的过程中，<code>info, version, licenses</code>等信息没啥卵用，可以直接设为 <code>None</code>。</p>
<p>对于 <code>images</code> 字段，由『图片名、图片ID、图片宽高』组成，图片宽高和图片名可以直接获取。所以需要为每一个图片设置 <code>ID</code>，图片名相同，则 <code>ID</code> 名相同且唯一，这个用 python 的字典不难实现。</p>
<p>对于 <code>annotations</code> 字段，由『segmentation, area, iscrowd, image_id, bbox, category_id, id』组成。其中，这里的 <code>id</code> 是盒子的 <code>id</code>，全局唯一，遍历数据集的时候设置自增变量便可实现。</p>
<ul>
<li><code>segmentation</code> 表示分割的多边形，如果是矩形就写顺时针切割：<code>x1, y1, x2, y1, x2, y2, x1, y2</code>；如果不是矩形，题中的数据会提供的，自己获取即可；</li>
<li><code>area</code> 表示面积，矩形的话就长乘宽；</li>
<li><code>iscrowd</code> 为 1 时，表示用起始像素加一段其它像素来框住 <code>mask</code> 区域；为 0 时，表示 <code>segmentation</code> 为多边形；</li>
<li><code>image_id</code> 表示这个字段对应哪个图片；</li>
<li><code>bbox</code> 表示盒子区域；</li>
<li><code>category_id</code> 表示这个目标区域的类别；</li>
</ul>
<p>获取起来也不是很难的样子，一次 for 循环就可以搞定。<a href="https://github.com/XDU-Bigbing/Simple-Key-Point-Detection/blob/main/code/coco.py" target="_blank" rel="noopener">代码</a>。</p>
<h1 id="制作-mask-数据集"><a href="#制作-mask-数据集" class="headerlink" title="制作 mask 数据集"></a>制作 mask 数据集</h1><p><code>mask</code> 数据格式可以参考我的<a href="https://muyuuuu.github.io/2021/01/19/Mask-PIL-jpg-and-png/">上篇文章</a>。这里，因为一张图片里面有好几个目标。所以，先用字典按照 <code>name</code> 排序，再用 <code>groupby</code> 进行分组，使得一张图片下面能包括所有的目标区域。新json文件的格式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"197_100_t20201119093903298_CAM1.jpg"</span>,</span><br><span class="line">    <span class="attr">"image_height"</span>: <span class="number">6000</span>,</span><br><span class="line">    <span class="attr">"image_width"</span>: <span class="number">8192</span>,</span><br><span class="line">    <span class="attr">"category"</span>: [</span><br><span class="line">        <span class="number">3</span>,</span><br><span class="line">        <span class="number">3</span>,</span><br><span class="line">        <span class="number">3</span>,</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"bbox"</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="number">3485.51</span>,</span><br><span class="line">            <span class="number">5037.54</span>,</span><br><span class="line">            <span class="number">3492.51</span>,</span><br><span class="line">            <span class="number">5046.54</span></span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            <span class="number">4225.65</span>,</span><br><span class="line">            <span class="number">1587.67</span>,</span><br><span class="line">            <span class="number">4233.65</span>,</span><br><span class="line">            <span class="number">1597.67</span></span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            <span class="number">4362.51</span>,</span><br><span class="line">            <span class="number">4815.54</span>,</span><br><span class="line">            <span class="number">4370.51</span>,</span><br><span class="line">            <span class="number">4823.54</span></span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            <span class="number">1931.72</span>,</span><br><span class="line">            <span class="number">3621.12</span>,</span><br><span class="line">            <span class="number">1960.72</span>,</span><br><span class="line">            <span class="number">3725.12</span></span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>遍历得到的新字典(<strong>注意：groupby 后得到的字典只能迭代一次</strong>)。这里为了节省内存，不打开原始图片文件，按照 <code>json</code> 文件提供生成背景为黑色、尺寸为原图像尺寸的图片，在对图片的每个目标区域生成掩码颜色，把掩码颜色贴到背景图片在保存即可。<a href="https://github.com/XDU-Bigbing/Simple-Key-Point-Detection/blob/main/code/mask.py" target="_blank" rel="noopener">代码</a>。</p>
<h2 id="mask-颜色注意事项"><a href="#mask-颜色注意事项" class="headerlink" title="mask 颜色注意事项"></a>mask 颜色注意事项</h2><p>这里需要注意的是，如果要用颜色来区分类别（<del>取决于训练数据的代码如何写</del>），一定不能写成这样。因为读取图片后，想要根据目标的数量来设置训练使用的 label，此时用<code>np.unique()</code>统计类别数量时，所有类别的数值都一样，便无法获取准确类别。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'#FF0000'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'#00FF00'</span>,</span><br><span class="line">    <span class="string">'3'</span>: <span class="string">'#0000FF'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以写成这样，总之保证颜色不一致就可以了。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'#110000'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'#002200'</span>,</span><br><span class="line">    <span class="string">'3'</span>: <span class="string">'#000033'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="切割图片"><a href="#切割图片" class="headerlink" title="切割图片"></a>切割图片</h1><p>这个是最头疼的一步。假设我们要切割 <code>512 X 512</code> 的图片，使切割图片包含目标区域。<code>FasrerRCNN</code>等主流目标检测工具有负样本的机制，所以不用切割无关区域。初试的裁剪想法是，随机生成一个点的坐标，这个点是左上角的顶点，这个顶点的坐标加上 512 后能覆盖目标区域。点的坐标由两部分组成，分别是 <code>left</code> 和 <code>top</code>。在生成<code>left</code>和<code>top</code>时加入限制，保证裁剪区域会覆盖目标区域的像素点。但切割中仍然会有很多问题存在，溢出、损坏区域大于 512 等，如下图所示：</p>
<p><img data-src="https://static01.imgkr.com/temp/23b21b60987c46b199f89c3e66581084.png" alt></p>
<p>所以总结后的裁剪逻辑：</p>
<ol>
<li>先处理损坏区域大于 512 的情况</li>
<li>处理顶点左侧溢出边界</li>
<li>若不满足以上情况，随机生成顶点的横坐标</li>
<li>处理顶点下侧溢出边界</li>
<li>若不满足以上情况，随机生成顶点的纵坐标</li>
<li>如果横向裁剪溢出右边界，那么缩小横坐标</li>
<li>如果竖向裁剪溢出下边界，那么缩小纵坐标</li>
<li>判断裁剪区域和目标区域是否有交集，没有交集的情况下，移动坐标点</li>
</ol>
<p>裁剪完毕后，需要对裁剪区域进行检验，防止裁剪失败。这里就是用<code>np.unique(array)</code>来获取裁剪区域中的所有像素点，判断返回值的长度是否大于1来判断是否含有目标区域。因为背景元素肯定占一个元素，所以不能用大于0来判断。<a href="https://github.com/XDU-Bigbing/Simple-Key-Point-Detection/blob/main/code/cut.py" target="_blank" rel="noopener">代码</a>。</p>
<h1 id="自适应切割"><a href="#自适应切割" class="headerlink" title="自适应切割"></a>自适应切割</h1><p>图片的大小大约为 <code>6000X8000</code>，是不小存在了。在处理图片的时候我们发现，有的坏点（目标区域）很小，只有 <code>5X5</code> 的规模，而有的目标区域很大，有 <code>512X512</code>的规模。除了网络要就加入自适应机制外，我们在图像预处理部分也加入了相关处理。</p>
<p>首先定位到原始的盒子<code>B1</code>，用随机数生成一个更大的<code>B2</code>框，<code>B2</code>框在允许的情况下是 <code>B1</code> 的 10 倍左右(这里用随机数实现)。最后裁剪<code>B2</code>框，裁剪后将裁剪的图片设置为统一大小，<strong>也就是所有的目标区域在512尺寸的图片中大小都会一致</strong>。防止了特别大和特别小的极端对立，也省去了在 <code>FasterRCNN</code> 中 <code>Ancthor</code> 数量和规模的设置，训练和推理更加迅速。在切割的时候，把原始盒子<code>B1</code>的位置重新定位下，保存到新的 <code>json</code>，预处理就做完了。<a href="https://github.com/XDU-Bigbing/Simple-Key-Point-Detection/blob/main/code/cut.py" target="_blank" rel="noopener">代码</a>。</p>
<h1 id="类别平衡处理"><a href="#类别平衡处理" class="headerlink" title="类别平衡处理"></a>类别平衡处理</h1><p>在训练集中，我们发现5号类有8886个样本，6号类只有331个样本。可能是由于制作工艺的原因，6号类对应的损坏很难出现，但容易出现5号类对应的损坏。为了平衡样本，直接采取了一种简单粗暴的解决方案：</p>
<ul>
<li>每个类共需要 2000 张图片；</li>
<li>对于样本数量大于 2000 的类来说，就随机选择；</li>
<li>对于样本数量低于 2000 的类来说，就做数据增强，翻转或每个盒子多裁剪几张都是可以的</li>
</ul>
<p>最后，每个类都有 2000 张图片，这样样本就均衡了许多。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>完整项目代码：<br><a href="https://github.com/XDU-Bigbing/Simple-Key-Point-Detection/tree/main/code" target="_blank" rel="noopener">https://github.com/XDU-Bigbing/Simple-Key-Point-Detection/tree/main/code</a></p>
<h1 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h1><p>参加比赛的时候距离比赛开始过去半个月了，and实验室一直有破事，比赛打的断断续续，没有弃赛胜似弃赛，这次就当积累经验和踩坑了，准确率23%，排名460/4700。生命不息，踩坑无数，记录参赛经验<del>毕竟纯做论文得不到更加贴近实际的经验</del>：</p>
<ol>
<li>写完代码后要检查，不要怕麻烦，不要等到最后执行完采取看结果，或者执行小规模的代码，发现错误后可能两个小时已经浪费了，这一点上我的确吃了不少亏；</li>
<li>数据与代码分离，不要将代码和数据放在一个文件夹。虽然读取数据方便，可万一认为当前的模型不好使想删除时，一不小心直接 <code>rm -rf /*</code> 了，连数据一起删没了。数据应该放在单独文件夹，不在任何代码的文件夹下。这一点在使用服务器进行炼丹的时候要尤为注意；</li>
<li>写出通用性强的代码，做出一次结果后，很可能不满意需要再次调整数据和模型，比如额外增加功能或选择判断。需求可能会一直在变，所以代码不要一次性写死，要写的更加灵活和可维护。当然这需要一些程序设计经验，只可意会不可言传。这里只是推荐 <code>argparse</code> 这个库，不用一次次去程序里面改参数了；</li>
<li>模型大体上都一样，学懂理论后，先找个别人实现好的直接套用观察结果就好<del>实力硬可以自己重头写</del>；其他的印象不是很深刻了，只要python功底强大，还是能应付各种场景需求和读懂他人源代码的。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>COCO 数据集格式：<a href="https://blog.yuxinzhao.top/coco-dataset-format/" target="_blank" rel="noopener">https://blog.yuxinzhao.top/coco-dataset-format/</a></li>
<li>segmentation写法：<a href="http://www.xyu.ink/3612.html" target="_blank" rel="noopener">http://www.xyu.ink/3612.html</a></li>
<li>iscrowd解释：<a href="https://github.com/cocodataset/cocoapi/issues/184" target="_blank" rel="noopener">https://github.com/cocodataset/cocoapi/issues/184</a></li>
<li>PIL缩放图像注释事项：<a href="https://jdhao.github.io/2020/11/18/pillow_image_resize_pitfall/" target="_blank" rel="noopener">https://jdhao.github.io/2020/11/18/pillow_image_resize_pitfall/</a></li>
</ol>
]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>黄山相册</title>
    <url>/2019/05/02/pic-Huang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有机会买个单反吧，手机拍摄质量差。</p>
<p>去的路上看了一本叫《文化苦旅》的书，杭州宣言和黄州突围。一个地区总有属于自己的内涵文化，而且我文字功底也差，就不写狗屁的散文游记了，单纯的留个相册作为纪念然后就溜。</p>
<p><img data-src="/2019/05/02/pic-Huang/104.jpg" alt></p>
<a id="more"></a>
<p><img data-src="/2019/05/02/pic-Huang/12.jpg" alt></p>
<p><img data-src="/2019/05/02/pic-Huang/62.jpg" alt></p>
<p><img data-src="/2019/05/02/pic-Huang/66.jpg" alt></p>
<p><img data-src="/2019/05/02/pic-Huang/67.jpg" alt></p>
<p><img data-src="/2019/05/02/pic-Huang/70.jpg" alt></p>
<p><img data-src="/2019/05/02/pic-Huang/71.jpg" alt></p>
<p><img data-src="/2019/05/02/pic-Huang/72.jpg" alt></p>
<p><img data-src="/2019/05/02/pic-Huang/88.jpg" alt></p>
<p><img data-src="/2019/05/02/pic-Huang/103.jpg" alt></p>
]]></content>
      <categories>
        <category>江南水乡</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>pagerank 算法实现</title>
    <url>/2021/03/19/pagerank/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个好的搜索引擎是现如今面向互联网编程的重要工具。而<code>pagerank</code>是曾经谷歌用来确定搜索引擎网页排名的算法，算法足够简洁且实用，且采用集群进行分布式计算而不是小型机的方法，给当时的网页排名带来了革命性突破。如果你实在看不懂理论部分如何处理的，就想当初的我一样。建议好好看一下代码，一目了然。</p>
<a id="more"></a>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>这个算法十分简单，核心思想是『用投票的方法来确定哪个网页的质量好』，可以画几张图就描述清楚。</p>
<p><img data-src="https://s3.ax1x.com/2021/03/19/6WVjv4.png" alt></p>
<ul>
<li>如上图所示，当三个评分为0.2的网页指向一个网页时，那个网页的评分就是0.6；</li>
<li>当一个0.4评分的网页指向两个网页时，那两个网页平分分数，都是0.2。</li>
</ul>
<p>算法将整个互联网，看做一张有向图，网页是图上的点，链接是图上的有向边。每个网页都有一个分数，称作 PageRank，可以把它当做是一种「投票权」，将每一个链接作为一次「投票」，每个网页的 PageRank 等于所有指向该网页的网页的 PageRank 的求和。如果一个网页被指向的次数很多，且分数很大，那么就认为这个网页是被投票选出来的高质量网页；反之是广告等流氓网页。</p>
<h2 id="环形处理"><a href="#环形处理" class="headerlink" title="环形处理"></a>环形处理</h2><p><img data-src="https://s3.ax1x.com/2021/03/19/6WZ0iV.png" alt></p>
<p>如果是这样的网页，1号网页指向2号网页，2号网页指向3号网页，3号网页又指回1号网页。这个环路会一直循环，分数会持续叠加。这样的结果肯定不正确。为了处理环路，论文中指出：当用户在浏览网页时，有$\alpha$的概率沿着链接去访问下一个网页；$1-\alpha$的概率直接关闭网页去看其他网页。那么问题就迎刃而解了，设置随机数，来确定沿着链接访问网页还是访问其他的网页。处理环路的代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pagerank</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, alpha=<span class="number">0.15</span>, num=<span class="number">1000</span>)</span>:</span></span><br><span class="line">        self.__alpha = alpha</span><br><span class="line">        self.__num = num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 邻接矩阵</span></span><br><span class="line">        adj = np.array(([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], </span><br><span class="line">                        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]))</span><br><span class="line">        cnt = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">        <span class="comment"># 最开始访问的页面</span></span><br><span class="line">        page = np.random.randint(<span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.__num):</span><br><span class="line">            tmp = np.random.random()</span><br><span class="line">            <span class="comment"># 页面内选择</span></span><br><span class="line">            <span class="keyword">if</span> tmp &gt; self.__alpha:</span><br><span class="line">                page = np.where(adj[page] == <span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">                cnt[page] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 随机游走</span></span><br><span class="line">            <span class="keyword">if</span> tmp &lt;= self.__alpha:</span><br><span class="line">                page = int(np.random.randint(<span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>))</span><br><span class="line">                cnt[page] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alpha, num = <span class="number">0.15</span>, <span class="number">1000</span></span><br><span class="line">page_num = pagerank(num=num, alpha=alpha)</span><br><span class="line">cnt = page_num.run()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 百分比表示某个时间点查看某个页面的概率</span></span><br><span class="line">page_pro = [str(i / num * <span class="number">100</span>) + <span class="string">'%'</span> <span class="keyword">for</span> i <span class="keyword">in</span> cnt]</span><br><span class="line">print(page_pro)</span><br></pre></td></tr></table></figure>
<p>而最后用百分比来表示某个页面在某一个时间段内被查看的概率，就可以按照概率的大小来确定网页排名了。结果大概是：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="number">0.04</span></span><br><span class="line"><span class="number">1</span>: <span class="number">0.33</span></span><br><span class="line"><span class="number">2</span>: <span class="number">0.32</span></span><br><span class="line"><span class="number">3</span>: <span class="number">0.3</span></span><br></pre></td></tr></table></figure>
<h2 id="一般化"><a href="#一般化" class="headerlink" title="一般化"></a>一般化</h2><p>Step1：假设得到$N$个网页，所有的网站的初始排名是$B_0=(\frac{1}{N},\frac{1}{N},…,\frac{1}{N})^T$。</p>
<p>Step2：矩阵$A$是网页之间的链接数目，得到这个矩阵并不难，只要有个爬虫机器人就好了。</p>
<p>Step3: 更新网页排名分数：<script type="math/tex">B_{i+1}=\alpha A B_i + (1−\alpha)B_0</script> 。公式第一项为其他页面沿着链接访问该页面的分数，第二项为直接跳转到该页面的分数。</p>
<p>Step4：迭代计算直至$|B_{i+1}−B_i|&lt;\epsilon$，或者制定迭代轮数，可以得到最终结果。（选排名前几的就可以了）</p>
<p><img data-src="https://s3.ax1x.com/2021/03/19/6WezA1.png" alt></p>
<p>对于上图，一个完整的 <code>pagerank</code> 算法代码如下所示：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pagerank</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, adj, alpha=<span class="number">0.15</span>, num=<span class="number">1000</span>)</span>:</span></span><br><span class="line">        self.__adj = adj</span><br><span class="line">        self.__alpha = alpha</span><br><span class="line">        self.__num = num</span><br><span class="line">        self.__page_num = self.__adj.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 均匀设置分数</span></span><br><span class="line">        score = [<span class="number">1</span> / self.__page_num <span class="keyword">for</span> i <span class="keyword">in</span> range(self.__page_num)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 看看有哪些页面指向自己</span></span><br><span class="line">        point_to_self = [</span><br><span class="line">            list(np.where(self.__adj[:, i] == <span class="number">1</span>)[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.__page_num)</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果四个页面，3号页面指向1号页面和2号页面，那么转移到任何一个页面的概率要平分</span></span><br><span class="line">        point_to_other = [</span><br><span class="line">            s / np.where(self.__adj[i, :] == <span class="number">1</span>)[<span class="number">0</span>].size</span><br><span class="line">            <span class="keyword">for</span> i, s <span class="keyword">in</span> enumerate(score)</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 均匀跳转概率</span></span><br><span class="line">        jump_pro = <span class="number">1</span> / self.__page_num</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 网页访问 num 次，计算每个页面的概率</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(self.__num):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.__page_num):</span><br><span class="line">                s = sum(point_to_other[j] <span class="keyword">for</span> j <span class="keyword">in</span> point_to_self[i])</span><br><span class="line">                <span class="comment"># 其它页面指向自己，加上跳转概率，就是自己被访问的概率</span></span><br><span class="line">                score[i] = s * (<span class="number">1</span> - self.__alpha) + self.__alpha * jump_pro</span><br><span class="line">            <span class="comment"># 访问一次后，指向其它页面的概率更新，也就是再次均匀划分</span></span><br><span class="line">            point_to_other = [</span><br><span class="line">                s / np.where(self.__adj[i, :] == <span class="number">1</span>)[<span class="number">0</span>].size</span><br><span class="line">                <span class="keyword">for</span> i, s <span class="keyword">in</span> enumerate(score)</span><br><span class="line">            ]</span><br><span class="line">        <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 邻接矩阵</span></span><br><span class="line">    adj = np.array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">assert</span> adj.shape[<span class="number">0</span>] == adj.shape[<span class="number">1</span>]</span><br><span class="line">    alpha = <span class="number">0.15</span></span><br><span class="line">    num = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    p = pagerank(adj, alpha=alpha, num=num)</span><br><span class="line">    score = p.run()</span><br><span class="line"></span><br><span class="line">    page_pro = [str(round(i * <span class="number">100</span>, <span class="number">2</span>)) + <span class="string">'%'</span> <span class="keyword">for</span> i <span class="keyword">in</span> score]</span><br><span class="line">    print(page_pro)</span><br></pre></td></tr></table></figure>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><ul>
<li><a href="https://course.ccs.neu.edu/cs6200f14/wt2g_inlinks" target="_blank" rel="noopener">数据集</a>（把数据集直接复制粘贴保存为<code>link.data</code>）</li>
<li>数据集说明：<a href="https://amslaurea.unibo.it/10469/1/Temporal_PageRank.pdf" target="_blank" rel="noopener">https://amslaurea.unibo.it/10469/1/Temporal_PageRank.pdf</a></li>
<li>代码链接：<a href="https://github.com/muyuuuu/Spark-learn/blob/main/pagerank-demo/main.py" target="_blank" rel="noopener">https://github.com/muyuuuu/Spark-learn/blob/main/pagerank-demo/main.py</a></li>
</ul>
<p>我做出来的结果是下面这样的，和网上公布的大多结果保持一致。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 节点数量</span></span><br><span class="line">vertex number <span class="keyword">is</span> : <span class="number">183811</span></span><br><span class="line"><span class="comment"># 边的数量</span></span><br><span class="line">edge number <span class="keyword">is</span> : <span class="number">641727</span></span><br><span class="line"><span class="comment"># 迭代 100 轮执行时间</span></span><br><span class="line"><span class="number">33.12673735618591</span></span><br><span class="line"><span class="comment"># 排名前几的结果</span></span><br><span class="line">WT21-B37<span class="number">-76</span> <span class="number">0.0014513384131756468</span></span><br><span class="line">WT21-B37<span class="number">-75</span> <span class="number">0.0008265334385338406</span></span><br><span class="line">WT25-B39<span class="number">-116</span> <span class="number">0.0007959759004498566</span></span><br><span class="line">WT23-B21<span class="number">-53</span> <span class="number">0.000743342282644727</span></span><br><span class="line">WT24-B40<span class="number">-171</span> <span class="number">0.0006743921148099952</span></span><br><span class="line">WT23-B39<span class="number">-340</span> <span class="number">0.000671900553656238</span></span><br><span class="line">WT23-B37<span class="number">-134</span> <span class="number">0.0006528246305109245</span></span><br><span class="line">WT08-B18<span class="number">-400</span> <span class="number">0.000619414607912892</span></span><br><span class="line">WT13-B06<span class="number">-284</span> <span class="number">0.0006092497992106295</span></span><br><span class="line">WT24-B26<span class="number">-46</span> <span class="number">0.0005877279600700914</span></span><br><span class="line">WT13-B06<span class="number">-273</span> <span class="number">0.0005658734074429803</span></span><br><span class="line">WT01-B18<span class="number">-225</span> <span class="number">0.0005354041130099478</span></span><br><span class="line">WT04-B27<span class="number">-720</span> <span class="number">0.0005072144885359412</span></span><br><span class="line">WT23-B19<span class="number">-156</span> <span class="number">0.0004843699050803331</span></span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://liam.page/2017/04/04/Python-100-lines-of-PageRank/" target="_blank" rel="noopener">https://liam.page/2017/04/04/Python-100-lines-of-PageRank/</a></p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>正则化调教神经网络</title>
    <url>/2019/02/19/optimizeDL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>来整理一下在机器学习中常用的优化方法，无非是在容易出问题的地方加入人的调控，包括数据数据，数据处理，反向传播，梯度函数等方面，在各种容易出问题的地方加入调控，使得神经网络更有效，或者说神经网络的运行在你的控制之中，而不是调了一堆参数后网络没有优化，甚至调一些无关紧要的参数。</p>
<p>本文收录内容：</p>
<ul>
<li>正则化的常用方式与实现</li>
<li>有关数据输入和传输的处理</li>
<li>优化后的梯度函数</li>
</ul>
<p>还是在实际的背景下对于这些概念的理解，学会变通和利用已有的知识进行问题转换。</p>
<a id="more"></a>
<hr>
<h2 id="L2正则化"><a href="#L2正则化" class="headerlink" title="L2正则化"></a>L2正则化</h2><p>假设此时的成本函数为：</p>
<script type="math/tex; mode=display">J(w,b)=\frac{1}{m}\sum_1^m L(\hat{y}^i,y^i)</script><p>那么在这个成本函数的后面加入正则项，修改之前的成本函数为：</p>
<script type="math/tex; mode=display">J(w,b)=\frac{1}{m}\sum_1^m L(\hat{y}^i,y^i)+\frac{\lambda}{2m}||w||^2_2</script><p>$\lambda$是需要自己调节的正则化参数，因为对于网络的参数而言，$w$比$b$要多得多，而且影响在非线性空间内，对于线性空间的调节较为容易，所以正则项中是不含有$b$的。</p>
<h3 id="L2正则化为何有效"><a href="#L2正则化为何有效" class="headerlink" title="L2正则化为何有效"></a>L2正则化为何有效</h3><p>这个正则项是如何工作的呢？在反向传播时，利用代价函数对$l$层的$w$进行梯度下降，得到：</p>
<script type="math/tex; mode=display">dw^{[l]}=\frac{\partial{J}}{\partial{w^{[l]}}}+\frac{\lambda}{m}w^{[l]}</script><p>于是在参数$w$更新的过程中，会减去额外的正则项，假设当$\lambda$足够大时，会有许多的$w$会近似为零，导致正向传播时输出$z$也位于0的附近。两点好处：$w$近似为0会缩小了网络的规模，防止了过拟合。输出$z$近似0会使得$z$位于激活函数最容易激活的区域，比如$\mathrm{sigmoid}$函数在$x=0$处的导数最大，利于网络的学习。</p>
<p>而且观察更新时的正则梯度，对于数值越大的$w$，参数下降的幅度也就越大，同样会导致权重衰减，参数近似于0之后相当于缩小了网络规模。</p>
<h3 id="简单的Tensorflow实现"><a href="#简单的Tensorflow实现" class="headerlink" title="简单的Tensorflow实现"></a>简单的Tensorflow实现</h3><p>这里创建了一个差不多的模型，一个小规模网络，一个大规模网络，还有一个正则化的网络，进行对比，了解正则项的作用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">NUM_WORDS = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">(train_data, train_labels), (test_data, test_labels) = keras.datasets.imdb.load_data(num_words=NUM_WORDS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># data preprocessing</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_hot_sequences</span><span class="params">(sequences, dimension)</span>:</span></span><br><span class="line">    <span class="comment"># Create an all-zero matrix of shape (len(sequences), dimension)</span></span><br><span class="line">    results = np.zeros((len(sequences), dimension))</span><br><span class="line">    <span class="keyword">for</span> i, word_indices <span class="keyword">in</span> enumerate(sequences):</span><br><span class="line">        results[i, word_indices] = <span class="number">1.0</span>  <span class="comment"># set specific indices of results[i] to 1s</span></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">train_data = multi_hot_sequences(train_data, dimension=NUM_WORDS)</span><br><span class="line">test_data = multi_hot_sequences(test_data, dimension=NUM_WORDS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># basic model</span></span><br><span class="line">baseline_model = keras.Sequential([</span><br><span class="line">    <span class="comment"># `input_shape` is only required here so that `.summary` works.</span></span><br><span class="line">    keras.layers.Dense(<span class="number">16</span>, activation=tf.nn.relu, input_shape=(NUM_WORDS,)),</span><br><span class="line">    keras.layers.Dense(<span class="number">16</span>, activation=tf.nn.relu),</span><br><span class="line">    keras.layers.Dense(<span class="number">1</span>, activation=tf.nn.sigmoid)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">baseline_model.compile(optimizer=<span class="string">'adam'</span>,</span><br><span class="line">                       loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">                       metrics=[<span class="string">'accuracy'</span>, <span class="string">'binary_crossentropy'</span>])</span><br><span class="line"></span><br><span class="line">baseline_history = baseline_model.fit(train_data,</span><br><span class="line">                                      train_labels,</span><br><span class="line">                                      epochs=<span class="number">20</span>,</span><br><span class="line">                                      batch_size=<span class="number">512</span>,</span><br><span class="line">                                      validation_data=(test_data, test_labels),</span><br><span class="line">                                      verbose=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># smaller model</span></span><br><span class="line">smaller_model = keras.Sequential([</span><br><span class="line">    keras.layers.Dense(<span class="number">4</span>, activation=tf.nn.relu, input_shape=(NUM_WORDS,)),</span><br><span class="line">    keras.layers.Dense(<span class="number">4</span>, activation=tf.nn.relu),</span><br><span class="line">    keras.layers.Dense(<span class="number">1</span>, activation=tf.nn.sigmoid)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">smaller_model.compile(optimizer=<span class="string">'adam'</span>,</span><br><span class="line">                loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">                metrics=[<span class="string">'accuracy'</span>, <span class="string">'binary_crossentropy'</span>])</span><br><span class="line"></span><br><span class="line">smaller_history = smaller_model.fit(train_data,</span><br><span class="line">                                    train_labels,</span><br><span class="line">                                    epochs=<span class="number">20</span>,</span><br><span class="line">                                    batch_size=<span class="number">512</span>,</span><br><span class="line">                                    validation_data=(test_data, test_labels),</span><br><span class="line">                                    verbose=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bigger model</span></span><br><span class="line">bigger_model = keras.models.Sequential([</span><br><span class="line">    keras.layers.Dense(<span class="number">512</span>, activation=tf.nn.relu, input_shape=(NUM_WORDS,)),</span><br><span class="line">    keras.layers.Dense(<span class="number">512</span>, activation=tf.nn.relu),</span><br><span class="line">    keras.layers.Dense(<span class="number">1</span>, activation=tf.nn.sigmoid)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">bigger_model.compile(optimizer=<span class="string">'adam'</span>,</span><br><span class="line">                     loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">                     metrics=[<span class="string">'accuracy'</span>,<span class="string">'binary_crossentropy'</span>])</span><br><span class="line"></span><br><span class="line">bigger_history = bigger_model.fit(train_data, train_labels,</span><br><span class="line">                                  epochs=<span class="number">20</span>,</span><br><span class="line">                                  batch_size=<span class="number">512</span>,</span><br><span class="line">                                  validation_data=(test_data, test_labels),</span><br><span class="line">                                  verbose=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对比效果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_history</span><span class="params">(histories, key=<span class="string">'binary_crossentropy'</span>)</span>:</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">16</span>,<span class="number">10</span>))</span><br><span class="line">    <span class="keyword">for</span> name, history <span class="keyword">in</span> histories:</span><br><span class="line">        val = plt.plot(history.epoch, history.history[<span class="string">'val_'</span>+key],</span><br><span class="line">                   <span class="string">'--'</span>, label=name.title()+<span class="string">' Val'</span>)</span><br><span class="line">        plt.plot(history.epoch, history.history[key], color=val[<span class="number">0</span>].get_color(),</span><br><span class="line">             label=name.title()+<span class="string">' Train'</span>)</span><br><span class="line"></span><br><span class="line">    plt.xlabel(<span class="string">'Epochs'</span>)</span><br><span class="line">    plt.ylabel(key.replace(<span class="string">'_'</span>,<span class="string">' '</span>).title())</span><br><span class="line">    plt.legend()</span><br><span class="line"></span><br><span class="line">    plt.xlim([<span class="number">0</span>,max(history.epoch)])</span><br><span class="line"></span><br><span class="line">plot_history([(<span class="string">'baseline'</span>, baseline_history),</span><br><span class="line">              (<span class="string">'smaller'</span>, smaller_history),</span><br><span class="line">              (<span class="string">'bigger'</span>, bigger_history)])</span><br></pre></td></tr></table></figure>
<p>发现效果是这样的，较大的网络几乎仅仅1个周期之后便立即开始过拟合，并且之后严重多。网络容量越大，便能够越快对训练数据进行建模（产生较低的训练损失），但越容易过拟合（导致训练损失与验证损失之间的差异很大）。</p>
<p>奥卡姆剃刀定律：如果对于同一现象有两种解释，最可能正确的解释是“最简单”的解释，即做出最少量假设的解释。这也适用于神经网络学习的模型：给定一些训练数据和一个网络架构，有多组权重值（多个模型）可以解释数据，而简单模型比复杂模型更不容易过拟合。</p>
<hr>
<p><img data-src="/2019/02/19/optimizeDL/1.png" alt></p>
<hr>
<p>加入正则的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l2_model = keras.models.Sequential([</span><br><span class="line">    keras.layers.Dense(<span class="number">16</span>, kernel_regularizer=keras.regularizers.l2(<span class="number">0.001</span>),</span><br><span class="line">                       activation=tf.nn.relu, input_shape=(NUM_WORDS,)),</span><br><span class="line">    keras.layers.Dense(<span class="number">16</span>, kernel_regularizer=keras.regularizers.l2(<span class="number">0.001</span>),</span><br><span class="line">                       activation=tf.nn.relu),</span><br><span class="line">    keras.layers.Dense(<span class="number">1</span>, activation=tf.nn.sigmoid)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">l2_model.compile(optimizer=<span class="string">'adam'</span>,</span><br><span class="line">                 loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">                 metrics=[<span class="string">'accuracy'</span>, <span class="string">'binary_crossentropy'</span>])</span><br><span class="line"></span><br><span class="line">l2_model_history = l2_model.fit(train_data, train_labels,</span><br><span class="line">                                epochs=<span class="number">20</span>,</span><br><span class="line">                                batch_size=<span class="number">512</span>,</span><br><span class="line">                                validation_data=(test_data, test_labels),</span><br><span class="line">                                verbose=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plot_history([(<span class="string">'baseline'</span>, baseline_history),</span><br><span class="line">              (<span class="string">'l2'</span>, l2_model_history)])</span><br></pre></td></tr></table></figure>
<hr>
<p><img data-src="/2019/02/19/optimizeDL/2.png" alt></p>
<p>这样，正则项的确有效的降低了在测试集中的方差，没有产生严重的过拟合现象。</p>
<hr>
<h2 id="DropOut正则化"><a href="#DropOut正则化" class="headerlink" title="DropOut正则化"></a>DropOut正则化</h2><p>DropOut是随机丢弃的意思（应用于某个层），指在训练期间随机“丢弃”该层的多个输出特征。假设某个指定的层通常会在训练期间针对给定的输入样本返回一个向量 [0.2, 0.5, 0.3, 0.8, 0.7]；在应用丢弃后，取消低于某概率的神经元连接。</p>
<h3 id="DropOut为何有效"><a href="#DropOut为何有效" class="headerlink" title="DropOut为何有效"></a>DropOut为何有效</h3><p>在下一次的正向传播时，Dropout又开始运转，随机丢弃其他的层，所以每次传播时丢弃的节点是不一样的。假设某一神经元$x$接受的输入数为10，$x$就不会过分的依赖10个输入中的某一个，因为当过分依赖$y$时，$y$可能随机失活导致网络不够稳定，因此$x$对输入的权重依赖是均衡的。</p>
<p>在测试时，网络不会丢弃任何单元，而是将层的输出值按等同于丢弃率的比例进行缩减，以便平衡以下事实：测试时的活跃单元数大于训练时的活跃单元数。</p>
<h3 id="简单的Tensorflow实现-1"><a href="#简单的Tensorflow实现-1" class="headerlink" title="简单的Tensorflow实现"></a>简单的Tensorflow实现</h3><p>在网络中添加两个丢弃层，看看它们在降低过拟合方面表现如何：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dpt_model = keras.models.Sequential([</span><br><span class="line">    keras.layers.Dense(<span class="number">16</span>, activation=tf.nn.relu, input_shape=(NUM_WORDS,)),</span><br><span class="line">    keras.layers.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">16</span>, activation=tf.nn.relu),</span><br><span class="line">    keras.layers.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">1</span>, activation=tf.nn.sigmoid)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">dpt_model.compile(optimizer=<span class="string">'adam'</span>,</span><br><span class="line">                  loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">                  metrics=[<span class="string">'accuracy'</span>,<span class="string">'binary_crossentropy'</span>])</span><br><span class="line"></span><br><span class="line">dpt_model_history = dpt_model.fit(train_data, train_labels,</span><br><span class="line">                                  epochs=<span class="number">20</span>,</span><br><span class="line">                                  batch_size=<span class="number">512</span>,</span><br><span class="line">                                  validation_data=(test_data, test_labels),</span><br><span class="line">                                  verbose=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plot_history([(<span class="string">'baseline'</span>, baseline_history),</span><br><span class="line">              (<span class="string">'dropout'</span>, dpt_model_history)])</span><br></pre></td></tr></table></figure>
<hr>
<p><img data-src="/2019/02/19/optimizeDL/3.png" alt></p>
<p>我们发现，效果还说的过去，在测试集中表现良好。</p>
<hr>
<h2 id="正则化的输入与传播"><a href="#正则化的输入与传播" class="headerlink" title="正则化的输入与传播"></a>正则化的输入与传播</h2><p>其实对输入数据和网络中正向传播的数据进行正则化的处理，也能加快网络的学习速度。先放上正则化的处理方式：</p>
<script type="math/tex; mode=display">x_i=\frac{x_i-\mu_i}{\sigma_i}</script><p>也就是每个特征减去自己的均值在除以自己的方差（测试是均值，方差保持一致），如果学过概率论的话，这样处理后的数据会服从均值为0，方差为1的正态分布，即$X\sim N(0,1)$，看下图：</p>
<p><img data-src="/2019/02/19/optimizeDL/4.png" alt></p>
<h3 id="优化意义"><a href="#优化意义" class="headerlink" title="优化意义"></a>优化意义</h3><p>当不对数据进行正则化时，比如特征$x_1$可能分布在$[1,1000]$，而特征$x_2$可能分布在$[0,1]$，这样的输入会使得成本函数分布在一个乱七八糟(左图)的空间内，可能会沿着最复杂的梯度进行下降，而对所有特征数据正则化到$[0,1]$区间内部时，无论是哪个方向的梯度，都能很快的寻找到最优点。</p>
<p>此外，在网络的正向传播过程中，如果对网络的每一层的接受的输出(激活之前)也进行这样的处理，后面的网络也会运行的更快，如此，正则化便从输入推广到了传播。</p>
<p>传播过程对数据的政策化会使得参数$b$没有意义($x-\mu$)，所以也就取消了这个参数，而且还可以正则化为任意的均值和方差：</p>
<script type="math/tex; mode=display">z=\gamma z_{norm}+\beta</script><p>所以$\gamma$决定了方差，$\beta$决定了均值，这两个参数也是由网络学习而来(每层和煤层不一样，测试时使用的$\mu,\sigma$为所有的batch的加权平均值)。</p>
<p>此外，当对数据进行正则化时，网络也能更加泛化。比如面临不同的输入：黑猫与白猫。网络在学习了认识黑猫后，可能还不认识白猫，因为两者的RGB数值差异很大。但是正则化会限制输入的均值与方差，保证了数据在$[-1,1]$范围内，也就是前层无论面临何种输入，对后层的权重影响都不会太大。</p>
<h3 id="Python的简单实现"><a href="#Python的简单实现" class="headerlink" title="Python的简单实现"></a>Python的简单实现</h3><p>该层在每个batch上将前一层的激活值重新规范化，即使得其输出数据的均值接近0，其标准差接近1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keras.layers.normalization.BatchNormalization(axis=<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<p>利用numpy的广播机制快速对输入的数据标准化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (a - np.mean(a, axis=<span class="number">0</span>)) / (np.std(a, axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h2 id="其他正则化方案"><a href="#其他正则化方案" class="headerlink" title="其他正则化方案"></a>其他正则化方案</h2><p>简单的介绍一种early_stop的方法，在测试误差达到最低点并开始上升的时刻终止训练，也就是在训练没有结束是提前结束训练过程。</p>
<h3 id="Tensorflow的实现"><a href="#Tensorflow的实现" class="headerlink" title="Tensorflow的实现"></a>Tensorflow的实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintDot</span><span class="params">(keras.callbacks.Callback)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_epoch_end</span><span class="params">(self, epoch, logs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">100</span> == <span class="number">0</span>: </span><br><span class="line">            print(epoch / <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">EPOCHS = <span class="number">500</span></span><br><span class="line"><span class="comment"># The patience parameter is the amount of epochs to check for improvement</span></span><br><span class="line">early_stop = keras.callbacks.EarlyStopping(monitor=<span class="string">'val_loss'</span>, patience=<span class="number">200</span>)</span><br><span class="line"><span class="comment"># Store training stats</span></span><br><span class="line">history = model.fit(train_data, train_labels, epochs=EPOCHS,</span><br><span class="line">                    validation_split=<span class="number">0.2</span>, verbose=<span class="number">0</span>,</span><br><span class="line">                    callbacks=[early_stop, PrintDot()])</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_history</span><span class="params">(history)</span>:</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.xlabel(<span class="string">'Epoch'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Mean Abs Error [1000$]'</span>)</span><br><span class="line">    plt.plot(history.epoch, np.array(history.history[<span class="string">'mean_absolute_error'</span>]),</span><br><span class="line">           label=<span class="string">'Train Loss'</span>)</span><br><span class="line">    plt.plot(history.epoch, np.array(history.history[<span class="string">'val_mean_absolute_error'</span>]),</span><br><span class="line">           label = <span class="string">'Val loss'</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.ylim([<span class="number">0</span>, <span class="number">5</span>])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_history(history)</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/02/19/optimizeDL/5.png" alt></p>
<p>希望根据这些数据判断：对模型训练多长时间之后它会停止优化。此图显示，在大约200个周期之后，模型几乎不再出现任何改进。所以更新一下model.fit方法，以便在验证分数不再提高时自动停止训练。将使用一个回调来测试每个周期的训练状况。如果模型在一定数量的周期之后没有出现任何改进，则自动停止训练。</p>
<h3 id="缺陷与不足"><a href="#缺陷与不足" class="headerlink" title="缺陷与不足"></a>缺陷与不足</h3><p>缺陷是什么呢？在之前的几种正则化方案中，降低成本函数$J(w,b)$和防止过拟合是两部分，但是early_stop中降低成本函数和防止过拟合成为了一部分，也就是为了防止过拟合，停止了训练，也停止了降低成本函数。这样得到的精确度不是最高的，但是训练速度可能比较快，在某些简单的场合也不是不能用。</p>
<hr>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>打球～～～</title>
    <url>/2018/11/02/playball-2018-11-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>好久不打球的说。</p>
<p>赶在一个大家都没有课的下午，阳关暖人，秋风惬意。拿着球拍，去隔壁学校打球（舒缓一下筋骨）。</p>
<a id="more"></a>
<p>想起了很久以前，大概是八、九岁的样子，家属院里买来一个乒乓球台，和发小开始了打球的生涯，每周五解放赶紧骑着车子去打球，然后是周六中午下午，周日中午中午下午，上午要写作业，毕竟小时候听话。寒暑假那就是基本泡在球台，从早上玩到晚上，直到日落西山看不见一点东西才恋恋不舍的回家。记得是12岁的时候，以发小里面那群球打得好的而论，技术一般的大人根本打不过我们。当初杀球的速度、切球的角度、发球的旋转还有拉球的力度，现在都难及当初水平的五分之一。</p>
<p>日复一日的练习，球打的越来越好，球拍买的也越来越贵，就是有了传说中的一技之长吧，后来课程越来越多，后来球台附近长满了草，后来球台没了，童年也随之而去了。后来有的人去练体育，也有人学习很好去了浙江大学，也有人搬家离开了，那时候也没有QQ没有微信，搬家是真的再也见不到了，我还记得那孩子特别聪明，写了5页的作文来嘲讽老师，我这种人比较平凡，学习不好打球也一般，不过这都是后话了。</p>
<p>在后来就是一个高中，和所有高中一样，各种借口占体育课，体育设施说不能用吧，用着恶心；说能用吧，还是用着不爽。在为数不多的几个体育课中，也只能去打羽毛球了，蓝天为上界，黄土为下界，没有球网，没有界限。这可能是我人生中打球打的最爽的几次，更确切的说不是打球，是抡胳膊，尽全力的把球打远，就那样两个人（我同桌）对打，打上一节课。即使课后浑身是汗胳膊酸痛，可是很舒服啊，可这样的青春眨眼间就再也回不来了。我不羡慕现在环境的高质量球拍，也不羡慕有专业的场地，只想再来一场操场下的哈哈大笑，再来一次蓝天白云下放开了抡的球，还有当时最重要的年少气盛啊。终究要告别，是再也回不来的青春，告别幼稚后的不舍和怀念，是再难相见的人。</p>
<p>上了大学，因为是新建设的校区，还没有相关的设备，打球也只能去隔壁的学校。这可能是两年来的第一次打球吧，讲真玩的不是很尽兴，就当怀念下过去，挺好~</p>
<p><img data-src="/2018/11/02/playball-2018-11-2/1.png" alt><br><img data-src="/2018/11/02/playball-2018-11-2/2.png" alt></p>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统『三』：进程同步</title>
    <url>/2021/02/19/process-synchronization/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用多线程必须注意一个问题，如果有多个线程同时运行，而且它们试图访问相同的资源，就会遇到各种问题。如请求在代码在阅读时写入其他函数，即一个线程要读，一个线程要写，读线程占据着资源，写线程得不到资源，自然就会与理想的结果相违背。<strong>本文更侧重理论解读，某些场景下，这些概念可同样用到进程中；样例代码为C语言，其他语言仍然适用。</strong></p>
<a id="more"></a>
<h1 id="没有锁的保护"><a href="#没有锁的保护" class="headerlink" title="没有锁的保护"></a>没有锁的保护</h1><p>多线程中，变量都由所有线程共享。所以，任何一个变量都可以被任何一个线程修改。如修改一个变量需要多条语句，在执行这几条语句时，线程可能中断，很可能把内容给改乱了。如下所示的代码，创建一个为0的变量，创建两个线程，每个线程对变量执行+1的操作，得到的最后结果不一定是2。<code>t1, t2</code>为线程，<code>x1, x2</code>为各自线程的临时变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始值 g = 0</span></span><br><span class="line">t1: x1 = g + <span class="number">1</span>   <span class="comment">// x1 = 0 + 1</span></span><br><span class="line">t2: x2 = g + <span class="number">1</span>   <span class="comment">// x2 = 0 + 1</span></span><br><span class="line"></span><br><span class="line">t1: g = x1       <span class="comment">// g = x1 = 1</span></span><br><span class="line">t2: g = x2       <span class="comment">// g = x2 = 1</span></span><br><span class="line"><span class="comment">// 最终结果 g = 1 而不是 2</span></span><br></pre></td></tr></table></figure>
<p>而执行顺序则完全取决于操作系统的调度方案和CPU的核心是否忙碌。如：操作系统是否允许任务长时间占用CPU，CPU在不忙碌的情况下是否会进行线程切换。如果一旦发生线程切换，且没有对临界资源添加保护锁，很容易写出危险的程序。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>实现一个上面所描述情况的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 2000</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的运行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">count</span><span class="params">(<span class="keyword">void</span>* args)</span></span>&#123;</span><br><span class="line">    g++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义线程的 id 变量，多个变量使用数组</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数</span></span><br><span class="line">            <span class="keyword">int</span> ret = pthread_create(&amp;tids[i], <span class="literal">NULL</span>, count, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"pthread_create error: error_code = %d"</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_join(tids[i], <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"g = %d\n"</span>, g);</span><br><span class="line">        g = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>危险的程序自然得不到准确的结果：</p>
<p><img data-src="https://s3.ax1x.com/2021/02/18/yWG5Ax.png" alt></p>
<h1 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h1><p>临界资源：一个只允许一个进程使用的资源，也称互斥资源，独占资源，共享变量，如打印机，和上面程序中的变量<code>g</code>。涉及临界资源的代码段称为临界区。临界区是代码片段，包含了对临界资源的访问，每个进程可以有一个或多个临界区，临界区的设置由程序员设置。</p>
<p>为保证结果正确，需要各个进程互斥进入具有相同临界资源的临界区，实现对临界资源的互斥访问。有以下规则：</p>
<ul>
<li>互斥准则：某个进程在临界区执行，其他所有进程被排斥在临界区外。其他进程不能进入相同临界资源的临界区。所以只有相同临界资源的临界区需要互斥。</li>
<li>有空让进：临界区无进程执行时，不能无限期延长下一个进入临界区进程的等待时间。离开临界区的进程要开放临界区，让其他进程加入。</li>
<li>有限等待：每个进程进入临界区的等待时间有限，不能无限等待。临界区资源尽可能小，否则一个进程霸占资源，其他进程等待时间会很长。</li>
</ul>
<p>按照上述原则，得到访问临界区的方法：</p>
<ul>
<li>进入区，实现互斥准则，保证一个进程进入</li>
<li>临界区，有限等待准则，不能过大</li>
<li>退出区，有空让进准则，放行其他进程的进入</li>
</ul>
<h1 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h1><p>互斥量用于线程互斥访问临界资源，允许多个线程安全地共享一个关联的软件或者硬件资源。当一个线程想使用共享资源时，它必须先通过获取互斥量以获得专有的访问权限，成功加锁才能操作，操作结束解锁。如果该互斥量已被另一个线程锁定，请求线程可以等待该互斥量被解锁。</p>
<p>所以互斥信号量的取值范围只有0和1。在同一进程内使用，使用步骤为：</p>
<ul>
<li>初始化</li>
<li>临界区前wait操作</li>
<li>临界区后signal操作</li>
</ul>
<p>因此同一时刻，只能有一个线程持有该锁。因为资源是共享的，线程间也还是竞争的，但通过锁就将资源的访问变成互斥操作，线程不能同时操作数据。虽然降低了并发性，但能保证结果正确。</p>
<p>所以在锁定互斥量后，线程可以长时间地安全地使用相关联的资源。但是单个线程持有互斥量时间应尽可能的短，避免其他线程一直处于等待状态。当线程不再需要使用资源时，它必须将互斥量解锁，使得其它线程可以使用该资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化线程数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 200</span></span><br><span class="line"><span class="keyword">pthread_t</span> tid[NUM_THREADS];</span><br><span class="line"><span class="comment">// 要计算的量</span></span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个线程要执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始换互斥量</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n mutex init failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10次循环执行，多次执行 观察结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建线程 分配任务</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; NUM_THREADS)</span><br><span class="line">        &#123;</span><br><span class="line">            err = pthread_create(&amp;(tid[i]), <span class="literal">NULL</span>, &amp;thread_func, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\ncan't create thread :[%s]"</span>, strerror(err));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程执行完毕 </span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; NUM_THREADS)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印变量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, counter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变量清空</span></span><br><span class="line">        counter = <span class="number">0</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥量</span></span><br><span class="line">    pthread_mutex_destroy(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量用于线程的同步，如经典的生产者消费者。信号量是一个同步对象，用于保持在0至指定最大值（初始化指定）之间的一个计数值，同样只能被两个标准的原语<code>wait</code>和<code>signal</code>访问。使用步骤为：</p>
<ol>
<li>进入关键代码前，进程必须获取一个信号量，否则不能运行</li>
<li>执行完关键代码，释放信号量</li>
<li>信号量有数值，正值表示空闲，负值表示忙碌。</li>
</ol>
<p>只能通过两个不可分割的原子操作来访问信号量，一个是申请操作<code>wait</code>，一个是释放操作<code>signal</code>。</p>
<ul>
<li>当线程访问共享资源时，需完成一次对信号量的等待<code>wait</code>操作，该计数值减一；</li>
<li>当线程访问完毕共享资源时，需要完成一次对信号量的释放<code>signal</code>操作，计数值加一。</li>
<li>计数值大于0，表示其他线程可以访问该共享资源；</li>
<li>计数值等于0，则其他线程不能访问该资源;</li>
</ul>
<p>假设信号量的初始值为$S$：</p>
<ul>
<li>$S&gt;0$：有S个资源可用</li>
<li>$S=0$：无资源可用</li>
<li>$S&lt;0$：有$|S|$个进程在等待</li>
</ul>
<p>有m个进程共享同一临界资源，若使用信号量机制实现对这一临界资源的互斥访问，则信号量的变化范围是<code>[-(m-1),1]</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;   //导入 信号量 的包</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 200</span></span><br><span class="line"><span class="keyword">pthread_t</span> tid[NUM_THREADS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 声明信号量 </span></span><br><span class="line"><span class="comment">// 其中 sem_t 可视作 unsigned int</span></span><br><span class="line"><span class="keyword">sem_t</span> count_sem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多线程要执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sem_wait(&amp;count_sem);</span><br><span class="line">        count++;</span><br><span class="line">    sem_post(&amp;count_sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始换信号量</span></span><br><span class="line">    <span class="keyword">if</span> (sem_init(&amp;count_sem, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sem_init: failed\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10次执行 多次执行观察结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">        <span class="comment">// 创建多线程的任务</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; NUM_THREADS)</span><br><span class="line">        &#123;</span><br><span class="line">            err = pthread_create(&amp;(tid[i]), <span class="literal">NULL</span>, &amp;thread_func, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\ncan't create thread :[%s]"</span>, strerror(err));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程释放</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; NUM_THREADS)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, count);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;count_sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="信号量与互斥量的区别"><a href="#信号量与互斥量的区别" class="headerlink" title="信号量与互斥量的区别"></a>信号量与互斥量的区别</h2><p>虽然互斥量和信号量在一定程度上可以互相替代，比如可以把值最大为1的信号量当互斥量用，也可以用互斥量＋计数器当信号量。</p>
<p>但是对于设计理念上还是有不同的，互斥量管理的是资源的使用权，偏向锁的概念；而信号量的绝对值表示资源的数量，有那么一点微妙的小区别。</p>
<p>打个比方，在早餐餐厅，大家要喝咖啡。</p>
<ul>
<li>如果用互斥量的方式，同时只有一个人可以使用咖啡机，他获得了咖啡机的使用权后，开始做咖啡，其他人只能在旁边等着，直到他做好咖啡后，另外一个人才能获得咖啡机的使用权。</li>
<li>如果用信号量的模式，服务员获取咖啡机的锁，开始做咖啡。把咖啡做好放到柜台上，谁想喝咖啡就拿走一杯，服务员会不断做咖啡，如果咖啡杯被拿光了，想喝咖啡的人就排队等着。互斥量管理的是咖啡机的使用权，而信号量管理的是做好的咖啡数量。</li>
</ul>
<p>如果信号量只有二进制的0或1，称为二进制信号量。在linux系统中，二进制信号量又称互斥锁。所以互斥锁和信号量的使用方法较为相似。</p>
<h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p>以生产者消费者模型为例说明条件变量的使用条件。为节省开销，希望生产者制造出 100 个产品后才通知消费者。如果直接使用 mutex 互斥锁，需要在某个线程上不断地轮询：100 个产品是否生产完毕。相当于进行大量无效的询问，才能知道条件是否已经满足，并且每次询问均需要加锁和释放锁，这无疑会带来额外的开销。</p>
<p>而条件变量则高效地解决了这个问题。使用条件变量的情况下，我们可以直接等待某个条件的发生，而不需要主动轮询。条件变量是一种线程同步机制。核心思想是：一个线程等待『条件变量的条件成立』而挂起；另一个线程使『条件成立』。为了防止竞争，条件的检测是在互斥锁的保护下进行的，线程在改变条件状态前先要锁住互斥量。如果一个条件为假，则一个线程自动阻塞，该线程处于等待状态，并释放相关变量的互斥锁。如果另一个线程改变了条件，它将信号发送给关联的条件变量，唤醒一个或多个处于等待中的线程，使其重新获得互斥锁，重新评价条件。</p>
<p>但由于系统实现，会存在虚假唤醒等情况。即：线程并没有发出唤醒信号，处于等待中的线程仍然会自己醒来，这是一种能保证执行效率的方法。假设此时有10个线程处于等待中，在收到一个唤醒信号后，操作系统尝试去唤醒所有的线程，这会打破发送信号与唤醒之间一对一的关系。所以此时只能唤醒一个线程，而其余九个线程处于等待阶段。为了更灵活的处理这种情况，所以无论条件是否满足，操作系统允许等待中的线程自己醒来，称为虚假唤醒。</p>
<p>为了避免虚假唤醒对条件带来的影响，条件判断需要使用<code>while</code>而不是<code>if</code>。这是由于存在虚假唤醒等情况，导致唤醒后发现条件依旧不成立。因此需要使用<code>while</code>语句来循环地进行等待，直到条件成立为止。根据原理解析中生产者与消费者的模型，创建100个线程，且每当<code>count \% 20 == 0</code>时叫醒等待中的线程，防止过度轮循。试验结果如下图所示。</p>
<p><img data-src="https://s3.ax1x.com/2021/02/19/yhplxe.png" alt></p>
<p>在上图中，可以观察到，在<code>count</code>取值为20,40,60,80时，由于叫醒速度过快，等待线程没有及时获取<code>mutex</code>锁来响应，因此等待线程中没有任何输出。而当等待线程因为虚假唤醒判断条件是否满足时，因为99小于100，不满足条件，所以等待线程继续等待。当最后<code>count</code>的取值为100时，等待线程被唤醒并继续向后执行，打印<code>[thread main] wake - cond was signalled.</code>语句。打印出最后的输出语句来判断<code>count</code>的值是否正确，结果<code>[thread main] count == 100 so everyone is count</code>显示答案正确。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 100 个线程</span></span><br><span class="line"><span class="keyword">int</span> NUMTHREADS = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">// 条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量满足条件时执行的任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ThreadEntry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 叫 5 次，每个20回叫一次</span></span><br><span class="line">    <span class="keyword">if</span> (count % <span class="number">20</span> == <span class="number">0</span> &amp;&amp; count != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"count is now %d. Signalling cond.\n"</span>, count);</span><br><span class="line">        <span class="comment">// 每次完成加法后发送信号</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后释放锁</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUMTHREADS];</span><br><span class="line">    <span class="comment">// 初始化线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; NUMTHREADS; t++)</span><br><span class="line">        pthread_create(&amp;threads[t], <span class="literal">NULL</span>, ThreadEntry, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相加到 100 才会满足条件</span></span><br><span class="line">    <span class="keyword">while</span> (count != NUMTHREADS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[thread main] count is %d which is &lt; %d so waiting on cond\n"</span>, count, NUMTHREADS);</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[thread main] wake - cond was signalled."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 pthread_cond_wait 返回之前，会锁住 mutex</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印最后结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[thread main] count == %d so everyone is count\n"</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁条件变量和互斥量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zhihu.com/question/47704079/answer/135960522" target="_blank" rel="noopener">https://www.zhihu.com/question/47704079/answer/135960522</a></p>
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>工程开发经验总结一，如何参与开发？</title>
    <url>/2021/12/03/project-experience-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>拖更了两个月，不知道是最近无事发生还是之前太能写了，这期间发生了很多事，现实与虚幻并存，度过目前的难关以后再慢慢吐槽吧。决定更新一篇工程开发经验的文章，无技术细节。</p>
<p>亿点点项目总结。大概是第一次接这么正规的项目，从代码要求、提交规范、开发流程、开发需求、测试流程到文档撰写，虽然其中有不尽人意的地方，但也算正规。按时间流程说吧。</p>
<a id="more"></a>
<h1 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h1><p>首先是明确需求，也就是说知道自己从开始到结束要干什么。开始很简单，配置环境，登陆远程服务器，clone 源代码；中间的开发过程由甲方提供，对我而言就是实现 <code>sspaddmm</code> 算子，并且通过单元测试和性能测试；在开发完成后，需要提交程序、撰写文档和完成适配，这也就是知道自己要干什么。</p>
<p>不尽人意的地方是：甲方说哪里不明白直接去 github new issue，我也照做了，可惜直到半个月后才回复我。反而直接微信找他聊天反馈更快，这样问题、分析和解答都是私有的，得不到积累和分享，不利于后来者的查阅以及项目的进展。</p>
<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>这个对于乙方是重点，那么重点来谈一下。</p>
<h2 id="关于读文档"><a href="#关于读文档" class="headerlink" title="关于读文档"></a>关于读文档</h2><p>配置环境、clone 源代码就不用说了，都是基础操作。重点是开发，按着文档一步一步来，先写哪个文件，在写哪个文件，不得不说，甲方文档写的好丑。</p>
<p>如果期间遇到不懂的疑问，可以翻阅文档，也可以查阅相关代码，但是建议查阅代码的 API，为什么呢？文档不是更好吗？我遇到的情况并不是的，众所周知，代码的更新速度是要比文档更新速度快的，代码写完就可以提交，文档要等代码写完后才能写，甚至懒得写，懒得写占大多数情况。程序员最讨厌的四件事：写文档、写注释、别人不写文档、别人不写注释。</p>
<p>这就导致了一个问题，文档滞后于程序，我甚至发现文档的描述和程序的功能不符，这会造成一定的时间浪费，具体表现在：用户按照文档写程序，结果写到一半发现错了，需要重写；用户不读文档，直接读代码 API 的难度系数又可想而知。</p>
<p>尽管难度系数大，但也要能读代码，为什么呢？还是回到懒这一话题，工程中很多 API 并没有记录在文档中，换句话说，文档中没有描述的操作，工程含有的 API 也许支持。因此遇到问题时，我们需要找到相关类的定义，可以粗糙的通过见名知意来了解函数的用途。</p>
<p>这一流程的确帮了我一个大忙。简而言之：我在程序实现的时候必须新开辟空间，修改传入的指针指向的地址，程序结束后，指针还在那里，但不能指向实现中开辟的空间，因为变量是被封装的，不是修改指针指向那么简单。困惑的时候，发现对应的累有 API 可以实现获取修改数据的地址，万事大吉。</p>
<h2 id="关于实现"><a href="#关于实现" class="headerlink" title="关于实现"></a>关于实现</h2><h3 id="关于参考"><a href="#关于参考" class="headerlink" title="关于参考"></a>关于参考</h3><p>而对于刚接手工程而言，以飞快的速度吃透原理、架构和各个类的各个功能是不现实的，毕竟代码过于庞大。那么这个时候就建议先看工程中有没有类似的实现，做一个参考。这会节省很多的时间，包括 API 阅读、实现逻辑和类设计这三个角度。</p>
<p>除此之外，还可以参考已有程序，避免造轮子。举个例子，<code>sspaddmm</code> 是要对标 <code>torch.sspaddmm</code> 的，那么就先可以参考 <code>torch.sspaddmm</code> 是如何实现的。借鉴前人千锤百炼的代码，我们能更好的出发。</p>
<h3 id="关于开发"><a href="#关于开发" class="headerlink" title="关于开发"></a>关于开发</h3><p>无论如何，都会回到具体的程序开发中。这个时候，我推荐的是<strong>迭代式开发</strong>，不要一次性做到尽善尽美，这样后面 debug 的压力会很大，没有任何一个程序员可以保证一次性写千行左右的程序而不报错，我自己说的。</p>
<p>这个时候写一个最小的程序版，感觉对即可。由于大型工程项目的编译和运行并不像平时点按钮就能运行那么简单。因此，在调试困难的情况下，写完最小程序版通过编译即可，不必关心程序运行结果的正确与否。与此同时，做好 <code>info</code> 的输出，也就是说，在执行各个子模块时，在前面加一句 <code>std::cout &lt;&lt; &quot;run module X&quot; &lt;&lt; std::endl</code>，这样更方便定位到程序哪里出了问题。</p>
<h2 id="关于测试"><a href="#关于测试" class="headerlink" title="关于测试"></a>关于测试</h2><h3 id="关于单元测试"><a href="#关于单元测试" class="headerlink" title="关于单元测试"></a>关于单元测试</h3><p>在开发中，由于我们没有保证程序的逻辑正确性，这一点可以在测试时完成。因为程序上线之前必须经过严格的测试，测试样例尽可能广泛、极端，保证程序的行覆盖率。生成测试样例和期望输出后，就可以对自己写的程序正确与否进行校对了。</p>
<p>如果不对，确切而言，99.99% 的情况都是不对的。我是通过缩小单元测试样例的数量和数据量，比如只有一个测试样例，这个测试样例的数据很小，毕竟应该通过常见用例后再去测其他广泛的用例。在凭借 <code>std::cout</code> 一步一步的 debug 后，程序基本没问题了，其中的技术细节不在这里详谈，技术内容会单独写到其他文章中。这里需要注意的是，每次编译运行都比较耗时间，因此多加几个 <code>std::cout</code>，之加一个每次 debug 一小段，太浪费时间。</p>
<p>单元测试通过后，就可以进行编译部署，将自己的程序部署到工程中。这个时候，我不建议提交代码，因为性能测试还会发现程序的问题，程序还会面临二次修改，这是其一；其二是：有些人自以为是贪功冒进，写一点代码就提交，也不管正确与否，这样别人在 pull 时会拉取到错误的代码，编译时不会通过，这种行为令人做呕。</p>
<h3 id="关于性能测试"><a href="#关于性能测试" class="headerlink" title="关于性能测试"></a>关于性能测试</h3><p>性能测试就不多说了，批量生成不同大小的数据，记录执行时间，与甲方要求的性能进行对比即可。我当时在这里遇到了很多问题，具体来说一下：</p>
<p>首先是甲方工程的报错信息不够人性化，说不支持 int 类型，不支持 int 类型你咋不上天呢？后来发现，是性能测试配置文件中有的内容由脚本生成、有的内容直接写到配置文件中导致的。由于数据量大，数据字段由脚本生成，类型字段我直接写到配置文件中了，也就是 int。所以报一个「不支持 int 类型的错误」，我不理解。别问我是怎么发现这个错误的，呵呵。</p>
<p>之后发现性能测试报错，其报错信息提示「不支持输入类型」，已经有了前车之鉴，我知道真正的错误不会是不支持数据类型，后来发现是：数据格式排列错误，比如 [2] 应该写成 [1, 2]，这些是小错误，可以通过阅读代码来解决。那么大错误呢？比如直接告诉我运行超时，但不可能是运行超时，如何解决？</p>
<p>一个万能的方案是，看日志。其实写到这里，虽然吐槽甲方程序的缺点，但是能把自定义类型、类的设计、架构设计、各种极端情况的应对 API、单元测试模块、性能测试模块、整合并调用第三方库、报错信息提示和日志收集做的如此系统，虽然有瑕疵，但也可圈可点，这其中使用了多少设计模式，细思极恐。也不知道什么时候我才能有这么强的工程能力，成为一个工程的总设计师得多厉害。</p>
<p>回到看日志这一话题，我发现导致超时的原因是：core dumped，一个喜闻乐见的错误。再次回到实现部分的代码加上 <code>std::cout</code> 进行 debug。结果发现是开辟内存空间出错了，怀疑单元测试和性能测试用的链接库不是同一个。换成更加安全的内存开辟方法，bug 解决了。</p>
<p>但是发现性能比 <code>pytorch</code> 弱了不少，这个时候继续迭代开发。给程序增加多线程功能，读到这里，也许你能更好的明白：「为什么不要急着提交程序」，你以为的程序正确，但也只是你以为的，后期还有很大概率要完善和修改。修改完毕后，记得回头去执行单元测试，因为修改代码后很可能导致单元测试无法通过。</p>
<p>增加多线程的时候，回顾操作系统，多线程访问变量的弊端，因此很轻松能确定什么时候加多线程，什么时候不加。因为只能使用被封装的多线程库，不能自己手写，所以有些地方不方便加锁。至此，程序开发的东西告以结束，性能比 <code>pytorch</code> 快了两倍。前前后后花费了大约 20 天的时间，也收获了不少东西，做此记录。</p>
]]></content>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>工程开发经验总结二，如果我是甲方，该如何外包？</title>
    <url>/2021/12/09/project-experience-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本来是想直接写下的，半路除了点问题，写一篇中吧。具体出了什么意外呢？当然是自己不太熟悉的 <code>git</code> 操作，实在是缺乏和别人一起开发项目的经验。后来又陆续有一些其他的收获，一并整理。</p>
<a id="more"></a>
<p>承接上文，在代码开发与测试完成后，其实工作量才完成了一半，对的，你没听错。</p>
<h2 id="关于代码提交"><a href="#关于代码提交" class="headerlink" title="关于代码提交"></a>关于代码提交</h2><p>提交代码自然而然用的是 <code>git</code>，但是甲方的代码开放程度是不同的，甲方的主代码我们称为 <code>master</code> 分支，每个组有一个 <code>owner</code>，<code>owner</code> 能直接获取 <code>master</code> 的仓库，而开发人员只能获取 <code>owner</code> 的仓库。</p>
<p>这种操作就导致了一个问题，<strong>代码更新不及时，开发者和甲方沟通低效</strong>。开发者想要更新仓库，就必须先让 <code>owner</code> 更新；甲方提出代码的问题，就必须由 <code>master</code> 转发。</p>
<p>暂且假设更新成功，本地提交时，创建分支，提交代码，由于没获取 <code>master</code> 仓库的权限，只能由 <code>owner</code> 发起 <code>pull request</code>。而众所周知：一件事情经过的转手次数越多，经过的人员越多，处理速度就越慢。脑补你办一件事情，一张纸要盖很多章，那些人踢皮球的水平超乎你的想象。</p>
<p>其实这也不能怪 <code>owner</code>，如果这是在公司，上班时间我们开发的会很快；但是这是在学校，且还是研究生，你永远不知道你的老师会在什么时间给你安排什么奇奇怪怪的任务，事情一多就容易耽误，且心累。</p>
<p>再次假设，<code>pull request</code> 成功了，由于 <code>master</code> 频繁收录提交的代码进行更新，刚刚提交的 <code>pull request</code> 很可能代码冲突，此时就需要手动处理。我尝试了用 <code>gitee</code> 的界面进行处理，结果，呵呵，我们组全部的 <code>pr</code> 被我弄没了，全部重新提交，大型操作失误现场。</p>
<p>之后尝试用命令行操作，手动处理冲突并提交，<code>pr</code> 处显示没冲突，但是代码审核就是有冲突，冲突的位置我看了一下，本地明明已经处理好了。也许是我 <code>git</code> 操作不熟练，也许是线上环境的问题，很奇怪，最后也没有修复，重新拉取最新，草草提交了。</p>
<p>这前前后后大概浪费了三天宝贵的时间，这也在提醒我，抽时间学 <code>git</code>。</p>
<h2 id="关于修改程序"><a href="#关于修改程序" class="headerlink" title="关于修改程序"></a>关于修改程序</h2><p>因为需求性分析搞错了方向，导致我在这上面吃了大亏。当时大概有两种可行路线，一种是 A 路线，一种是 B 路线，两者只是表现形式不一样，但最终结果是一样的。我当时盲目自信，以为都行，就选择了 A 路线。后来个甲方沟通才知道，要实现 B 路线。<strong>这就导致了代码大改，白白的浪费时间和精力。</strong> 以至于为了赶进度，我还叫别人帮我一起改，可真是愧疚。</p>
<p>实现代码的改动会带动原型定义代码、测试代码的一起变动，难确实不难，恶心是真的恶心。我也第一次体会到，实际开发中，测试代码会比实现代码多的多。而且改代码的时候需要注意，改一点编译一点，不要一次性改一堆然后一次性编译，出错了都不知道是哪错了。</p>
<p>用一句话总结吧，中国有个成语叫管中窥豹，但也有见微知著，有一叶知秋，也有一叶障目不见泰山，无论如何都有个成语，叫自以为是。</p>
<h2 id="从甲方的视角看代开发"><a href="#从甲方的视角看代开发" class="headerlink" title="从甲方的视角看代开发"></a>从甲方的视角看代开发</h2><p>因为在开发的过程中遇到了一些困难，不是实现代码的困难，而是理解逻辑的困难。所以引出了这个思考，如果我是甲方，我把项目外放给别人，<strong>我应该怎么描述问题，才能让对面完成的更好？</strong>毕竟花同样一份钱，我希望拿到更好的程序。</p>
<p>第一点是提前告知项目的所有内容。这次开发有两个任务，第一个任务是开发和测试，第二个任务是适配。当时大家都以为适配很简单，外什么呢？因为一开始根本看不到第二个任务的说明书和文档，只有做完第一个任务才能看到后续任务的文档。相比之下，我们都认为适配会比开发简单的多，所以时间花费不合理，导致在开发浪费的过多的精力。等看到第二个任务的文档时，才发现代码量不会比开发低，但此时已经没有时间了，只能延期。如果是我，我会提前告知，以及在开发期间进行适当的催促。</p>
<p>第二点是整理常用的编译命令。因为大型项目的编译不是点按钮就能实现了，需要在命令行执行很长的了命令。我会写单独的一个文档，把这些命令从文档的各个角落收集起来，方便开发人员的粘贴。不然翻来翻去太麻烦了，真的。</p>
<p>最后一点，也是我认为最重要的一点。<strong>在文档之中，而不是文档之前进行一个逻辑说明</strong>，而不是单纯的告诉用户哪个文件的程序该怎么写。为什么呢？配置环境，如何开发等基础文档在这里就先忽略了，不是重点。</p>
<p>如果把概念性的东西写在最前面，开发者读起来会晕，而且不知所云。放在文档中间，当用户写完程序后，相对有了一定了解，知道代码写的是什么，在看到概念性的东西会比较直观。这就像看当代论文一样，先看摘要和引言，丝毫不知道在说什么，往往看到最后才明白。这其实和中国人的思维不符。举个例子，中国人盖房先打地基，自底向上，外国人盖房先设计房顶，自顶向下。两者都没有错，可中国人习惯了自底向上，被迫看自顶向下的东西不舒服。再举个例子，学计算机网络，是从物理层学到网络层，还是从网络层学到物理层？</p>
<p>其次，我要告诉用户他写的那些文件之间是什么逻辑。假设有 A B C 三个代码，开发者可能以为 A 会调用 B，为保证运行正确，B 中需要进行初始化操作；但其实呢，A 不会调用 B，B 也不用初始化，因为初始化工作已经在 C 中完成了。相信我，当项目规模十分庞大的时候，复杂的文件以及这些调用关系不是人眼能看出来的。即使能看出来，你也不会相信这种调用关系，不信？我举个例子。A 是测试代码，里面含有正确结果，B 是实现代码，B 需要把返回结果写到数组中，但数组大小未知。</p>
<ul>
<li>第一种情况，B 不需要经过运算获得数组大小，直接把结果写到测试代码的结果里面就好。</li>
<li>第二种情况，B 需要运算并获取数组大小，开辟新的数组，将结果写到新的数组，并返回与测试结果对比。</li>
</ul>
<p>正确答案是第一种情况。为什么不用具体实现？实际调用代码的时候没人会给你测试代码提供结果啊？代码不实现功能怎么能行？刚开始我也这么想的，但后来发现在实际使用的时候，会在一个默默无闻的 C 文件的代码中对 B 文件中的代码进行初始化，这就是没有搞清楚逻辑的后果，再次导致了代码的改动，而这种改动是可以在一开始避免的。</p>
<p>那么对于乙方，如何避免这种情况呢？开发的时候多和身边的人聊一聊，要多问多交流，而不是闷头凭自己的感觉和想象写程序，独行快，众行远。</p>
]]></content>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统『四』：进程通信</title>
    <url>/2021/02/20/process-communicate/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用多进程编程时，会经常涉及到进程之间通信的问题。除了借助文件、<a href="https://muyuuuu.github.io/2021/02/18/simple-multithread/">特殊变量</a>等，还可以借助一些特殊的数据结构完成功能复杂的通信。并行应用常常需要在进程之间交换数据。python的Multiprocessing库有两个通信通道可以交换对象：队列(queue)和管道(pipe)。</p>
<a id="more"></a>
<ul>
<li>队列返回一个进程共享的队列，队列的操作是<a href="https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes" target="_blank" rel="noopener">线程安全</a>的，也是进程安全的。任何可序列化的对象（Python通过 pickable 模块序列化对象）都可以通过它进行交换。</li>
<li>管道返回一对被管道连接的连接对象，然后对象就有了 <code>send/receive</code> 方法，可以在进程之间通信</li>
</ul>
<h1 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h1><p><strong>消息通信机制</strong>分为同步和异步，在进程间调用：</p>
<ul>
<li>所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。用户进程发起请求后，需要等待或者轮询操作完成后才能继续执行。</li>
<li>而异步则是相反，调用在发出之后，这个调用就直接返回了。可能去执行其他的东西，所以暂时没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者。</li>
</ul>
<p>举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书:</p>
<ul>
<li>如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5分钟，也可能是一天）告诉你结果（返回结果）。</li>
<li>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过回电这种方式来回调。</li>
</ul>
<p>一定要区分与阻塞、非阻塞的区别。在通俗一点，阻塞、非阻塞关注的是用户，同步、异步关注的是老板。</p>
<h1 id="借助队列的通信"><a href="#借助队列的通信" class="headerlink" title="借助队列的通信"></a>借助队列的通信</h1><p>写了这么多理论，来点代码看一看。这里需要注意的是，如果要创建一个进程的类并封装任务，只需要继承<code>multiprocessing.Process</code>类，并覆写<code>run()</code>方法即可。实现一个多生产者、多消费者的模型。这是典型的异步通信，生产者无需通知消费者，消费者也不需要通知生产者，而是将『队列长度』作为信号，来判断接下来的动作：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span></span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.queue = queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            item = random.randint(<span class="number">0</span>, <span class="number">256</span>)</span><br><span class="line">            self.queue.put(item)</span><br><span class="line">            print(<span class="string">"Producer : item %d appended to queue %s"</span> % (item, self.name))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            print(<span class="string">"The size of queue is %s"</span> % self.queue.qsize())</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span></span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.queue = queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.queue.empty():</span><br><span class="line">                print(<span class="string">"the queue is empty"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line">                item = self.queue.get()</span><br><span class="line">                print(<span class="string">'Consumer : item %d popped from by %s \n'</span> % (item, self.name))</span><br><span class="line">                <span class="comment"># put到队列的每个任务都调用了task_done方法后，join才会完成阻塞</span></span><br><span class="line">                self.queue.task_done()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.queue = multiprocessing.Queue()</span><br><span class="line">        self.process_producer = Producer(self.queue)</span><br><span class="line">        self.process_consumer = Consumer(self.queue)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.t = threading.Timer(<span class="number">1</span>, self.dead)</span><br><span class="line">        self.t.start()</span><br><span class="line">        self.process_producer.start()</span><br><span class="line">        self.process_consumer.start()</span><br><span class="line">        self.process_producer.join()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dead</span><span class="params">(self)</span>:</span></span><br><span class="line">        t = threading.Timer(<span class="number">1</span>, self.dead)</span><br><span class="line">        <span class="comment"># 生产者终止，队列为空，则结束消费者</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.process_producer.is_alive() <span class="keyword">and</span> self.queue.empty():</span><br><span class="line">            self.process_consumer.terminate()</span><br><span class="line">            self.t.cancel()</span><br><span class="line">            t.cancel()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = main()</span><br><span class="line">    a.run()</span><br></pre></td></tr></table></figure>
<h1 id="借助管道的通信"><a href="#借助管道的通信" class="headerlink" title="借助管道的通信"></a>借助管道的通信</h1><p><img data-src="https://s3.ax1x.com/2021/02/21/yozLin.png" alt></p>
<p>管道会返回两个对象，代表了管道的两个端点。每个对象都能通过 send() 和 recv() 方法进行通信。最简单的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(conn)</span>:</span></span><br><span class="line">    conn.send([<span class="number">42</span>, <span class="literal">None</span>, <span class="string">'hello'</span>])</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parent_conn, child_conn = Pipe()</span><br><span class="line">    p = Process(target=f, args=(parent_conn, ))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(child_conn.recv())</span><br><span class="line">    child_conn.close()</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，如果俩个进程试图在管道的一端同时进行读或写操作，可能会导致管道崩溃，也就是需要互斥。如果使用管道的两端来同时干这件事是安全的。</p>
<p>来演示一种通信模型，异步阻塞的通信方式：</p>
<p><img data-src="https://s3.ax1x.com/2021/02/21/yTfHBT.png" alt></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sender</span><span class="params">(conn, msgs)</span>:</span> </span><br><span class="line">    <span class="string">""" </span></span><br><span class="line"><span class="string">    function to send messages to other end of pipe </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> msg <span class="keyword">in</span> msgs: </span><br><span class="line">        conn.send(msg) </span><br><span class="line">        print(<span class="string">"Sent the message: &#123;&#125;"</span>.format(msg))</span><br><span class="line">    <span class="comment"># 不发送了就关闭</span></span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiver</span><span class="params">(conn)</span>:</span> </span><br><span class="line">    <span class="string">""" </span></span><br><span class="line"><span class="string">    function to print the messages received from other </span></span><br><span class="line"><span class="string">    end of pipe</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">        msg = conn.recv() </span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">"END"</span>: </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">"Received the message: &#123;&#125;"</span>.format(msg)) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: </span><br><span class="line">    <span class="comment"># messages to be sent </span></span><br><span class="line">    msgs = [<span class="string">"hello"</span>, <span class="string">"hey"</span>, <span class="string">"hru?"</span>, <span class="string">"END"</span>] </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># creating a pipe </span></span><br><span class="line">    parent_conn, child_conn = multiprocessing.Pipe()</span><br><span class="line">    print(parent_conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># creating new processes </span></span><br><span class="line">    p1 = multiprocessing.Process(target=sender, args=(parent_conn, msgs)) </span><br><span class="line">    p2 = multiprocessing.Process(target=receiver, args=(child_conn))</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># running processes </span></span><br><span class="line">    p1.start() </span><br><span class="line">    p2.start() </span><br><span class="line"></span><br><span class="line">    <span class="comment"># wait until processes finish </span></span><br><span class="line">    p1.join() </span><br><span class="line">    p2.join()</span><br></pre></td></tr></table></figure>
<p>但是我在使用管道的通信的时候发现了一个<a href="https://stackoverflow.com/questions/66301489/is-connection-objects-returned-by-multiprocessing-pipe-shared-in-different-pro?" target="_blank" rel="noopener">问题</a>。众所周知多进程不共享变量，我在主进程、两个子进程中打印了<code>parent_conn</code>的地址，三个地址都是不相同的。也就是说，<code>p1</code>的发送端和<code>p2</code>的发送端是不一样的，也就是<code>p1</code>的发送端和<code>p2</code>的接收端可能对不上，离奇的是他们居然能通信。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主进程 parent_coon 地址：0x000001F239546580</span><br><span class="line">p1进程 parent_coon 地址：0x0000016B62B6D460</span><br><span class="line">p2进程 parent_coon 地址：0x000001CC9A709190</span><br></pre></td></tr></table></figure>
<ul>
<li>子进程虽然在不同的变量空间中，他们的变量也不一样。这不影响通信，也就是说，子进程发送的数据，被另一个子进程收到，这也正是管道的用处。</li>
<li>在<code>sender()</code>函数中关闭了发送端，但我在主进程检测发送端是否关闭的时候他又<strong>没有关闭</strong>。这是因为多进程不共享变量，子进程关闭不会影响主进程。神奇。</li>
</ul>
<h1 id="与阻塞的组合"><a href="#与阻塞的组合" class="headerlink" title="与阻塞的组合"></a>与阻塞的组合</h1><p>结合<a href="https://muyuuuu.github.io/2021/02/18/simple-multithread/">之前</a>提到的阻塞，有四种工作模式：</p>
<ul>
<li><strong>同步阻塞方式</strong>：发送方发送请求之后一直等待响应。接收方处理请求时，直到进行的操作返回结果后，才响应发送方，期间不能进行其他工作。</li>
<li><strong>同步非阻塞方式</strong>：发送方发送请求之后，一直等待响应。接受方处理请求时进行的IO操作如果不能马上的得到结果，就立即返回，去做其他事情。但是由于没有得到请求处理结果，不响应发送方，发送方一直等待。当操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方，发送方才进入下一次请求过程。（实际不应用）</li>
<li><strong>异步阻塞方式</strong>：发送方向接收方请求后，不等待响应，可以继续其他工作。接收方处理请求时进行IO操作如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作。（实际不应用）</li>
<li><strong>异步非阻塞方式</strong>：发送方向接收方请求后，不等待响应，可以继续其他工作。接收方处理请求时进行IO操作如果不能马上得到结果，也不等待，而是马上返回去做其他事情。当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方。（效率最高）</li>
</ul>
<p>写完上面的理论后，讲真我是有点晕的。网上也没有多少货真价实的代码，要么乱抄，要么结合到具体的框架，如协称等，不容易让人读懂。2021年4月回来填坑，每个示例加一部分代码，企图让自己读懂 and 帮助后来者更好的理解这一部分。每一个代码的后面都有输出，可以仔细看看输出。</p>
<h2 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h2><p>这也是最容易实现的一种方式，实现不了好的，我还实现不出来坏的？<code>loop</code> 函数阻塞了主线程，主线程等待子线程执行完毕。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread(target=loop, name=<span class="string">'Thread-&#123;&#125;'</span>.format(i))</span><br><span class="line">    t.start()</span><br><span class="line">    <span class="comment"># 阻塞调用线程直至线程的join()方法结束</span></span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Main Thread can run now'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># thread Thread-0 is running...</span></span><br><span class="line"><span class="comment"># thread Thread-0 ended.</span></span><br><span class="line"><span class="comment"># thread Thread-1 is running...</span></span><br><span class="line"><span class="comment"># thread Thread-1 ended.</span></span><br><span class="line"><span class="comment"># thread Thread-2 is running...</span></span><br><span class="line"><span class="comment"># thread Thread-2 ended.</span></span><br><span class="line"><span class="comment"># Main Thread can run now</span></span><br></pre></td></tr></table></figure>
<h2 id="异步非阻塞"><a href="#异步非阻塞" class="headerlink" title="异步非阻塞"></a>异步非阻塞</h2><p>这里通俗一点，假设<code>A</code>线程调用<code>B</code>线程。就是调用线程<code>A</code>没有被阻塞，目标线程<code>B</code>以异步的形式去执行代码，获取结果后回调。而<code>A</code>线程不用一直等待结果，而是通过回调函数拿到返回结果并处理，直接执行下一步操作。</p>
<p>我们创建一个线程池，通过线程池来观察异步的执行情况。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(threading.current_thread().name, <span class="string">'has task &#123;&#125;'</span>.format(n))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> n ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回调函数:异步提交之后一旦任务有返回结果，自动交给另外一个去执行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_back</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(threading.current_thread().name, <span class="string">"get result &#123;&#125;"</span>.format(n.result()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        <span class="comment"># 异步提交任务，通过回掉函数拿到执行结果</span></span><br><span class="line">        future = pool.submit(task, i).add_done_callback(call_back)</span><br><span class="line">        t_list.append(future)</span><br><span class="line">    <span class="comment"># 异步提交，所以没有返回结果，t_list 全是 None</span></span><br><span class="line">    print(t_list)</span><br><span class="line">    print(<span class="string">'Main thread can run others'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_0 has task 0</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_1 has task 1</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_2 has task 2</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_3 has task 3</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_4 has task 4</span></span><br><span class="line"><span class="comment"># [None, None, None, None, None, None]</span></span><br><span class="line"><span class="comment"># Main thread can run others</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_2 get result 4</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_0 get result 0</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_2 has task 5</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_4 get result 16</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_1 get result 1</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_3 get result 9</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_2 get result 25</span></span><br></pre></td></tr></table></figure>
<p>关于 <code>add_done_callback</code>，将可调用的 func 附加到 future 上。当 future 被取消或完成运行时，将调用 func，并将 future 作为其唯一的参数。</p>
<h2 id="同步非阻塞"><a href="#同步非阻塞" class="headerlink" title="同步非阻塞"></a>同步非阻塞</h2><p>和上述代码类似，创建一个线程池提交任务，主进程不被阻塞，但同步的等待结果。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同步非阻塞</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(threading.current_thread().name, <span class="string">'has task &#123;&#125;'</span>.format(n))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> n ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        <span class="comment"># 同步:提交任务之后，原地等待任务的返回结果，再继续执行下一步代码</span></span><br><span class="line">        <span class="comment"># 所以不需要回调</span></span><br><span class="line">        future = pool.submit(task, i)</span><br><span class="line">        t_list.append(future.result())</span><br><span class="line">    <span class="comment"># 同步提交能等待结果，所以 list 里面就是结果</span></span><br><span class="line">    print(t_list)</span><br><span class="line">    print(<span class="string">'Main thread can run others'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_0 has task 0</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_0 has task 1</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_0 has task 2</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_0 has task 3</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_0 has task 4</span></span><br><span class="line"><span class="comment"># ThreadPoolExecutor-0_0 has task 5</span></span><br><span class="line"><span class="comment"># [0, 1, 4, 9, 16, 25]</span></span><br><span class="line"><span class="comment"># Main thread can run others</span></span><br></pre></td></tr></table></figure>
<h2 id="异步阻塞"><a href="#异步阻塞" class="headerlink" title="异步阻塞"></a>异步阻塞</h2><p>这个实现也是比较简单的，主线程启动一个子任务后去执行其它命令，等待子任务的回调，这就是异步；而子任务会把调用子任务的线程给阻塞起来；所以要实现这个任务，包括主线程在内，至少要有三个线程。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    print(threading.current_thread().name, <span class="string">'is running'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(threading.current_thread().name, <span class="string">'is ended'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=loop, name=<span class="string">'Thread-&#123;&#125;'</span>.format(i))</span><br><span class="line">        t.start()</span><br><span class="line">        t.join()</span><br><span class="line">    print(<span class="string">"call back here"</span>)</span><br><span class="line"></span><br><span class="line">t = threading.Timer(<span class="number">2</span>, task)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Main thread can run others"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Main thread can run others</span></span><br><span class="line"><span class="comment"># Thread-0 is running</span></span><br><span class="line"><span class="comment"># Thread-0 is ended</span></span><br><span class="line"><span class="comment"># Thread-1 is running</span></span><br><span class="line"><span class="comment"># Thread-1 is ended</span></span><br><span class="line"><span class="comment"># Thread-2 is running</span></span><br><span class="line"><span class="comment"># Thread-2 is ended</span></span><br><span class="line"><span class="comment"># call back here</span></span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>例子尽力举的通俗一些，企图让我和其他小白读者看懂。等哪天学到协称了吧，通过一个项目实际的讲解下。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="noopener">https://www.zhihu.com/question/19732473/answer/20851256</a></li>
<li><a href="https://www.cnblogs.com/loveer/p/11479249.html" target="_blank" rel="noopener">https://www.cnblogs.com/loveer/p/11479249.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>工程开发经验总结三，以 sspaddmm 为例，再来谈一谈并行加速</title>
    <url>/2021/12/27/project-experience-3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天来写什么呢？准备整理一些多线程的东西，虽然多线程相对很熟悉了，可每次工程中都会有新的收获。这次不谈多线程的理论问题，毕竟计算机专业都懂多线程的理论并写过相关程序，也了解其使用的背景。之前使用多线程的时候，总是看一看加速比和结果是否准确就完了，那么这次以多线程使用者和多线程设计者的角度出发，来谈一谈如何更好的使用和设计多线程。</p>
<a id="more"></a>
<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>给定一个 2D 的稀疏矩阵，稀疏矩阵的采用 COO 格式的表示，如下图所示：</p>
<p><img data-src="https://s4.ax1x.com/2021/12/27/Treg5d.png" alt></p>
<p>稀疏矩阵由三部分组成，包括 <code>Indices, Values, Shapes</code>。具体而言，这是一个 100 X 100 的二维稀疏矩阵，索引的第一行表示行，第二行表示列，行列对应的索引处为具体的数值，初次之前全部是 0。比如，<code>sparse[1][0]=0.6</code>，注意：其中的索引是可以重复的，比如有两个 <code>[2,1]</code>。</p>
<p>现在的问题是，稀疏矩阵乘以稠密矩阵，既然是矩阵乘法，很容易想到并行。不过在此之前，还是简单说一下矩阵乘法的流程：</p>
<p>假设稀疏矩阵第 $r_1$ 行和第 $c_1$ 列的值为 $v_1$，假设稠密矩阵由 $C$ 列，那么乘法就是：将 $v_1$ 与稠密矩阵中第 $c_1$ 行对应的所有的列的值相乘，结果的索引是 $(r_1, 1), (r_1, 2), \cdots, (r_1, C)$。举个例子：</p>
<p><img data-src="https://s4.ax1x.com/2021/12/27/TreoqS.png" alt></p>
<p>如上的例子中，稀疏矩阵乘以稠密矩阵，将单个系数矩阵元素相乘的结果，直接以 <code>+=</code> 的形式放到对应的位置中，既然画图了，那么也就能看出来并行的点：</p>
<ol>
<li>方案 1：乘以稠密矩阵要遍历其所有的列，所以在取列的时候并行，这样不会有冲突</li>
<li>方案 2：稀疏矩阵并行，以上图为例，直接拿那两个的稀疏矩阵的元素去乘以稠密矩阵的列。不过这里会有冲突，比如稀疏矩阵中有多个行相同的索引，比如上图的稀疏矩阵 <code>[1,0], [1, 2]</code> 这样的，在 <code>+=</code> 的时候不加锁，多线程会出问题。</li>
</ol>
<p>以下，<code>mat1</code> 表示稀疏矩阵，<code>mat2</code> 表示稠密矩阵，且 <code>sspaddmm</code> 函数<strong>要求返回稀疏矩阵</strong>而不是稠密矩阵，上面的图只是为了便于理解。此外，能使用的并行工具有限，这取决于所在的工程，这个没办法，有点戴着镣铐跳舞的意思，高中老师经常用戴着镣铐跳舞来 PUA 我们，即：你必须听话，在听话的范围内做到很好，不能越界。</p>
<h2 id="并行-API"><a href="#并行-API" class="headerlink" title="并行 API"></a>并行 API</h2><p>API 是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对矩阵中每个元素自增 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 串行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  arr[i] += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> shared = [&amp;](uint start, uint end) &#123;</span><br><span class="line">  <span class="keyword">for</span> (uint i = start; i &lt; end; i++) &#123;</span><br><span class="line">    arr[i] += <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">parallelfor(<span class="number">10000</span>, <span class="number">10000</span> / n_threads, shared);</span><br></pre></td></tr></table></figure>
<p>其中 <code>parallelfor</code> 的第一个元素是任务总数，<code>n_threads</code> 是线程的数量，最后传入定义的匿名函数，在匿名函数中，默认从 0 开始，到任务总数结束，并划分对应的 <code>start</code> 和 <code>end</code> 区间，比如 1 到 5000 为一组，5000 到 10000 为另一组。</p>
<h1 id="串行版本"><a href="#串行版本" class="headerlink" title="串行版本"></a>串行版本</h1><p>矩阵的串行乘法比较容易理解，写出串行程序来，也就知道了如何写并行程序。先遍历第一个矩阵，在遍历第二个矩阵，相乘即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat1_nums; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> row1 = mat1_indices[i][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> col1 = mat1_indices[i][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat2_col; j++) &#123;</span><br><span class="line">    output_val[cnt] += mat1_val[i] * mat2_val[col1][j];</span><br><span class="line">    output_idx[cnt][<span class="number">0</span>] = row1;</span><br><span class="line">    output_idx[cnt][<span class="number">1</span>] = j;</span><br><span class="line">    cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用方案-1"><a href="#使用方案-1" class="headerlink" title="使用方案 1"></a>使用方案 1</h1><p>方案 1 的并行似乎很简单，可真的是这样吗？看上文的串行程序，我们发现做完一次乘法，就将结果直接写到 <code>output</code> 对应的地址中，写完一次，<code>cnt++</code>，为下一次写出数据做准备。那么问题来了，<code>parallelfor</code> 不提供锁，那么变量在没被保护的情况下的自增就会错误，如何解决呢？</p>
<p>既然读写会出现错误，而多线程的读是没有问题的，那么就想办法去掉写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; idx_map_cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat1_nums; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> row1 = mat1_indices[i][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat2_col; j++) &#123;</span><br><span class="line">    idx_map_cnt[row1][j] = cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat1_nums; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> row1 = mat1_indices[i][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> col1 = mat1_indices[i][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">auto</span> shared = [&amp;](uint start, uint end) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; end; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> idx = idx_map_cnt[row1][j];</span><br><span class="line">      output_val[idx] += mat1_val[i] * mat2_val[col1][j];</span><br><span class="line">      output_idx[idx][<span class="number">0</span>] = row1;</span><br><span class="line">      output_idx[idx][<span class="number">1</span>] = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  parallelfor(<span class="number">10000</span>, <span class="number">10000</span>/n_threads, shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你看，在时间复杂度不变的情况下，借助一个额外的映射表就实现了并行，因为是针对 mat2 进行了并行，mat1 部分仍然是串行，也就是说，不会同时出现两个 <code>row1</code> 相等的情况，因此多线程中的 <code>+=</code> 是安全的。</p>
<h1 id="使用方案-2"><a href="#使用方案-2" class="headerlink" title="使用方案 2"></a>使用方案 2</h1><p>如果明白了方案 1 的并行思路，那么问题又来了，假设 mat1 有 2000 个元素，mat2 的列也是 20，那么此时我们应该针对 mat1 进行并行，而不是 mat2。但是 mat1 并行会出乱子，因为使用多线程访问上述程序中的 <code>row1</code>，可能会用重复的结果，那么多线程中的 <code>+=</code> 就是不安全的。如何解决呢？反而言之，多线程访问 mat1，如何保证每个线程拿到的 <code>row1</code> 是不一样的。我和师弟提出了两种思路：</p>
<ol>
<li>先来看思路 1。设计一个数据结构，这个数据结构每次从 mat1_indices 中抽取出不重复的行，因为行是不同的，那么这样就可以并行了。举个例子，mat1 中的行是 <code>[1, 2, 1, 2, 3, 4, 5, 5, 6, 7]</code>，那么我第一次选择 <code>[1, 2, 3, 4, 5, 6, 7]</code> 去并行，第二次选择 <code>[1, 2, 5]</code> 去运算，每次选择的元素不会有重复，这样多线程的 <code>+=</code> 就安全了。可视化一下这样的结构：</li>
</ol>
<p><img data-src="https://s4.ax1x.com/2021/12/27/Trm9ZF.png" alt></p>
<p>来看如何实现这样的数据结构，也就是下文中的 <code>unrepeated</code>，因为映射的 <code>key</code> 是唯一的，所以使用 <code>key</code> 来记录不同的索引，选择的时候，也是选择其中的 <code>key</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; unrepeated;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int64_t</span> i = <span class="number">0</span>; i &lt; mat1_num; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> _row = mat1_indices[i][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> _col = mat1_indices[i][<span class="number">1</span>];</span><br><span class="line">  unrepeated[_row].push_back(_col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (unrepeated.size()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = unrepeated.begin(); it != unrepeated.end(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unrepeated[it-&gt;first].size() == <span class="number">1</span>) &#123;</span><br><span class="line">      res.push_back(&#123;it-&gt;first, it-&gt;second.back()&#125;);</span><br><span class="line">      tmp.push_back(it-&gt;first);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.push_back(&#123;it-&gt;first, it-&gt;second.back()&#125;);</span><br><span class="line">      it-&gt;second.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : tmp) &#123;</span><br><span class="line">    unrepeated.erase(i);</span><br><span class="line">  &#125;</span><br><span class="line">  tmp.clear();</span><br><span class="line">  <span class="keyword">int</span> n = res.size();</span><br><span class="line">  <span class="keyword">auto</span> shared = [&amp;](uint start, uint end) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> row1 = res[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> col1 = res[i][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &gt; mat2_col; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> idx = idx_map_cnt[row1][j];</span><br><span class="line">      output_val[idx] += mat1_val[i] * mat2_val[col1][j];</span><br><span class="line">      output_idx[idx][<span class="number">0</span>] = row1;</span><br><span class="line">      output_idx[idx][<span class="number">1</span>] = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  parallelfor(res.size(), res.size()/n_threads, shared);</span><br><span class="line">  res.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有没有发现问题？我猜一定没有，因为不会有人盯着一段非必须的程序仔细的看。还是直接说把，上述程序中的 <code>mat1_val[i]</code> 不是合法的，因为并行化以后，i 对应的是 <code>res.size()</code> 的某个元素，而不是 <code>mat1_values</code> 的第 i 个数值。怎么办呢？再加一个映射 <code>co_map_idx</code> 呗，把索引映射为数值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; co_map_idx;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int64_t</span> i = <span class="number">0</span>; i &lt; mat1_vals_num; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> _row = mat1_indices[i][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> _col = mat1_indices[i][<span class="number">1</span>];</span><br><span class="line">  unrepeated[_row].push_back(_col);</span><br><span class="line">  co_map_idx[_row][_col].push_back(mat1_val_addr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> shared = [&amp;](uint start, uint end) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> row1 = res[i][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> col1 = res[i][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">double</span> val = co_map_idx[row_mat1][row_mat2].back();</span><br><span class="line">  co_map_idx[row_mat1][row_mat2].pop_back();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &gt; mat2_col; j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> idx = idx_map_cnt[row1][j];</span><br><span class="line">    output_val[idx] += val * mat2_val[col1][j];</span><br><span class="line">    output_idx[idx][<span class="number">0</span>] = row1;</span><br><span class="line">    output_idx[idx][<span class="number">1</span>] = j;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是根据实际运行的结果来看中，这是一种很烂的方案，每次都要选择不重复元素、清空和删除，这会带来不必要的开销，时间会很慢。那么再来看二种并行思路：我们已经有了 <code>unrepeated</code> 这样的数据结构，那么直接对 <code>unrepeated</code> 直接分组不是更好吗？</p>
<p><img data-src="https://s4.ax1x.com/2021/12/27/TrmesK.png" alt></p>
<p>直接对 <code>unrepeated</code> 的 <code>key</code> 进行分组计算，这样就不会出现重复的 <code>key</code>，不过为了拿到不同的 <code>key</code>，仍然需要一些预处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = unrepeated.begin(); it != unrepeated.end(); it++)</span><br><span class="line">  res.push_back(it-&gt;first)</span><br><span class="line"><span class="keyword">auto</span> multi = [&amp;](<span class="keyword">uint32_t</span> start, <span class="keyword">uint32_t</span> end) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="comment">// get val</span></span><br><span class="line">    <span class="keyword">auto</span> row_mat1 = res[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> row_mat2 : unrepeated[row_mat1]) &#123;</span><br><span class="line">        <span class="keyword">double</span> val = co_map_idx[row_mat1][row_mat2].back();</span><br><span class="line">        co_map_idx[row_mat1][row_mat2].pop_back();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; mat2_col; j++) &#123;</span><br><span class="line">            <span class="comment">// get val</span></span><br><span class="line">          <span class="keyword">uint32_t</span> idx = idx_map_cnt[row_mat1][j];</span><br><span class="line">          *(out_val_addr + idx) +=</span><br><span class="line">              val * mat2_val_addr[row_mat2 * mat2_col + j];</span><br><span class="line">          out_idx_addr[idx] = row_mat1;</span><br><span class="line">          out_idx_addr[idx + out_num] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看，方法总比困难多，问题被完美解决。在这之后，我尝试了各种并行方案，以及双重并行，上述代码是性能最好的一个，但性能与其他库比仍然查了很多。为什么呢？来分析原因。当矩阵规模很小的时候会执行串行乘法，而串行乘法的效率会远远好于其他库，这就说明乘法的思路没问题，我觉得是并行 <code>API</code> 设计的不够好，它只支持一维的并行，且不支持额外的自定义，这就导致了这个接口的应用受限，甚至为了使用这个 API 还要执行很多其他的辅助。如果一定要在矩阵乘法中套两次并行，效率会极度低下。</p>
<h1 id="如何设计多线程-API？"><a href="#如何设计多线程-API？" class="headerlink" title="如何设计多线程 API？"></a>如何设计多线程 API？</h1><p>既然 <code>parallelfor</code> 这么难用，那如果我们是工程师，该如何设计这个接口呢？首先我们要知道，多线程的使用场景多种多样变化无穷，以计算为例，可以以行为单位进行并行，也可以以列为单位，甚至可以以数据块为单位。我想了很久，并没有想出一个很好的方案。也许，我要是能想出来，甲方也不至于提供 <code>parallelfor</code> 这样的 API 。</p>
]]></content>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>碰运气的优化算法</title>
    <url>/2020/12/07/pso-ga-sa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在很久之前，看过粒子群算法等相关的以概率收敛的优化算法。当时那个破教程写的又臭又长，丝毫没看懂。今日考试重温了一下，原来是这么简单。八点半考完的，闲的没事于是手动实现了粒子群算法。之后考虑在本文中添加遗传算法、模拟退火这两个主流的碰运气的优化算法。</p>
<p>这类算法被优化课程的老师嘲讽了一番，缺乏严格的推导证明和参数的解释，大多是以科学的方法去碰运气，在解空间内进行搜索。</p>
<a id="more"></a>
<h1 id="粒子群算法"><a href="#粒子群算法" class="headerlink" title="粒子群算法"></a>粒子群算法</h1><p>对于一个目标函数，随机生成几个解视为粒子。将这几个粒子（数学意义为决策变量的取值）代入目标函数中，根据公式不断的迭代粒子的位置和速度参数，模仿鸟类觅食的行为来求出目标函数的最优解。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img data-src="https://static01.imgkr.com/temp/56609f049fc147fa8846b417236f846f.gif" alt></p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>假设此时要优化的目标为：</p>
<p>\begin{cases}<br>\min \Bigl( (x - 2)^2 - 6x + \frac{12\sin x}{x} - 9x \cos x \Bigr) \\<br>\text{s.t.} -4 \leq x \leq 4<br>\end{cases}</p>
<p>粒子的更新只有以下两个公式：</p>
<p>\begin{cases}<br>x_i(t+1)=x_i(t)+v_i(t+1) \\<br>v_i(t+1)=wv_i(t)+c_1r_{1t}\bigl(\text{pbest}-x_i(t)\bigl)+c_2r_{2t}\bigl(\text{gbest}-x_i(t)\bigl)<br>\end{cases}</p>
<ul>
<li>$x_i(t)$，表示$t$时刻第$i$个粒子的位置，$0$时刻随机初始化即可；</li>
<li>$v_i(t)$，表示$t$时刻第$i$个粒子的移动速度，$0$时刻随机初始化即可；</li>
<li>$w$，权重。取值大时，速度也大，具有较强的搜索能力；反之搜索能力较差；</li>
<li>$c_1,c_2$，常数，表示例子向局部最优和全局最优移动的能力；</li>
<li>$r_{1t}, r_{2t}$，是一个在$[0,1]$区间的常数，每次迭代都要重新生成；</li>
<li>$\text{pbest}$，$t$时刻的局部最优解，含义为某一点决策变量的取值，非目标函数值，该决策变量对应的目标函数值局部最小；</li>
<li>$\text{gbest}$，从开始迭代至今得到的全局最优解，含义为某一点决策变量的取值，非目标函数值，该决策变量对应的目标函数值全局最优；</li>
</ul>
<p>其中，$\text{pbest},\text{gbest}$带进目标函数求解即可获得。编程实现可以考虑向量形式，容易实现。</p>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>核心程序如下所示，全部程序请<a href="https://github.com/muyuuuu/Algorithm/tree/master/PSO" target="_blank" rel="noopener">点击这里</a>。注意：代码目前仅限于单决策变量，暂时没时间适配到多决策变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 迭代次数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(self._iter_num):</span><br><span class="line">    <span class="comment"># 计算每个点的 fitness</span></span><br><span class="line">    self._fitness = op_func(self._x)</span><br><span class="line">    <span class="comment"># 当前最优</span></span><br><span class="line">    self._pbest = self._x[np.argmin(self._fitness)]</span><br><span class="line">    <span class="comment"># 全局最优</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        self._gbest = self._pbest</span><br><span class="line">    <span class="keyword">elif</span> op_func(self._pbest) &lt; op_func(self._gbest):</span><br><span class="line">        self._gbest = self._pbest</span><br><span class="line">    <span class="comment"># 速度更新</span></span><br><span class="line">    r1, r2 = np.random.rand(), np.random.rand()</span><br><span class="line">    self._v = self._w * self._v + \</span><br><span class="line">        r1 * self._c1 * (self._pbest - self._x) + \</span><br><span class="line">        r2 * self._c2 * (self._gbest - self._x) </span><br><span class="line">    <span class="comment"># 位置更新</span></span><br><span class="line">    self._x += self._v</span><br><span class="line">    <span class="comment"># 越界后强制到边界点</span></span><br><span class="line">    self._x = np.clip(self._x, self._left, self._right)</span><br></pre></td></tr></table></figure>
<h1 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h1><h1 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h1>]]></content>
      <tags>
        <tag>Modeling</tag>
      </tags>
  </entry>
  <entry>
    <title>Github灵魂：pull-request</title>
    <url>/2020/05/02/pull-request/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://muyuuuu。github。io/2019/11/16/git-use/">承接上文</a>，人傻就要多学习系列，在记录完<code>git</code>的常用方法后，又学习了<code>github</code>的灵魂功能<code>pull request</code>，是团队开发和开源必不可少的工具。</p>
<p>同样，本文没有任何截图，都是文字阐述，更像是我的个人笔记。对纯小白不是很友好，若不喜欢这类形式可以选择性关闭。</p>
<a id="more"></a>
<h1 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h1><p><code>Pull Request</code>(以下简称<code>pr</code>)是自己修改源代码后，请求对方仓库采纳该修改方式时的一种行为，能更好的实现多人开发。</p>
<p>如发现了一个软件的<code>BUG</code>并修改后，在<code>github</code>上发送了<code>pr</code>，接收方的仓库会创建一个附带源代码的<code>issue</code>，在这个<code>issue</code>里详细记录内容。发送过去的<code>pr</code>是否被采纳，要由接收方的管理者进行判断。如果被接收，<code>pr</code>的发起者就会变成这个项目的<code>contributor</code>，也就变成了开源软件的贡献者。</p>
<h2 id="发送pr"><a href="#发送pr" class="headerlink" title="发送pr"></a>发送<code>pr</code></h2><h3 id="发送前的准备"><a href="#发送前的准备" class="headerlink" title="发送前的准备"></a>发送前的准备</h3><ul>
<li><code>fork</code>:在对方的仓库中点击<code>fork</code>按钮，然后会发现自己的仓库中也有了对应的仓库。(当然也可以不用进行<code>fork</code>，假设团队的成员对仓库都有编辑的权限时，可以免去<code>fork</code>这一步骤)</li>
<li><code>clone</code>:复制自己<code>fork</code>仓库的<code>URL</code>，建议以<code>SSH</code>协议将仓库克隆到本地仓库中。此时修改仓库内容并<code>push</code>，只会修改自己的仓库，不会修改他人的仓库，这也是<code>github</code>的一大优势。</li>
<li><code>branch</code>:创建特性分支然后在分支中修改代码，这是个好习惯。因为在给对方仓库<code>pr</code>时都是发送特性分支，这样对方仓库就能根据分支来更好的理解代码的意图。如修改错别字分支，那么就<code>git branch typo</code>。</li>
<li><code>git branch -a</code>查看分支，开头带有<code>remotes/origin/</code>的是<code>github</code>端仓库的分支。</li>
<li>在修改完代码后，提交修改。<code>git add filename</code> 还有<code>git commit -m &quot;comment&quot;</code>。</li>
<li>要从<code>github</code> 发送<code>pr</code>，<code>github</code>仓库端必须有一个包含了修改代码后的分支，所以就创建本地<code>typo</code>分支的远程分支，<code>git push origin typo</code>即可。</li>
</ul>
<h3 id="发送期间"><a href="#发送期间" class="headerlink" title="发送期间"></a>发送期间</h3><p>登录<code>github</code>并切换到<code>typo</code>分支，确认发送的内容准确无误后，点击<code>create pull request</code>，然后在表单中填写本次<code>pr</code>的理由和改进即可。</p>
<p>再次确认无误后，点击<code>send pull request</code>，这样，<code>pr</code>的目标仓库就会新建<code>pr</code>和<code>issue</code>，至于对方仓库接收与否，还得看仓库原作者的想法了。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在程序的开发过程中，<code>pr</code>是对软件实现和功能探讨的好方法。当然更建议的是不要写完代码在<code>pr</code>，而是可以尽早的<code>pr</code>获得反馈，统一大家的开发思路，提高代码质量。否则一声不吭的写完并<code>pr</code>后，会导致一个功能开发完毕后才能得到修正，甚至要大幅度改变代码，很浪费经历。</p>
<p>所以，只想要发起讨论的时候<code>pr</code>即可，不必等代码有所实现。即使对某个正在开发的功能提供简短的伪代码让大家有个印象，也能获得不少反馈。如被他人指正自己没注意到的小错误，或功能的修改意见，或已经有他人实现的代码等，能让自己避免浪费不必要的精力。这种边审查边开发的过程，比开发完在审查高效的多。</p>
<p>但需要注意的是，在发送的一个<code>pr</code>或者<code>issue</code>中，不要讨论无关的东西，当需要讨论另外的内容时，重新开一个<code>pr</code>即可。</p>
<h3 id="仓库的维护"><a href="#仓库的维护" class="headerlink" title="仓库的维护"></a>仓库的维护</h3><p>当然在<code>fork</code>和<code>clone</code>后想修改代码，但因某些不可避免的原因搁置了。而远程仓库一直在开发，则此时本地的仓库和远程的最新仓库难免有很多不同之处，所以要让本地的仓库保持最新的状态:</p>
<ul>
<li>首先给目标仓库设置一个名称，这里叫上游<code>upstream</code>，<code>git remote add upstream git://github.com/user/repo.git</code>作为远程仓库。</li>
<li>然后<code>git fetch upstream</code>就能从远程仓库获取最新的代码，将<code>upstream/master</code>分支与当前分支合并，以此来获取远程仓库的最新状态。</li>
</ul>
<h2 id="接收pr"><a href="#接收pr" class="headerlink" title="接收pr"></a>接收<code>pr</code></h2><p>接收到他人发送的<code>pr</code>后，点击即可查看详细内容，在检测完他人发送<code>pr</code>的代码准确无误后，点击<code>merge pull request</code>按钮就会将内容自动合并到仓库的主分支。</p>
<h3 id="接收前的准备"><a href="#接收前的准备" class="headerlink" title="接收前的准备"></a>接收前的准备</h3><ul>
<li>审查代码，对代码作出必要的注释和评论，点击代码左侧的<code>+</code>号即可。</li>
<li>将<code>pr</code><strong>接收方</strong>的仓库<code>clone</code>到本地(不要操作原有的仓库)，如果已经克隆，可以<code>git pull</code>获取最新状态。</li>
<li>然后获取<code>pr</code><strong>发送方</strong>的仓库，设置为本地仓库的远程仓库:<code>git remote add pr-sender git@github.com:pr-sender/repo.git</code>，并<code>git fetch</code>合并。</li>
<li>创建用于检测的分支<code>test</code>，将<code>fetch</code>完的分支和<code>test</code>分支合并，这样<code>test</code>分支就捕获了他人发送<code>pr</code>的分支。</li>
<li>检查代码无误后<code>git branch -D test</code>删除此分支即可。</li>
<li>确认无误后，进入浏览器，点击<code>merge pull request</code>即可，自动合并仓库，仓库的<code>pr</code>会自动从<code>open</code>变为<code>close</code>。</li>
</ul>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>无法运行的代码不要合并到仓库;</li>
<li>不要发布错误的不能运行的代码;</li>
</ul>
]]></content>
      <tags>
        <tag>Computer</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5的基本控件整理</title>
    <url>/2019/10/06/pyqt5-basic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当初就不该踩这个坑，答应老师写这个软件干嘛。算了，给自己点动力。</p>
<p>学了一个星期的PyQt5(主要是玩)，用于GUI（graphicx user interface）开发。想在这里整理基本控件的用法和功能，在后期开发软件中便于查询（整理知识，按照软件需求的功能，筛选合理的控件）。</p>
<p>因代码太长，所以每节的代码都会在章节最后一压缩包的形式呈现，且，本文不适合没有GUI开发经验的人看，但是代码适合新手观看。如果真的是新手来看此文，还是建议多写写，结合代码多看看。</p>
<a id="more"></a>
<p>多年前写过的GUI（西电的优研答辩）效果如下，可以做到不错的效果，但是还是要系统的学一下。</p>
<p><img data-src="/2019/10/06/pyqt5-basic/1.gif" alt></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://muyuuuu.github.io/2019/11/16/A-Beautiful-PyQt5-Interface/">一个好看的通用的界面</a></p>
<p><a href="https://muyuuuu.github.io/2019/10/19/pyqt-layout/">高级布局，与实际软件开发</a></p>
<p><a href="https://muyuuuu.github.io/2019/10/11/pyqt-pit/">pyqt5的高级应用和踩坑</a></p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>使用QtDesigner，可视化的GUI设计工具。采用拖拽式界面，在大多情况下可以轻松对布局、控件、变量名，甚至是菜单栏、工具栏进行便捷的管理。界面为<code>.ui</code>文件，而以记事本打开会发现是<code>XML</code>格式的文件，即<code>.ui</code>文件里面包含的内容会按照<code>XML</code>格式处理，<code>pyuic5</code>会将<code>.ui</code>文件转为<code>.py</code>文件，之后将<code>.py</code>文件引入自定义的代码中。</p>
<p>但QtDesigner也并非最好，如在信号与槽的实现中，就不如直接写代码方便。</p>
<p><code># -*- coding: UTF-8 -*-</code> 避免出现中文乱码。</p>
<h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><p>布局主要为绝对布局和使用布局管理器进行布局。</p>
<h2 id="绝对布局"><a href="#绝对布局" class="headerlink" title="绝对布局"></a>绝对布局</h2><p>绝对布局是最傻的一种方式，只有两三个控件问题不大。但对于大规模的软件开发，控件数量过多会造成严重不便。如新加空间，可能会全部重新布局，且控件的大小和位置不会随窗口大小变化而变化。</p>
<h2 id="布局管理器布局"><a href="#布局管理器布局" class="headerlink" title="布局管理器布局"></a>布局管理器布局</h2><p>分为水平、垂直、网格、表单四种方式。表单主要用于两列的布局，左边是<code>key</code>，右边是<code>value</code>。网格布局较为便利，可以设置控件的其实坐标和横跨坐标，设置较为精确。控件的间距（addStretch）、对其方式（Qt.AlignLeft）均可以调节。还可以实现嵌套布局，如下图所示（水平布局、垂直布局嵌套在网格布局中）。</p>
<p><img data-src="/2019/10/06/pyqt5-basic/1.png" alt></p>
<p>均在QtDesigner里面实现，因此无代码。</p>
<h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2><p>可以通过QtDesigner里面的<code>minimumsize</code>和<code>maximumsize</code>属性设置控件随窗口大小变化而变动的最小尺寸与最大尺寸(用于撑开布局)。<code>sizepolicy</code>可以设置水平、竖直方向的延伸策略，如<code>minimum</code>,<code>maximum</code>,<code>fixed</code>等。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><a href="/download/layout.zip">在窗口中加载子窗口。</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- childrenform.py 是 childrenform2.ui 的生成文件</span><br><span class="line">- mainwindow2.py 是  mainwindow.ui 的生成文件</span><br><span class="line">- layout.py 是主文件，调用了mainwindow2和childrenform</span><br><span class="line">所以执行方式为 ：python layout.py</span><br></pre></td></tr></table></figure>
<p>单击工具栏按钮会调用子窗口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="comment"># 单击工具栏按钮触发</span></span><br><span class="line">    self.actiontst.triggered.connect(self.child_show) </span><br><span class="line">    <span class="comment"># 单击后，加载子窗口</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child_show</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.gridLayout.addWidget(self.child)</span><br><span class="line">    self.child.show()</span><br></pre></td></tr></table></figure>
<h1 id="基本窗口控件"><a href="#基本窗口控件" class="headerlink" title="基本窗口控件"></a>基本窗口控件</h1><p>窗口是指：没有嵌入到其他控件中，还有标题栏，菜单栏等，是程序的整体界面，控件是指按钮、文本框等组成程序的基本元素。一个程序可以有多个窗口，一个窗口可以有多个元素。</p>
<p><code>QMainWindow</code> 是最常见的窗口形式，继承自<code>QWidget</code>，<code>QWidget</code>也是所有用户界面对象的基类。</p>
<p>主函数的执行流程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 在shell中执行</span></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    mywin = MyMainWindow()</span><br><span class="line">    mywin.show()</span><br><span class="line">    sys.exit(app.exec()) <span class="comment"># 开始主循环，直到退出</span></span><br></pre></td></tr></table></figure>
<p>事件代码在主循环开始，接受消息发送给各个控件，点用<code>exit()</code> 或者主窗口被销毁，主循环就会退出。程序运行成功，返回0。</p>
<p>返回0的原因是：PyQt5的底层是C++，C++的<code>main</code>函数返回结果相当与调用了<code>exit</code>函数，<code>main</code>函数的返回值会传送给<code>exit</code>函数，0表示圆满结束。<code>return 1</code> 不具备移植性。`````</p>
<h2 id="窗口基本实现"><a href="#窗口基本实现" class="headerlink" title="窗口基本实现"></a>窗口基本实现</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">功能与控件</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">创建主窗口</td>
<td style="text-align:left">继承自<code>QMainWindow</code> </td>
</tr>
<tr>
<td style="text-align:left">窗口居中显示</td>
<td style="text-align:left">计算屏幕尺寸，窗口尺寸，除以2</td>
</tr>
<tr>
<td style="text-align:left">关闭窗口</td>
<td style="text-align:left"><code>QApplication.instance().quit()</code></td>
</tr>
<tr>
<td style="text-align:left">设置图标</td>
<td style="text-align:left">仿苹果主题不会被显示，因为苹果左上角是三个按钮</td>
</tr>
<tr>
<td style="text-align:left">显示气泡信息</td>
<td style="text-align:left">设置为随鼠标移动比较合适</td>
</tr>
<tr>
<td style="text-align:left"><code>Qlabel</code></td>
<td style="text-align:left">用于信息提示，显示图片、网页链接、不可编辑的文本</td>
</tr>
<tr>
<td style="text-align:left"><code>QLineEdit</code></td>
<td style="text-align:left">单行文本编辑，可设置掩代码、显示方式，内容改变后可发射信号链接到槽函数。可以增加验证器，屏蔽无效输入。</td>
</tr>
<tr>
<td style="text-align:left"><code>QTextEdit</code></td>
<td style="text-align:left">多行文本编辑，与但行文本编辑基本类似，可以显示Html文档。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="按钮类控件"><a href="#按钮类控件" class="headerlink" title="按钮类控件"></a>按钮类控件</h2><p>在任何GUI中，按钮都是常用的出发动作的请求方式，用于和用户的交互操作。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">控件</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>QPushButton</code></td>
<td style="text-align:left">常见按钮，可设置图标，可控制按钮可用与不可用，点击后发射信号到槽函数。</td>
</tr>
<tr>
<td style="text-align:left"><code>QRadioButton</code></td>
<td style="text-align:left">用户之可以选择一个选项，用于多选一的互斥选项，如性别。切换状态后发射信号。</td>
</tr>
<tr>
<td style="text-align:left"><code>QCheckBox</code></td>
<td style="text-align:left">多选多，可以设置图标。</td>
</tr>
<tr>
<td style="text-align:left"><code>QComboBox</code></td>
<td style="text-align:left">下拉列表框，可以获得当前所选项和索引，可用于限制输入。</td>
</tr>
<tr>
<td style="text-align:left"><code>Qslider</code></td>
<td style="text-align:left">滑动条，设置刻度，最大值最小值，如控制坐标轴的大小。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="对话框类控件"><a href="#对话框类控件" class="headerlink" title="对话框类控件"></a>对话框类控件</h2><p>一些提示框，如选择字体、颜色等，所有对话框的父类是<code>QDialog</code>，子类如下。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">控件</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>QMessageBox</code></td>
<td style="text-align:left">用于提示信息, 如警告、询问和严重出错等。</td>
</tr>
<tr>
<td style="text-align:left"><code>QFileDialog</code></td>
<td style="text-align:left">用于打开文件和保存文件，可以设置过滤器限制文件后缀名。</td>
</tr>
<tr>
<td style="text-align:left"><code>QFontDialog</code></td>
<td style="text-align:left">用于设置字体。</td>
</tr>
<tr>
<td style="text-align:left"><code>QInputDialog</code></td>
<td style="text-align:left">用于控件的标准输入，如<code>getInt</code>只能获得整数输入。</td>
</tr>
<tr>
<td style="text-align:left"><code>QColorDialog</code></td>
<td style="text-align:left">用于设置颜色。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><p>用日期类的控件输入，可以避免用户的输入不规范。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">控件</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>QCalendar</code></td>
<td style="text-align:left">以网格日历的形式输入日期，可以获取日期，日期改变后发射信号</td>
</tr>
<tr>
<td style="text-align:left"><code>QDateTimeEdit</code></td>
<td style="text-align:left">可编辑日期，感觉不好用，可以设置为弹出日历。</td>
</tr>
<tr>
<td style="text-align:left"><code>QCalendar</code></td>
<td style="text-align:left">以日历的形式输入日期</td>
</tr>
<tr>
<td style="text-align:left"><code>QCalendar</code></td>
<td style="text-align:left">以日历的形式输入日期</td>
</tr>
</tbody>
</table>
</div>
<h2 id="菜单栏、状态栏、工具栏"><a href="#菜单栏、状态栏、工具栏" class="headerlink" title="菜单栏、状态栏、工具栏"></a>菜单栏、状态栏、工具栏</h2><p>菜单栏、工具栏的创建和编辑在QtDesigner里面比较容易实现。用代码实现反而舍近求远。</p>
<p>状态栏的理想是：鼠标在哪里就显示什么信息，但不太好实现。但也不是不能实现，只是学完基本控件还不能实现，需要学一下信号与槽的高级设置。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><a href="/download/BasicWin.zip">基本控件练习</a></p>
<p>执行方式为：<code>python control.py</code>，以上所有功能的界面如下所示：</p>
<p><img data-src="/2019/10/06/pyqt5-basic/2.png" alt></p>
<p>软件运行界面如下：（上面提到的基本内容都有）</p>
<p><img data-src="/2019/10/06/pyqt5-basic/3.png" alt></p>
<h1 id="高级控件"><a href="#高级控件" class="headerlink" title="高级控件"></a>高级控件</h1><h2 id="表格与树"><a href="#表格与树" class="headerlink" title="表格与树"></a>表格与树</h2><p>表格与树可以有效的解决在一个控件中有规律的呈现更多的数据。如对一批数据进行交互，以表格的形式输出这些信息。</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">控件</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>QTableView</code></td>
<td style="text-align:left">可以使用自定义的数据模型，<code>setModel</code>绑定数据源，也可以对<code>SQL</code>的查询结果进行封装，更新控件内容。更类似于视图，更能较少。</td>
</tr>
<tr>
<td style="text-align:left"><code>QListView</code></td>
<td style="text-align:left">先建立数据模型，然后在保存数据，单列显示。</td>
</tr>
<tr>
<td style="text-align:left"><code>QListWidget</code></td>
<td style="text-align:left">是<code>QListView</code>的子类，列表条目的添加与删除。</td>
</tr>
<tr>
<td style="text-align:left"><code>QTableWidget</code></td>
<td style="text-align:left">是<code>QTableView</code>的子类，也就是父类所有的方法子类均可以使用。对表格的编辑操作比较多，如对齐、禁止编辑、整行选中、排序、嵌套其他控件、设置单元格颜色和支持右键菜单栏等。功能较为强大。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><code>QTreeWidget</code>实现了树形结构，一添加子节点的形式对树形结构进行扩充，实现最基本的树形预览。可以设置节点的背景颜色，节点状态，给节点添加响应事件，也可以定制系统模式实现复杂的树形结构，如文件系统盘的树列表。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>所开发的程序包含太多控件，一个窗口装载不下或者装载太多控件而不美观，应该使用容器装载更多的控件。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">控件</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>QTabWidget</code></td>
<td style="text-align:left">一个选项卡，一个页面区域，单击选项卡查看各个页面。</td>
</tr>
<tr>
<td style="text-align:left"><code>QDockWidgetWidget</code></td>
<td style="text-align:left">浮动窗口，类似与Dev C++ 中的底层Debug窗口，保持浮动状态或者在制定位置附加到主窗口。</td>
</tr>
<tr>
<td style="text-align:left"><code>QScrollBar</code></td>
<td style="text-align:left">提供水平或者垂直的滚动条，扩大窗口的有效装载面积。（暂时没有尝试）</td>
</tr>
<tr>
<td style="text-align:left"><code>QGroupBox</code></td>
<td style="text-align:left">下拉框，就是，一个页面内一直向下拖动</td>
</tr>
</tbody>
</table>
</div>
<h2 id="网页交互"><a href="#网页交互" class="headerlink" title="网页交互"></a>网页交互</h2><p>使用<code>PyQt5.QtWebKitWidgets.QWebEngineView</code>类来使用网页控件，可以加载外部的网页地址，也可以加载本地的html文档。但是并不推荐，建议使用系统浏览器完成打开网页的功能。</p>
<p>效果如下图所示：</p>
<p><img data-src="/2019/10/06/pyqt5-basic/4.png" alt></p>
<p>当然也可以调用<code>javascript</code>的代码，也可以在<code>javascript</code>中调用<code>pyqt5</code>，暂时没这个需求，所以没有学。</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p><a href="/download/Container.zip">容器的代码实现</a></p>
<p><a href="/download/ViewWidget.zip">表格与树的代码实现</a></p>
<p><a href="/download/WebPage.zip">加载外部网页（无JavaScript相关）</a></p>
]]></content>
      <tags>
        <tag>GUI</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5踩坑</title>
    <url>/2019/10/11/pyqt-pit/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>PyQt5</code>的文档相对较少，在自己的实际开发使用中，遇到了些许的坑。网上也没有大把的例子供我参考，还有好多例子停留在Qt4这个版本。所以将调bug的过程记录于此，均为自己探索的较为良好的解决方案。包括：</p>
<ul>
<li>布局相关</li>
<li>代码结构</li>
<li>qtpandas的版本问题</li>
<li>切换主题</li>
<li>数据库使用</li>
<li>pyqtgraph绘图</li>
<li>提升窗口(matplotlib)</li>
<li>Html的动态绘图</li>
</ul>
<p>同样，代码太长，不能全部放上来，只放了核心代码，稍微有GUI开发基础的人都能看懂。或者，你可以按照目录观看自己想要的部分。或者，去给出的github链接内拿代码。</p>
<a id="more"></a>
<h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p><a href="https://github.com/muyuuuu/PyQt-learn/tree/master/GUI/Basic-train" target="_blank" rel="noopener">https://github.com/muyuuuu/PyQt-learn/tree/master/GUI/Basic-train</a></p>
<h1 id="布局相关"><a href="#布局相关" class="headerlink" title="布局相关"></a>布局相关</h1><p>还是使用<code>Qt designer</code>进行布局管理较为方便，写代码一行一行的调试实在是费劲。而且，可以在布局管理器中进行嵌套布局，如先对几个小控件进行水平布局，在对另外的空间垂直布局，最后整体网格布局，这样会较为便捷。效果如下所示：</p>
<p><img data-src="/2019/10/11/pyqt-pit/1.png" alt></p>
<p><code>verticalLayout_5</code> 下面有多个布局。此外，<code>Qt designer</code>里面设置的布局不一定为软件最终的布局，还是要实际运行一下，看看到底软件长啥样。如，在designer里面每个控件都很大，实际运行却可能很小，不过大体相同。</p>
<h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><p><code>QWidget</code> 是所有类的基类，也包括<code>QMainWindow</code>，而在设置窗口风格时，只能在<code>QWidget</code>里面使用<code>self.setStyleSheet(self.style)</code>， 在<code>QMainWindow</code>里面则无效（这里的无效是指：切换主题后会有一些设置无法更改，导致界面很丑）。</p>
<p>但是，一个完整的窗口程序（包括任务栏，菜单栏，状态栏等）是离不开<code>QMainWindow</code>的，所以我们可以在<code>QMainWindow</code>设置中心区域为<code>QWidget</code>，然后在<code>QWidget</code>里面添加控件即可，即将控件的实现和布局委托给<code>QWidget</code>。</p>
<p>所以，我们需要两个<code>ui</code>文件。与控件相关的东西，如添加控件，修改控件可以在<code>QWidget</code>里面完成，而有关窗口的设置，如菜单栏，设置透明度，居中显示等可以在<code>QMainWindow</code>里面设置，最后将<code>QWidget</code>添加即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mainwidget <span class="keyword">import</span> Ui_Form <span class="comment">#widget的ui</span></span><br><span class="line"><span class="keyword">from</span> mainwindow <span class="keyword">import</span> Ui_MainWindow <span class="comment">#mainwindow的ui</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承QWidget</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainWidget</span><span class="params">(QWidget, Ui_Form)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None)</span>:</span></span><br><span class="line">        super(MyMainWidget, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line">        self.setLayout(self.gridLayout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 退出窗口</span></span><br><span class="line">        self.quit_btn.clicked.connect(self.quit_act)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quit_act</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># sender 是发送信号的对象</span></span><br><span class="line">        sender = self.sender()</span><br><span class="line">        print(sender.text() + <span class="string">'键被按下'</span>)</span><br><span class="line">        qApp = QApplication.instance()</span><br><span class="line">        qApp.quit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承QMainWindow</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainWindow</span><span class="params">(QMainWindow, Ui_MainWindow)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None)</span>:</span></span><br><span class="line">        super(MyMainWindow, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建实例，并添加</span></span><br><span class="line">        q = MyMainWidget()</span><br><span class="line">        self.setCentralWidget(q)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置窗口透明</span></span><br><span class="line">        self.setWindowOpacity(<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># self.resize(1000, 700)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 默认的状态栏</span></span><br><span class="line">        <span class="comment"># 可以设置其他按钮点击 参考多行文本显示 然而不行 </span></span><br><span class="line">        self.status = self.statusBar()</span><br><span class="line">        self.status.showMessage(<span class="string">"你在主页面～"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 标题栏</span></span><br><span class="line">        self.setWindowTitle(<span class="string">"建模协会录入信息"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 窗口居中</span></span><br><span class="line">        self.center()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        获取桌面长宽</span></span><br><span class="line"><span class="string">        获取窗口长宽</span></span><br><span class="line"><span class="string">        移动</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        screen = QDesktopWidget().screenGeometry()</span><br><span class="line">        size = self.geometry()</span><br><span class="line">        self.move((screen.width() - size.width()) / <span class="number">2</span>, (screen.height() - size.height()) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 在shell中执行</span></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    mywin = MyMainWindow()</span><br><span class="line">    mywin.show()</span><br><span class="line">    <span class="comment"># 开始主循环，直到退出</span></span><br><span class="line">    sys.exit(app.exec())</span><br></pre></td></tr></table></figure>
<h1 id="qtpandas的使用"><a href="#qtpandas的使用" class="headerlink" title="qtpandas的使用"></a>qtpandas的使用</h1><p><code>pandas</code>是比较好好用的数据分析的库，而与<code>PyQt5</code>的结合，最方便的方法是使用<code>qtpandas</code>。这个库会将<code>pandas</code>的数据显示在<code>QTableWidget</code>上，自动实现<code>QTableWidget</code>的各种功能，如增加，排序，保存，删除等。</p>
<p>但是，<code>pip install qtpandas</code>暂时的版本只支持<code>PyQt4</code>，如果想支持<code>PyQt5</code>，需要去github下载最新版。下载好后进入目录，命令行内<code>python setup.py install</code>即可。</p>
<p>而且<code>qtpandas</code>依赖于<code>pandas 0.23</code>，需要提前安装<code>pandas 0.23</code>。如果直接<code>pip install pandas</code>是不可以的，因为直接pip会到最新版0.25（写这篇博客的时候），<code>qtpandas</code>不能使用，会直接报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">No module named <span class="string">'pandas.tslib</span></span><br></pre></td></tr></table></figure>
<p>因此我创建了虚拟环境，在虚拟环境内直接<code>pip install pandas==0.23</code> 即可，但是还不能放心使用。</p>
<p>通过这几天的使用发现，<code>PyQt5</code>的依赖库做的都不是很好。</p>
<p>有些库<code>pip</code>后可以放心使用；<br>有些库<code>pip</code>后关机开机电脑才能生效，比如<code>pyqtgraph</code>;<br>有些库<code>pip</code>后关机开机还是用不了，比如<code>qtpandas</code>。</p>
<p>于是，我在github上下载了<code>qtpandas</code>，将文件夹放在代码的同级目录下，便可以引用进来，然后使用。期待开发者做后后面的完善吧。</p>
<p><a href="https://github.com/draperjames/qtpandas" target="_blank" rel="noopener">https://github.com/draperjames/qtpandas</a></p>
<p>库的安装很费劲，但是，真的好用，代码与截图如下：</p>
<p>文件结构：（qtpandas的文件夹在这，调用里面的代码，库的本质还是代码啊）<br><img data-src="/2019/10/11/pyqt-pit/2.png" alt></p>
<p>执行效果：<br><img data-src="/2019/10/11/pyqt-pit/3.png" alt></p>
<p>代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> qtpandas.views.DataTableView <span class="keyword">import</span> DataTableWidget</span><br><span class="line"><span class="keyword">from</span> qtpandas.models.DataFrameModel <span class="keyword">import</span> DataFrameModel</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainWidget</span><span class="params">(QWidget, Ui_Form)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None)</span>:</span></span><br><span class="line">        super(MyMainWidget, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line">        self.setLayout(self.gridLayout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 退出窗口</span></span><br><span class="line">        self.quit_btn.clicked.connect(self.quit_act)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># qtpandas</span></span><br><span class="line">        model = DataFrameModel() </span><br><span class="line">        <span class="comment"># 空模型那个用于存储和处理数据</span></span><br><span class="line">        <span class="comment"># print(type(self.widget_2))</span></span><br><span class="line">        self.widget_2.setViewModel(model)</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">'A'</span>: [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">            <span class="string">'B'</span>: [<span class="number">12</span>, <span class="number">11</span>, <span class="number">10</span>],</span><br><span class="line">            <span class="string">'C'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        self.df = pandas.DataFrame(data)</span><br><span class="line">        self.df[<span class="string">'A'</span>] = self.df[<span class="string">'A'</span>].astype(np.int8) <span class="comment"># 委托，规定某一列的类型</span></span><br><span class="line">        model.setDataFrame(self.df)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存数据</span></span><br><span class="line">        self.quit_btn_7.clicked.connect(self.save_data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.df.to_csv(<span class="string">'data.csv'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quit_act</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># sender 是发送信号的对象</span></span><br><span class="line">        sender = self.sender()</span><br><span class="line">        print(sender.text() + <span class="string">'键被按下'</span>)</span><br><span class="line">        qApp = QApplication.instance()</span><br><span class="line">        qApp.quit()</span><br></pre></td></tr></table></figure></p>
<h1 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h1><p>对于我这种不会（不想写）前端的人来说，写<code>QSS(Qt Style Sheet)</code>无疑在要我命，不如用他人写好的代替一下，在代码中引入样式即可。这样也能实现界面和逻辑的代码分离。</p>
<p>别人写好的：<br><a href="https://blog.csdn.net/liang19890820/article/details/52384042" target="_blank" rel="noopener">https://blog.csdn.net/liang19890820/article/details/52384042</a></p>
<p>每个<code>Widget</code>都可以设置风格，因此建议主要界面使用<code>QWidget</code>作为窗口的主要区域用于设背景风格。同样，如上文提到的，<code>QMainWindow</code>里切换风格效果很不好，不如把所有控件放在<code>QWidget</code>里面，切换风格也方便。black.qss还有white.qss都是从上面的CSDN里的博客下载的。</p>
<p>文件结构如下：<br><img data-src="/2019/10/11/pyqt-pit/4.png" alt></p>
<p>切换风格的代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 样式的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StyleFile</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readQSS</span><span class="params">(style)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open (style, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">return</span> f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在QWidget里面切换风格才有效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainWidget</span><span class="params">(QWidget, Ui_Form)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None)</span>:</span></span><br><span class="line">        super(MyMainWidget, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.quit_btn_3.clicked.connect(self.style_change)</span><br><span class="line">        self.quit_btn_4.clicked.connect(self.style_change1)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">style_change1</span><span class="params">(self)</span>:</span></span><br><span class="line">        style_file = <span class="string">'white.qss'</span></span><br><span class="line">        self.style = StyleFile.readQSS(style_file)</span><br><span class="line">        self.setStyleSheet(self.style)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">style_change</span><span class="params">(self)</span>:</span></span><br><span class="line">        style_file = <span class="string">'black.qss'</span></span><br><span class="line">        self.style = StyleFile.readQSS(style_file)</span><br><span class="line">        self.setStyleSheet(self.style)</span><br></pre></td></tr></table></figure></p>
<p>效果如下：</p>
<p>黑色主题<br><img data-src="/2019/10/11/pyqt-pit/5.png" alt><br>白色主题<br><img data-src="/2019/10/11/pyqt-pit/6.png" alt></p>
<p>而设置窗口的无边框风格、透明度风格则必须要在<code>QMainWindow</code>里面设置，因为这是窗口的特有方法。</p>
<h1 id="数据库的使用"><a href="#数据库的使用" class="headerlink" title="数据库的使用"></a>数据库的使用</h1><p>数据库的使用还是很常见的，对于开发小型的应用程序，使用<code>SQLite</code>即可（Manjaro环境下已经内置），以及可视化的管理软件SQLiteStudio。<code>PyQt</code>使用<code>QSqlDataBase</code>连接数据库，一个实例表示了一次连接（连接到IP地址，本地数据库均可），连接、操作完毕后记得关闭，否则会占用数据库的资源。</p>
<p>此外，<code>QSqlTableModel</code>提供了可读写的数据模型，链接到数据库后可设置查询的表。设置查询的过滤条件，执行查询语句。之后，将数据模型填充到<code>QTableView</code>中，可滚动，可编辑（编辑后改变数据库中的存储）。</p>
<p>放一次完整的代码吧，但是copy下来不能运行，因为没有<code>ui</code>文件，自己画一个或者只看数据库部分的代码吧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> PyQt5</span><br><span class="line"><span class="comment"># 基本控件都在这里面</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QApplication, QMainWindow, QDesktopWidget, QStyleFactory, QWidget,</span><br><span class="line">                             QMessageBox, QTableView)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QPalette, QColor</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> Qt</span><br><span class="line"><span class="comment"># 导入数据库</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtSql <span class="keyword">import</span> QSqlDatabase, QSqlQuery, QSqlTableModel</span><br><span class="line"><span class="keyword">from</span> mainwidget <span class="keyword">import</span> Ui_Form</span><br><span class="line"><span class="keyword">from</span> mainwindow <span class="keyword">import</span> Ui_MainWindow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承主窗口 Qmainwindow 和 自己画的界面 Ui_MainWindow</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainWidget</span><span class="params">(QWidget, Ui_Form)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None)</span>:</span></span><br><span class="line">        super(MyMainWidget, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line">        self.setLayout(self.gridLayout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 链接sql与查询</span></span><br><span class="line">        self.db = QSqlDatabase.addDatabase(<span class="string">"QSQLITE"</span>)</span><br><span class="line">        self.db.setDatabaseName(<span class="string">'table/test.db'</span>)</span><br><span class="line">        self.db.open()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.db.open():</span><br><span class="line">            QMessageBox.critical(<span class="literal">None</span>, (<span class="string">"无法打开数据库"</span>), (<span class="string">"SQlite支持"</span>), QMessageBox.Cancel)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        self.model = QSqlTableModel()</span><br><span class="line"></span><br><span class="line">        self.pushButton.clicked.connect(self.insert)</span><br><span class="line">        self.pushButton_2.clicked.connect(self.query)</span><br><span class="line">        self.pushButton_3.clicked.connect(self.insert_oneline)</span><br><span class="line">        self.pushButton_4.clicked.connect(self.del_oneline)</span><br><span class="line">        self.pushButton_5.clicked.connect(self.find_row)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印行列号</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_row</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.view.currentIndex().row() + <span class="number">1</span>, self.view.currentIndex().column() + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除一行</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">del_oneline</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.model.removeRow(self.view.currentIndex().row())</span><br><span class="line">        self.model.setEditStrategy(QSqlTableModel.OnFieldChange)</span><br><span class="line">        self.model.select()</span><br><span class="line">        self.view.setModel(self.model)</span><br><span class="line">        self.view.show()       </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 插入一行</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_oneline</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.model.insertRows(self.model.rowCount(), <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># print(str(ret))</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.model.setTable(<span class="string">"people"</span>)</span><br><span class="line">        self.model.setEditStrategy(QSqlTableModel.OnFieldChange)</span><br><span class="line">        <span class="comment"># self.model.setFilter("id &gt; 1")</span></span><br><span class="line">        self.model.select()</span><br><span class="line">        self.model.setHeaderData(<span class="number">0</span>, Qt.Horizontal, <span class="string">"ID"</span>)</span><br><span class="line">        self.model.setHeaderData(<span class="number">1</span>, Qt.Horizontal, <span class="string">"Name"</span>)</span><br><span class="line">        self.model.setHeaderData(<span class="number">2</span>, Qt.Horizontal, <span class="string">"Address"</span>)</span><br><span class="line">        self.view.setModel(self.model)</span><br><span class="line">        self.view.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self)</span>:</span></span><br><span class="line">        query = QSqlQuery()</span><br><span class="line">        <span class="comment"># query.exec_("create table people(id int primary key, name varchar(20), address varchar(30))")</span></span><br><span class="line">        <span class="comment"># query.exec_("insert into people values(1, 'one', 'test1')")</span></span><br><span class="line">        <span class="comment"># query.exec_("insert into people values(2, 'two', 'test2')")</span></span><br><span class="line">        <span class="comment"># query.exec_("insert into people values(3, 'three', 'test3')")</span></span><br><span class="line">        <span class="comment"># query.exec_("inse![](pyqt-pit/7.png)rt into people values(4, 'four', 'test4')")</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">6</span>, <span class="number">100</span>):</span><br><span class="line">            query.exec_(<span class="string">"insert into people values(&#123;&#125;, 'test', 'test&#123;&#125;')"</span>.format(i, i))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainWindow</span><span class="params">(QMainWindow, Ui_MainWindow)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None)</span>:</span></span><br><span class="line">        super(MyMainWindow, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line">        self.q = MyMainWidget()</span><br><span class="line">        self.setCentralWidget(self.q)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置窗口透明</span></span><br><span class="line">        self.setWindowOpacity(<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭时，默认关闭数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span><span class="params">(self, e)</span>:</span></span><br><span class="line">        self.q.db.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 在shell中执行</span></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    mywin = MyMainWindow()</span><br><span class="line">    mywin.show()</span><br><span class="line">    <span class="comment"># 开始主循环，直到退出</span></span><br><span class="line">    sys.exit(app.exec())</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/10/11/pyqt-pit/7.png" alt></p>
<h1 id="pyqtgraph使用"><a href="#pyqtgraph使用" class="headerlink" title="pyqtgraph使用"></a>pyqtgraph使用</h1><p>这个库，简直有毒，总以为我装失败了，没想到关机开机后这个库能用了。</p>
<p>这个绘图库是纯<code>python</code>图形<code>GUI</code>库，由于是基于<code>pyqt</code>开发的集成绘图模块，所以<code>PyQtGraph</code>绘图与底层方式实现绘图功能在速度上的区别不大。这个库的好处是，可以写两行代码，点击<code>run example</code>查看所有的绘图效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyqtgraph.examples</span><br><span class="line">pyqtgraph.examples.run()</span><br></pre></td></tr></table></figure>
<p>绘图效果，看下图，个人感觉还可以，虽然比不上<code>matlab</code>的工具箱和<code>matplotlib</code>。</p>
<p><img data-src="/2019/10/11/pyqt-pit/1.gif" alt></p>
<p>模仿上述的例子进行简单的集成。这里用到了提升窗口的技术，如果不了解，可以先看后文的提升窗口。基类：<code>QWidget</code>，头文件：<code>pyqtgraph</code>， 名称：<code>GraphicsLayoutWidget</code>，一个字母都不要错哦。在本代码中，使用了提升窗口的对象名为：<code>pyqtgraph2</code>， <code>pyqtgraph</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyqtgraph <span class="keyword">as</span> pg </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainWidget</span><span class="params">(QWidget, Ui_Form)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None)</span>:</span></span><br><span class="line"></span><br><span class="line">        super(MyMainWidget, self).__init__(parent)</span><br><span class="line">        <span class="comment"># 在初始化之前设置pg，因为初始化会写死配置，无法在更改</span></span><br><span class="line">        pg.setConfigOption(<span class="string">'background'</span>, <span class="string">'#f0f0f0'</span>)</span><br><span class="line">        pg.setConfigOption(<span class="string">'foreground'</span>, <span class="string">'d'</span>)</span><br><span class="line">        <span class="comment"># 使曲线看起来光滑</span></span><br><span class="line">        pg.setConfigOptions(antialias = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setLayout(self.gridLayout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 退出窗口</span></span><br><span class="line">        self.quit_btn.clicked.connect(self.quit_act)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘图</span></span><br><span class="line">        self.pushButton.clicked.connect(self.graph_plot)</span><br><span class="line">        self.pushButton_2.clicked.connect(self.graph_plot1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多曲线绘图</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">graph_plot1</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pyqtgraph2.clear()</span><br><span class="line">        plt = self.pyqtgraph2.addPlot(title=<span class="string">"test"</span>)</span><br><span class="line">        x = np.random.normal(size=<span class="number">20</span>)</span><br><span class="line">        y1 = np.sin(x)</span><br><span class="line">        y2 = <span class="number">1.1</span> * np.sin(x + <span class="number">1</span>)</span><br><span class="line">        bg1 = pg.BarGraphItem(x = x, height = y1, width = <span class="number">2</span>, brush = <span class="string">'r'</span>)</span><br><span class="line">        bg2 = pg.BarGraphItem(x = x, height = y2, width = <span class="number">2</span>, brush = <span class="string">'b'</span>)</span><br><span class="line">        plt.addItem(bg1)</span><br><span class="line">        plt.addItem(bg2)</span><br><span class="line">        <span class="comment"># 新的一列还是新的一行</span></span><br><span class="line">        <span class="comment"># self.pyqtgraph2.nextColumn()</span></span><br><span class="line">        self.pyqtgraph2.nextRow()</span><br><span class="line">        plt2 = self.pyqtgraph2.addPlot(title=<span class="string">"test1"</span>)</span><br><span class="line">        x = np.linspace(<span class="number">1</span>, <span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line">        y3 = np.random.normal(size=<span class="number">20</span>)</span><br><span class="line">        plt2.plot(x, y3, pen = pg.mkPen(width = <span class="number">2</span>, color = <span class="string">'d'</span>))</span><br><span class="line">        plt2.showGrid(x=<span class="literal">True</span>, y=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单标题，多曲线绘图</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">graph_plot</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pyqtgraph.clear()</span><br><span class="line">        <span class="comment"># 两种绘图方式</span></span><br><span class="line">        <span class="comment"># self.pyqtgraph.addPlot(y = np.random.normal(size=100),</span></span><br><span class="line">            <span class="comment"># pen = pg.mkPen(color='b', width=2))</span></span><br><span class="line">        plt2 = self.pyqtgraph.addPlot(title=<span class="string">"multi rules"</span>)</span><br><span class="line">        plt2.plot(np.random.normal(size=<span class="number">150</span>),</span><br><span class="line">            pen = pg.mkPen(color=<span class="string">'r'</span>, width=<span class="number">2</span>))</span><br><span class="line">        plt2.plot(np.random.normal(size=<span class="number">150</span>) + <span class="number">5</span>,</span><br><span class="line">            pen = pg.mkPen(color=<span class="string">'b'</span>, width=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/10/11/pyqt-pit/4.gif" alt></p>
<h1 id="Matplotlib与PyQt的结合"><a href="#Matplotlib与PyQt的结合" class="headerlink" title="Matplotlib与PyQt的结合"></a>Matplotlib与PyQt的结合</h1><p>谈到绘图，不得不提一下<code>Matplotlib</code>，很出名的python绘图库。如果可以把<code>Matplotlib</code>绘制的图形嵌入到<code>PyQt</code>中，也就避免了底层绘制图像的繁琐。</p>
<p>说干就干。（官网也有实例）</p>
<p>工具库的引入：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.backends.backend_qt5agg <span class="keyword">import</span> FigureCanvasQTAgg <span class="keyword">as</span> FigureCanvas</span><br><span class="line"><span class="keyword">from</span> matplotlib.figure <span class="keyword">import</span> Figure</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.backends.backend_qt5 <span class="keyword">import</span> NavigationToolbar2QT <span class="keyword">as</span> NavigationToolbar</span><br></pre></td></tr></table></figure></p>
<p>创建空白的绘图界面的类，实现静态绘图和动态绘图两种方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘图的空白界面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MymplCanvas</span><span class="params">(FigureCanvas)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None, width=<span class="number">5</span>, height=<span class="number">4</span>, dpi=<span class="number">100</span>)</span>:</span></span><br><span class="line">        self.fig = Figure(figsize=(width, height), dpi=dpi)</span><br><span class="line">        self.axes = self.fig.add_subplot(<span class="number">111</span>) <span class="comment"># 多界面绘图</span></span><br><span class="line">        FigureCanvas.__init__(self, self.fig)</span><br><span class="line">        self.setParent(parent)</span><br><span class="line">        FigureCanvas.setSizePolicy(self, </span><br><span class="line">            QSizePolicy.Expanding, QSizePolicy.Expanding</span><br><span class="line">        )</span><br><span class="line">        FigureCanvas.updateGeometry(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_plot</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.axes.clear()</span><br><span class="line">        self.fig.suptitle(<span class="string">"static FIG"</span>)</span><br><span class="line">        t = np.linspace(<span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">        s = np.sin(np.pi * t)</span><br><span class="line">        self.axes.plot(t, s)</span><br><span class="line">        self.axes.grid(<span class="literal">True</span>)</span><br><span class="line">        self.draw()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为何要加参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dynamic_plot</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        timer = QTimer(self)</span><br><span class="line">        timer.timeout.connect(self.update_fig)</span><br><span class="line">        timer.start(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_fig</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.axes.clear()</span><br><span class="line">        self.fig.suptitle(<span class="string">"dynamic FIG"</span>)</span><br><span class="line">        l = np.random.randint(<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>)</span><br><span class="line">        self.axes.plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], l, <span class="string">'r'</span>)</span><br><span class="line">        self.axes.grid(<span class="literal">True</span>)</span><br><span class="line">        self.draw()</span><br></pre></td></tr></table></figure>
<p>之后，封装绘图类。将绘图类封装到<code>MatplotlibWidget</code>类，调用<code>MatplotlibWidget</code>类直接实现绘图功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实现绘图类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MatplotlibWidget</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span></span><br><span class="line">        super(MatplotlibWidget, self).__init__(parent)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 封装绘图类</span></span><br><span class="line">        self.gridLayout = QGridLayout()</span><br><span class="line">        self.mpl = MymplCanvas(self)</span><br><span class="line">        <span class="comment"># 添加工具栏</span></span><br><span class="line">        self.mpl_tool = NavigationToolbar(self.mpl, self)</span><br><span class="line">        self.setLayout(self.gridLayout)</span><br><span class="line">        self.gridLayout.addWidget(self.mpl)</span><br><span class="line">        self.gridLayout.addWidget(self.mpl_tool)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.mpl.static_plot()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dynamic</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.mpl.dynamic_plot()</span><br></pre></td></tr></table></figure>
<p>之后在窗口<code>QWidget</code>里面调用<code>MatplotlibWidget</code>即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainWidget</span><span class="params">(QWidget, Ui_Form)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None)</span>:</span></span><br><span class="line">        super(MyMainWidget, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line">        self.setLayout(self.gridLayout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 退出窗口</span></span><br><span class="line">        self.quit_btn.clicked.connect(self.quit_act)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提升后</span></span><br><span class="line">        self.widget = MatplotlibWidget()</span><br><span class="line">        self.widget.setVisible(<span class="literal">False</span>)</span><br><span class="line">        self.widget_2 = MatplotlibWidget()</span><br><span class="line">        self.widget_2.setVisible(<span class="literal">False</span>)</span><br><span class="line">        self.gridLayout.addWidget(self.widget)</span><br><span class="line">        self.gridLayout.addWidget(self.widget_2)</span><br><span class="line">        self.pushButton.clicked.connect(self.dynamic)</span><br><span class="line">        self.pushButton_2.clicked.connect(self.static)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.widget.setVisible(<span class="literal">True</span>)</span><br><span class="line">        self.widget.mpl.static_plot()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dynamic</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.widget_2.setVisible(<span class="literal">True</span>)</span><br><span class="line">        self.widget_2.mpl.dynamic_plot()</span><br></pre></td></tr></table></figure>
<p>效果如下所示：</p>
<p><img data-src="/2019/10/11/pyqt-pit/2.gif" alt></p>
<h1 id="提升窗口"><a href="#提升窗口" class="headerlink" title="提升窗口"></a>提升窗口</h1><h2 id="已经含有的类"><a href="#已经含有的类" class="headerlink" title="已经含有的类"></a>已经含有的类</h2><p>在上文已经提到了一次提升窗口。再说这个之前，确保已经看懂了上面<code>pyqtgraph</code>和<code>matplotlib</code>的例子，不然这里更加看不懂。之后会在说明自定义和引用已有类的角度说明如何提升窗口。（毕竟我之前也以为这个没多大用）</p>
<blockquote>
<p>基类：<code>QWidget</code>，头文件：<code>pyqtgraph</code>， 名称：<code>GraphicsLayoutWidget</code>。</p>
</blockquote>
<p>因为pyqtgraph是已经安装好的库，所以可以设置头文件为<code>pyqtgraph</code>，相当与传统的<code>import</code>。</p>
<p>而在Qt Designer内，首先将<code>Widget</code>托入界面，右键，提升为。（不好意思这里没办法截图，linux下的截图可真难用，wine QQ的截图也不能全局有效）</p>
<p><img data-src="/2019/10/11/pyqt-pit/12.png" alt></p>
<p>输入：头文件：<code>pyqtgraph</code>， 名称：<code>GraphicsLayoutWidget</code>。（不要输入错误，一个字母都不要错）</p>
<p>输入后以此点击添加、提升即可。</p>
<p><img data-src="/2019/10/11/pyqt-pit/10.png" alt></p>
<p>之后<code>pyuic5 -o mainwidget.py mainwidget.ui</code>后，会在辅助的<code>mainwidget.py</code>文件里发现：<code>from pyqtgraph import GraphicsLayoutWidget</code>这么一句话，也就是，上面说的传统的import。手工也可写这行代码，为什么大费周折呢？因为提升了窗口，会发现，这个类有了自己的界面，而不在是简单的导入类，之后可以使用这个特殊的界面进行随意的拖动、布局、使用，会比纯代码方便很多。</p>
<p>相当与在库<code>pyqtgraph</code>中引入了一个布局，并且给了这个布局一个界面，这个界面可以实现绘图功能，那么以后在想绘图的时候就可以复制、拖动这个界面，更加轻松的布局和设置大小。此时提升完毕。</p>
<h2 id="自己写的类"><a href="#自己写的类" class="headerlink" title="自己写的类"></a>自己写的类</h2><p>以上是在有相应的库和方法的前提下设置提升类。如果没有相应的库，如上文的类<code>MatplotlibWidget</code>，如何将自己写的类关联到<code>Widget</code>里面进行提升，形成容易操作的控件呢？且看下文。</p>
<p>这个时候需要将自己写的类单独拿出来成为一个文件，在同级目录下引用即可。</p>
<h3 id="文件结构："><a href="#文件结构：" class="headerlink" title="文件结构："></a>文件结构：</h3><p><img data-src="/2019/10/11/pyqt-pit/11.png" alt></p>
<h3 id="提升方法"><a href="#提升方法" class="headerlink" title="提升方法"></a>提升方法</h3><p>自行托入<code>Widget</code>，右键提升，输入名称和头文件，名称是类名，文件就是同级目录下的文件，最后添加，提升即可。</p>
<p><img data-src="/2019/10/11/pyqt-pit/13.png" alt></p>
<h3 id="相关代码："><a href="#相关代码：" class="headerlink" title="相关代码："></a>相关代码：</h3><p><code>MatplotlibWidget.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> PyQt5</span><br><span class="line"><span class="comment"># 基本控件都在这里面</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QApplication, QMainWindow, QDesktopWidget, QStyleFactory, QWidget,</span><br><span class="line">                                QSizePolicy, QPushButton, QGridLayout)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QPalette, QColor</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> Qt, QTimer</span><br><span class="line"><span class="keyword">from</span> mainwidget <span class="keyword">import</span> Ui_Form</span><br><span class="line"><span class="keyword">from</span> mainwindow <span class="keyword">import</span> Ui_MainWindow</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib.backends.backend_qt5agg <span class="keyword">import</span> FigureCanvasQTAgg <span class="keyword">as</span> FigureCanvas</span><br><span class="line"><span class="keyword">from</span> matplotlib.figure <span class="keyword">import</span> Figure</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.backends.backend_qt5 <span class="keyword">import</span> NavigationToolbar2QT <span class="keyword">as</span> NavigationToolbar</span><br><span class="line"><span class="comment"># 绘图的空白界面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MymplCanvas</span><span class="params">(FigureCanvas)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None, width=<span class="number">5</span>, height=<span class="number">4</span>, dpi=<span class="number">100</span>)</span>:</span></span><br><span class="line">        self.fig = Figure(figsize=(width, height), dpi=dpi)</span><br><span class="line">        self.axes = self.fig.add_subplot(<span class="number">111</span>) <span class="comment"># 多界面绘图</span></span><br><span class="line">        FigureCanvas.__init__(self, self.fig)</span><br><span class="line">        self.setParent(parent)</span><br><span class="line">        FigureCanvas.setSizePolicy(self, </span><br><span class="line">            QSizePolicy.Expanding, QSizePolicy.Expanding</span><br><span class="line">        )</span><br><span class="line">        FigureCanvas.updateGeometry(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_plot</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.axes.clear()</span><br><span class="line">        self.fig.suptitle(<span class="string">"static FIG"</span>)</span><br><span class="line">        t = np.linspace(<span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">        s = np.sin(np.pi * t)</span><br><span class="line">        self.axes.plot(t, s)</span><br><span class="line">        self.axes.grid(<span class="literal">True</span>)</span><br><span class="line">        self.draw()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为何要加参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dynamic_plot</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        timer = QTimer(self)</span><br><span class="line">        timer.timeout.connect(self.update_fig)</span><br><span class="line">        timer.start(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_fig</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.axes.clear()</span><br><span class="line">        self.fig.suptitle(<span class="string">"dynamic FIG"</span>)</span><br><span class="line">        l = np.random.randint(<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>)</span><br><span class="line">        self.axes.plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], l, <span class="string">'r'</span>)</span><br><span class="line">        self.axes.grid(<span class="literal">True</span>)</span><br><span class="line">        self.draw()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现绘图类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MatplotlibWidget</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span></span><br><span class="line">        super(MatplotlibWidget, self).__init__(parent)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 封装绘图类</span></span><br><span class="line">        self.gridLayout = QGridLayout()</span><br><span class="line">        self.mpl = MymplCanvas(self)</span><br><span class="line">        self.mpl_tool = NavigationToolbar(self.mpl, self)</span><br><span class="line">        self.setLayout(self.gridLayout)</span><br><span class="line">        self.gridLayout.addWidget(self.mpl)</span><br><span class="line">        self.gridLayout.addWidget(self.mpl_tool)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.mpl.static_plot()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dynamic</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.mpl.dynamic_plot()</span><br></pre></td></tr></table></figure>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>最终呈现的效果和上面matplotlib绘图一样。这里只给出对比部分的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainWidget</span><span class="params">(QWidget, Ui_Form)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None)</span>:</span></span><br><span class="line">        super(MyMainWidget, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line">        self.setLayout(self.gridLayout)</span><br><span class="line">        <span class="comment"># 提升前</span></span><br><span class="line">        <span class="comment"># self.widget = MatplotlibWidget()</span></span><br><span class="line">        <span class="comment"># self.widget.setVisible(False)</span></span><br><span class="line">        <span class="comment"># self.widget_2 = MatplotlibWidget()</span></span><br><span class="line">        <span class="comment"># self.widget_2.setVisible(False)</span></span><br><span class="line">        <span class="comment"># print(type(self.widget_2))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提升后 不用创建实例，直接拖一拖，pyuic5一下即可</span></span><br><span class="line">        self.gridLayout.addWidget(self.widget)</span><br><span class="line">        self.gridLayout.addWidget(self.widget_2)</span><br><span class="line">        self.pushButton.clicked.connect(self.dynamic)</span><br><span class="line">        self.pushButton_2.clicked.connect(self.static)</span><br></pre></td></tr></table></figure>
<h1 id="Html的动态绘图"><a href="#Html的动态绘图" class="headerlink" title="Html的动态绘图"></a>Html的动态绘图</h1><p>直接引入画好的图片即可，不过图片的后缀是html，使用<code>QWebEngineView</code>加载即可，一个坑是：必须使用绝对路径，相对路径是找不到的。另一个坑是，Qt4 Designer里面没有<code>QWebEngineView</code>这个类，因为这个类是新的，Qt4 Designer 里面只有旧的类<code>QWebView</code>。别问我为什么不用新的，因为linux下还没有Qt5 designer。</p>
<p>旧的类不再维护，新的类使用chromium内核，如果不想写代码实现（布局，定位，大小，这里写代码很麻烦的），那么怎么在Qt4 Designer使用新的类呢？<br>很简单，使用上文说的提升窗口，设置好基类，头文件，名称就很容易在旧界面中使用新的类了。</p>
<p>提升窗口为<code>QWebEngineView</code>， 同样不要写错一个字母。</p>
<p><img data-src="/2019/10/11/pyqt-pit/13.png" alt></p>
<p>Html的绘图技术的强大之处在于炫酷、可交互。而python也不缺少html的绘图库，如<code>plotly</code>（javascript的绘图库，python调用接口），还有pyecharts，也很炫酷。（pyecharts版本做了更新，之前就版本的代码无法运行，我一年前的时候还用的旧版本，新版本的用法参考github）</p>
<p>echarts的（我写的时候服务器维修，无法下载图片，使用的pyecharts的）：<br><a href="https://gallery.echartsjs.com/explore.html#sort=rank~timeframe=all~author=all" target="_blank" rel="noopener">https://gallery.echartsjs.com/explore.html#sort=rank~timeframe=all~author=all</a></p>
<p>pyecharts的：<br><a href="https://github.com/pyecharts/pyecharts/tree/master/example" target="_blank" rel="noopener">https://github.com/pyecharts/pyecharts/tree/master/example</a></p>
<p>我随意挑选了一个，执行后生成本地的html文件（可交互的图形）。</p>
<p>文件结构：</p>
<p><img data-src="/2019/10/11/pyqt-pit/15.png" alt></p>
<p>效果如下所示：</p>
<p><img data-src="/2019/10/11/pyqt-pit/3.gif" alt></p>
<p>代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 继承主窗口 Qmainwindow 和 自己画的界面 Ui_MainWindow</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMainWidget</span><span class="params">(QWidget, Ui_Form)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None)</span>:</span></span><br><span class="line">        super(MyMainWidget, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line">        self.setLayout(self.gridLayout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># html 绘图</span></span><br><span class="line">        self.quit_btn_2.clicked.connect(self.html_plot)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">html_plot</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 必须用绝对路径</span></span><br><span class="line">        url = <span class="string">"/home/lanling/Srcode/python/tools/GUI/practice/Pyecharts/render.html"</span></span><br><span class="line">        <span class="comment"># web_view 是 QWebEngineView 对象的一个实例</span></span><br><span class="line">        self.web_view.load(QUrl.fromLocalFile(url))</span><br></pre></td></tr></table></figure></p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>因为这里给的都是核心代码，没有给全部代码，如果你是在弄不出来，底下留言给下邮箱，我给你代码。</p>
<p>不过还是建议多折腾，多走两步，多研究，伸手党不好。</p>
<p>下一步，自定义信号与槽，类与函数进阶，多线程。</p>
]]></content>
      <tags>
        <tag>GUI</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5高级布局与美化</title>
    <url>/2019/10/19/pyqt-layout/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>还记得我之前说过布局什么的用Qt Designer就行了，还强力推荐过。用了一段时间后，现在想来，Qt Designer就是个垃圾。布局什么的，还是使用代码进行管理吧，其实也不难。而且也不用分两个文件，一个写<code>QWidget</code>，另一个写<code>QMainWindow</code>了。在<code>QMainWindow</code>中创建一个<code>QWidget</code>的实例，并且加入即可。</p>
<blockquote>
<p>本文收录：</p>
<ul>
<li>如何美化布局，使界面更优美</li>
<li>StackLayout布局管理，模仿常用软件功能，使界面更人性化</li>
<li>Qspliter，像一个IDE一个自由拖动</li>
<li>综合实例，实际开发一个软件，用到以上功能。</li>
</ul>
</blockquote>
<p>软件主体功能：调用天气网的API，爬取数据，将数据放到软件的<code>QTableWidget</code>中，预测未来天气，对天气走向进行绘图<code>pyqtgraph</code>。功能简易，但用到了Qt开发中的大部分控件和常见功能。</p>
<a id="more"></a>
<p>软件结果如下图所示：</p>
<p><img data-src="/2019/10/19/pyqt-layout/1.gif" alt></p>
<p>代码如下：</p>
<p><a href="/download/Weather.zip">本文全部代码下载链接，建议在这里下载代码，因为需要辅助文件</a></p>
<p>天气API参考：<br><a href="https://www.sojson.com/api/weather.html" target="_blank" rel="noopener">https://www.sojson.com/api/weather.html</a></p>
<h1 id="高级布局管理"><a href="#高级布局管理" class="headerlink" title="高级布局管理"></a>高级布局管理</h1><p><code>QHBoxLayout</code>, <code>QVBoxLayout</code>, <code>QGridLayout</code>, 这几个基本的布局管理的入门教程如下，也是我目前看到过的最好的：<br><a href="https://www.learnpyqt.com/courses/start/layouts/" target="_blank" rel="noopener">https://www.learnpyqt.com/courses/start/layouts/</a></p>
<p>此外，还有网上盛传的布局美化代码，网上清一色是这个：<br><img data-src="/2019/10/19/pyqt-layout/1.png" alt><br>虽然也不知道谁是原创，只要一搜索：<code>PyQt5美化开发</code>，全部都是这个代码。</p>
<p>我知道写的美它好，但我不想抄袭。不过从以上网址的代码确实学到了点东西，那就是设立总体布局和子布局，子布局管理控件，总体布局管理子布局，这样布置出来的界面是很好看的。</p>
<p>接下来，一点一点的写出来我上面那个天气预报的软件。</p>
<p>需要导入的库如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QApplication, QMainWindow, QDesktopWidget, QStyleFactory, QWidget,</span><br><span class="line">                            QGridLayout, QHeaderView, QTableWidgetItem, QMessageBox, QFileDialog,</span><br><span class="line">                            QSlider, QLabel, QLineEdit, QPushButton, QTableWidget)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QPalette, QColor, QBrush</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> Qt</span><br><span class="line"><span class="keyword">from</span> pyqtgraph <span class="keyword">import</span> GraphicsLayoutWidget</span><br><span class="line"><span class="keyword">import</span> pyqtgraph <span class="keyword">as</span> pg </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pyqtgraph.exporters <span class="keyword">as</span> pe</span><br><span class="line"><span class="keyword">import</span> qdarkstyle, requests, sys, time, random, json, datetime, re</span><br></pre></td></tr></table></figure>
<h2 id="整体布局"><a href="#整体布局" class="headerlink" title="整体布局"></a>整体布局</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainUi</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置绘图背景</span></span><br><span class="line">        pg.setConfigOption(<span class="string">'background'</span>, <span class="string">'#19232D'</span>)</span><br><span class="line">        pg.setConfigOption(<span class="string">'foreground'</span>, <span class="string">'d'</span>)</span><br><span class="line">        pg.setConfigOptions(antialias = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 窗口居中显示</span></span><br><span class="line">        self.center()</span><br><span class="line">  </span><br><span class="line">        self.init_ui()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置城市的编号</span></span><br><span class="line">        self.code = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 多次查询时，查询近5天， 受限于 API 接口提供的数量</span></span><br><span class="line">        self.num = <span class="number">5</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># return request json file</span></span><br><span class="line">        self.rep = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建绘图面板</span></span><br><span class="line">        self.plt = []</span><br><span class="line">        <span class="comment"># 控制绘图的文件名称</span></span><br><span class="line">        self.filename = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 默认的状态栏</span></span><br><span class="line">        <span class="comment"># 可以设置其他按钮点击 参考多行文本显示 然而不行 </span></span><br><span class="line">        self.status = self.statusBar()</span><br><span class="line">        self.status.showMessage(<span class="string">"我在主页面～"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 标题栏</span></span><br><span class="line">        self.setWindowTitle(<span class="string">"天气查询软件"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_ui</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># self.setFixedSize(960,700)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建窗口主部件</span></span><br><span class="line">        self.main_widget = QWidget()  </span><br><span class="line">        <span class="comment"># 创建主部件的网格布局</span></span><br><span class="line">        self.main_layout = QGridLayout()  </span><br><span class="line">        <span class="comment"># 设置窗口主部件布局为网格布局</span></span><br><span class="line">        self.main_widget.setLayout(self.main_layout)  </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建左侧部件</span></span><br><span class="line">        self.left_widget = QWidget()  </span><br><span class="line">        self.left_widget.setObjectName(<span class="string">'left_widget'</span>)</span><br><span class="line">        <span class="comment"># 创建左侧部件的网格布局层</span></span><br><span class="line">        self.left_layout = QGridLayout()  </span><br><span class="line">        <span class="comment"># 设置左侧部件布局为网格</span></span><br><span class="line">        self.left_widget.setLayout(self.left_layout) </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建右侧部件</span></span><br><span class="line">        self.right_widget = QWidget() </span><br><span class="line">        self.right_widget.setObjectName(<span class="string">'right_widget'</span>)</span><br><span class="line">        self.right_layout = QGridLayout()</span><br><span class="line">        self.right_widget.setLayout(self.right_layout) </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 左侧部件在第0行第0列，占12行5列</span></span><br><span class="line">        self.main_layout.addWidget(self.left_widget, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">5</span>) </span><br><span class="line">        <span class="comment"># 右侧部件在第0行第6列，占12行7列</span></span><br><span class="line">        self.main_layout.addWidget(self.right_widget, <span class="number">0</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">7</span>)</span><br><span class="line">        <span class="comment"># 设置窗口主部件</span></span><br><span class="line">        self.setCentralWidget(self.main_widget) </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        获取桌面长宽</span></span><br><span class="line"><span class="string">        获取窗口长宽</span></span><br><span class="line"><span class="string">        移动</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        screen = QDesktopWidget().screenGeometry()</span><br><span class="line">        size = self.geometry()</span><br><span class="line">        self.move((screen.width() - size.width()) / <span class="number">2</span>, (screen.height() - size.height()) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    gui = MainUi()</span><br><span class="line">    gui.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>现在只能执行出一个小窗口来，没关系，继续下面的东西。</p>
<p><img data-src="/2019/10/19/pyqt-layout/2.png" alt></p>
<h2 id="左侧添加控件"><a href="#左侧添加控件" class="headerlink" title="左侧添加控件"></a>左侧添加控件</h2><p>这个时候我们再来添加左边的按钮控件。代码缩进添加至<code>def init_ui(self):</code>中。</p>
<p>提醒：在布局的时候，<code>button</code>在<code>clicked connect</code>的时候找不到逻辑函数报错，加入逻辑函数就不会错了。逻辑函数在之后会加入。所以，现在只看布局，就别点按钮以至于报错了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># function button </span></span><br><span class="line">self.single_query = QPushButton(<span class="string">"查询今日"</span>)</span><br><span class="line">self.single_query.clicked.connect(self.request_weather)</span><br><span class="line">self.single_query.setEnabled(<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># self.single_query.setFixedSize(400, 30)</span></span><br><span class="line">self.btn_tempa = QPushButton(<span class="string">"温度预测(可绘图)"</span>)</span><br><span class="line">self.btn_tempa.clicked.connect(self.request_weather)</span><br><span class="line">self.btn_tempa.setEnabled(<span class="literal">False</span>)</span><br><span class="line">self.btn_wind = QPushButton(<span class="string">"风力预测(可绘图)"</span>)</span><br><span class="line">self.btn_wind.clicked.connect(self.request_weather)</span><br><span class="line">self.btn_wind.setEnabled(<span class="literal">False</span>)</span><br><span class="line">self.btn_stawea = QPushButton(<span class="string">"综合天气预测"</span>)</span><br><span class="line">self.btn_stawea.clicked.connect(self.request_weather)</span><br><span class="line">self.btn_stawea.setEnabled(<span class="literal">False</span>)  </span><br><span class="line">self.left_layout.addWidget(self.single_query, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">self.left_layout.addWidget(self.btn_tempa, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">self.left_layout.addWidget(self.btn_wind, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">self.left_layout.addWidget(self.btn_stawea, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># lineEdit to input a city</span></span><br><span class="line">self.city_line = QLineEdit()</span><br><span class="line">self.city_line.setPlaceholderText(<span class="string">"输入城市回车确认"</span>)</span><br><span class="line">self.city_line.returnPressed.connect(self.match_city)</span><br><span class="line">self.left_layout.addWidget(self.city_line, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># save figure and quit window</span></span><br><span class="line">self.save_fig = QPushButton(<span class="string">"保存绘图"</span>)</span><br><span class="line">self.save_fig.setEnabled(<span class="literal">False</span>)</span><br><span class="line">self.save_fig.clicked.connect(self.fig_save)</span><br><span class="line">self.left_layout.addWidget(self.save_fig, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">self.load = QPushButton(<span class="string">"写日记"</span>)</span><br><span class="line">self.left_layout.addWidget(self.load, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">self.quit_btn = QPushButton(<span class="string">"退出"</span>)</span><br><span class="line">self.quit_btn.clicked.connect(self.quit_act)</span><br><span class="line">self.left_layout.addWidget(self.quit_btn, <span class="number">8</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/10/19/pyqt-layout/4.png" alt></p>
<p>添加完按钮控件后，加入<code>QtableWidget</code>控件用于观察数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tablewidgt to view data</span></span><br><span class="line">self.query_result = QTableWidget()</span><br><span class="line">self.left_layout.addWidget(self.query_result, <span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">self.query_result.verticalHeader().setVisible(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/10/19/pyqt-layout/5.png" alt></p>
<h2 id="右侧窗口布局"><a href="#右侧窗口布局" class="headerlink" title="右侧窗口布局"></a>右侧窗口布局</h2><p>最后完成右侧窗口的布局即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.label = QLabel(<span class="string">"预测天气情况绘图展示区"</span>)</span><br><span class="line">self.right_layout.addWidget(self.label, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">self.plot_weather_wind = GraphicsLayoutWidget()</span><br><span class="line">self.plot_weather_temp = GraphicsLayoutWidget()</span><br><span class="line">self.right_layout.addWidget(self.plot_weather_temp, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>)</span><br><span class="line">self.right_layout.addWidget(self.plot_weather_wind, <span class="number">6</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h2 id="整体美化"><a href="#整体美化" class="headerlink" title="整体美化"></a>整体美化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.setWindowOpacity(<span class="number">0.9</span>) <span class="comment"># 设置窗口透明度</span></span><br><span class="line">self.main_layout.setSpacing(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 美化风格</span></span><br><span class="line">self.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/10/19/pyqt-layout/7.png" alt></p>
<h2 id="逻辑函数"><a href="#逻辑函数" class="headerlink" title="逻辑函数"></a>逻辑函数</h2><p>此外，还需要单独引入<code>import read_citycode, get_weather</code>，这两个单独成两个文件，和主文件放在一起。</p>
<p><code>read_citycode</code>以字典的形式返回每个城市对应的ID。<code>json</code>文件在上面提供的压缩包内，上面提到的天气API网址内也有。</p>
<p>有的逻辑函数需要引入外部文件，否则会报错。因此，简易使用上文提供的代码下载链接，下载代码执行。直接copy这里的代码是不能执行的，因为需要外部文件的支持。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_code</span><span class="params">(filename)</span>:</span></span><br><span class="line">    city_ = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        temp = json.loads(f.read())</span><br><span class="line">        <span class="keyword">for</span> city <span class="keyword">in</span> temp:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'city_code'</span> <span class="keyword">in</span> city:</span><br><span class="line">                key = city[<span class="string">'city_name'</span>]</span><br><span class="line">                value = city[<span class="string">'city_code'</span>]</span><br><span class="line">                city_[key] = value</span><br><span class="line"></span><br><span class="line">    sorted(city_.keys())</span><br><span class="line">    <span class="keyword">return</span> city_</span><br></pre></td></tr></table></figure>
<p><code>get_weather</code>是对网址发送具体城市的天气请求，获取对应的结果，结果形式为<code>json</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rep = requests.get(url)</span><br><span class="line">        rep.encoding = <span class="string">'utf-8'</span></span><br><span class="line">        <span class="keyword">return</span> rep</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"network error"</span>)</span><br></pre></td></tr></table></figure>
<p>以上两份代码分别整理到两个文件中，命名为<code>read_citycode.py</code>和<code>get_weather.py</code>。文件结构图如下：</p>
<p><img data-src="/2019/10/19/pyqt-layout/3.png" alt></p>
<p>布局完成之后，开始增加功能，所以我把所有的逻辑函数放上来。因为之前布局的时候，<code>button</code>在<code>clicked connect</code>的时候找不到逻辑函数报错，加入逻辑函数就不会错了。</p>
<h3 id="退出窗口函数："><a href="#退出窗口函数：" class="headerlink" title="退出窗口函数："></a>退出窗口函数：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 退出按钮</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quit_act</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># sender 是发送信号的对象</span></span><br><span class="line">    sender = self.sender()</span><br><span class="line">    print(sender.text() + <span class="string">'键被按下'</span>)</span><br><span class="line">    qApp = QApplication.instance()</span><br><span class="line">    qApp.quit()</span><br></pre></td></tr></table></figure>
<h3 id="窗口居中函数："><a href="#窗口居中函数：" class="headerlink" title="窗口居中函数："></a>窗口居中函数：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">center</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    获取桌面长宽</span></span><br><span class="line"><span class="string">    获取窗口长宽</span></span><br><span class="line"><span class="string">    移动</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    screen = QDesktopWidget().screenGeometry()</span><br><span class="line">    size = self.geometry()</span><br><span class="line">    self.move((screen.width() - size.width()) / <span class="number">2</span>, (screen.height() - size.height()) / <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="获取城市ID函数"><a href="#获取城市ID函数" class="headerlink" title="获取城市ID函数"></a>获取城市ID函数</h3><p>根据json文件，将获得的输入城市转换为ID，完成进一步查询。因为API的url只能传入ID，不可传入城市名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取 json 文件, 获得城市的code</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match_city</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment">#　输入城市后才能点击绘图</span></span><br><span class="line">    self.btn_tempa.setEnabled(<span class="literal">True</span>)</span><br><span class="line">    self.btn_wind.setEnabled(<span class="literal">True</span>)</span><br><span class="line">    self.single_query.setEnabled(<span class="literal">True</span>)</span><br><span class="line">    self.btn_stawea.setEnabled(<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 在外部json文件中 读取所有城市的 code</span></span><br><span class="line">    city = read_citycode.read_code(<span class="string">"最新_city.json"</span>) </span><br><span class="line">    line_city = self.city_line.text() </span><br><span class="line">    <span class="comment"># code与输入的城市对比, 如果有, 返回code, 如果没有则默认为北京</span></span><br><span class="line">    <span class="keyword">if</span> line_city <span class="keyword">in</span> city.keys():</span><br><span class="line">        self.code = city[line_city]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.code = <span class="string">"101010100"</span></span><br><span class="line">        self.city_line.setText(<span class="string">"北京"</span>)</span><br><span class="line">        Qreply = QMessageBox.about(self, <span class="string">"你犯了一个粗误"</span>, <span class="string">"输入城市无效,请示新输入,否则默认为北京"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="请求天气"><a href="#请求天气" class="headerlink" title="请求天气"></a>请求天气</h3><p>在获得城市的ID之后，便能生成url，请求API返回天气。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照城市的code, 请求一个城市的天气 返回 json 形式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_weather</span><span class="params">(self)</span>:</span></span><br><span class="line">    root_url = <span class="string">"http://t.weather.sojson.com/api/weather/city/"</span></span><br><span class="line">    url = root_url + str(self.code)</span><br><span class="line">    self.rep = get_weather.run(url)</span><br><span class="line">    sender = self.sender()</span><br><span class="line">    <span class="keyword">if</span> sender.text() == <span class="string">"查询今日"</span>:</span><br><span class="line">        self.query(<span class="number">1</span>, <span class="number">5</span>, <span class="string">'温度'</span>, <span class="string">'风向'</span>, <span class="string">'风力'</span>, <span class="string">'PM2.5'</span>, <span class="string">'天气描述'</span>)</span><br><span class="line">    <span class="keyword">if</span> sender.text() == <span class="string">"温度预测(可绘图)"</span>:</span><br><span class="line">        self.btn_tempa.setEnabled(<span class="literal">False</span>)</span><br><span class="line">        self.query(self.num, <span class="number">2</span>, <span class="string">'日期'</span>, <span class="string">'温度'</span>)</span><br><span class="line">    <span class="keyword">if</span> sender.text() == <span class="string">"风力预测(可绘图)"</span>:</span><br><span class="line">        self.btn_wind.setEnabled(<span class="literal">False</span>)</span><br><span class="line">        self.query(self.num, <span class="number">2</span>, <span class="string">'日期'</span>, <span class="string">'风力'</span>)</span><br><span class="line">    <span class="keyword">if</span> sender.text() == <span class="string">"综合天气预测"</span>:</span><br><span class="line">        self.query(self.num, <span class="number">4</span>, <span class="string">'温度'</span>, <span class="string">'风向'</span>, <span class="string">'风力'</span>, <span class="string">'天气描述'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="开始查询"><a href="#开始查询" class="headerlink" title="开始查询"></a>开始查询</h3><p>在得到请求城市的天气后，开始按照查询的需求输出结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询, 可以接受多个参数, 更加灵活的查询</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, row_num, col_num, *args)</span>:</span></span><br><span class="line">    <span class="comment"># true value </span></span><br><span class="line">    tempature = self.rep.json()[<span class="string">'data'</span>][<span class="string">'wendu'</span>]</span><br><span class="line">    wind_power = self.rep.json()[<span class="string">'data'</span>][<span class="string">'forecast'</span>][<span class="number">0</span>][<span class="string">'fl'</span>]</span><br><span class="line">    wind_direction = self.rep.json()[<span class="string">'data'</span>][<span class="string">'forecast'</span>][<span class="number">0</span>][<span class="string">'fx'</span>]</span><br><span class="line">    pm = self.rep.json()[<span class="string">'data'</span>][<span class="string">'pm25'</span>]</span><br><span class="line">    type_ = self.rep.json()[<span class="string">'data'</span>][<span class="string">'forecast'</span>][<span class="number">0</span>][<span class="string">'type'</span>]</span><br><span class="line">    <span class="comment"># forecast value</span></span><br><span class="line">    pre_tempature = []</span><br><span class="line">    pre_wind_power = []</span><br><span class="line">    pre_wind_direction = []</span><br><span class="line">    pre_pm = []</span><br><span class="line">    pre_type_ = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num):</span><br><span class="line">        pre_tempature.append(str(self.rep.json()[<span class="string">'data'</span>][<span class="string">'forecast'</span>][i][<span class="string">'low'</span>]))</span><br><span class="line">        pre_wind_power.append(str(self.rep.json()[<span class="string">'data'</span>][<span class="string">'forecast'</span>][i][<span class="string">'fl'</span>]))</span><br><span class="line">        pre_wind_direction.append(str(self.rep.json()[<span class="string">'data'</span>][<span class="string">'forecast'</span>][i][<span class="string">'fx'</span>]))</span><br><span class="line">        pre_type_.append(str(self.rep.json()[<span class="string">'data'</span>][<span class="string">'forecast'</span>][i][<span class="string">'type'</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置当前查询结果的行列</span></span><br><span class="line">    self.query_result.setRowCount(row_num)  </span><br><span class="line">    <span class="comment"># 否则不会显示</span></span><br><span class="line">    self.query_result.setColumnCount(col_num) </span><br><span class="line">    <span class="comment"># 表头自适应伸缩</span></span><br><span class="line">    self.query_result.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)</span><br><span class="line">    <span class="comment"># 按照 传入的参数设置表头, 因为每次查询的表头都不一样</span></span><br><span class="line">    ls = [i <span class="keyword">for</span> i <span class="keyword">in</span> args]</span><br><span class="line">    self.query_result.setHorizontalHeaderLabels(ls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> col_num &gt; <span class="number">2</span> <span class="keyword">and</span> row_num == <span class="number">1</span>:</span><br><span class="line">        item = QTableWidgetItem(str(tempature) + <span class="string">"℃"</span>)</span><br><span class="line">        <span class="comment"># 设置单元格文本颜色</span></span><br><span class="line">        item.setForeground(QBrush(QColor(<span class="number">144</span>, <span class="number">182</span>, <span class="number">240</span>)))</span><br><span class="line">        self.query_result.setItem(<span class="number">0</span>, <span class="number">0</span>, item)</span><br><span class="line"></span><br><span class="line">        item = QTableWidgetItem(str(wind_direction))</span><br><span class="line">        item.setForeground(QBrush(QColor(<span class="number">144</span>, <span class="number">182</span>, <span class="number">240</span>)))</span><br><span class="line">        self.query_result.setItem(<span class="number">0</span>, <span class="number">1</span>, item)</span><br><span class="line"></span><br><span class="line">        item = QTableWidgetItem(str(wind_power))</span><br><span class="line">        item.setForeground(QBrush(QColor(<span class="number">144</span>, <span class="number">182</span>, <span class="number">240</span>)))</span><br><span class="line">        self.query_result.setItem(<span class="number">0</span>, <span class="number">2</span>, item)</span><br><span class="line"></span><br><span class="line">        item = QTableWidgetItem(str(pm))</span><br><span class="line">        item.setForeground(QBrush(QColor(<span class="number">144</span>, <span class="number">182</span>, <span class="number">240</span>)))</span><br><span class="line">        self.query_result.setItem(<span class="number">0</span>, <span class="number">3</span>, item)</span><br><span class="line">        </span><br><span class="line">        item = QTableWidgetItem(str(type_))</span><br><span class="line">        item.setForeground(QBrush(QColor(<span class="number">144</span>, <span class="number">182</span>, <span class="number">240</span>)))                    </span><br><span class="line">        self.query_result.setItem(<span class="number">0</span>, <span class="number">4</span>, item)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> col_num &gt; <span class="number">2</span> <span class="keyword">and</span> row_num &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">0</span>, self.num):</span><br><span class="line">            item = QTableWidgetItem(<span class="string">"最"</span> + str(pre_tempature[i]))</span><br><span class="line">            <span class="comment"># 设置单元格文本颜色</span></span><br><span class="line">            item.setForeground(QBrush(QColor(<span class="number">144</span>, <span class="number">182</span>, <span class="number">240</span>)))</span><br><span class="line">            self.query_result.setItem(i, <span class="number">0</span>, item)</span><br><span class="line"></span><br><span class="line">            item = QTableWidgetItem(str(pre_wind_direction[i]))</span><br><span class="line">            item.setForeground(QBrush(QColor(<span class="number">144</span>, <span class="number">182</span>, <span class="number">240</span>)))</span><br><span class="line">            self.query_result.setItem(i, <span class="number">1</span>, item)</span><br><span class="line"></span><br><span class="line">            item = QTableWidgetItem(str(pre_wind_power[i]))</span><br><span class="line">            item.setForeground(QBrush(QColor(<span class="number">144</span>, <span class="number">182</span>, <span class="number">240</span>)))</span><br><span class="line">            self.query_result.setItem(i, <span class="number">2</span>, item)</span><br><span class="line">            </span><br><span class="line">            item = QTableWidgetItem(str(pre_type_[i]))</span><br><span class="line">            item.setForeground(QBrush(QColor(<span class="number">144</span>, <span class="number">182</span>, <span class="number">240</span>)))                    </span><br><span class="line">            self.query_result.setItem(i, <span class="number">3</span>, item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> col_num == <span class="number">2</span> <span class="keyword">and</span> row_num &gt; <span class="number">1</span>:</span><br><span class="line">        date = self.get_date(addDays=self.num)</span><br><span class="line">        key = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> date:</span><br><span class="line">            item = QTableWidgetItem(i)</span><br><span class="line">            item.setForeground(QBrush(QColor(<span class="number">144</span>, <span class="number">182</span>, <span class="number">240</span>)))  </span><br><span class="line">            self.query_result.setItem(key, <span class="number">0</span>, item)</span><br><span class="line">            key += <span class="number">1</span>              </span><br><span class="line">        <span class="keyword">if</span> self.query_result.horizontalHeaderItem(<span class="number">1</span>).text() == <span class="string">'温度'</span>:</span><br><span class="line">            key = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> pre_tempature:</span><br><span class="line">                item = QTableWidgetItem(<span class="string">"最"</span> + i)</span><br><span class="line">                item.setForeground(QBrush(QColor(<span class="number">144</span>, <span class="number">182</span>, <span class="number">240</span>)))  </span><br><span class="line">                self.query_result.setItem(key, <span class="number">1</span>, item)</span><br><span class="line">                key += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.query_result.horizontalHeaderItem(<span class="number">1</span>).text() == <span class="string">'风力'</span>:</span><br><span class="line">            key = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> pre_wind_power:</span><br><span class="line">                item = QTableWidgetItem(i)</span><br><span class="line">                item.setForeground(QBrush(QColor(<span class="number">144</span>, <span class="number">182</span>, <span class="number">240</span>)))  </span><br><span class="line">                self.query_result.setItem(key, <span class="number">1</span>, item)</span><br><span class="line">                key += <span class="number">1</span>               </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只有两列的时候才可以绘制图像, </span></span><br><span class="line">    <span class="keyword">if</span> col_num &lt; <span class="number">4</span>:</span><br><span class="line">        ls, y = [], []</span><br><span class="line">        x = np.linspace(<span class="number">1</span>, self.num, self.num)</span><br><span class="line">        <span class="comment"># 将 treeview 里面的结果以数字的形式返回到列表中, 用于绘图</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(self.num):</span><br><span class="line">            str1 = str(self.query_result.item(row, <span class="number">1</span>).text())</span><br><span class="line">            ls.extend(re.findall(<span class="string">r'\d+(?:\.\d+)?'</span>, str1))</span><br><span class="line">        <span class="keyword">if</span> len(ls) == <span class="number">5</span>:</span><br><span class="line">            y = [float(i) <span class="keyword">for</span> i <span class="keyword">in</span> ls]</span><br><span class="line">        <span class="keyword">if</span> len(ls) == <span class="number">10</span>:</span><br><span class="line">            lt = [float(i) <span class="keyword">for</span> i <span class="keyword">in</span> ls]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">0</span>, len(lt), <span class="number">2</span>):</span><br><span class="line">                y.append((lt[i] + lt[i + <span class="number">1</span>]) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> len(ls) == <span class="number">5</span>:</span><br><span class="line">            y = [float(i) <span class="keyword">for</span> i <span class="keyword">in</span> ls]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y = [float(i) <span class="keyword">for</span> i <span class="keyword">in</span> ls[<span class="number">0</span>:<span class="number">5</span>]]</span><br><span class="line">        <span class="comment"># 获取 treeview 的标题, 以得到绘图时的标得</span></span><br><span class="line">        <span class="keyword">if</span> self.query_result.horizontalHeaderItem(<span class="number">1</span>).text() == <span class="string">'温度'</span>:</span><br><span class="line">            title_ = <span class="string">"近期一个月温度变化（预测）"</span></span><br><span class="line">        <span class="keyword">if</span> self.query_result.horizontalHeaderItem(<span class="number">1</span>).text() == <span class="string">'风力'</span>:</span><br><span class="line">            title_ = <span class="string">"近期一个月风力变化（预测）"</span></span><br><span class="line">        <span class="comment"># 绘图时先清空面板 否则会新加一列,效果不好 </span></span><br><span class="line">        <span class="comment"># 且 pyqtgraph 的新加一列有bug, 效果不是很好 下次使用 matplotlib</span></span><br><span class="line">        <span class="keyword">if</span> title_ == <span class="string">"近期一个月风力变化（预测）"</span>:</span><br><span class="line">            self.plot_weather_wind.clear()</span><br><span class="line">            bg1 = pg.BarGraphItem(x=x, height=y, width=<span class="number">0.3</span>, brush=QColor(<span class="number">137</span>, <span class="number">232</span>, <span class="number">165</span>))</span><br><span class="line">            self.plt1 = self.plot_weather_wind.addPlot(title = title_)</span><br><span class="line">            self.plt1.addItem(bg1)</span><br><span class="line">        <span class="keyword">if</span> title_ == <span class="string">"近期一个月温度变化（预测）"</span>:</span><br><span class="line">            self.plot_weather_temp.clear()</span><br><span class="line">            self.plt = self.plot_weather_temp.addPlot(title = title_)</span><br><span class="line">            bg2 = pg.BarGraphItem(x=x, height=y, width=<span class="number">0.3</span>, brush=QColor(<span class="number">32</span>, <span class="number">235</span>, <span class="number">233</span>))</span><br><span class="line">            self.plt.addItem(bg2)</span><br><span class="line">        <span class="comment"># 绘图后才可以保存图片</span></span><br><span class="line">        self.save_fig.setEnabled(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="保存图片与显示日期"><a href="#保存图片与显示日期" class="headerlink" title="保存图片与显示日期"></a>保存图片与显示日期</h3><p>逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存图片成功时的提醒</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pic_messagebox</span><span class="params">(self)</span>:</span></span><br><span class="line">    string = <span class="string">'第'</span> + str(self.filename) + <span class="string">'张图片.png'</span></span><br><span class="line">    Qreply = QMessageBox.information(self, string, <span class="string">"已经成功保存图片到当前目录, 关闭软件后请及时拷贝走"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存图片的设置 pyqtgraph 保存无法设置图片路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fig_save</span><span class="params">(self)</span>:</span></span><br><span class="line">    ex = pe.ImageExporter(self.plt.scene())</span><br><span class="line">    filename = <span class="string">'第'</span> + str(self.filename) + <span class="string">'张图片.png'</span></span><br><span class="line">    self.filename += <span class="number">1</span></span><br><span class="line">    ex.export(fileName = filename)</span><br><span class="line">    self.pic_messagebox()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_date</span><span class="params">(self, dateFormat=<span class="string">"%Y-%m-%d"</span>, addDays=<span class="number">0</span>)</span>:</span></span><br><span class="line">    ls = []</span><br><span class="line">    timeNow = datetime.datetime.now()</span><br><span class="line">    key = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (addDays != <span class="number">0</span>) <span class="keyword">and</span> key &lt; addDays - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range (addDays):</span><br><span class="line">            anotherTime = timeNow + datetime.timedelta(days = key)</span><br><span class="line">            anotherTime.strftime(dateFormat)</span><br><span class="line">            ls.append(str(anotherTime)[<span class="number">0</span>:<span class="number">10</span>])</span><br><span class="line">            key += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        anotherTime = timeNow</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  ls</span><br></pre></td></tr></table></figure>
<p>最终结果如下所示，以上代码见开头下载链接的<code>weather.py</code>文件。</p>
<p><img data-src="/2019/10/19/pyqt-layout/2.gif" alt></p>
<p>以上，我们见识到了层次布局管理后，软件的界面效果是可以接受的。</p>
<p>那么问题来了，我想要像某个IDE或者编辑器，比如Pycharm或者Vscode一样，主界面下的框能拖动自由改变大小。接下来实现这个。</p>
<h1 id="QSplitter-布局"><a href="#QSplitter-布局" class="headerlink" title="QSplitter 布局"></a>QSplitter 布局</h1><p>这个实现比较容易，需要实例化对象，加入frame，在添加至主布局中即可。参考：<br><a href="http://zetcode.com/gui/pyqt5/widgets2/" target="_blank" rel="noopener">http://zetcode.com/gui/pyqt5/widgets2/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QWidget, QHBoxLayout, QFrame, </span><br><span class="line">    QSplitter, QStyleFactory, QApplication)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> Qt</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        </span><br><span class="line">        self.initUI()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span><span class="params">(self)</span>:</span>      </span><br><span class="line"></span><br><span class="line">        hbox = QHBoxLayout(self)</span><br><span class="line"></span><br><span class="line">        topleft = QFrame(self)</span><br><span class="line">        topleft.setFrameShape(QFrame.StyledPanel)</span><br><span class="line"> </span><br><span class="line">        topright = QFrame(self)</span><br><span class="line">        topright.setFrameShape(QFrame.StyledPanel)</span><br><span class="line"></span><br><span class="line">        bottom = QFrame(self)</span><br><span class="line">        bottom.setFrameShape(QFrame.StyledPanel)</span><br><span class="line"></span><br><span class="line">        splitter1 = QSplitter(Qt.Horizontal)</span><br><span class="line">        splitter1.addWidget(topleft)</span><br><span class="line">        splitter1.addWidget(topright)</span><br><span class="line"></span><br><span class="line">        splitter2 = QSplitter(Qt.Vertical)</span><br><span class="line">        splitter2.addWidget(splitter1)</span><br><span class="line">        splitter2.addWidget(bottom)</span><br><span class="line"></span><br><span class="line">        hbox.addWidget(splitter2)</span><br><span class="line">        self.setLayout(hbox)</span><br><span class="line">        </span><br><span class="line">        self.setGeometry(<span class="number">300</span>, <span class="number">300</span>, <span class="number">300</span>, <span class="number">200</span>)</span><br><span class="line">        self.setWindowTitle(<span class="string">'QSplitter'</span>)</span><br><span class="line">        self.show()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    </span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/10/19/pyqt-layout/3.gif" alt></p>
<p>之后，在frame里面添加控件，便可以随心所欲的玩耍。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>代码见本文开头给出的下载链接中的<code>weather1.py</code>。</p>
<p><img data-src="/2019/10/19/pyqt-layout/4.gif" alt></p>
<h1 id="StackLayout布局"><a href="#StackLayout布局" class="headerlink" title="StackLayout布局"></a>StackLayout布局</h1><p>脑部网易云音乐的界面，是不是点击左侧的按钮后，右侧的窗口也会跟着改变。而实现这个技术，就需要StackLayout布局的管理。</p>
<p>一个Demo, <code>stacklayout</code>添加完控件后，会自动设立索引，只需要按照索引访问对应项即可，以下代码实现了最简单的界面切换。</p>
<p><img data-src="/2019/10/19/pyqt-layout/5.gif" alt></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QApplication, QMainWindow, QDesktopWidget, QStyleFactory, QWidget,</span><br><span class="line">                            QGridLayout, QHeaderView, QTableWidgetItem, QMessageBox, QFileDialog,</span><br><span class="line">                            QStackedLayout, QFrame, QLabel, QLineEdit, QPushButton, QTableWidget, QVBoxLayout,</span><br><span class="line">                            QHBoxLayout, QSplitter)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QPalette, QColor, QBrush</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(QWidget)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, color, *args, **kwargs)</span>:</span></span><br><span class="line">        super(Color, self).__init__(*args, **kwargs)</span><br><span class="line">        self.setAutoFillBackground(<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        palette = self.palette()</span><br><span class="line">        palette.setColor(QPalette.Window, QColor(color))</span><br><span class="line">        self.setPalette(palette)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super(MainWindow, self).__init__(*args, **kwargs)</span><br><span class="line">        </span><br><span class="line">        self.setWindowTitle(<span class="string">"My Awesome App"</span>)</span><br><span class="line"></span><br><span class="line">        pagelayout = QVBoxLayout()</span><br><span class="line">        button_layout = QHBoxLayout()</span><br><span class="line">        layout = QStackedLayout()</span><br><span class="line"></span><br><span class="line">        pagelayout.addLayout(button_layout)</span><br><span class="line">        pagelayout.addLayout(layout)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n, color <span class="keyword">in</span> enumerate([<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>,<span class="string">'yellow'</span>]):</span><br><span class="line">            btn = QPushButton( str(color) )</span><br><span class="line">            btn.pressed.connect( <span class="keyword">lambda</span> n=n: layout.setCurrentIndex(n) )</span><br><span class="line">            button_layout.addWidget(btn)</span><br><span class="line">            layout.addWidget(Color(color))</span><br><span class="line"></span><br><span class="line">        widget = QWidget()</span><br><span class="line">        widget.setLayout(pagelayout)</span><br><span class="line">        self.setCentralWidget(widget)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    gui = MainWindow()</span><br><span class="line">    gui.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>那么反过来思考以下，如果一个软件要综合Stacklayout，splitter等，要怎么实现呢。以下给一个例子，综合以上所有的内容，实现更加综合的布局管理。（以下代码copy后可以单独运行，不需要外部文件，也没有在上文的下载链接中给出）</p>
<p>坑 1：整体界面resize前，先要设置splitter的大小，否则无效。<br>坑 2：TreeView和QWebEngineView不能放在同一个layout中，否则QWebEngineView会不显示。具体为啥，我也不知道。</p>
<p><img data-src="/2019/10/19/pyqt-layout/6.gif" alt></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">import</span> sys, hashlib</span><br><span class="line"><span class="keyword">import</span> qdarkstyle</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QApplication, QSplitter, QGridLayout, QHBoxLayout, QPushButton, </span><br><span class="line">                            QTreeWidget, QFrame, QLabel, QHBoxLayout, QMainWindow,</span><br><span class="line">                            QStackedLayout, QWidget, QVBoxLayout, QLineEdit, QRadioButton,</span><br><span class="line">                            QTreeWidgetItem, QDesktopWidget)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> Qt, QUrl</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWebEngineWidgets <span class="keyword">import</span> QWebEngineView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super(MainWindow, self).__init__(*args, **kwargs)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置窗口名称</span></span><br><span class="line">        self.setWindowTitle(<span class="string">"华北理工数学建模协会比赛查询"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置状态栏</span></span><br><span class="line">        self.status = self.statusBar()</span><br><span class="line">        self.status.showMessage(<span class="string">"我在主页面～"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置初始化的窗口大小</span></span><br><span class="line">        self.resize(<span class="number">600</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最开始窗口要居中显示</span></span><br><span class="line">        self.center()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置窗口透明度</span></span><br><span class="line">        self.setWindowOpacity(<span class="number">0.9</span>) <span class="comment"># 设置窗口透明度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置窗口样式</span></span><br><span class="line">        self.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置整体布局 左右显示</span></span><br><span class="line">        pagelayout = QGridLayout()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 左侧开始布局</span></span><br><span class="line">        <span class="comment"># 创建左侧部件</span></span><br><span class="line">        top_left_frame = QFrame(self)  </span><br><span class="line">        top_left_frame.setFrameShape(QFrame.StyledPanel)</span><br><span class="line">        <span class="comment">#　左边按钮为垂直布局</span></span><br><span class="line">        button_layout = QVBoxLayout(top_left_frame)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 登录按钮</span></span><br><span class="line">        verifyid_btn = QPushButton(top_left_frame)</span><br><span class="line">        verifyid_btn.setFixedSize(<span class="number">100</span>, <span class="number">30</span>), verifyid_btn.setText(<span class="string">"确认身份"</span>)</span><br><span class="line">        button_layout.addWidget(verifyid_btn)</span><br><span class="line">        <span class="comment"># 输入用户名　密码按钮</span></span><br><span class="line">        user_btn = QPushButton(top_left_frame)</span><br><span class="line">        user_btn.setFixedSize(<span class="number">100</span>, <span class="number">30</span>), user_btn.setText(<span class="string">"登录"</span>)</span><br><span class="line">        button_layout.addWidget(user_btn)</span><br><span class="line">        <span class="comment"># 申请账号　按钮</span></span><br><span class="line">        registor_btn = QPushButton(top_left_frame)</span><br><span class="line">        registor_btn.setFixedSize(<span class="number">100</span>, <span class="number">30</span>), registor_btn.setText(<span class="string">"申请帐号"</span>)</span><br><span class="line">        button_layout.addWidget(registor_btn)</span><br><span class="line">        <span class="comment"># 录入信息按钮</span></span><br><span class="line">        input_btn = QPushButton(top_left_frame)</span><br><span class="line">        input_btn.setFixedSize(<span class="number">100</span>, <span class="number">30</span>), input_btn.setText(<span class="string">"录入信息"</span>)</span><br><span class="line">        button_layout.addWidget(input_btn) </span><br><span class="line">        <span class="comment"># 查询按钮</span></span><br><span class="line">        query_btn = QPushButton(top_left_frame)</span><br><span class="line">        query_btn.setFixedSize(<span class="number">100</span>, <span class="number">30</span>), query_btn.setText(<span class="string">"查询信息"</span>)</span><br><span class="line">        button_layout.addWidget(query_btn) </span><br><span class="line">        <span class="comment"># 建模之家　按钮</span></span><br><span class="line">        friend_btn = QPushButton(top_left_frame)</span><br><span class="line">        friend_btn.setFixedSize(<span class="number">100</span>, <span class="number">30</span>), friend_btn.setText(<span class="string">"建模园地"</span>)</span><br><span class="line">        button_layout.addWidget(friend_btn) </span><br><span class="line">        <span class="comment"># 退出按钮</span></span><br><span class="line">        quit_btn = QPushButton(top_left_frame)</span><br><span class="line">        quit_btn.setFixedSize(<span class="number">100</span>, <span class="number">30</span>), quit_btn.setText(<span class="string">"退出"</span>)</span><br><span class="line">        button_layout.addWidget(quit_btn)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 左下角为空白 必须要有布局，才可以显示至内容中</span></span><br><span class="line">        bottom_left_frame = QFrame(self)</span><br><span class="line">        blank_label = QLabel(bottom_left_frame)</span><br><span class="line">        blank_layout = QVBoxLayout(bottom_left_frame)</span><br><span class="line">        blank_label.setText(<span class="string">"建模学子的博客"</span>)</span><br><span class="line">        blank_label.setFixedHeight(<span class="number">20</span>)</span><br><span class="line">        blank_layout.addWidget(blank_label)</span><br><span class="line">        self.webEngineView = QWebEngineView(bottom_left_frame)</span><br><span class="line">        self.webEngineView.close()</span><br><span class="line">        blank_layout.addWidget(self.webEngineView)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 右侧开始布局 对应按钮布局</span></span><br><span class="line">        right_frame = QFrame(self)</span><br><span class="line">        right_frame.setFrameShape(QFrame.StyledPanel)</span><br><span class="line">        <span class="comment"># 右边显示为stack布局</span></span><br><span class="line">        self.right_layout = QStackedLayout(right_frame)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确认身份</span></span><br><span class="line">        <span class="comment"># 管理员身份</span></span><br><span class="line">        radio_btn_admin = QRadioButton(right_frame)</span><br><span class="line">        radio_btn_admin.setText(<span class="string">"我是管理员，来输入数据的"</span>)</span><br><span class="line">        <span class="comment"># 游客身份</span></span><br><span class="line">        radio_btn_user = QRadioButton(right_frame)</span><br><span class="line">        radio_btn_user.setText(<span class="string">"我是游客，就来看看"</span>)</span><br><span class="line">        <span class="comment"># 以处置布局管理器管理</span></span><br><span class="line">        radio_btn_layout = QVBoxLayout()  <span class="comment"># 这里没必要在传入frame，已经有布局了</span></span><br><span class="line">        radio_btn_widget = QWidget(right_frame)</span><br><span class="line">        radio_btn_layout.addWidget(radio_btn_admin)</span><br><span class="line">        radio_btn_layout.addWidget(radio_btn_user)</span><br><span class="line">        radio_btn_widget.setLayout(radio_btn_layout)</span><br><span class="line">        self.right_layout.addWidget(radio_btn_widget)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 登录界面</span></span><br><span class="line">        user_line = QLineEdit(right_frame)</span><br><span class="line">        user_line.setPlaceholderText(<span class="string">"输入账号："</span>)</span><br><span class="line">        user_line.setFixedWidth(<span class="number">400</span>)</span><br><span class="line">        password_line = QLineEdit(right_frame)</span><br><span class="line">        password_line.setPlaceholderText(<span class="string">"请输入密码："</span>)</span><br><span class="line">        password_line.setFixedWidth(<span class="number">400</span>)</span><br><span class="line">        login_layout = QVBoxLayout()</span><br><span class="line">        login_widget = QWidget(right_frame)</span><br><span class="line">        login_widget.setLayout(login_layout)</span><br><span class="line">        login_layout.addWidget(user_line)</span><br><span class="line">        login_layout.addWidget(password_line)</span><br><span class="line">        self.right_layout.addWidget(login_widget)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 申请帐号</span></span><br><span class="line">        registor_id = QLineEdit(right_frame)</span><br><span class="line">        registor_id.setPlaceholderText(<span class="string">"请输入新帐号："</span>)</span><br><span class="line">        registor_id.setFixedWidth(<span class="number">400</span>)</span><br><span class="line">        registor_psd = QLineEdit(right_frame)</span><br><span class="line">        registor_psd.setPlaceholderText(<span class="string">"请输入密码："</span>)</span><br><span class="line">        registor_psd.setFixedWidth(<span class="number">400</span>)</span><br><span class="line">        registor_confirm = QLineEdit(right_frame)</span><br><span class="line">        registor_confirm.setPlaceholderText(<span class="string">"请确认密码："</span>)</span><br><span class="line">        registor_confirm.setFixedWidth(<span class="number">400</span>)</span><br><span class="line">        registor_confirm_btn = QPushButton(<span class="string">"确认提交"</span>)</span><br><span class="line">        registor_confirm_btn.setFixedSize(<span class="number">100</span>, <span class="number">30</span>)</span><br><span class="line">        registor_layout = QVBoxLayout()</span><br><span class="line">        register_widget = QWidget(right_frame)</span><br><span class="line">        register_widget.setLayout(registor_layout)</span><br><span class="line">        registor_layout.addWidget(registor_id)</span><br><span class="line">        registor_layout.addWidget(registor_psd)</span><br><span class="line">        registor_layout.addWidget(registor_confirm)</span><br><span class="line">        registor_layout.addWidget(registor_confirm_btn)</span><br><span class="line">        self.right_layout.addWidget(register_widget)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建模园地 使用 TreeView　水平布局　应该读取数据库</span></span><br><span class="line">        self.friend_tree = QTreeWidget(right_frame)</span><br><span class="line">        self.friend_tree.setColumnCount(<span class="number">3</span>)  <span class="comment"># 一列 </span></span><br><span class="line">        self.friend_tree.setHeaderLabels([<span class="string">'年级'</span>, <span class="string">'人员'</span>, <span class="string">'友情链接'</span>]) <span class="comment"># 设置标题</span></span><br><span class="line">        root = QTreeWidgetItem(self.friend_tree) <span class="comment"># 设置根节点</span></span><br><span class="line">        self.friend_tree.setColumnWidth(<span class="number">2</span>, <span class="number">400</span>) <span class="comment"># 设置宽度</span></span><br><span class="line">        <span class="comment"># 设置子节点</span></span><br><span class="line">        root.setText(<span class="number">0</span>, <span class="string">"年级"</span>) <span class="comment"># 0 表示位置</span></span><br><span class="line">        root.setText(<span class="number">1</span>, <span class="string">"姓名"</span>)</span><br><span class="line">        root.setText(<span class="number">2</span>, <span class="string">"网址"</span>)</span><br><span class="line">        child_16 = QTreeWidgetItem(root)</span><br><span class="line">        child_16.setText(<span class="number">0</span>, <span class="string">"16级"</span>)</span><br><span class="line"></span><br><span class="line">        child_ljw = QTreeWidgetItem(child_16)</span><br><span class="line">        child_ljw.setText(<span class="number">1</span>, <span class="string">"刘佳玮"</span>)</span><br><span class="line">        child_ljw.setText(<span class="number">2</span>, <span class="string">"https://muyuuuu.github.io"</span>)</span><br><span class="line"></span><br><span class="line">        child_17 = QTreeWidgetItem(root)</span><br><span class="line">        child_17.setText(<span class="number">0</span>, <span class="string">"17级"</span>)</span><br><span class="line"></span><br><span class="line">        child_lqr = QTreeWidgetItem(child_17)</span><br><span class="line">        child_lqr.setText(<span class="number">1</span>, <span class="string">"李秋然"</span>)</span><br><span class="line">        child_lqr.setText(<span class="number">2</span>, <span class="string">"https://dgimoyeran.github.io"</span>)</span><br><span class="line"></span><br><span class="line">        friend_widget = QWidget(right_frame)</span><br><span class="line">        friend_layout = QVBoxLayout()</span><br><span class="line">        friend_widget.setLayout(friend_layout)</span><br><span class="line">        friend_layout.addWidget(self.friend_tree)</span><br><span class="line">        self.right_layout.addWidget(friend_widget)</span><br><span class="line"></span><br><span class="line">        self.url = <span class="string">''</span>  <span class="comment">#　后期会获取要访问的url</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 三分界面，可拖动</span></span><br><span class="line">        self.splitter1 = QSplitter(Qt.Vertical)</span><br><span class="line">        top_left_frame.setFixedHeight(<span class="number">250</span>)</span><br><span class="line">        self.splitter1.addWidget(top_left_frame)</span><br><span class="line">        self.splitter1.addWidget(bottom_left_frame)</span><br><span class="line"></span><br><span class="line">        self.splitter2 = QSplitter(Qt.Horizontal)</span><br><span class="line">        self.splitter2.addWidget(self.splitter1)</span><br><span class="line">        <span class="comment">#　添加右侧的布局</span></span><br><span class="line">        self.splitter2.addWidget(right_frame)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 窗口部件添加布局</span></span><br><span class="line">        widget = QWidget()</span><br><span class="line">        pagelayout.addWidget(self.splitter2)</span><br><span class="line">        widget.setLayout(pagelayout)</span><br><span class="line">        self.setCentralWidget(widget)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 函数功能区</span></span><br><span class="line">        verifyid_btn.clicked.connect(self.show_verifyid_page)</span><br><span class="line">        user_btn.clicked.connect(self.show_login_page)</span><br><span class="line">        registor_btn.clicked.connect(self.show_register_page)</span><br><span class="line">        friend_btn.clicked.connect(self.show_friend_page)</span><br><span class="line">        self.friend_tree.clicked.connect(self.show_firend_web)</span><br><span class="line">        quit_btn.clicked.connect(self.quit_act)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 刚开始要管理浏览器，否则很丑</span></span><br><span class="line">        self.webEngineView.close()</span><br><span class="line">        <span class="comment"># 注意先后顺序，resize　在前面会使代码无效</span></span><br><span class="line">        self.splitter1.setMinimumWidth(<span class="number">150</span>)</span><br><span class="line">        self.splitter2.setMinimumWidth(<span class="number">250</span>)</span><br><span class="line">        self.resize(<span class="number">600</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># TreeView 的点击事件</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_firend_web</span><span class="params">(self)</span>:</span></span><br><span class="line">        item = self.friend_tree.currentItem()</span><br><span class="line">        <span class="keyword">if</span> item.text(<span class="number">2</span>)[:<span class="number">4</span>] == <span class="string">"http"</span>:</span><br><span class="line">            self.url = item.text(<span class="number">2</span>)</span><br><span class="line">            self.resize(<span class="number">1800</span>, <span class="number">1200</span>)</span><br><span class="line">            self.webEngineView.show()</span><br><span class="line">            self.splitter1.setFixedWidth(<span class="number">1400</span>)</span><br><span class="line">            self.webEngineView.load(QUrl(self.url))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 展示树形结构</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_friend_page</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.init()</span><br><span class="line">        self.center()</span><br><span class="line">        self.right_layout.setCurrentIndex(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示注册帐号的页面</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_register_page</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.init()</span><br><span class="line">        self.center()</span><br><span class="line">        self.right_layout.setCurrentIndex(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示登录的页面</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_login_page</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.init()</span><br><span class="line">        self.center()</span><br><span class="line">        self.right_layout.setCurrentIndex(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># stacklayout 布局，显示验证身份的页面</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_verifyid_page</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.init()</span><br><span class="line">        self.center()</span><br><span class="line">        self.right_layout.setCurrentIndex(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置窗口居中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        获取桌面长宽</span></span><br><span class="line"><span class="string">        获取窗口长宽</span></span><br><span class="line"><span class="string">        移动</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        screen = QDesktopWidget().screenGeometry()</span><br><span class="line">        size = self.geometry()</span><br><span class="line">        self.move((screen.width() - size.width()) / <span class="number">2</span>, (screen.height() - size.height()) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 退出按钮 有信息框的提示　询问是否确认退出</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quit_act</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># sender 是发送信号的对象</span></span><br><span class="line">        sender = self.sender()</span><br><span class="line">        print(sender.text() + <span class="string">'键被按下'</span>)</span><br><span class="line">        qApp = QApplication.instance()</span><br><span class="line">        qApp.quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    w = MainWindow()</span><br><span class="line">    w.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>PyQt5 这方面的文档，国内的资源很少。而且很单一（因为普遍都在抄袭，或者说没有特意的写出来）。</p>
<p>出了问题去StackOverflow上或者谷歌一下，能搜出来很多、很有效的解决方案，至少国内的搜索引擎还做不到能快速的搜索出有效的科技文档来。</p>
]]></content>
      <tags>
        <tag>GUI</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5 显示超清高分辨率图片</title>
    <url>/2021/04/10/pyqt5-load-huge-image/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>昨天写程序遇到一个问题，<code>pyqt5</code> 加载常规的图片完全可以显示。可当加载超清的高分辨率图片时，只能显示一个小角落。可我就想把一张 <code>3840x2160</code> 的图片加载到一个 <code>800x600</code> 的标签里该怎么办呢，如何自适应放缩尺寸？国内社区众所周知大多是抄袭，没什么解决方案，<del>就像本文刚发布两天就被抄走了</del>；外网站搜了一下也没找到现成的解决方案，我知道又到了我开坑的时候了。<del>博客能火全靠pyqt5，以后请叫我pyqt5之父（不是</del></p>
<a id="more"></a>
<h1 id="常规加载"><a href="#常规加载" class="headerlink" title="常规加载"></a>常规加载</h1><p>先来看一下，如何借助 <code>QLabel</code> 和 <code>QFileDialog</code> 加载低分辨率的图片，这时候时能正常显示的。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QMainWindow, QWidget, QHBoxLayout, QApplication, </span><br><span class="line">                             QPushButton, QLabel, QFileDialog, QVBoxLayout, </span><br><span class="line">                             QLineEdit)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QPixmap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mainwindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(mainwindow, self).__init__()</span><br><span class="line"></span><br><span class="line">        layout = QVBoxLayout()</span><br><span class="line">        w = QWidget()</span><br><span class="line">        w.setLayout(layout)</span><br><span class="line">        self.setCentralWidget(w)</span><br><span class="line"></span><br><span class="line">        self.image_label = QLabel()</span><br><span class="line">        self.image_label.setFixedSize(<span class="number">800</span>, <span class="number">500</span>)</span><br><span class="line">        layout.addWidget(self.image_label)</span><br><span class="line"></span><br><span class="line">        tmp_layout = QHBoxLayout()</span><br><span class="line">        btn = QPushButton(<span class="string">"选择图片路径"</span>)</span><br><span class="line">        tmp_layout.addWidget(btn)</span><br><span class="line">        btn.clicked.connect(self.load_image)</span><br><span class="line"></span><br><span class="line">        self.result = QLineEdit()</span><br><span class="line">        self.result.setPlaceholderText(<span class="string">"车牌展示"</span>)</span><br><span class="line">        self.result.setReadOnly(<span class="literal">True</span>)</span><br><span class="line">        tmp_layout.addWidget(self.result)</span><br><span class="line">        layout.addLayout(tmp_layout)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_image</span><span class="params">(self)</span>:</span></span><br><span class="line">        fname, _ = QFileDialog.getOpenFileName(self, <span class="string">'Open File'</span>, </span><br><span class="line">                    <span class="string">'C://'</span>, <span class="string">"Image files (*.jpg *.png)"</span>)</span><br><span class="line">        <span class="keyword">if</span> fname <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            pixmap = QPixmap(fname)</span><br><span class="line">            self.image_label.setPixmap(pixmap)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QApplication([])</span><br><span class="line">    m = mainwindow()</span><br><span class="line">    m.show()</span><br><span class="line">    sys.exit(app.exec())</span><br></pre></td></tr></table></figure>
<p>上述代码中，点击『选择图片路径』按钮就会调用文件对话框，选择图片后就会打开。步骤为：</p>
<ol>
<li>第一步，<code>QFileDialog</code> 选择文件路径</li>
<li>第二步，将文件路径传入 <code>QPixmap</code> 类，通过重载构造一个对象，文档原话：Constructs a pixmap from the file with the given fileName. If the file does not exist or is of an unknown format, the pixmap becomes a null pixmap.</li>
<li>第三步，将 <code>QPixmap</code> 对象传给标签的 <code>setPixmap</code> 方法，就完成了图片的显示。</li>
</ol>
<p>对于低分辨率图片，加载是没问题的：</p>
<p><img data-src="https://z3.ax1x.com/2021/04/10/calOyQ.png" alt></p>
<p>但高分辨率的图片，只能显示一个角落，也就是蓝色框那一部分：</p>
<p><img data-src="https://z3.ax1x.com/2021/04/10/ca81Zd.png" alt></p>
<p>如何解决呢？既然国内外都没有现成的解决方案，只能掏出万能的官方文档了。</p>
<h1 id="QImageReader-类"><a href="#QImageReader-类" class="headerlink" title="QImageReader 类"></a>QImageReader 类</h1><p>需要注意的是官方文档的语言是 <code>C++</code>，<del>还好我会C++。</del>打开文档，映入眼帘的就四句话：</p>
<ul>
<li><code>QImageReader reader(&quot;large.jpeg&quot;);</code> 读取图片</li>
<li><code>reader.size();</code> 图片尺寸</li>
<li><code>reader.setClipRect(myRect);</code> 图片裁剪</li>
<li><code>reader.setScaledSize(mySize);</code> 设置图片尺寸，文档原话：Another common function is to show a smaller version of the image. Loading a very large image and then scaling it down to the approriate size can be a very memory consuming operation. By calling the QImageReader::setScaledSize function, you can set the size that you want your resulting image to be.</li>
</ul>
<p>剩下的任务就很简单了，读图片，设置尺寸，显示。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QMainWindow, QWidget, QHBoxLayout, QApplication, </span><br><span class="line">                             QPushButton, QLabel, QFileDialog, QVBoxLayout, </span><br><span class="line">                             QLineEdit)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QPixmap, QFont</span><br><span class="line"><span class="keyword">from</span> PyQt5.Qt <span class="keyword">import</span> QSize, QImageReader</span><br><span class="line"><span class="keyword">import</span> qdarkstyle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mainwindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(mainwindow, self).__init__()</span><br><span class="line"></span><br><span class="line">        layout = QVBoxLayout()</span><br><span class="line">        w = QWidget()</span><br><span class="line">        w.setLayout(layout)</span><br><span class="line">        self.setCentralWidget(w)</span><br><span class="line"></span><br><span class="line">        self.image_label = QLabel()</span><br><span class="line">        self.image_label.setFixedSize(<span class="number">800</span>, <span class="number">500</span>)</span><br><span class="line">        layout.addWidget(self.image_label)</span><br><span class="line"></span><br><span class="line">        tmp_layout = QHBoxLayout()</span><br><span class="line">        btn = QPushButton(<span class="string">"选择图片路径"</span>)</span><br><span class="line">        tmp_layout.addWidget(btn)</span><br><span class="line">        btn.clicked.connect(self.load_image)</span><br><span class="line"></span><br><span class="line">        self.result = QLineEdit()</span><br><span class="line">        self.result.setPlaceholderText(<span class="string">"车牌展示"</span>)</span><br><span class="line">        self.result.setReadOnly(<span class="literal">True</span>)</span><br><span class="line">        tmp_layout.addWidget(self.result)</span><br><span class="line">        layout.addLayout(tmp_layout)</span><br><span class="line"></span><br><span class="line">        self.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_image</span><span class="params">(self)</span>:</span></span><br><span class="line">        fname, _ = QFileDialog.getOpenFileName(self, <span class="string">'Open File'</span>, </span><br><span class="line">                   <span class="string">'C://'</span>, <span class="string">"Image files (*.jpg *.png)"</span>)</span><br><span class="line">        <span class="keyword">if</span> fname <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 还需要对图片进行重新调整大小</span></span><br><span class="line">            img = QImageReader(fname)</span><br><span class="line">            scale = <span class="number">800</span> / img.size().width()</span><br><span class="line">            height = int(img.size().height() * scale)</span><br><span class="line">            img.setScaledSize(QSize(<span class="number">800</span>, height))</span><br><span class="line">            img = img.read()</span><br><span class="line">            <span class="comment"># 打开设置好的图片</span></span><br><span class="line">            pixmap = QPixmap(img)</span><br><span class="line">            self.image_label.setPixmap(pixmap)</span><br><span class="line">            self.result.setText(<span class="string">"车牌号放到这里"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QApplication([])</span><br><span class="line">    font = QFont()</span><br><span class="line">    font.setFamily(<span class="string">"SimHei"</span>)</span><br><span class="line">    font.setPointSize(<span class="number">14</span>)</span><br><span class="line">    app.setFont(font)</span><br><span class="line">    m = mainwindow()</span><br><span class="line">    m.show()</span><br><span class="line">    sys.exit(app.exec())</span><br></pre></td></tr></table></figure>
<p>考虑到可能会加载超清图像，为了方便对图片进行控制，不要采用 <code>QImage</code> 或 <code>QPixmap</code>，而是使用 <code>QImageReader</code></p>
<p>代码解析：</p>
<ol>
<li>创建 <code>QImageReader</code> 对象，方便对图片进行更多的操作</li>
<li>自适应伸缩，将宽度限定为 800，自适应计算高度应该是多少，而后设置要缩放的大小</li>
<li>将设置好的图像读入为 <code>QImage</code> 类型，而后程序里将其转为 <code>QPixmap</code> 类型</li>
<li>正常方法设置即可，超清图像完美被加载</li>
</ol>
<p><img data-src="https://z3.ax1x.com/2021/04/10/caJGgf.png" alt></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://wiki.qt.io/Loading_Large_Images" target="_blank" rel="noopener">QImageReader官方文档</a></li>
</ol>
]]></content>
      <tags>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt 打造的图像预览软件</title>
    <url>/2022/02/12/pyqt5-view-image/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>寒假某天下午的突发奇想，想实现一款图像预览软件。大概思路是：在软件的左侧点击图片，软件的右侧就能实时预览图片，因为感觉这个功能有一定的应用场景，所以实现了一下。</p>
<p><img data-src="https://s4.ax1x.com/2022/02/12/H0ywWQ.png" alt></p>
<a id="more"></a>
<p>简单说一下设计思路吧，代码没啥难度：</p>
<ol>
<li>使用 GridLayout 手动布局提升美感，左侧是文件列表，右侧是图片预览</li>
<li>当从左侧文件列表点击文件时，判断点击的文件是否为图像类型，如果是，右侧显示图像。关于如何显示高清图像，可以参考我之前的<a href="https://muyuuuu.github.io/2021/04/10/pyqt5-load-huge-image/">博客</a></li>
<li>文件列表使用 <code>QTreeView</code> 和 <code>QListView</code> 实现，<code>QTreeView</code> 负责显示文件夹层级关系，<code>QListView</code> 负责显示文件。两者都挂载文件模型。</li>
<li><del>Qt 的使用就是学会基础操作后大量翻阅官方库的过程。</del></li>
</ol>
<p><img data-src="https://s4.ax1x.com/2022/02/12/H0sJ5F.gif" alt></p>
<p>可以看到里面还有加载模型、识别等按钮，也能猜出来这是深度学习应用的软件。</p>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QMainWindow, QWidget, QGridLayout, QApplication,</span><br><span class="line">                             QPushButton, QStatusBar, QProgressBar, QLabel,</span><br><span class="line">                             QTreeView, QListView, QFileSystemModel, QLineEdit,</span><br><span class="line">                             QInputDialog, QFileDialog, QTextEdit, QMessageBox)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QDir</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QPixmap, QFont</span><br><span class="line"><span class="keyword">from</span> PyQt5.Qt <span class="keyword">import</span> QSize, QImageReader</span><br><span class="line"><span class="keyword">import</span> qdarkstyle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondWindow</span><span class="params">(QWidget)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        super(SecondWindow, self).__init__()</span><br><span class="line">        self.resize(<span class="number">400</span>, <span class="number">400</span>)</span><br><span class="line">        self.move(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">        layout = QGridLayout()</span><br><span class="line">        self.info = QTextEdit()</span><br><span class="line">        layout.addWidget(self.info)</span><br><span class="line">        self.info.setText(msg)</span><br><span class="line">        self.setLayout(layout)</span><br><span class="line">        self.setWindowTitle(<span class="string">'详细信息'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mainwindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(mainwindow, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.setWindowTitle(<span class="string">"天然草地类型识别系统"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示正在加载</span></span><br><span class="line">        self.status = QStatusBar()</span><br><span class="line">        self.status.setStyleSheet(<span class="string">'QStatusBar::item &#123;border: none;&#125;'</span>)</span><br><span class="line">        self.setStatusBar(self.status)</span><br><span class="line"></span><br><span class="line">        self.progressBar = QProgressBar()</span><br><span class="line">        self.label = QLabel()</span><br><span class="line">        self.label.setText(<span class="string">"加载中，请稍后... "</span>)</span><br><span class="line">        self.status.addPermanentWidget(self.label, stretch=<span class="number">2</span>)</span><br><span class="line">        self.status.addPermanentWidget(self.progressBar, stretch=<span class="number">4</span>)</span><br><span class="line">        self.progressBar.setRange(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">        self.progressBar.setMinimum(<span class="number">0</span>)</span><br><span class="line">        self.progressBar.setMaximum(<span class="number">0</span>)</span><br><span class="line">        self.statusBar().setVisible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        self.setMinimumSize(<span class="number">1500</span>, <span class="number">720</span>)</span><br><span class="line"></span><br><span class="line">        layout = QGridLayout()</span><br><span class="line">        w = QWidget()</span><br><span class="line">        w.setLayout(layout)</span><br><span class="line">        self.setCentralWidget(w)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 文件树</span></span><br><span class="line">        self.treeview = QTreeView()</span><br><span class="line">        self.listview = QListView()</span><br><span class="line">        layout.addWidget(self.treeview, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>)</span><br><span class="line">        layout.addWidget(self.listview, <span class="number">0</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        path = QDir.rootPath()</span><br><span class="line"></span><br><span class="line">        self.dirModel = QFileSystemModel()</span><br><span class="line">        self.dirModel.setRootPath(QDir.rootPath())</span><br><span class="line">        self.dirModel.setFilter(QDir.NoDotAndDotDot | QDir.AllDirs)</span><br><span class="line"></span><br><span class="line">        self.fileModel = QFileSystemModel()</span><br><span class="line">        self.fileModel.setFilter(QDir.NoDotAndDotDot | QDir.Files)</span><br><span class="line"></span><br><span class="line">        self.treeview.setModel(self.dirModel)</span><br><span class="line">        self.listview.setModel(self.fileModel)</span><br><span class="line"></span><br><span class="line">        self.treeview.setRootIndex(self.dirModel.index(path))</span><br><span class="line">        self.listview.setRootIndex(self.fileModel.index(path))</span><br><span class="line"></span><br><span class="line">        self.treeview.clicked.connect(self.on_clicked)</span><br><span class="line">        self.listview.clicked.connect(self.run_model)</span><br><span class="line"></span><br><span class="line">        self.treeview.hideColumn(<span class="number">1</span>)</span><br><span class="line">        self.treeview.hideColumn(<span class="number">2</span>)</span><br><span class="line">        self.treeview.hideColumn(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示图片</span></span><br><span class="line">        self.image_label = QLabel()</span><br><span class="line">        self.image_label.setMinimumSize(<span class="number">800</span>, <span class="number">700</span>)</span><br><span class="line">        layout.addWidget(self.image_label, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加载模型</span></span><br><span class="line">        btn = QPushButton(<span class="string">"加载模型"</span>)</span><br><span class="line">        layout.addWidget(btn, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        btn.clicked.connect(self.load_model)</span><br><span class="line"></span><br><span class="line">        more_btn = QPushButton(<span class="string">"详细信息"</span>)</span><br><span class="line">        layout.addWidget(more_btn, <span class="number">7</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        more_btn.clicked.connect(self.show_info)</span><br><span class="line"></span><br><span class="line">        reco_btn = QPushButton(<span class="string">"识别"</span>)</span><br><span class="line">        layout.addWidget(reco_btn, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        reco_btn.clicked.connect(self.predict)</span><br><span class="line"></span><br><span class="line">        clear_btn = QPushButton(<span class="string">"清空"</span>)</span><br><span class="line">        layout.addWidget(clear_btn, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        clear_btn.clicked.connect(self.clear)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预测结果</span></span><br><span class="line">        self.res = QLineEdit()</span><br><span class="line">        self.res.setReadOnly(<span class="literal">True</span>)</span><br><span class="line">        layout.addWidget(self.res, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        self.model = <span class="literal">None</span></span><br><span class="line">        self.fname = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res.clear()</span><br><span class="line">        self.image_label.setVisible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.fname <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 调用你的图片信息代码，我这里没对应的 excel</span></span><br><span class="line">            <span class="comment"># 详细信息赋值给 msg 即可</span></span><br><span class="line">            msg = <span class="string">"详细信息"</span></span><br><span class="line">            self.child = SecondWindow(msg)</span><br><span class="line">            self.child.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当选中图片的时候，直接进行预测</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_model</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.image_label.setVisible(<span class="literal">True</span>)</span><br><span class="line">        idx = self.listview.currentIndex()</span><br><span class="line">        fname = self.fileModel.filePath(idx)</span><br><span class="line">        img_type = fname.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 判断下是不是图片</span></span><br><span class="line">        <span class="keyword">if</span> img_type <span class="keyword">in</span> [<span class="string">"png"</span>, <span class="string">"jpg"</span>]:</span><br><span class="line">            img = QImageReader(fname)</span><br><span class="line">            scale = self.image_label.width() / img.size().width()</span><br><span class="line">            height = int(img.size().height() * scale)</span><br><span class="line">            img.setScaledSize(QSize(self.image_label.width(), height))</span><br><span class="line">            img = img.read()</span><br><span class="line">            pixmap = QPixmap(img)</span><br><span class="line">            self.image_label.setPixmap(pixmap)</span><br><span class="line">            self.fname = fname</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试代码放在这里</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.fname <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># y = self.model(x)</span></span><br><span class="line">            <span class="comment"># y = str(y)</span></span><br><span class="line">            self.res.setText(<span class="string">"cls 1: 0.9, cls 2: 0.8, cls 3: 0.9"</span>)</span><br><span class="line">        <span class="comment"># res = self.model(img)</span></span><br><span class="line">        <span class="comment"># self.res.setText(res)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msgBox = QMessageBox()</span><br><span class="line">            msgBox.setIcon(QMessageBox.Warning)</span><br><span class="line">            msgBox.warning(self, <span class="string">"警告"</span>, <span class="string">"请选择图片后再预测"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_clicked</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        path = self.dirModel.fileInfo(index).absoluteFilePath()</span><br><span class="line">        self.listview.setRootIndex(self.fileModel.setRootPath(path))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载模型的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_model</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.status.setVisible(<span class="literal">True</span>)</span><br><span class="line">        file_filter = <span class="string">'PKL File (*.pt *.pth *.pkl)'</span></span><br><span class="line">        response = QFileDialog.getOpenFileName(</span><br><span class="line">            parent=self,</span><br><span class="line">            caption=<span class="string">'Select a data file'</span>,</span><br><span class="line">            directory=os.getcwd(),</span><br><span class="line">            filter=file_filter,</span><br><span class="line">        )</span><br><span class="line">        pth_file, _ = response</span><br><span class="line">        <span class="comment"># torch load model</span></span><br><span class="line">        <span class="comment"># self.model.load_state_dict(torch.load(pth_file))</span></span><br><span class="line">        self.status.setVisible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QApplication([])</span><br><span class="line">    dark_stylesheet = qdarkstyle.load_stylesheet_pyqt5()</span><br><span class="line">    <span class="comment"># 如果想美化就取消注释</span></span><br><span class="line">    <span class="comment"># app.setStyleSheet(dark_stylesheet)</span></span><br><span class="line">    m = mainwindow()</span><br><span class="line">    m.show()</span><br><span class="line">    sys.exit(app.exec())</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>python黑魔法</title>
    <url>/2019/02/05/python-black-magic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>让python<del>更</del><del>酷</del>更实用一些~</p>
<p>记录一些黑魔法，比如正则表达式，或者各种库的应用，虽然感觉日后可能并无卵用。</p>
<p>暂时收录：</p>
<ul>
<li>pandas 对多属性约束下的数据筛选(比如接收到一份excel数据后对数据的快速清洗)。</li>
<li>numpy的广播机制。</li>
<li>pandas 将数据写入同一个excel文件的多个sheet表。</li>
<li>numpy存取csv文件</li>
<li>在需要多次写入csv文件的情况下，如何保持不会产生空行</li>
</ul>
<p>停止更新，并无卵用。（日后这里会记录numpy和pandas，等我用熟了再说）</p>
<a id="more"></a>
<p>如果对本文有疑问或者想找男朋友，可以联系我，<a href="https://muyuuuu.github.io/about/">点击此处有我联系方式</a>。</p>
<hr>
<h2 id="pandas数据清洗"><a href="#pandas数据清洗" class="headerlink" title="pandas数据清洗"></a>pandas数据清洗</h2><p>同时筛选属性<code>COUNTY</code>取值为<code>BLAND</code>和属性<code>State</code>取值为<code>VA</code>的数据，并且将筛选的多组数据写入同一个excel文件的不同sheet表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_excel(<span class="string">'MCM_NFLIS_Data.xlsx'</span>, <span class="string">'Data'</span>)</span><br><span class="line">VA = df.loc[df[<span class="string">'State'</span>] == <span class="string">'VA'</span>]</span><br><span class="line">OH = df.loc[df[<span class="string">'State'</span>] == <span class="string">'OH'</span>]</span><br><span class="line"><span class="comment"># 同时写入一个excel不同的sheet</span></span><br><span class="line">writer=pd.ExcelWriter(<span class="string">'output.xlsx'</span>)</span><br><span class="line">VA.to_excel(writer, sheet_name = <span class="string">'VA'</span>)</span><br><span class="line">OH.to_excel(writer, sheet_name = <span class="string">'OH'</span>)</span><br><span class="line">writer.save()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时筛选</span></span><br><span class="line">BLAND = df.loc[(df[<span class="string">'COUNTY'</span>] == <span class="string">'BLAND'</span>) &amp; (df[<span class="string">'State'</span>] == <span class="string">'VA'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转成numpy快速开车</span></span><br><span class="line">array = VA.values</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="numpy广播机制"><a href="#numpy广播机制" class="headerlink" title="numpy广播机制"></a>numpy广播机制</h2><p>在numpy广播机制的作用下，应该避免去写<code>for</code>循环的程序，显得不够<code>pythonic</code>而且浪费时间和计算力。</p>
<p>可以发现，在对矩阵和一个元素求和时，numpy会对一个元素进行复制填充，使得一个元素的维度和矩阵维度相同，下面的例子中<code>a+10</code>中的<code>10</code>被填充为<code>[[10,10,10]]</code>。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line">print(a)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]]</span><br><span class="line">print(a+<span class="number">10</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[[<span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]]</span><br><span class="line">print(a.shape)</span><br><span class="line">&gt;&gt;&gt;(<span class="number">1</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>同时也要避免矩阵维度不严格带来的BUG：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([1, 2, 3]) #不推荐</span><br><span class="line">b = np.array([[1, 2, 3]])</span><br><span class="line">print(a.shape, b.shape)</span><br><span class="line">&gt;&gt;&gt;(3,) (1, 3)</span><br></pre></td></tr></table></figure></p>
<hr>
<p><span id="inline-green">广播机制的推广：</span></p>
<p>矩阵每一个元素除以对应列元素的和。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">test = np.random.randint(<span class="number">0</span>, <span class="number">100</span>, size=(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[[<span class="number">91</span> <span class="number">25</span> <span class="number">41</span> <span class="number">37</span>]</span><br><span class="line"> [<span class="number">82</span> <span class="number">72</span> <span class="number">86</span> <span class="number">25</span>]</span><br><span class="line"> [<span class="number">29</span> <span class="number">38</span> <span class="number">31</span> <span class="number">22</span>]</span><br><span class="line"> [<span class="number">74</span> <span class="number">88</span> <span class="number">54</span> <span class="number">44</span>]]</span><br><span class="line"></span><br><span class="line">test = test / test.sum(axis=<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">[[<span class="number">0.32971014</span> <span class="number">0.11210762</span> <span class="number">0.19339623</span> <span class="number">0.2890625</span> ]</span><br><span class="line"> [<span class="number">0.29710145</span> <span class="number">0.32286996</span> <span class="number">0.40566038</span> <span class="number">0.1953125</span> ]</span><br><span class="line"> [<span class="number">0.10507246</span> <span class="number">0.17040359</span> <span class="number">0.14622642</span> <span class="number">0.171875</span>  ]</span><br><span class="line"> [<span class="number">0.26811594</span> <span class="number">0.39461883</span> <span class="number">0.25471698</span> <span class="number">0.34375</span>   ]]</span><br></pre></td></tr></table></figure></p>
<h2 id="广播机制对数据归一化"><a href="#广播机制对数据归一化" class="headerlink" title="广播机制对数据归一化"></a>广播机制对数据归一化</h2><p>属性缩放到一个指定的最大和最小值（通常是1-0）之间，常用的最小最大规范化方法：<br>\begin{equation}<br>(x-min(x))/(max(x)-min(x))<br>\end{equation}<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">print(test)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">test_nor = (test - test.min(axis=<span class="number">0</span>))/ (test.max(axis=<span class="number">0</span>) - test.min(axis=<span class="number">0</span>))</span><br><span class="line">print(test_nor)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[[<span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span> ]</span><br><span class="line"> [<span class="number">0.5</span> <span class="number">0.5</span> <span class="number">0.5</span>]</span><br><span class="line"> [<span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span> ]]</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="numpy数组复制并填充"><a href="#numpy数组复制并填充" class="headerlink" title="numpy数组复制并填充"></a>numpy数组复制并填充</h2><p><span id="inline-green">实现功能：</span></p>
<p>将一个$n\times n$的矩阵复制3次，使维度变为$n \times n \times 3$。推广：将$x$个$n\times n$的矩阵复制3次，即维度为$x \times n \times n$的矩阵变为$x \times n \times n \times 3$的矩阵。</p>
<p>背景：将单通道的gray图像填充为RGB图像，R,G,B的取值为原始的gray颜色值，共对$x$个图像进行这样的处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gray2rgb</span><span class="params">(array)</span>:</span></span><br><span class="line">    number = array.shape[<span class="number">0</span>]</span><br><span class="line">    height = array.shape[<span class="number">1</span>]</span><br><span class="line">    width = array.shape[<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    array = np.repeat(array, <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    array = array.reshape(number, height, width, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">x_train = gray2rgb(x_train)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="numpy实现存取csv文件"><a href="#numpy实现存取csv文件" class="headerlink" title="numpy实现存取csv文件"></a>numpy实现存取csv文件</h2><p>读入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = numpy.loadtxt(open(<span class="string">"1.csv"</span>,<span class="string">"rb"</span>),delimiter=<span class="string">","</span>,skiprows=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>写出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.savetxt(<span class="string">'2.csv'</span>, array, delimiter = <span class="string">','</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="多次写入csv文件不产生空行"><a href="#多次写入csv文件不产生空行" class="headerlink" title="多次写入csv文件不产生空行"></a>多次写入csv文件不产生空行</h2><p>重点是加入<code>newline=&#39;&#39;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"filename.csv"</span>, <span class="string">"a+"</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile: </span><br><span class="line">    writer = csv.writer(csvfile)</span><br><span class="line">    writer.writerow(array, delimiter=<span class="string">','</span> )</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python批量生成和调用变量</title>
    <url>/2020/01/07/python-create-and-call-variables-batches/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这几天写代码中遇到的一个常见问题，在<code>Python</code>中如何批量的生成一些变量，如生成变量<code>X1, X2, X3</code>，并在后续的方法中调用，完成赋值、取值等操作。这个问题也算是常见的吧，之前遇到过，也不了了之了。而这次遇到了同样的问题，虽然是创建三个变量数量较少，但从代码维护和易读性的角度考虑，需要使用一些恰当的手段，来避免重复写三次同样代码带来的弊端。一百次，一万次？总不能复制这么多次吧。（为何不复制？详情参考软件工程中的软件维护）。</p>
<p>因此有必要养成良好的习惯，而不是复制三次同样的代码。</p>
<a id="more"></a>
<h1 id="使用Locals-方法"><a href="#使用Locals-方法" class="headerlink" title="使用Locals()方法"></a>使用Locals()方法</h1><p>在普通函数内的确可以使用，但在类中不行。这个问题也困扰了我很久，所以，建议在编写类时需要批量创建和调用变量时，不建议使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    locals() [<span class="string">'x'</span> + str(i)] = i</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    a = locals() [<span class="string">'x'</span> + str(j)]</span><br><span class="line">    print(a)</span><br><span class="line">print(x0)</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>此时在普通函数中一切正常，但在编写的类中无法运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            locals() [<span class="string">'self.x'</span> + str(i)] = i</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            a = locals() [<span class="string">'self.x'</span> + str(i)]</span><br><span class="line">            print(a)</span><br><span class="line"></span><br><span class="line">a = test()</span><br><span class="line">a.run()</span><br></pre></td></tr></table></figure>
<p>报错信息如下，并没有找到这个变量。而我在编写<code>GUI</code>时，类是常用的工具，所以在类中调用这个方法时，导致了错误。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">KeyError: <span class="string">'self.x0'</span></span><br></pre></td></tr></table></figure>
<p>所以我找到了一种更加优雅的方式，使用字典。</p>
<h1 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h1><p>字典键值对的形式，尤其是键可设置为字符串，对此类问题可以提供良好的解决方案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            self.d[<span class="string">'x'</span> + str(i)] = i</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            a = self.d[<span class="string">'x'</span> + str(i)]</span><br><span class="line">            print(a)</span><br><span class="line"></span><br><span class="line">asd = test()</span><br><span class="line">asd.run()</span><br></pre></td></tr></table></figure>
<p>此时便可以愉快的在类中批量的生成与调用变量。而在普通函数中也是可以的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    d[<span class="string">'x'</span> + str(i)] = i</span><br><span class="line">    </span><br><span class="line">print(d.keys())</span><br><span class="line">print(d[<span class="string">'x0'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    print(d[<span class="string">'x'</span> + str(i)])</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict_keys([<span class="string">'x0'</span>, <span class="string">'x1'</span>, <span class="string">'x2'</span>])</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python __init__.py 文件的用法</title>
    <url>/2021/07/11/python-init-file/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近 <code>rush</code> 代码遇到一些问题，如一种典型的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-main/</span><br><span class="line">|----test1/</span><br><span class="line">|--------module1.py</span><br><span class="line">|----test2/</span><br><span class="line">|--------module2.py</span><br></pre></td></tr></table></figure>
<p>如上，想在 <code>module2.py</code> 中调用 <code>module1.py</code> 中的某个类，如果在 <code>module2.py</code> 中写：<code>from ..test1 import module1</code>，在 <code>test2</code> 文件夹下执行 <code>python module2.py</code> 会提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ImportError: attempted relative import with no known parent package</span><br></pre></td></tr></table></figure>
<p>会遇到这样的错误。那么，如何解决呢？如果你只想看如何解决问题，直接翻到文末即可；网上大概搜了一下，需要 <code>__init__.py</code> 来解决下这个问题，但是网上搜了一圈，没啥写的特别好的教程，实在是烂的可以，特此来填坑。</p>
<a id="more"></a>
<h1 id="init-py-是什么-1"><a href="#init-py-是什么-1" class="headerlink" title="__init__.py 是什么 1"></a>__init__.py 是什么 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h1><p>假设此时的路径结构为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-main/</span><br><span class="line">|----__init__.py</span><br><span class="line">|----test1/</span><br><span class="line">|--------__init__.py</span><br><span class="line">|--------module1.py</span><br><span class="line">|----test2/</span><br><span class="line">|--------__init__.py</span><br><span class="line">|--------module2.py</span><br></pre></td></tr></table></figure>
<p>在 <code>test1</code> 目录下的 <code>__init__.py</code> 中写入：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'module1 was called'</span>)</span><br></pre></td></tr></table></figure>
<p>在 <code>test2</code> 目录下的 <code>__init__.py</code> 中写入：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'module2 was called'</span>)</span><br></pre></td></tr></table></figure>
<p>在 <code>main</code> 目录下的 <code>__init__.py</code> 中写入：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'parent package was called'</span>)</span><br><span class="line"><span class="comment"># 导入 [] 里面定义的模块</span></span><br><span class="line">__all__ = [<span class="string">'test1'</span>, <span class="string">'test2'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>通俗来说，<code>__init__.py</code> 可以将文件封装成包，将多个文件合并到一个逻辑命名空间。但是这么说太突兀了，由浅入深，一点一点来。先来看看文件夹中添加 <code>__init__.py</code> 会发生什么。假设此时的路径为 <code>main</code> 文件夹下，尝试导入模块，会发现上述信息被打印：</p>
<p><img data-src="https://z3.ax1x.com/2021/07/11/WCmmuT.png" alt></p>
<p>同理，在 <code>main</code> 文件夹的 <strong>上一级路径</strong> 下执行导入，也会有同样的效果，但是不会导入子模块。</p>
<p><img data-src="https://z3.ax1x.com/2021/07/11/WCm05d.png" alt></p>
<p>如果想导入单个子模块，可以 <code>import main.test1</code>，此时会打印 <code>module1 was called</code>；如果再次调用 <code>import main.test1</code>，也就是在模块已经导入的情况下再次导入，则不会打印任何信息。</p>
<p>如果导入全部子模块，也是可以的。因为声明了 <code>__all__</code>，所以子模块被导入。</p>
<p><img data-src="https://z3.ax1x.com/2021/07/11/WCmyxP.png" alt></p>
<p>但是你也许会有疑问，我经常写 <code>import math</code>，而 <code>math.sin</code> 等函数是导入的，且可以使用，为什么这里就不行了呢？如果想行，也是可以的，只需要在 <code>main</code> 目录下的 <code>__init__.py</code> 中写入以下信息就可以了，也就是 <code>import main; main.test1</code> 可用。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'parent package was called'</span>)</span><br><span class="line"><span class="comment"># 删除 __all__</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> test1</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> test2</span><br></pre></td></tr></table></figure>
<p>通过以上例子，我们可以看出，<code>__init__.py</code> 会起到以下作用：</p>
<ul>
<li>导入模块时初始化一些信息，如 <code>web</code> 项目中，启动 <code>session</code> 等</li>
<li>在父目录中，导入多个子模块</li>
</ul>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>也许你会觉得以上功能比较弱，或者说没啥用。那么来看一些实用的简化工作量的写法 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 。此时的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├─ main.py</span><br><span class="line">└─ network</span><br><span class="line">       ├─ __init__.py</span><br><span class="line">       ├─ msg</span><br><span class="line">       │    └─ info</span><br><span class="line">       │           └─ send.py</span><br><span class="line">       └─ parse.py</span><br></pre></td></tr></table></figure>
<p>在 <code>send.py</code> 中，定义如下函数：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'send:'</span>, msg)</span><br></pre></td></tr></table></figure>
<p>如果想在 <code>main.py</code> 中调用这个函数，需要以下写法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> network.msg.info <span class="keyword">import</span> send</span><br><span class="line">send.send_msg(<span class="string">'hello'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># from network.msg.info.send import send_msg</span></span><br><span class="line"><span class="comment"># send_msg('hello')</span></span><br></pre></td></tr></table></figure>
<p>但无论那种方法，都要写长长的路径，甚为不便。这个时候，我们可以在 <code>network</code> 文件夹下面创建一个 <code>__init__.py</code> 文件，并在里面填写如下内容：<code>from .msg.info.send import send_msg</code>。而 <code>main.py</code> 文件中的内容可以修改为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> network <span class="keyword">import</span> send_msg</span><br><span class="line">send_msg(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>
<p>是不是简短了很多。这是因为，当一个文件夹里面有 <code>__init__.py</code> 以后，这个文件夹就会被 <code>python</code> 作为一个包 <code>package</code> 来处理。此时，对于这个包里面层级比较深的函数、常量、类，我们可以先把它们导入到 <code>__init__.py</code> 中。这样以来，包外面再想导入这些内容时，就可以用 <code>from 包名 import 函数名</code> 来导入了。</p>
<p>这样做有很多好处，由于调用包的其他模块所在的绝对路径是千变万化的，当有一些代码会在很多地方被使用时，我们可以把这些代码打包起来，作为一个公共的接口提供给其他模块调用，这会方便很多。</p>
<p>所以在<strong>包的内部</strong>调用自身其他文件中的函数、常量、类，就不应该使用相对路径，而是绝对路径。这里以添加新功能为例，如下所示，在 <code>parse.py</code> 文件中添加以下内容：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 两种都可以</span></span><br><span class="line"><span class="comment"># from .msg.info.send import send_msg</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> send_msg</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_msg</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'parse:'</span>, msg)</span><br><span class="line">    send_msg(msg)</span><br></pre></td></tr></table></figure>
<p>可以看到，在包里面的一个文件调用这个包里面的另一个文件，只需要知道另一个文件的相对位置就可以了，不用关心这个包被放在哪里。上 面<code>parse.py</code> 中导入 <code>send_msg</code> 函数的代码还可以进一步简化，由于 <code>send_msg</code> 函数已经被导入到了 <code>__init__.py</code> 中，所以我们可以直接从 <code>.</code> 里面导入 <code>send_msg</code> 函数。</p>
<p>之后在 <code>__init__.py</code> 中追加：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .parse <span class="keyword">import</span> parse_msg</span><br></pre></td></tr></table></figure>
<p>此时，<code>main.py</code> 的写法可以如下，可以看到，即使追加了新的模块，<code>main.py</code> 调用起来也会很方便，并不需要知道 <code>parse_msg</code> 这个方法的任何位置信息。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> network <span class="keyword">import</span> parse_msg</span><br><span class="line">parse_msg(<span class="string">'hhh'</span>)</span><br></pre></td></tr></table></figure>
<p>此外，当一个文件夹里面包含 <code>__init__.py</code> 时，这个文件夹会被 <code>python</code> 认为是一个包 <code>package</code>，此时，包内部的文件之间互相导入可以使用相对导入，并且通过提前把函数、常量、类导入到 <code>__init__.py</code> 中再在其他文件中导入，可以精简代码。</p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>既然了解了 <code>__init__.py</code> 的用法，那么去解决文章最开始提到的问题。目录结构如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">├─ main.py</span><br><span class="line">├─ test1</span><br><span class="line">│    ├─ __init__.py</span><br><span class="line">│    └─ m1.py</span><br><span class="line">└─ test2</span><br><span class="line">       └─ m2.py</span><br></pre></td></tr></table></figure>
<p>实现的想法也很简单，<code>m2.py</code> 调用 <code>m1.py</code> 中的函数。</p>
<p><code>m1.py</code> 定义如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure>
<p><code>m2.py</code> 定义如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> m1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    m1.send(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>
<p>距离成功只差一步，那就是修改 <code>test1</code> 中的 <code>__init__.py</code> 的内容，把 <code>test1</code> 看成一个 <code>package</code>，暴露其中的 <code>m1</code> 即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> m1</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># from . import m1</span></span><br></pre></td></tr></table></figure>
<p>这样，在外部的 <code>main</code> 函数中：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> test2.m2 <span class="keyword">as</span> m2</span><br><span class="line">m2.run()</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># from test2 import m2</span></span><br><span class="line"><span class="comment"># m2.run()</span></span><br></pre></td></tr></table></figure>
<p>就可以了。</p>
<h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">https://zhuanlan.zhihu.com/p/130927618</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">https://www.kingname.info/2020/03/23/init-in-python/</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>看了本文也可能搞不太懂的 Python 装饰器的使用</title>
    <url>/2020/01/07/python-wrapper/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>问题背景：之前学过<code>python</code>的装饰器的语法，但因当时接触的代码很少涉及装饰器的使用，所以很少使用以至于忘干净了。而今天接触的问题的确需要使用装饰器，果然还是任务驱动大法好。</p>
<p>问题背景：在<code>GUI</code>的开发中，有很多的<code>QLineEdit</code>对象，并在其中输入信息。假设某个输入框位置输入的是学号，学号作为学生数据表的主键插入，而字符串多一个空格会影响数据表内的存储，如<code>123</code> 和 <code>123{ }</code>是两个不一样的东西，即在数据库内存储两份，但实际是一个东西。<code>{ }</code>表示有个空格占位符。</p>
<p>而在输入时普通用户可能会一不小心多加了一个空格，从开发良好软件的角度出发：后台应该把这些空格得去掉。而有很多的<code>QLineEdit()</code>对象时，又不想一个个的找到对象的位置，写很多次去除空格的函数(并不是很好的编码习惯)，这个时候可能就需要装饰器了。</p>
<p>即：在含有<code>QLineEdit()</code>的函数中，调用装饰器给函数装饰一下，在不影响原来代码结构和语句的基础上，增加去除空格的装饰工作。省时省力，不破坏原有结构，值得推荐。</p>
<p>今天：写个函数<code>return</code>回来不好么，写装饰器改全局变量还不够费劲（不太想装饰器里面<code>global</code>）。</p>
<a id="more"></a>
<p>装饰器<code>Decorators</code>是 <code>Python</code> 的一个重要部分，简单地说：他们是增加和装饰其他函数的功能的函数。</p>
<p>装饰器本质上是一个 <code>Python</code> 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。</p>
<p>概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p>
<h1 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h1><p>更多的像是转载<br><a href="https://www.runoob.com/w3cnote/python-func-decorators.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/python-func-decorators.html</a></p>
<h1 id="Python的函数"><a href="#Python的函数" class="headerlink" title="Python的函数"></a>Python的函数</h1><h2 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h2><p>函数可以作为参数执行：Python 中的函数可以像普通变量一样当做参数传递给另外一个函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"foo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(func)</span>:</span></span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line">bar(foo)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">foo</span><br></pre></td></tr></table></figure>
<h2 id="函数中定义与调用函数"><a href="#函数中定义与调用函数" class="headerlink" title="函数中定义与调用函数"></a>函数中定义与调用函数</h2><p>在 Python 中我们可以在一个函数中定义另一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span><span class="params">(name=<span class="string">"yasoob"</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"now you are inside the hi() function"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the greet() function"</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">welcome</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the welcome() function"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 执行</span></span><br><span class="line">    print(welcome())</span><br><span class="line">    print(greet())</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"now you are back in the hi() function"</span>)</span><br><span class="line"> </span><br><span class="line">hi()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">now you are inside the hi() function</span><br><span class="line">now you are <span class="keyword">in</span> the welcome() function</span><br><span class="line">now you are <span class="keyword">in</span> the greet() function</span><br><span class="line">now you are back <span class="keyword">in</span> the hi() function</span><br></pre></td></tr></table></figure>
<h2 id="从函数中返回函数"><a href="#从函数中返回函数" class="headerlink" title="从函数中返回函数"></a>从函数中返回函数</h2><p>注意与上述代码的差别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span><span class="params">(name=<span class="string">"yasoob"</span>)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the greet() function"</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">welcome</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the welcome() function"</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">"yasoob"</span>:</span><br><span class="line">        b = greet</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> welcome</span><br><span class="line"> </span><br><span class="line">a = hi()</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 把 a 返回的函数对象给执行掉 </span></span><br><span class="line">print(a())</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;function hi.&lt;locals&gt;.greet at <span class="number">0x7fb8b02579e0</span>&gt;</span><br><span class="line">now you are <span class="keyword">in</span> the greet() function</span><br></pre></td></tr></table></figure>
<p>再次看看这个代码。在 <code>if/else</code> 语句中我们返回 <code>greet</code> 和 <code>welcome</code>，而不是 <code>greet()</code> 和 <code>welcome()</code>。</p>
<p>为什么这样？这是因为当你把一对小括号放在后面，这个函数就会执行；然而如果你不放括号在它后面，那它可以被到处传递，并且可以赋值给别的变量而不去执行它。</p>
<h1 id="第一个装饰器和-语法糖"><a href="#第一个装饰器和-语法糖" class="headerlink" title="第一个装饰器和@语法糖"></a>第一个装饰器和@语法糖</h1><p>虽然可以通过函数传递的方式来完成函数执行前的修饰功能，如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    logging.warn(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo'</span>)</span><br><span class="line"></span><br><span class="line">use_logging(foo)</span><br></pre></td></tr></table></figure>
<p>这样做逻辑上是没问题的，功能是实现了，但是我们调用的时候不再是调用真正的业务逻辑 <code>foo</code> 函数，而是换成了 <code>use_logging</code> 函数，这就破坏了原有的代码结构， 现在我们不得不每次都要把原来的那个 <code>foo</code> 函数作为参数传递给 <code>use_logging</code> 函数，那么有没有更好的方式的呢？当然有，答案就是装饰器。</p>
<p>如果函数 <code>bar()</code>、<code>bar2()</code> 等函数都有类似的需求，怎么做？再写一个 <code>logging</code> 在 <code>bar</code> 函数里？这样就造成大量雷同的代码，为了减少重复写代码，我们可以这样做，重新定义一个新的函数：专门处理日志，日志处理完之后再执行真正的业务代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">'asd'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(text)</span><br><span class="line">        print(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"i am foo"</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>如上所示，有了<code>@</code>，我们就可以省去<code>foo = use_logging(foo)</code>这一句了，直接调用 <code>foo()</code> 即可得到想要的结果。</p>
<p><code>foo()</code> 函数不需要做任何修改，只需在定义的地方加上装饰器，调用的时候还是和以前一样，如果我们有其他的类似函数，我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。</p>
<p>装饰器在 <code>Python</code> 使用如此方便都要归因于 <code>Python</code> 的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。</p>
<h1 id="函数元信息问题"><a href="#函数元信息问题" class="headerlink" title="函数元信息问题"></a>函数元信息问题</h1><p>之前网上的文章都说在使用装饰器时，修饰函数的元信息会代替调用函数的元信息，但现在2019(快2020)年了，貌似没了这个问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logit</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(func.__name__ + <span class="string">" was called"</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@logit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addition_func</span><span class="params">(x)</span>:</span></span><br><span class="line">   <span class="keyword">return</span> x + x</span><br><span class="line"></span><br><span class="line">result = addition_func(<span class="number">4</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">addition_func was called</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>之前（别人博客写的）的输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">with_logging was called</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><code>仅供参考：</code>(我并没遇到此类问题)：当然安全起见，可以使用下面的方法。使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的<code>docstring</code>、<code>__name__</code>、参数列表，我们有<code>functools.wraps</code>，<code>wraps</code>本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器里面的 <code>func</code> 函数中，这使得装饰器里面的 <code>func</code> 函数也有和原函数 <code>foo</code> 一样的元信息了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_name</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="comment"># @wraps接受一个函数来进行装饰  这可以让我们在装饰器里面访问在装饰之前的函数的属性</span></span><br><span class="line"><span class="meta">    @wraps(f)</span></span><br><span class="line">    <span class="comment"># 接受func传入的参数 对应</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 装饰工作</span></span><br><span class="line">        print(<span class="string">'test----&gt;'</span>)</span><br><span class="line">        <span class="comment"># 执行原本的函数</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="comment"># 返回装饰器</span></span><br><span class="line">    <span class="keyword">return</span> decorated</span><br><span class="line"> </span><br><span class="line"><span class="meta">@decorator_name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="string">"Function is running"</span>)</span><br><span class="line"></span><br><span class="line">print(func())</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test----&gt;</span><br><span class="line">Function <span class="keyword">is</span> running</span><br></pre></td></tr></table></figure>
<h1 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h1><p>若不同方法对装饰器的需求有细微的差别，需要额外传入参数来完成差别的区分。如<code>@use_logging(level=&quot;warn&quot;)</code> 等价于 <code>@decorator</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">"warn"</span>:</span><br><span class="line">                print(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">            <span class="keyword">elif</span> level == <span class="string">"info"</span>:</span><br><span class="line">                print(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(level = "warn")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name = <span class="string">'foo'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"i am %s"</span> % name)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>上面的 <code>use_logging</code> 是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我们使用<code>@use_logging(level=&quot;warn&quot;)</code>调用的时候，<code>Python</code> 能够发现这一层的封装，并把参数传递到装饰器的环境中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">foo <span class="keyword">is</span> running</span><br><span class="line">i am foo</span><br></pre></td></tr></table></figure>
<h1 id="装饰器类"><a href="#装饰器类" class="headerlink" title="装饰器类"></a>装饰器类</h1><p>没错，装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类的<code>__call__</code>方法，当使用 <code>@</code> 形式将装饰器附加到函数上时，就会调用此方法。</p>
<p>假设有时你只想打日志到一个文件。而有时你想把引起你注意的问题发送到一个<code>email</code>，同时也保留日志，留个记录。这是一个使用继承的场景，但目前为止我们只看到过用来构建装饰器的函数。</p>
<p>幸运的是，类也可以用来构建装饰器。那我们现在以一个类而不是一个函数的方式，来重新构建<code>logit</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logit</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, logfile=<span class="string">'out.log'</span>)</span>:</span></span><br><span class="line">        self.logfile = logfile</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log_string = func.__name__ + <span class="string">" was called"</span></span><br><span class="line">            print(log_string)</span><br><span class="line">            <span class="comment"># 打开logfile并写入</span></span><br><span class="line">            <span class="keyword">with</span> open(self.logfile, <span class="string">'a'</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">                <span class="comment"># 现在将日志打到指定的文件</span></span><br><span class="line">                opened_file.write(log_string + <span class="string">'\n'</span>)</span><br><span class="line">            <span class="comment"># 现在，发送一个通知</span></span><br><span class="line">            self.notify()</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapped_function</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># logit只打日志，不做别的</span></span><br><span class="line">        print(<span class="string">'-----test-----'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="meta">@logit()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'fun1 running'</span>)</span><br><span class="line"></span><br><span class="line">myfunc1()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myfunc1 was called</span><br><span class="line">-----test-----</span><br><span class="line">fun1 running</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>给 logit 创建子类，来添加 email 的功能(虽然 email 这个话题不会在这里展开)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">email_logit</span><span class="params">(logit)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    一个logit的实现版本，可以在函数调用时发送email给管理员</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email=<span class="string">'admin@myproject.com'</span>, *args, **kwargs)</span>:</span></span><br><span class="line">        self.email = email</span><br><span class="line">        super(email_logit, self).__init__(*args, **kwargs)</span><br><span class="line">        self.notify2()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 发送一封email到self.email</span></span><br><span class="line">        <span class="comment"># 这里就不做实现了</span></span><br><span class="line">        print(<span class="string">'--test1--'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@email_logit()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'my func2 running'</span>)</span><br><span class="line"></span><br><span class="line">myfunc2()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">--test1--</span><br><span class="line">myfunc2 was called</span><br><span class="line">-----test-----</span><br><span class="line">my func2 running</span><br></pre></td></tr></table></figure>
<h1 id="装饰器顺序"><a href="#装饰器顺序" class="headerlink" title="装饰器顺序"></a>装饰器顺序</h1><p>一个函数还可以同时定义多个装饰器，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="meta">@c</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span> <span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>它的执行顺序是从里到外，最先调用最里层的装饰器，最后调用最外层的装饰器，它等效于<code>f = a(b(c(f)))</code>。</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="去除字符串空格"><a href="#去除字符串空格" class="headerlink" title="去除字符串空格"></a>去除字符串空格</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line">text = <span class="string">'201614420112 '</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_blank</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">global</span> text</span><br><span class="line">        text = text.strip()</span><br><span class="line">        print(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@remove_blank</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(len(text))</span><br><span class="line">    </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>但是并不推荐这种global的写法，容易引起变量混乱。不如以下方式简洁明了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">'201614420112 '</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(t)</span>:</span></span><br><span class="line">    text = t.strip()</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line">text = foo(text)</span><br><span class="line"></span><br><span class="line">print(len(text))</span><br></pre></td></tr></table></figure>
<h2 id="记录函数执行时间"><a href="#记录函数执行时间" class="headerlink" title="记录函数执行时间"></a>记录函数执行时间</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        since = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'use time: '</span> + str(end - since))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@run_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">1000</span>):</span><br><span class="line">        i += <span class="number">3</span></span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@run_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">1000</span>):</span><br><span class="line">        i = i * <span class="number">3</span></span><br><span class="line">        i = i - <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">test1()</span><br><span class="line"></span><br><span class="line">test2()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">use time: <span class="number">8.249282836914062e-05</span></span><br><span class="line">use time: <span class="number">4.0531158447265625e-06</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>manjaro下python创建虚拟环境</title>
    <url>/2019/09/21/python-virenv/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>话说Linux下的Typora真的是难用，能卡死，也可能是我电脑老了。本来下午是想把Linux下的GUI开发工具配置好，PyQt5安装一切正常，Qt5 Designer一直安装不上，就开始各种搜索。好在后来配置上了，但是也折腾了好久，配置PyQt5的过程放在另外的文章里，这里写一下创建虚拟环境的过程。毕竟这个很重要，而我居然刚学会。</p>
<a id="more"></a>
<h1 id="选择一份好文档"><a href="#选择一份好文档" class="headerlink" title="选择一份好文档"></a>选择一份好文档</h1><p>折腾好久的一个原因是，我看了份CSDN的文档，原因说的是版本原因，python3.7不行，得python3.5。好，既然版本错误，我就在安装一个python3.5, 创建python3.5的虚拟环境在试一下（然后就开始了瞎折腾）。</p>
<p>但折腾到最后创建了虚拟环境，也安装了python3.5, 可还不行，后来去了官网，呵，没有linux版本的。<a href="https://pypi.org/project/pyqt5-tools/#files" target="_blank" rel="noopener">https://pypi.org/project/pyqt5-tools/#files</a></p>
<p>windows用户安装Qt Designer就很简单了：<code>pip install pyqt5-tools</code>, 然后去安装的库文件中寻找designer.exe即可（<code>python3.5\Lib\site-packages\pyqt5-tools</code>）。</p>
<p>具体怎么折腾上PyQt5的，是后话了（我发现每次我折腾GUI都能踩一堆坑，上次就踩了一个，以后在整理吧）</p>
<h1 id="安装python3-5"><a href="#安装python3-5" class="headerlink" title="安装python3.5"></a>安装python3.5</h1><p>我的主要目的是创建一个python3.5的虚拟环境，我这里manjaro自带python2.7.16和python3.7.4。</p>
<p>安装python3.5的过程借鉴：<a href="https://www.cnblogs.com/kimyeee/p/7250560.html" target="_blank" rel="noopener">https://www.cnblogs.com/kimyeee/p/7250560.html</a></p>
<p>我的安装路径为：<code>./configure --prefix=/usr/local/python3.5</code></p>
<p>我创立的软链接为：<code>ln -s /usr/local/python3/bin/python3.5 /usr/bin/python3.5</code>（后文创立虚拟环境要用，所以请好好写路径）</p>
<h1 id="虚拟环境的创建"><a href="#虚拟环境的创建" class="headerlink" title="虚拟环境的创建"></a>虚拟环境的创建</h1><p>安装—&gt;激活—&gt;创建—&gt;退出，这几个流程请按顺序走完。剩下的随意。</p>
<h2 id="安装工具库"><a href="#安装工具库" class="headerlink" title="安装工具库"></a>安装工具库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install virtualenv</span><br><span class="line">sudo pip install virtualenvwrapper</span><br></pre></td></tr></table></figure>
<h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><p><code>source virtualenvwrapper.sh</code></p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p><code>mkvirtualenv -p [地址] [名称]</code></p>
<p>地址是python3.5所在的地址，只需要输入<code>whereis python3.5</code>查询即可（所以，一定记得python安装在哪里，对我来说就是<code>/usr/bin/python3.5</code>）。如<code>mkvirtualenv -p /usr/bin/python3.5 GUI-layout</code>，会在当前路径下创建虚拟环境，自由操作了，进入虚拟环境后命令行会有所变化。（一定不要<code>sudo</code>）</p>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><p><code>deactivate</code>即可。</p>
<h2 id="激活后直接进入"><a href="#激活后直接进入" class="headerlink" title="激活后直接进入"></a>激活后直接进入</h2><p>一定先激活，然后<code>workon GUI-layout</code>，可以实现在任何路径下由命令行直接进入虚拟环境。不需要进入到 主目录下的/.virtualenvs目录，在任何目录下都可以执行命令，创建的虚拟环境和进入虚拟环境的位置都一样。(但是工作路径不一样)</p>
<p>因为工作路径不一样，一定要一直在命令行里开着虚拟环境，然后在命令行里编译，这样用的才是虚拟环境。比如用vscode写完代码，就地编译，用的是外部环境而不是虚拟环境。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>同样要先激活，然后<code>rmvirtualenv</code> 如 <code>rmvirtualenv GUI-layout</code>。</p>
<h2 id="查看所有虚拟环境"><a href="#查看所有虚拟环境" class="headerlink" title="查看所有虚拟环境"></a>查看所有虚拟环境</h2><p>当前用户的主目录下<code>cd .virtualenvs/</code>。</p>
<p>如下所示，在虚拟环境里面python版本已经变成了3.5</p>
<p><img data-src="/2019/09/21/python-virenv/1.png" alt></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>重参数技巧</title>
    <url>/2020/10/05/reparametrization-tricks/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天读小样本的论文又遇到了重参数技巧，记得之前在 VAE 中也看到了它。遂来做一个归纳整理，了解<strong>重参数</strong>到底是什么，一般都用在什么背景下。</p>
<a id="more"></a>
<h1 id="VAE-中重参数生成高斯分布"><a href="#VAE-中重参数生成高斯分布" class="headerlink" title="VAE 中重参数生成高斯分布"></a>VAE 中重参数生成高斯分布</h1><p>在 VAE 中，需要从 $p(Z|X)$ 中采样得到样本，但采样的过程本身是不可逆的，就导致整个过程无法反向传播。我们已经知道 $P(Z|X)$ 是服从正态分布的，也知道均值和方差，那么如何产生数据呢？这个时候就是重采样技术了。</p>
<p>我们首先生成一个均值为0, 标准差为1的高斯分布 $N\sim (0,1)$。在这个分布中中采样数据 $\epsilon$，经过一个变换后得到目标分布：$Z=\mu + \sigma \epsilon$。$\mu$为均值，$\sigma$为方差，由网络计算得出。伪代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reparametrization</span><span class="params">(z_mean, z_log_var)</span>:</span></span><br><span class="line">    epsilon = K.random_normal(shape=K.shape(z_mean))</span><br><span class="line">    <span class="keyword">return</span> z_mean + z_log_var * epsilon</span><br></pre></td></tr></table></figure>
<p>此时，返回的变量就具有了梯度，而采样的过程在整个计算图之外，采样的 $\epsilon$ 就是一个常量，此时便可以梯度下降。</p>
<h1 id="Gumbel-Softmax"><a href="#Gumbel-Softmax" class="headerlink" title="Gumbel Softmax"></a>Gumbel Softmax</h1><p><a href="https://static01.imgkr.com/temp/8798f13886ad45d78ed32dbdccdb0386.png" target="_blank" rel="noopener">https://static01.imgkr.com/temp/8798f13886ad45d78ed32dbdccdb0386.png</a></p>
<p>上图在 DARTS 算法中表示为一个 Cell。每个 Cell 由多个 Node 组成，Node 和 Node 之间有多条边，每条边代表的操作不一样，比如可能是CNN，可能是RNN，可能是 maxpool。每条边都有一个权重 $\alpha$，权重是可以学习的。根据权重来选择每条边到底执行什么操作。</p>
<p>假设每条边上有三条操作。如果只是简单地选择权重最大的操作，那么<code>[0.2,0.3,0.5]</code>和<code>[0.1,0.2,0.7]</code>并没有本质的区别了，而且这样一来可能第一个和第二个操作根本就没有机会得到更新，但从概率上来说这两个权重分布差别是巨大的，所以需要一种方法不仅选出动作，而且遵从概率的含义。</p>
<p>所以一个很自然的想法就是我们希望以 0.1 的概率选择第一个操作，0.2 的概率选择第二个操作，0.7 的概率选择第三个操作。实现起来很简单，按照概率选择就好。但问题又来了，这个过程没有办法梯度下降。所以需要借助重采样技术。</p>
<ul>
<li>生成均匀分布 $U(0,1)$，从中采样得到样本 $\epsilon$；</li>
<li>计算 $G$，$G=-\log(-\log(\epsilon))$；</li>
<li>计算新的权重向量：$w=[w_1+G_1, w_2+G_2, \cdots, w_n+G_n]$；</li>
<li>softmax一下，使得每个操作都能以一定的概率被选中，所以gumbel softmax成功地引入了随机性：<br>\begin{equation}<br>w’=\frac{\exp (w/\tau)}{\sum_{i=1}^n\exp(w_i/\tau)}<br>\end{equation}</li>
</ul>
<p>$\tau$控制着softmax的程度，温度越高，生成的分布越平滑（接近这里的均匀分布）；温度越低，生成的分布越接近离散的one-hot分布。因此，训练时可以逐渐降低温度，以逐步逼近真实的离散分布，且保留了梯度信息。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大概可以发现，有两种情况会使用重参数：</p>
<ol>
<li>需要对某一分布的数据进行采样；</li>
<li>需要保留梯度信息用于反向传播。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>VAE：<a href="https://kexue.fm/archives/5253" target="_blank" rel="noopener">https://kexue.fm/archives/5253</a></li>
<li>Gumbel Softmax：<a href="https://www.cnblogs.com/marsggbo/p/13227992.html" target="_blank" rel="noopener">https://www.cnblogs.com/marsggbo/p/13227992.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>和自己和解</title>
    <url>/2021/01/10/reconcile-myself-to-life/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>初中时候，读过一篇叫<a href="http://blog.sina.com.cn/s/blog_4b6aa97f0100ljcj.html" target="_blank" rel="noopener">『月光恰恰好』</a>的散文，被其中优美的句子所吸引。但那时候始终觉得有一句话和文章内容不符：</p>
<blockquote>
<p>在和自己漫长的战争中，我懂得了如何运用化骨绵掌，懂得低眉，也懂得了，从容的和自己调个情，让自己和自己相爱，化干戈为玉帛。</p>
</blockquote>
<p>当时丝毫想不通：为什么要和自己作斗争，为什么要低眉，为什么要化干戈为玉帛，没有任何道理呀。</p>
<a id="more"></a>
<p>四五年前，考上了某二本大学。也就是刚上大学那会儿，落差很大，大的让人让人很难说清那是什么感觉。师者不师，学者不学，身边的东西没有一丝大学应有的味道。年轻那会儿，为了变强，想尽办法去学各种东西，无论是<code>MOOC</code>学自己感兴趣的课程，图书馆阅读还是校内的各种竞赛培训。那会儿累的周一到周日全是课，还是满课。在心中执念的驱使下，除了课程的学习外还准备了一堆比赛，也不看电影，不出校门，唯一的放松方式就是跑步，不知休息为何物。临近期末就直接睡在实验室，三年暑假全部留校，两年的寒假也留校到除夕附近，那年我大一、大二，正是刚入大学可以愉快玩耍的时候。</p>
<p>后来凭借运气加成，也拿到了专业唯一的保研名额，可我要面临一个更为残酷的事实：我失眠了，整夜整夜的睡不着，也许是得到自己想要后的怅然若失吧。尝试过各种方法，到最后褪黑素这样的安眠药终于也对我也无济于事了。我可以做到每天都很累，上午7点起床，晚上十一点跑步，十二点才回宿舍，可还是睡不着。身体面临巨大的消耗，也日渐憔悴。理论上是，保研了就没事了，考完了就早点回家。回到家后，我发现我还是丝毫睡不着，能一直躺到太阳升起天空大亮而毫无困意。企图出门旅行放松自己，打游戏和看视频来缓冲自己都并无卵用。</p>
<ul>
<li>总感觉心里有股执念没放下，意难平；</li>
<li>总感觉自己努力了，但没达到自己想要的高度，这就等于没努力；</li>
<li>总是一次次期待后，又一次次面临巨大的失望；</li>
<li>看到更强的人后，感叹自己总是沉浸在自己的井底世界，总是感觉自己差的还很远很远。</li>
</ul>
<p>而后就是自己的黑暗反思：</p>
<ul>
<li>为什么我没有他们那样的天分？为什么别人一眼就看会的东西我要花费很多时间学上好几遍？</li>
<li>为什么我记忆力和专注力都比不上别人，反而还衰退的这么厉害？初中的时候还能过目不忘，可上了高中后这项技能完全消失，是上天针对我吗？</li>
<li>为什么我没有他们那么好的命？</li>
<li>为什么我没有他们那么强的简历？</li>
<li>为什么我没有他们那么好的家庭？</li>
<li>为什么我学习这么差，为什么我不是个天才？</li>
</ul>
<p>被心中的执念所反噬，曾一度仇视自己，一度仇视自己没有个很好的家庭，一度仇视小时候的棍棒教育给我留下了童年阴影，一度仇视自己没有个好的出身，在黑化的边缘反复横跳，内心极度敏感。一直持续到读研。读研期间也意识到了几个重要的事情：</p>
<ul>
<li>科研对我这种二本出身的人来说是死路一条</li>
<li>很多事情没有办法再用学校里的标准去衡量，奖学金/排名/竞赛/论文 我本科所追求的东西对我今后发展再无任何意义，不如努力写好程序</li>
<li>我想我告别了学生时代，研究生所作的事情和涉及的领域，不再是单纯的师生关系。如果说大学不在是单纯的刷题，那么研究生就不再是单纯的学习知识提升自己</li>
</ul>
<p>心中执念加剧，读研完全和自己的预料的不一样，我曾以为读研就是好好读论文好好科研，参加点比赛做点项目找个工作or深造，后来发现并不是这样。事实与生活只会更加残酷，落差一遍遍的在内心放大。说着恶心的话而毫不自知，伤害着身边的人，无限度透支他人的耐心，也戏称这屎一样的生活，the fucking world。</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>后来想了想，要不和自己和解吧。 </p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<ul>
<li>达不到的高度要不就不去了吧，把自己该做的做好就行</li>
<li>这个世界总是把活人往死路上逼，又劝想轻生的人好好活着，所以大多数人都半死不活的苟延残喘</li>
<li>温柔正确的人总是难以生存，因为这个世界既不温柔，也不正确</li>
<li>想想小时候那会儿，走在上学路上能感受到风里的气息和温柔，看到蓝天和绿叶就感觉很美，能感受到阳光照耀的温暖，能闻到花开的芳香，能享受到奔跑的快乐，能在日落西山时呼呼睡去，能听到窗外风吹树叶的沙沙声，能幻想一幅完美的童话世界，能耐心的花一下午去观察蚂蚁搬家，能在田野上嬉闹一下午，能为偷吃一块糖而窃喜，能为一场雨或一场雪感到快乐，能在晚上回家的路上安静的看看天空中的一轮明月和星星。可长大后，青春越来越少，这些快乐也逐步消失，连跑步都变成了日常健身任务，午休变成了下午更好的工作，为数不多的快乐也变成了花钱去电影院、花钱去娱乐场所、花钱去旅游景点打卡、花钱去吃顿好吃的火锅，可真是讽刺。</li>
</ul>
<p>那就慢慢的和自己和解吧，放下心中的执念。不如好好享受生活，感受一杯牛奶的醇香、一粒大米的香甜，感受泡脚的温度，好好看剧，慢慢吃饭，认真的晒晒太阳吹吹风，这并不是什么罪恶和蹉跎岁月的事情。阳光迟早会落在身上，而我也会快乐一场。那就和自己和解吧，释放内存，留意生活中幸福亦或是奇奇怪怪的瞬间，快乐的享受生活。这也是我今年来最大的收获了，也许是前半生学生时代的最大收获。</p>
<p><img data-src="https://static01.imgkr.com/temp/aeee828bf8414123b29edfff9d0fd35b.jpg" alt></p>
]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>倒车雷达（一）：介绍</title>
    <url>/2020/04/18/reverse-radar-begin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>问题背景说来话长，在去年选毕设的时候，计算机的毕设95%都是游戏开发和后端开发(后端数据库配前端页面展示)，这些东西我实在不会，唯一会的就是其中为数不多的单片机开发。而唯一的深度学习项目难度过大当作研究生毕设也不为过，后期老师提供的一些python项目也没及时看到，阴差阳错的选了这个毕设。</p>
<a id="more"></a>
<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>大概的要求是：基于Arduino实现倒车雷达，并在电脑端绘制实时的倒车影像。这个产品其实已经存在于市面上，也有幸见过一次倒车雷达，因此对倒车雷达的基本概念有了初步了解。<br>所以很容易得到这个设计的思路：</p>
<ol>
<li>按毕设要求，车辆的主控芯片选择Arduino；</li>
<li>使用超声波模块测量距离，当倒车过程中距离小于某个安全值时采取紧急制动；</li>
<li>因需要将距离数据发送给PC端用于绘制实时影象，因此数据的发送借助蓝牙模块实现；</li>
<li>既然Arduino将距离发送回PC，那么就在PC端写一个图形化的上位机，用于发送控制指令，如前进、后退等。</li>
</ol>
<p>以及相关注意事项：</p>
<ol>
<li>在正常开车时不能开启倒车雷达。因为在堵车时，后面的车离自己很近，但此时不能制动，防止车祸发生；</li>
<li>实时影象可以考虑Wifi图传，但价格我承受不起，所以选择非实际影象，而是制作动画代替；</li>
<li>可以考虑在车的两侧添加超声波模块，用于反馈倒车时车身两侧的距离。但IO口不够，因此只添加车身后侧的超声波；</li>
<li>PCB难以绘制，Altium Designer学到一半就放弃。实在搞不懂什么时候放电阻、电容、电感等。确切的说电路等相关知识并不是计算机专业必须要会和要求掌握的东西，所以选择面包板偷工减料。</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><img data-src="/2020/04/18/reverse-radar-begin/1.jpg" alt></p>
<p><a href="https://muyuuuu.github.io/2018/05/22/C51/">左图是两年前做的</a>，包括：蓝牙、电机、液晶、加速减速、避障、巡迹等常见功能；右图是今年的做的，只有雷达、电机和蓝牙，更多的是PC端的上位机。</p>
<p>在这两周的开发中，也遇到了各种难以解决的bug，好在我<del>智勇双全</del>(文档丰富)。不过，也正因如此，我也选择了彻底放弃开发单片机的幻想。在三年前大一结束转专业的时候，我大概花了一个晚上去分析我到底是转专业去计算机呢，还是去电子信息呢，还是去自动化专业呢？毕竟以当时的成绩还是能想去哪里就去哪里的。</p>
<p>想去计算机是因为发现代码很有趣，大一自学了C语言and看着别人的python，都挺好玩的样子；想去电子信息是因为在大一的时候自学了C51单片机，发现单片机做出来的诸如：四旋翼、飞思卡尔智能车等东西也很有趣。当时以极低的分数考上大学，大一的专业都是调剂的，好不容易有了能凭自己兴趣选专业的机会不能错过。</p>
<p>大概在斟酌了专业的发展前景和研究方向后，还是选择了计算机专业，<del>当时单纯的以为自动化等专业还得去车间，像个电焊工一样带着护目镜作业</del>。事实证明，这个选择终究是正确的。经过这几天的开发，总结了我认为的电子方向的缺陷(仅仅是我片面的观点，电子专业的看管求放过)：</p>
<ol>
<li>程序执行不便，每次执行程序都是：修改ino、接线烧录、拔线、启动PC端、观察结果，某次执行不对还得重复这个流程。</li>
<li>bug难以调试。当软件出问题时，可以很方便的查文档、debug去解决；但硬件层面的bug并不是能轻易解决的，如某个模块内部的一个电路被击穿了，供电电压不够导致模块不稳定而烧坏，或者是不小心把某个线路弄坏了。这种硬件问题对计算机专业的人来说很难准确定位和解决。如上次调试了好久的bug，以为是驱动问题，代码问题，库依赖问题，最后才发现只是那个蓝牙模块坏了。</li>
<li>烧钱。承接第一个缺陷，蓝牙模块坏了是个大问题，根本不知道如何维修别人集成好的电路。因质量问题、电子元件寿命、错误操作等多个原因都可能导致模块损坏，甚至是快递的途中颠簸坏了，都会导致金钱白白的流失。而软件开发则不要钱(当然是选择免费工具)，且不会因误操作和寿命问题导致软件损坏，大不了更新嘛。</li>
<li>也是最重要的一点，我没学过电路、模电、电磁场等专业课。所以我只适合开发软件，硬件对我来说到处都是知识盲区。</li>
</ol>
<p>因此，尽管我能用所学知识做出相应的产品，但我也不会在去选择单片机开发这条路，也算是了却了一件心事吧。（单纯的开发不涉及任何硬件的软件除外）</p>
<p>当然我不是在贬低电子这个专业，只是我不适合。这个世界离不开电子这个专业，从常见的手机、充电宝，到大街上的电子灯，到一般的蓝牙耳机，包括我写这篇文章用的键盘、鼠标和电脑，到不常见的机器人控制芯片，这都离不开电子这个专业。</p>
<p>等彻底完结了再去发后面的设计过程。</p>
]]></content>
      <tags>
        <tag>microcomputer</tag>
      </tags>
  </entry>
  <entry>
    <title>倒车雷达(二)：硬件搭建</title>
    <url>/2020/04/23/reverse-radar-hardware/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>硬件是软件运行的基础，因此有必要建立良好的硬件系统供软件的运行。因此，针对通信功能的蓝牙模块、制动功能的电机模块和测距功能的超声波模块三大模块，建立电路连接，提供电路连接图，并编写程序。</p>
<p>本文也提供部分代码，代码虽然都是核心代码<strong>但不能够独立运行</strong>。程序都附注释，有一丢丢开发基础都能看懂。希望看官能有所思考后取得所需代码，而不是无脑的复制粘贴。完整代码参考<a href="https://github.com/muyuuuu/Reversing-radar-on-Arduino/blob/master/code/Reverse-radar/Reverse-radar.ino" target="_blank" rel="noopener">这里</a>。且代码仅以我的接线方式为标准。</p>
<a id="more"></a>
<h1 id="通信功能"><a href="#通信功能" class="headerlink" title="通信功能"></a>通信功能</h1><p>通信功能选取了HC-05蓝牙模块，某购物平台25RMB左右。对于Arduino而言，还是能很轻易的做到Arduino与HC-05蓝牙模块的连接。连接的电路图如下所示：</p>
<p><img data-src="/2020/04/23/reverse-radar-hardware/1.jpg" alt></p>
<ul>
<li>5V连接VCC，GND相互连接构成回路</li>
<li>HC-05的发射端TXD连接Arduino的接收端RXD</li>
<li>HC-05的接收端RXD连接Arduino的发射端TXD</li>
<li>以此来构成通信的回路。</li>
</ul>
<p>但需要注意的是，在给Arduino烧录程序时，需要断开Arduino与HC-05的RXD和TXD连接。否则Arduni的TXD和RXD处于连接状态而非悬空状态时，程序无法烧录。(也可能是我用Vscode做IDE的原因)</p>
<h2 id="PC向Arduino发送数据"><a href="#PC向Arduino发送数据" class="headerlink" title="PC向Arduino发送数据"></a>PC向Arduino发送数据</h2><p>而在完成电路的连接后，需要编写程序来测试连接是否正确。首先Arduino处于接收端，电脑处于发送端。接通电路，电脑开启蓝牙并连接。对于接收端，当available()返回值大于0时，表明串口有数据发送到Arduino，此时调用read方法读取即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置硬件串口通信的波特率</span></span><br><span class="line">    Serial.begin(<span class="number">9600</span>);</span><br><span class="line">    <span class="comment">// 先清空串口缓存</span></span><br><span class="line">    <span class="keyword">while</span>(Serial.available())</span><br><span class="line">        Serial.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 读取串口数据 </span></span><br><span class="line">    <span class="keyword">if</span> (Serial.available() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        delay(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">char</span> val;</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        val = Serial.read();</span><br><span class="line">        <span class="comment">// 进入倒车模式</span></span><br><span class="line">        <span class="keyword">if</span> (val == <span class="string">'5'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="string">'6'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在发送端，选择了使用python作为发射信号和读取信号的工具。借助pyserial串口，很容易实现这个功能。(pip install pyserial)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> serial</span><br><span class="line"><span class="comment"># 读取串口数据的类</span></span><br><span class="line"></span><br><span class="line">s = serial.Serial(port=<span class="string">'COM6'</span>,</span><br><span class="line">                baudrate=<span class="number">9600</span>,</span><br><span class="line">                stopbits=serial.STOPBITS_ONE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送数据</span></span><br><span class="line">s.write(<span class="string">b"5"</span>)</span><br><span class="line">s.write(<span class="string">b"6"</span>)</span><br></pre></td></tr></table></figure>
<p>至于为什么要用<code>b&quot;&quot;</code>这样的形式，因为serial这个库<strong>发送和读取</strong>的数据都是字节类型。蓝牙HC-05的使用是我经历的最难的一部分，主要的坑是：只有在程序连接蓝牙时才算连接，而仅仅在Win10蓝牙中连接是不够的。</p>
<h2 id="Arduino向PC发送数据"><a href="#Arduino向PC发送数据" class="headerlink" title="Arduino向PC发送数据"></a>Arduino向PC发送数据</h2><p>首先来看Arduino端的程序，一般是调用println方法完成发送，调用flush方法等待数据的发送完毕。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置硬件串口通信的波特率</span></span><br><span class="line">    Serial.begin(<span class="number">9600</span>);</span><br><span class="line">    <span class="comment">// 先清空串口缓存</span></span><br><span class="line">    <span class="keyword">while</span>(Serial.available())</span><br><span class="line">        Serial.read();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置发送数据</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"asd"</span></span><br><span class="line">    <span class="comment">// 参数可以是任何类型 不一定都是字符串 </span></span><br><span class="line">    Serial.println(str);</span><br><span class="line">    <span class="comment">// 等待串口发送完毕</span></span><br><span class="line">    Serial.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在python端完成读取数据的功能：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> serial</span><br><span class="line"><span class="comment"># 读取串口数据的类</span></span><br><span class="line"></span><br><span class="line">s = serial.Serial(port=<span class="string">'COM6'</span>,</span><br><span class="line">                baudrate=<span class="number">9600</span>,</span><br><span class="line">                stopbits=serial.STOPBITS_ONE)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 读取数据</span></span><br><span class="line">    data = s.readline()</span><br><span class="line">    <span class="keyword">if</span> data == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>同样读取的数据为字节类型，通常为这样的格式：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">b'1\r\n'</span></span><br><span class="line"><span class="string">b'1\r\n'</span></span><br><span class="line"><span class="string">b'1\r\n'</span></span><br><span class="line"><span class="string">b'1\r\n'</span></span><br><span class="line"><span class="string">b'1\r\n'</span></span><br><span class="line"><span class="string">b'1\r\n'</span></span><br><span class="line"><span class="string">b'1\r\n'</span></span><br></pre></td></tr></table></figure>
<p>所以可以str(data[2:-5])这样取出其中的数值部分。</p>
<h1 id="测距功能"><a href="#测距功能" class="headerlink" title="测距功能"></a>测距功能</h1><p>选用了HC-SR04模块作为超声测距模块，购物平台5RMB左右。超声波测距的原理较为简单，首先发送特定频率的声波，在接收对应频率的声波。记录声波传输的时间，再结合声波传输的速度，很容易得到当前与障碍物的距离。测距原理图如下所示：</p>
<p><img data-src="/2020/04/23/reverse-radar-hardware/2.png" alt></p>
<p>而具体到硬件而言，测距方法如下。HC-SR04有两个喇叭，Trig发送声波，Echo接收声波。Trig是启动信号引脚，使用的时候先给他10us以上的高电平，再拉低，SR04就会发送八个40khz的超声波。此时对Echo拉低。然后就开始等待Echo啥时候变高了我们就开始计时 <strong>(开始接收到反馈的声波)</strong>， 直到他变低为止 <strong>(声波接收完毕)</strong>，当它变低的时候，我们就可以根据这个时间计算距离了。</p>
<p>这个时间是声波在空气中传播的时间，因为是往返的，所以计算过程需要除以2，变成单程的时间，再将这个单程时间乘以声速即340米/秒，得到的就是从当前位置到对面障碍物的距离。因此，得到的电路连接方式如下：</p>
<p><img data-src="/2020/04/23/reverse-radar-hardware/3.jpg" alt></p>
<p>也很容易得到相应的程序，但也有相关的注意事项：</p>
<ul>
<li>使用pulseIn函数记录Echo持续高电平的时间即可。</li>
<li>在完成一次测距后一定要延时一秒左右。因为程序的执行速度和硬件的执行速度是不一样的，程序执行完了要缓一缓，等待硬件执行完。不延时的情况下HC-SR04是不能工作的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> trigBack = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> echoBack = A0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义超声波的输入输出模式 -----------------------------</span></span><br><span class="line">    pinMode(trigBack, OUTPUT);</span><br><span class="line">    pinMode(echoBack, INPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先拉底做初始化</span></span><br><span class="line">    digitalWrite(trigBack, LOW);</span><br><span class="line">    delayMicroseconds(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 拉高十毫秒</span></span><br><span class="line">    digitalWrite(trigBack, HIGH);</span><br><span class="line">    delayMicroseconds(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 在拉低</span></span><br><span class="line">    digitalWrite(trigBack, LOW);</span><br><span class="line">    <span class="comment">// 根据高电平持续的时间计算与障碍物的距离</span></span><br><span class="line">    cmB = (pulseIn(echoBack, HIGH) / <span class="number">2</span>) / <span class="number">29.1</span>;</span><br><span class="line">    Serial.println(cmB);</span><br><span class="line">    <span class="comment">// 一定要有延时</span></span><br><span class="line">    delay(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="制动功能"><a href="#制动功能" class="headerlink" title="制动功能"></a>制动功能</h1><p>车辆最基本的功能还是实现前进、后退、左转和右转，而这些功能的实现离不开电机模块。选用的电机模块是HC02-48，便宜到忘记了它的价格。但是Arduino不能直接驱动HC02-48电机完成工作，因为驱动电机需要较大电流，而Arduino的作用在于高低电平的控制而不是电流的输出。Arduino的IO口输出电流在40mA左右，无法驱动最低要求150mA的电机。因此需要借助电机驱动模块L298N来放大驱动电流。</p>
<p>L298N驱动直流电机时可选择任何额定电压在4.8~35V和电流小于2A范围内的电机。而HC02-48电机的工作电压在3-6V，且L298N的输出电流恰好能驱动电机模块，因此在硬件层面可完成驱动。这个好像也很便宜，大约10RMB左右。</p>
<p>将L298N的四个入口引脚IN1，IN2，IN3和IN4接Arduino的控制引脚，此时Out1，Out2连接一个电机，Out3，Out4出口引脚连接另外的电机。通过对4个入口引脚赋值来更改出口引脚的电平输出，进而控制电机的正反转，完成前进、后退和转向的功能。此外可以通过总开关ENA，ENB两个使能端控制两个电机能否转动和转速。电路连接方式下：</p>
<p><img data-src="/2020/04/23/reverse-radar-hardware/4.jpg" alt></p>
<p>而L298N的+12V和GND接口，需要单独的电池供电。正如上文所说，Arduino的核心功能是控制电平的输出而不是提供电压，因此仅将Arduino的IO口和L298N的使能端连接即可，L298N的供电部分需要另外的电池。</p>
<h2 id="转速调节"><a href="#转速调节" class="headerlink" title="转速调节"></a>转速调节</h2><p>在倒车的过程中，车辆不能够以过高的速度倒车，否则容易发生碰撞。因此，需要PWM调制的手段将车速给降下来。想必在做的看官应该不是自动化专业的，所以我准备通俗的解释PWM的含义：</p>
<ul>
<li>在一个时间段内，一直给电机供电，那么电机会持续转动，此时是满电的输出；</li>
<li>在一个时间段内，一半的时间供电，一半的时间不供电，那么电机只会在一半的时间内转动，此时的速度会低于满电输出；</li>
<li>在一个时间段内，75%的时间不供电，25%的时间供电，那么电机会在1/4的时间内转动，此时速度会更低；</li>
<li>如果将一个时间段取极限无限的减小，那么电机就是时而供电时而没电，此时便会减速。如下图所示：</li>
</ul>
<p><img data-src="/2020/04/23/reverse-radar-hardware/5.png" alt></p>
<p>而在Arduino实现这个并不是很难，只需要调用analogWrite方法对L298N的使能端进行PWM调制即可。其中，analogWrite方法接收一个参数，参数的取值范围是[0, 255]，取值越大，输出电压越大，电机转速越快。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义两个电机驱动的使能端</span></span><br><span class="line"><span class="keyword">int</span> en1 = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> en2 = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 定义行驶速度</span></span><br><span class="line"><span class="keyword">int</span> speed = <span class="number">95</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使能端为输出模式</span></span><br><span class="line">    pinMode(en1, OUTPUT);</span><br><span class="line">    pinMode(en2, OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// speed 就是行走的速度</span></span><br><span class="line">    analogWrite(en1, speed);</span><br><span class="line">    analogWrite(en2, speed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：电机的实际转速不仅和参数speed有关，还和供电的电压有关。即使speed的取值为255，但电池没电了，电机还是会转的很慢。</p>
<h2 id="电机转动"><a href="#电机转动" class="headerlink" title="电机转动"></a>电机转动</h2><p>在能够对电机的转速进行调节后，下一步就是实现电机的转动了：</p>
<ul>
<li>四个电机都向前转，那么车辆会向前行进；</li>
<li>四个电机都向后转，那么车辆会向后行进；</li>
<li>左侧的电机向前转，右侧的电机向后转，那么车辆会向右行进；</li>
<li>左侧的电机向后转，右侧的电机向前转，那么车辆会向左行进；</li>
</ul>
<p>仅需要digitalWrite方法对电机两侧输入不同的电平即可完成电机的转动，因此代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 右前轮 -----------------------------------------</span></span><br><span class="line"><span class="comment">// 定义 uno 的 pin 8 向 input1 输出</span></span><br><span class="line"><span class="keyword">int</span> input1 = <span class="number">8</span>; </span><br><span class="line"><span class="comment">// 定义 uno 的 pin 12 向 input2 输出</span></span><br><span class="line"><span class="keyword">int</span> input2 = <span class="number">10</span>; </span><br><span class="line"><span class="comment">// 左前轮 -----------------------------------------</span></span><br><span class="line"><span class="comment">// 定义 uno 的 pin 11 向 input3 输出</span></span><br><span class="line"><span class="keyword">int</span> input3 = <span class="number">11</span>; </span><br><span class="line"><span class="comment">// 定义 uno 的 pin 12 向 input4 输出</span></span><br><span class="line"><span class="keyword">int</span> input4 = <span class="number">12</span>; </span><br><span class="line"><span class="comment">// 右后轮 -----------------------------------------</span></span><br><span class="line"><span class="comment">// 定义 uno 的 pin 3 向 input5 输出</span></span><br><span class="line"><span class="keyword">int</span> input5 = <span class="number">3</span>; </span><br><span class="line"><span class="comment">// 定义 uno 的 pin 4 向 input6 输出</span></span><br><span class="line"><span class="keyword">int</span> input6 = <span class="number">4</span>; </span><br><span class="line"><span class="comment">// 左后轮 -----------------------------------------</span></span><br><span class="line"><span class="comment">// 定义 uno 的 pin 5 向 input7 输出</span></span><br><span class="line"><span class="keyword">int</span> input7 = <span class="number">5</span>; </span><br><span class="line"><span class="comment">// 定义 uno 的 pin 6 向 input8 输出</span></span><br><span class="line"><span class="keyword">int</span> input8 = <span class="number">7</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使能端</span></span><br><span class="line">    pinMode(en1, OUTPUT);</span><br><span class="line">    pinMode(en2, OUTPUT);</span><br><span class="line">    <span class="comment">// 右前</span></span><br><span class="line">    pinMode(input1, OUTPUT);</span><br><span class="line">    pinMode(input2, OUTPUT);</span><br><span class="line">    <span class="comment">// 左前  </span></span><br><span class="line">    pinMode(input3, OUTPUT);</span><br><span class="line">    pinMode(input4, OUTPUT);</span><br><span class="line">    <span class="comment">// 右后</span></span><br><span class="line">    pinMode(input5, OUTPUT);</span><br><span class="line">    pinMode(input6, OUTPUT);</span><br><span class="line">    <span class="comment">// 左后  </span></span><br><span class="line">    pinMode(input7, OUTPUT);</span><br><span class="line">    pinMode(input8, OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进函数 ------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    analogWrite(en1, speed);</span><br><span class="line">    analogWrite(en2, speed);</span><br><span class="line">    <span class="comment">// 右前轮</span></span><br><span class="line">    digitalWrite(input1, LOW); </span><br><span class="line">    digitalWrite(input2, HIGH);   </span><br><span class="line">    <span class="comment">// 右后轮</span></span><br><span class="line">    digitalWrite(input5, HIGH);</span><br><span class="line">    digitalWrite(input6, LOW);</span><br><span class="line">    <span class="comment">// 左后轮</span></span><br><span class="line">    digitalWrite(input7, HIGH);</span><br><span class="line">    digitalWrite(input8, LOW);</span><br><span class="line">    <span class="comment">// 左前轮 </span></span><br><span class="line">    digitalWrite(input3, LOW); </span><br><span class="line">    digitalWrite(input4, HIGH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止函数 ------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 左前轮</span></span><br><span class="line">    digitalWrite(input1, LOW); </span><br><span class="line">    digitalWrite(input2, LOW);  </span><br><span class="line">    <span class="comment">// 左后轮</span></span><br><span class="line">    digitalWrite(input7, LOW);</span><br><span class="line">    digitalWrite(input8, LOW);</span><br><span class="line">    <span class="comment">// 右前轮 </span></span><br><span class="line">    digitalWrite(input3, LOW); </span><br><span class="line">    digitalWrite(input4, LOW);</span><br><span class="line">    <span class="comment">// 右后轮</span></span><br><span class="line">    digitalWrite(input5, LOW);</span><br><span class="line">    digitalWrite(input6, LOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退函数 ------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    analogWrite(en1, speed);</span><br><span class="line">    analogWrite(en2, speed);</span><br><span class="line">    <span class="comment">// 右前轮</span></span><br><span class="line">    digitalWrite(input1, HIGH); </span><br><span class="line">    digitalWrite(input2, LOW);  </span><br><span class="line">    <span class="comment">// 右后轮</span></span><br><span class="line">    digitalWrite(input5, LOW);</span><br><span class="line">    digitalWrite(input6, HIGH);</span><br><span class="line">    <span class="comment">// 左后轮</span></span><br><span class="line">    digitalWrite(input7, LOW);</span><br><span class="line">    digitalWrite(input8, HIGH);</span><br><span class="line">    <span class="comment">// 左前轮 </span></span><br><span class="line">    digitalWrite(input3, HIGH); </span><br><span class="line">    digitalWrite(input4, LOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左转函数 ------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    analogWrite(en1, speed);</span><br><span class="line">    analogWrite(en2, speed);</span><br><span class="line">    <span class="comment">// 左后轮</span></span><br><span class="line">    digitalWrite(input7, LOW);</span><br><span class="line">    digitalWrite(input8, HIGH);</span><br><span class="line">    <span class="comment">// 左前轮 </span></span><br><span class="line">    digitalWrite(input3, HIGH); </span><br><span class="line">    digitalWrite(input4, LOW);</span><br><span class="line">    <span class="comment">// 右前轮</span></span><br><span class="line">    digitalWrite(input1, LOW); </span><br><span class="line">    digitalWrite(input2, HIGH);  </span><br><span class="line">    <span class="comment">// 右后轮</span></span><br><span class="line">    digitalWrite(input5, HIGH);</span><br><span class="line">    digitalWrite(input6, LOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右转函数 ------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">right</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    analogWrite(en1, speed);</span><br><span class="line">    analogWrite(en2, speed);</span><br><span class="line">    <span class="comment">// 左后轮</span></span><br><span class="line">    digitalWrite(input7, HIGH);</span><br><span class="line">    digitalWrite(input8, LOW);</span><br><span class="line">    <span class="comment">// 左前轮 </span></span><br><span class="line">    digitalWrite(input3, LOW); </span><br><span class="line">    digitalWrite(input4, HIGH);</span><br><span class="line">    <span class="comment">// 右前轮</span></span><br><span class="line">    digitalWrite(input1, HIGH); </span><br><span class="line">    digitalWrite(input2, LOW);  </span><br><span class="line">    <span class="comment">// 右后轮</span></span><br><span class="line">    digitalWrite(input5, LOW);</span><br><span class="line">    digitalWrite(input6, HIGH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    delay(<span class="number">3000</span>);</span><br><span class="line">    forward();</span><br><span class="line">    delay(<span class="number">3000</span>);</span><br><span class="line">    back();</span><br><span class="line">    delay(<span class="number">3000</span>);</span><br><span class="line">    stop();</span><br><span class="line">    delay(<span class="number">3000</span>);</span><br><span class="line">    right();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，电平高低的输出需要根据实际的接线情况来判断。</p>
<h1 id="供电系统"><a href="#供电系统" class="headerlink" title="供电系统"></a>供电系统</h1><p>全部系统的供电系统分为两部分，一个是给Arduino供电，一个是给L298N电机供电。</p>
<ul>
<li><p>对于给Arduino供电，我选择了使用电源接口为Arduino供电。通过此方法为Arduino开发板供电时，直流电源电压为9V ~ 12V，买一个9V电池和转接线即可。使用低于9V的电源电压可能导致Arduino工作不稳定，使用高于12V电源电压存在着毁坏Arduino开发板的风险。<img data-src="/2020/04/23/reverse-radar-hardware/6.jpg" alt></p>
</li>
<li><p>对于给L298N供电，选择的是3.7V 18650可充电锂电池，在配一个电池盒即可。电池盒要求是串联的，而不是并联，否则电压不够。将电池盒自带的红色线与L298N的+12V连接，将黑色线与L298N的GND连接即可完成电机部分的供电。</p>
</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>接线并不是很复杂，我都是用的杜邦线接起来的，大胆的去尝试就好了。有问题也欢迎在下方留言，毕竟计算机搞这些可能也是一头雾水，上文都是我一点点摸索出来的经验。</p>
<p><img data-src="/2020/04/23/reverse-radar-hardware/7.jpg" alt></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.taichi-maker.com/homepage/arduino-projects-index/arduino-power-supply/" target="_blank" rel="noopener">http://www.taichi-maker.com/homepage/arduino-projects-index/arduino-power-supply/</a></li>
<li><a href="http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/" target="_blank" rel="noopener">http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/</a></li>
<li><a href="http://www.taichi-maker.com/?s=HC-SR04" target="_blank" rel="noopener">http://www.taichi-maker.com/?s=HC-SR04</a></li>
</ol>
]]></content>
      <tags>
        <tag>microcomputer</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫系列（二）——操控浏览器模拟访问、点击与设置等待</title>
    <url>/2020/01/11/resptile/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关于如何实现爬虫，可以简单看这里：<a href="https://muyuuuu.github.io/2019/02/24/school-start1/">入门级别的难度，两个例子</a>。</p>
<p>更主要的目的是，把当时上课讲过的<code>Selenium</code>整理一下，毕竟当时我还做<code>PPT</code>上去讲课来，<code>Selenium</code>虽然是自动化测试工具，但也可以很好的用在爬虫领域。</p>
<p>在很多网页中使用了<code>Ajax</code>技术，即：你往下翻阅或者点击加载更多按钮才会加载剩下的内容，否则不会加载你暂时不看的内容。或者网页使用了反爬虫技术，爬取速度过快会严重影响对方服务器的流量，提高对方的成本，因此对方服务器会把你拉黑防止你的爬虫行为。</p>
<p>如何解决呢？</p>
<a id="more"></a>
<p>对于第一类问题，可以靠<code>Selenium</code>模拟网页浏览、按钮点击动作解决；<br>对于第二类问题，可以设置两种等待方式，放缓爬取速度，避免被拉黑。</p>
<p>所需软件和库：</p>
<ul>
<li><code>selenium</code> pip install 即可</li>
<li><code>chromeWebdriver</code> <a href="https://chromedriver.chromium.org/downloads" target="_blank" rel="noopener">下载安装</a>（firefox也有这个类似的）。我放到了D盘的根目录下，所以路径为’D:/chromedriver.exe’。</li>
</ul>
<h1 id="模拟按钮点击下一页"><a href="#模拟按钮点击下一页" class="headerlink" title="模拟按钮点击下一页"></a>模拟按钮点击下一页</h1><p>以著名的<code>ICU996</code>为例，我想看哪些人<code>star</code>了这个项目，且<code>star</code>这也页面的域名毫无规律可言，必须使用点击下一页的按钮才能看到下一页的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬取网页的根域名</span></span><br><span class="line">star_url = <span class="string">r"https://github.com/996icu/996.ICU/stargazers"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个driver用于打开网页，记得找到brew安装的chromedriver的位置，在创建driver的时候指定这个位置</span></span><br><span class="line">driver = webdriver.Chrome(<span class="string">r'D:/chromedriver.exe'</span>)</span><br><span class="line"><span class="comment"># 打开网页</span></span><br><span class="line">driver.get(star_url)</span><br><span class="line"></span><br><span class="line">name_counter = <span class="number">1</span></span><br><span class="line">page = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> page &lt; <span class="number">500</span>: <span class="comment"># 爬500页的，这里是手工指定的 | 每页30个人 共249000人 </span></span><br><span class="line">    print(page)</span><br><span class="line">    soup = BeautifulSoup(driver.page_source, <span class="string">"lxml"</span>)</span><br><span class="line">    data = p.findall(str(soup.body))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        i = i.strip(<span class="string">'Works for "'</span>)</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> df.index:</span><br><span class="line">            po=df.loc[[i],:]</span><br><span class="line">            po.Sum += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            df.loc[i] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># selenium的xpath用法，找到包含“下一页”的a标签去点击</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"//a[contains(text(),'Next')]"</span>).click() </span><br><span class="line">    page = page + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 睡0.5秒让网页加载完再去读它的html代码 防止爬虫过猛</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>) </span><br><span class="line">df.to_csv(<span class="string">'9961.csv'</span>, sheet_name = <span class="string">'watch'</span>)</span><br></pre></td></tr></table></figure>
<p>这样一个简单的代码就完成了，但是爬下来的<a href="/download/9961.csv">数据</a>没有经过处理，如<code>NCST</code>，<code>NCUST</code>和华北理工大学表示的是一个东西，数据应该经过后期处理整合，但这里在说爬虫，到此为止。</p>
<p>在上面的例子中，已经介绍了一种等待方式：显示等待，<code>time.sleep(0.5)</code>，而这也是显示等待中最糟糕的一个。即到这里强行停止0.5秒，然后在访问下一页，防止爬中速度快被拉黑。</p>
<h1 id="模拟浏览器翻阅"><a href="#模拟浏览器翻阅" class="headerlink" title="模拟浏览器翻阅"></a>模拟浏览器翻阅</h1><p>主要是用代码控制浏览器，完成向下翻阅浏览的功能，两点好处：</p>
<ul>
<li>使服务器辨别不出来是人在看他的网页还是机器在看他的网页。</li>
<li>触发<code>Ajax</code>，使浏览器自动加载剩下的内容，而不用使人去手动翻阅加载。如下图所示：</li>
</ul>
<p><img data-src="/2020/01/11/resptile/1.png" alt></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">r'D:/chromedriver.exe'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scroll_down</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (num):</span><br><span class="line">        <span class="comment"># 向下翻阅1000个像素单位</span></span><br><span class="line">        driver.execute_script(<span class="string">"window.scrollBy(0,1000)"</span>)</span><br><span class="line">        <span class="comment">#　停两秒在向下翻阅 等他加载</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻阅10次</span></span><br><span class="line">scroll_down(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p><code>(0, 1000)</code>中的<code>0</code>表示水平翻阅0个像素点，<code>1000</code>表示向下翻阅1000个像素点。还记得屏幕的分辨率是<code>1920X1080</code>吗，1080就是指竖直方向排列的像素点的数量。记住这段代码，一会儿配合其他任务一起用。</p>
<h1 id="设置页面等待"><a href="#设置页面等待" class="headerlink" title="设置页面等待"></a>设置页面等待</h1><h2 id="隐性等待"><a href="#隐性等待" class="headerlink" title="隐性等待"></a>隐性等待</h2><p>官方文档永远是第一：<br><a href="https://selenium-python-zh.readthedocs.io/en/latest/waits.html" target="_blank" rel="noopener">https://selenium-python-zh.readthedocs.io/en/latest/waits.html</a></p>
<p>如果某些元素不是立即可用的（可能页面不会第一时间加载该元素，可能浏览器翻阅到一定位置才加载），隐式等待是告诉WebDriver去等待一定的时间后去查找元素。 默认等待时间是0秒，一旦设置该值，隐式等待是设置该WebDriver的实例的生命周期（意思是：设置隐性等待30秒的话，全部代码全部的等待时间是30秒，第一次等了12秒，后续代码就只有剩下的18秒可用了）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">r'D:/chromedriver.exe'</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)  <span class="comment"># 隐性等待，最长等 10 秒</span></span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">'https://cn.bing.com'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常可以查找到</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    driver.find_element_by_id(<span class="string">'sb_form_q'</span>)</span><br><span class="line">    print(<span class="string">'yes'</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'false'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 查找不到</span></span><br><span class="line">since = time.time()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    driver.find_element_by_id(<span class="string">'bs_form_q'</span>)</span><br><span class="line">    print(<span class="string">'yes 1'</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'false 1'</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    driver.quit()</span><br><span class="line">    </span><br><span class="line">print(end - since)</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yes</span><br><span class="line">false <span class="number">1</span></span><br><span class="line"><span class="number">10.114457607269287</span></span><br></pre></td></tr></table></figure>
<p>因为第一次能找到，所以输出<code>yes</code>，第二次找不到，等了10秒，输出了<code>false</code>。重点：一定要用异常捕获，否则寻找不到代码会强行停止，影响后续代码执行。</p>
<p>当然隐性等待只用于加载元素，而<code>不是</code>打开网页：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">r'D:/chromedriver.exe'</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)  <span class="comment"># 隐性等待，最长等 10 秒</span></span><br><span class="line"></span><br><span class="line">page = [</span><br><span class="line">    <span class="string">"https://www.qq.com/"</span>,</span><br><span class="line">    <span class="string">"https://baidu.com"</span>,</span><br><span class="line">    <span class="string">"https://cn.bing.com"</span>,</span><br><span class="line">    <span class="string">"https://www.google.com/"</span>,  <span class="comment"># skip it automatic</span></span><br><span class="line">    <span class="string">"https://baidu.com"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> page:</span><br><span class="line">    since = time.time()</span><br><span class="line">    driver.get(url)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(end - since)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>
<p>输出如下（第四行输出显示：等了三十秒没打开网页 已经超出了设置的10秒，所以隐形等待是用来加载元素而不是加载整个网页）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3.0922935009002686</span></span><br><span class="line"><span class="number">1.215383768081665</span></span><br><span class="line"><span class="number">13.705082416534424</span></span><br><span class="line"><span class="number">33.13365077972412</span>   <span class="comment"># 等了三十秒没打开网页 已经超出了设置的10秒</span></span><br><span class="line"><span class="number">0.6389157772064209</span></span><br></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以<a href="https://gallery.echartsjs.com/explore.html#sort=rank~timeframe=all~author=all" target="_blank" rel="noopener">ECharts数据可视化实验室网站</a>为例，（百度 ECharts 团队创建，联合公司内外众多数据可视化从业人组成的技术研究虚拟组织，致力于数据可视化的相关研究、教育普及、产品研发及生态建设。），虽然是百度的，但是这个可视化网站还不错。</p>
<p>而这个网站使用了<code>Ajax</code>技术，不往下翻阅是不会加载内容的，正好用上之前写的控制浏览器翻阅的代码。</p>
<blockquote>
<p>我往下翻阅了很久，有个实例的作者叫 隐居威海 ，我们来爬取这个作者。（当然那个网站一直在变动，可能这个名字没了，或者加入了新的用例需要多翻阅几次，或者本次代码实效都很正常，主要介绍理念。我几个月前还是可以运行的。）</p>
<p>以下代码的效果：不往下翻阅浏览器加载不出来，只有向下加载才能定位到目标元素。意思是，不写<code>scroll_down(10)</code>会报错，写了这个函数才能爬取到。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">r'D:/chromedriver.exe'</span>)</span><br><span class="line"><span class="comment"># 隐性等待，最长等 30 秒</span></span><br><span class="line">driver.implicitly_wait(<span class="number">30</span>) </span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">"https://gallery.echartsjs.com/explore.html#sort=rank~timeframe=all~author=all"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scroll_down</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (num):</span><br><span class="line">        driver.execute_script(<span class="string">"window.scrollBy(0,1000)"</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    since = time.time()</span><br><span class="line">    <span class="comment"># 向下翻阅 10 次</span></span><br><span class="line">    scroll_down(<span class="number">10</span>) <span class="comment"># 这个代码注释掉程序会输出 loading......</span></span><br><span class="line">    <span class="comment"># 因为下面有个作者是叫 隐居威海</span></span><br><span class="line">    print(driver.find_element_by_link_text(<span class="string">'隐居威海'</span>).text)</span><br><span class="line">    end = time.time()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'loading....'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(end - since)</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure>
<p>写<code>scroll_down(10)</code>的输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">隐居威海</span><br></pre></td></tr></table></figure>
<p>不写<code>scroll_down(10)</code>的输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loading....</span><br><span class="line"><span class="number">30.12252512365</span></span><br></pre></td></tr></table></figure>
<h2 id="显性等待"><a href="#显性等待" class="headerlink" title="显性等待"></a>显性等待</h2><p>第一种等待方式<code>time.sleep</code>已经在<code>模拟按钮点击下一页</code>这一内容下介绍，并给出了程序实例，这也是最糟糕的。强制让浏览器等待X秒，不管当前操作是否完成，是否可以进行下一步操作，都必须等X秒的时间。</p>
<ul>
<li><p>缺点：不能准确把握需要等待的时间（有时操作还未完成，等待就结束了，导致报错；有时操作已经完成了，但等待时间还没有到，浪费时间），如果在用例中大量使用，会浪费不必要的等待时间，影响执行效率。</p>
</li>
<li><p>优点：使用简单，可以在调试时使用。</p>
</li>
</ul>
<p>另一种显示等待：程序每隔xx秒看一眼，如果条件成立了，则执行下一步，否则继续等待，直到超过设置的最长时间，然后抛出TimeoutException。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(<span class="string">r'D:/chromedriver.exe'</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">15</span>)  </span><br><span class="line"><span class="comment"># 隐性等待和显性等待可以同时用，但要注意：等待的最长时间取两者之中的大者</span></span><br><span class="line">driver.get(<span class="string">'https://liam.page/'</span>)</span><br><span class="line">locator = (By.LINK_TEXT, <span class="string">'NexT.Gemini'</span>)</span><br><span class="line"></span><br><span class="line">since = time.time()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    WebDriverWait(driver, <span class="number">10</span>, <span class="number">0.5</span>).until(EC.presence_of_element_located(locator))</span><br><span class="line">    print(<span class="string">'yes'</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'no'</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    end = time.time()</span><br><span class="line">    driver.close()</span><br><span class="line">    </span><br><span class="line">print(end - since)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yes</span><br><span class="line"><span class="number">0.019946813583374023</span></span><br></pre></td></tr></table></figure>
<p>可见用了不到一秒的时间加载了该元素。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如果我们设置了隐性等待和显性等待，最长的等待时间取决于两者之间的大者，如果隐性等待时间 &gt; 显性等待时间，则该句代码的最长等待时间等于隐性等待时间。</p>
<p>可以很好的利用自动化测试工具<code>Selenium</code>的元素查找、等待模式来完成爬虫中的工作。</p>
<p>等哪天心血来潮再去看看多线程异步爬虫吧。</p>
]]></content>
      <tags>
        <tag>Resptile</tag>
      </tags>
  </entry>
  <entry>
    <title>循环神经网络</title>
    <url>/2019/02/18/rnn/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>趁寒假看完了DeepLearning的前生今世之后，用了一个下午自己推导了一番，想来还是留下个电子版的整理，供他人交流和日后查阅。（其实是我纸质版整理的太丑了）。</p>
<p>本文收录内容：</p>
<ul>
<li>循环神经网络的基本概念</li>
<li>循环网络的经典结构</li>
<li>LSTM与GRU的keras实现，自行查阅keras文档喽</li>
</ul>
<p>重点是对于这些概念的理解，尽力写下人能看懂的公式描述，知道在什么背景下调用和背后的数学观念就可以啦。</p>
<a id="more"></a>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在NLP开车，语音识别，视频处理，机器翻译等领域，和面临着一段连续的输入，这个输入的前后还有关系，比如机器翻译时：</p>
<blockquote>
<center><span id="inline-blue">The cats are full then sleeping on the tree.</span></center>


</blockquote>
<p>我英语比较差，这句话的意思是一群猫吃饱了在树上睡觉，用are的原因是前面是cats复数，so，像这样序列化的输入，前后有关系的样本数据，通常会采用循环神经网络进行训练。</p>
<p>如果这类输入采用普通的全连接神经网络的话，每个句子长短不一，第一层神经元的数量怎么定义是不是？</p>
<h2 id="萌新阶段"><a href="#萌新阶段" class="headerlink" title="萌新阶段"></a>萌新阶段</h2><p>建立一个网络来判断一个单词是不是人名，这个技术在搜索引擎中会被用到。</p>
<p>当然为什么不采用查词典的技术呢？比如用查字典的方法也能解决，学过数据结构的话，知道这种情况建立索引查询会更快。如果一个人的名字是White(怀特)，总不能翻译成白色吧，判断是否是人名还得根据语境。</p>
<p><img data-src="/2019/02/18/rnn/1.png" alt></p>
<p>如上图所示，一个单词是一个输入，一句话是一个样本，1表示为人名，0表示不是。那么构建个什么样子的网络进行训练呢？而且还得解决每个样本输入维度不统一的问题。网络结构如下：</p>
<p><img data-src="/2019/02/18/rnn/2.png" alt></p>
<p>然后来解释下网络是如何运行的，参数的含义：</p>
<p>首先，$T_x$表示一个样本中单词的数量，$\hat{y}^{<1>}$表示对样本中第一个单词的预测，$a$就是个中间变量，图上画得一个方框加四个圈表示计算过程。$X^{<1>}$会经过one-hot编码处理，假设样本数据库共有10000个单词，$X^{<1>}$为第一个单词，假设在词典排序中的位置为7893，那么$X^{<1>}$就是一个长度为10000，只有第7893个位置是1的零向量，其余单词也是经过one-hot处理数值化。Keras中使用序列模型进行分类时，通常都会对类别进行one-hot编码：</1></1></1></1></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keras</span><br><span class="line">y_labels = keras.utils.to_categorical(y_label, num_classes=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>$a^{<0>}$是个初始化的零向量，推算$a^{<1>}$和$\hat{y}^{<1>}$的方式为：<br>\begin{equation}<br>a^{<1>}=g(W_{aa}a^{<0>}+W_{ax}X^{<1>}+b_a)<br>\end{equation}<br>$g$表示某种激活函数如RELU，$W_{aa}$为和$a$相乘的参数，$W_{ax}$表示和样本输入相乘的参数。输出的$a^{<1>}$为下一层的输入。<br>\begin{equation}<br>\hat{y}^{<1>}=f(W_{ya}a^{<1>}+b_y)<br>\end{equation}<br>$f$表示某种激活函数如RELU，$W_{ya}$为另外的和$a$相乘的参数。此外，在循环神经网络中参数是共享的以减少计算复杂度，对于之后每个输入的单词，$W_{ya},W_{ax},W_{aa}$都是一样的。</1></1></1></1></0></1></1></1></0></p>
<p>推广到一般形式，第$t$个输入的单词(第$t$个时间步)的计算为：</p>
<p><img data-src="/2019/02/18/rnn/3.png" alt></p>
<p>这样，有几个单词就有几个$X$，这个网络就走几次，输入结束的话也就停止。在训练时，方向传播成本函数$y$与$\hat{y}$的交叉熵来梯度下降，最终达到预测的目标。</p>
<hr>
<h2 id="推广结构"><a href="#推广结构" class="headerlink" title="推广结构"></a>推广结构</h2><p>也许会好奇，在机器翻译时，输入与输出的数量是不相等的呀，处理影评的时候，多个单词的输入只会变成一个评分，这个时候就需要对网络的结构进行略微的修改。</p>
<center>影评：多个输入对应一个输出</center>

<p><img data-src="/2019/02/18/rnn/4.png" alt></p>
<center>音乐合成：一个输入对应多个输出</center>

<p><img data-src="/2019/02/18/rnn/5.png" alt></p>
<p>此时第一次的输出作为下一次的输入使用，利用上一次的信息推理下一次的信息，更加连贯。</p>
<center>机器翻译：输入与输出不同</center>

<p><img data-src="/2019/02/18/rnn/6.png" alt></p>
<p>其中$x$的部分称为编码器，将单词编码为数字，$y$为解码器，将数字预测为单词。这个图也可以作为生成模型的范例，以一个训练好的问答模型为例：当只有几个词作为输入时，可以预测之后最有可能输出的单词。比如简单的问答模型，输入：Mountain height is，那么能够计算出mountain height is 后面最有可能出现的几个单词，直到预测出句子结束的标志。这样就可以判断出山的高度是多少，一个简单的人工智障系统就出来了。</p>
<hr>
<h2 id="RNN的信息利用"><a href="#RNN的信息利用" class="headerlink" title="RNN的信息利用"></a>RNN的信息利用</h2><p>来一个很长很长的句子为例：</p>
<blockquote>
<center><span id="inline-blue">The cats, which eat fish, fruit and vegetables brought store are full then sleeping on the tree.</span></center>

</blockquote>
<p>意思是，一群猫吃了从商店买来的鱼，水果和蔬菜后，吃饱了在树上睡觉，cats 和 are 之间间隔了很多单词，对于普通的RNN而言，很难记忆如此长的信息，专业一点就是后面学习到的梯度反向传播到前面就没了，前面的单词是复数，后面应该用are。这个时候LSTM和GRU便登上了历史舞台。</p>
<h2 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h2><p>GRU称为门控循环单元，即在网络中设立一个门，确保神经网络在输入长文本信息后能够记忆前面的单词是复数还是单数。</p>
<p>取消前面的网络中间生成的变量$a$，这里暂时用$c$记忆细胞代替。来看一下GRU的门控结构：</p>
<p><img data-src="/2019/02/18/rnn/9.png" alt></p>
<p>此时$c$的计算方式为：</p>
<p><img data-src="/2019/02/18/rnn/7.png" alt></p>
<p>使用$\tilde{c}$来更新$c$，而是否更新则取决于记忆门$\Gamma_u$，当$\Gamma_u$为1时，更新信息，为0时取消更新。如果$\Gamma_u$一直不更新，$c$就会长时间记忆之前的信息，保持了长时间的记忆，避免了梯度消失。</p>
<p>推广到一般形式，$c$的计算形式和GRU的预测方法为：<br><img data-src="/2019/02/18/rnn/8.png" alt></p>
<h2 id="泛化为LSTM"><a href="#泛化为LSTM" class="headerlink" title="泛化为LSTM"></a>泛化为LSTM</h2><p>LSTM与GRU大同小异，在GRU记忆门的基础上添加了遗忘门$\Gamma_f$，公式如下：</p>
<p><img data-src="/2019/02/18/rnn/10.png" alt></p>
<p>$\hat{y}$的计算和以前一样，使用了遗忘门$\Gamma_f$来代替之前的$1-\Gamma_u$，也就是，GRU实际是复杂的LSTM的简化版本。实际上，LSTM有更强健的结构，也更加强大和善于记忆，缺陷就是不易计算。</p>
<p>一个极度简单的LSTM实现：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate dummy data</span></span><br><span class="line">x_train = np.random.random((<span class="number">1000</span>, <span class="number">20</span>))</span><br><span class="line">y_train = keras.utils.to_categorical(np.random.randint(<span class="number">10</span>, size=(<span class="number">1000</span>, <span class="number">1</span>)), num_classes=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Embedding</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> LSTM</span><br><span class="line"></span><br><span class="line">max_features = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line"><span class="comment"># 嵌入层</span></span><br><span class="line">model.add(Embedding(max_features, output_dim=<span class="number">256</span>))</span><br><span class="line">model.add(LSTM(<span class="number">128</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">model.compile(loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">              optimizer=<span class="string">'rmsprop'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, batch_size=<span class="number">16</span>, epochs=<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="偷窥孔连接"><a href="#偷窥孔连接" class="headerlink" title="偷窥孔连接"></a>偷窥孔连接</h3><p>就是在LSTM中的三个门，记忆门、遗忘门、输出门的$W$乘的矩阵中$a,b$中在加入$t-1$时刻的$c$，也就是考虑了$t-1$时刻的记忆情况和输出情况，猜想他们共同影响了$t$时刻三个门的状况。(个人感觉多此一举)。</p>
<hr>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>倒车雷达(四)：PyQt5的多线程</title>
    <url>/2020/05/12/reverse-radar-multi-thread/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这可能也是我毕业设计的最终章了，由PyQt5创建两个线程，数据读取的线程负责读取Arduino发送的距离信息，主线程负责倒车雷达动画的实时显示。还是要认真一点，也算是给大学毕业一个交代。<del>然而还不开学</del></p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>根据前几章内容，我们已经实现了倒车雷达的：硬件搭建与编程、PC端上位机的动画制作两部分。结合前两篇文章的基础，在PC端的动画部分添加<strong>指令发送</strong>的界面，将Arduino硬件层的测量距离返回PC端上位机，并用距离和发送的指令来调节动画的移动，就大功告成了。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>举一个最通俗的例子，我们想实现以下的功能：在一个界面中，有一个按钮和一个计数器，点击按钮后，计数器每秒加一。就是这么简单的功能，却必须要使用多线程来实现。因为PyQt5运行后，界面所处的线程是显示线程，显示线程不断循环带保证界面的正常显示，但点击按钮后显示线程进入了每秒加一的循环且没有退出条件，所以显示线程会因长时间没响应而导致界面的卡死。</p>
<p>因此，必须要新建一个线程，即现在有两个线程。使得显示线程来显示界面，计算线程进入每秒加一的循环，互不干扰，互不卡死。至于为何不用进程，<a href="https://muyuuuu.github.io/2020/03/16/multi-process-thread/">是因为多进程之间不共享变量，不便操作</a>。</p>
<p>而倒车雷达也是如上的道理，需要两个线程，第一个显示线程来维护界面的显示，第二个串口线程来不断的读取距离数据和发送控制指令。因此，创建和串口进行交互的类（基于pyserial这个库）。因为需要将读取的距离信息返回主程序，所以在这个类内将读取的距离数据通过<strong>pyqt信号</strong>的形式发送。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取串口数据的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span><span class="params">(QThread)</span>:</span></span><br><span class="line">    <span class="comment"># 信号的返回</span></span><br><span class="line">    my_signal = pyqtSignal(str)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Com, self).__init__()</span><br><span class="line">        self.data = <span class="string">""</span></span><br><span class="line">        self.is_on = <span class="literal">True</span> </span><br><span class="line">        <span class="comment"># 创建连接实例</span></span><br><span class="line">        self.s = serial.Serial(port=<span class="string">'COM6'</span>,</span><br><span class="line">                                baudrate=<span class="number">9600</span>,</span><br><span class="line">                                stopbits=serial.STOPBITS_ONE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recv</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.sleep(<span class="number">1</span>)</span><br><span class="line">            data = self.s.readline()</span><br><span class="line">            <span class="keyword">if</span> data == <span class="string">''</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 是否打开成功</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.is_on:</span><br><span class="line">            <span class="keyword">if</span> self.s.isOpen():</span><br><span class="line">                print(<span class="string">"open success"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"open failed"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                self.data = self.recv()</span><br><span class="line">                <span class="comment"># 将读取的数据返回</span></span><br><span class="line">                self.my_signal.emit(str(self.data))    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送各种指令</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s.write(<span class="string">b"2"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s.write(<span class="string">b"0"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s.write(<span class="string">b"1"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">left</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s.write(<span class="string">b"3"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">right</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s.write(<span class="string">b"4"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">begin</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s.write(<span class="string">b"5"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lift</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s.write(<span class="string">b"6"</span>)</span><br></pre></td></tr></table></figure>
<p>在主程序中实例化这个线程的类，并通过start方法来启动。因为这个类会不断的将距离信息作为信号通过emit方法进行反馈。因此我们需要将这个信号连接至一个函数，那么这个函数就可以读取返回的距离信息。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">self.com = Com()</span><br><span class="line">self.com.my_signal.connect(self.run)</span><br><span class="line"><span class="comment"># 启动线程</span></span><br><span class="line">self.com.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># distance 就是 my_signal emit 返回的距离信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, distance)</span>:</span></span><br><span class="line">    self.dis = distance</span><br></pre></td></tr></table></figure>
<h1 id="指令发送"><a href="#指令发送" class="headerlink" title="指令发送"></a>指令发送</h1><p>指令的发送主要负责控制车辆的前进、后退等移动。其实嘛，指令的发送很简单，我们只需要做几个按钮，点击按钮发送对应的指令就好了。在上一章节已经实现了接收Arduino发来的数据的功能，且预留了形如<code>def lift()</code>等发送指令的接口，此时仅需要将发送指令的按钮和那些接口相对应即可，代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">btn_start = QPushButton(<span class="string">"倒车"</span>)</span><br><span class="line">btn_start.setFixedSize(<span class="number">100</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">btn_forward = QPushButton(<span class="string">"前进"</span>)</span><br><span class="line">btn_forward.setFixedSize(<span class="number">100</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">btn_left = QPushButton(<span class="string">"左转"</span>)</span><br><span class="line">btn_left.setFixedSize(<span class="number">100</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">btn_stop = QPushButton(<span class="string">"停车"</span>)</span><br><span class="line">btn_stop.setFixedSize(<span class="number">100</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">btn_right = QPushButton(<span class="string">"右转"</span>)</span><br><span class="line">btn_right.setFixedSize(<span class="number">100</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">exit_btn = QPushButton(<span class="string">"退出"</span>)</span><br><span class="line">exit_btn.setFixedSize(<span class="number">100</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">btn_back = QPushButton(<span class="string">"后退"</span>)</span><br><span class="line">btn_back.setFixedSize(<span class="number">100</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将按钮与发送数据相关联</span></span><br><span class="line">btn_start.clicked.connect(self.run)</span><br><span class="line">exit_btn.clicked.connect(self.lift)</span><br><span class="line">btn_stop.clicked.connect(self.stop)</span><br><span class="line">btn_left.clicked.connect(self.left)</span><br><span class="line">btn_right.clicked.connect(self.right)</span><br><span class="line">btn_forward.clicked.connect(self.forward)</span><br><span class="line">btn_back.clicked.connect(self.back)</span><br><span class="line"></span><br><span class="line">self.com = Com()</span><br><span class="line">self.com.my_signal.connect(self.run)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lift</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.com.lift()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.com.back()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.com.left()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.com.right()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.com.stop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.com.forward()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, distance)</span>:</span></span><br><span class="line">    self.com.start()</span><br><span class="line">    self.com.begin()</span><br></pre></td></tr></table></figure>
<h1 id="实时影像"><a href="#实时影像" class="headerlink" title="实时影像"></a>实时影像</h1><p>其实，将以上两部分的内容整合起来并与前几章的内容(如车身的旋转)在结合一下，就是全部的倒车雷达的代码了。</p>
<p>完整代码如下：</p>
<p><a href="https://github.com/muyuuuu/Reversing-radar-on-Arduino/blob/master/code/Reverse-radar/view.py" target="_blank" rel="noopener">https://github.com/muyuuuu/Reversing-radar-on-Arduino/blob/master/code/Reverse-radar/view.py</a></p>
]]></content>
      <tags>
        <tag>GUI</tag>
        <tag>microcomputer</tag>
      </tags>
  </entry>
  <entry>
    <title>倒车雷达(三)：动画制作</title>
    <url>/2020/04/27/reverse-radar-software-animation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在PC端绘制倒车的动画，达到实时显示车辆的倒车情况的目的。如车辆倒退时，动画中的车辆也倒退，车辆左转时，动画也实时变化。使用的工具为QT(python)，做了一个如上形式的可视化界面。</p>
<a id="more"></a>
<ul>
<li>选择的工具为：PyQt5，QGraphicsView，QGraphicsRectItem；</li>
<li>与以往的GUI设计不同，这次的GUI开发为场景和实体的运动，而不是控件的使用；前者更偏向游戏设计，场景移动和物体的碰撞检测，后者更像使用的软件，点击按钮输入密码等；</li>
</ul>
<h1 id="设置物体"><a href="#设置物体" class="headerlink" title="设置物体"></a>设置物体</h1><p>首先创建车辆的实体，这里以方块代表车辆：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RectItem</span><span class="params">(QGraphicsRectItem)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, rect=QRectF<span class="params">()</span>)</span>:</span></span><br><span class="line">        super(RectItem, self).__init__(rect)</span><br></pre></td></tr></table></figure>
<p>而后创建场景，场景中包括车辆：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 负责绘制车辆的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicsView</span><span class="params">(QGraphicsView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(GraphicsView, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建图形容器</span></span><br><span class="line">        self.setFixedSize(<span class="number">460</span>, <span class="number">560</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将车库实体化为 宽度450 长度600 大小</span></span><br><span class="line">        self.scene = QGraphicsScene()</span><br><span class="line">        self.scene.setSceneRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">450</span>, <span class="number">550</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建车辆实例</span></span><br><span class="line">        self.rect = RectItem()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化位置为 0 30 车辆宽度 250 长度 400</span></span><br><span class="line">        self.rect.setRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">240</span>, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建颜色刷子</span></span><br><span class="line">        brush1 = QBrush(Qt.SolidPattern)</span><br><span class="line">        brush1.setColor(QColor(<span class="number">124</span>, <span class="number">214</span>, <span class="number">175</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 给车身上色</span></span><br><span class="line">        self.rect.setBrush(brush1)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将车身添加到容器中 即放到车库里</span></span><br><span class="line">        self.scene.addItem(self.rect)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置当前场景</span></span><br><span class="line">        self.setScene(self.scene)</span><br></pre></td></tr></table></figure>
<p>之后，再将场景添加到窗口中即可，伪代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">g = GraphicsView()</span><br><span class="line"><span class="comment"># g.setFixedSize(450, 550)</span></span><br><span class="line">self.car = g.rect</span><br><span class="line">self.scene = g.scene</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(self.scene.x())</span></span><br><span class="line">layout.addWidget(g)</span><br></pre></td></tr></table></figure>
<p>因初始化位置为(0, 0)，所以车辆在左上角，效果如下所示。<a href="https://github.com/muyuuuu/Reversing-radar-on-Arduino/tree/master/code/Reverse-radar" target="_blank" rel="noopener">完整代码，car_test.py</a></p>
<p><img data-src="/2020/04/27/reverse-radar-software-animation/1.jpg" alt></p>
<h1 id="物体移动"><a href="#物体移动" class="headerlink" title="物体移动"></a>物体移动</h1><p>最初的想法是：设定一组位置，通过time.sleep()设置移动速度来达到缓慢移动的效果，但这并不是可行的思路，错误的伪代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x, y = <span class="number">100</span>, <span class="number">100</span></span><br><span class="line">i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    car.setpos(i, j)</span><br><span class="line">    <span class="keyword">if</span> i &lt; x <span class="keyword">and</span> j &lt; y:</span><br><span class="line">        i += <span class="number">10</span>, j += <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>但实际是，物体会直接移动到(100, 100)，并没有中间的过程。在Qt的开发中，一定不能使用time.sleep这种方法，因为它会阻塞事件的循环，导致窗口冻结，从而阻止了GUI的重新绘制。所以在Qt中，必须使用事件来执行操作，如：分为显示事件和工作事件，显示事件负责GUI的显示，工作事件负责刷新物体的位置。如：每次触发计时器的计时时，计算物体的位置，而后显示事件负责更新。</p>
<p>此时修改车辆实体的类，增加光滑移动的方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RectItem</span><span class="params">(QGraphicsRectItem)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, rect=QRectF<span class="params">()</span>)</span>:</span></span><br><span class="line">        super(RectItem, self).__init__(rect)</span><br><span class="line">        self.setFlag(QGraphicsItem.ItemIsSelectable, <span class="literal">True</span>)</span><br><span class="line">        self.setFlag(QGraphicsItem.ItemSendsGeometryChanges, <span class="literal">True</span>)</span><br><span class="line">        self._pos_animation = QVariantAnimation()</span><br><span class="line">        self._pos_animation.valueChanged.connect(self.setPos)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_smooth</span><span class="params">(self, end, duration)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._pos_animation.state() == QAbstractAnimation.Running:</span><br><span class="line">            self._pos_animation.stop()</span><br><span class="line">        self._pos_animation.setDuration(duration)</span><br><span class="line">        self._pos_animation.setStartValue(self.pos())</span><br><span class="line">        self._pos_animation.setEndValue(end)</span><br><span class="line">        self._pos_animation.start()</span><br></pre></td></tr></table></figure>
<p>而后设置计时器及时触发即可：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">btn_start.clicked.connect(self.run)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_pos</span><span class="params">(self, scene)</span>:</span></span><br><span class="line">    Left = [<span class="number">40</span>]</span><br><span class="line">    Center = [<span class="number">40</span>]</span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> scene.items():</span><br><span class="line">        self.item = it</span><br><span class="line">        <span class="keyword">for</span> left, center <span class="keyword">in</span> zip(Left, Center):</span><br><span class="line">            pos = QPointF(left, center)</span><br><span class="line">            <span class="keyword">if</span> hasattr(it, <span class="string">'move_smooth'</span>):</span><br><span class="line">                it.move_smooth(pos, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, distance)</span>:</span></span><br><span class="line">    <span class="comment"># 偏函数传入函数和参数</span></span><br><span class="line">    wrapper = partial(self.move_pos, self.scene)</span><br><span class="line">    timer = QTimer(interval=<span class="number">5000</span>, timeout=wrapper)</span><br><span class="line">    timer.start()</span><br><span class="line">    wrapper()</span><br></pre></td></tr></table></figure>
<p>实现效果如下，此时可以完美的时间光滑移动。<a href="https://github.com/muyuuuu/Reversing-radar-on-Arduino/blob/master/code/Reverse-radar/remove_test.py" target="_blank" rel="noopener">完整代码</a></p>
<p><img data-src="/2020/04/27/reverse-radar-software-animation/2.gif" alt></p>
<h1 id="物体旋转"><a href="#物体旋转" class="headerlink" title="物体旋转"></a>物体旋转</h1><p>我摸索了两种旋转方案，如下图所示：</p>
<p><img data-src="/2020/04/27/reverse-radar-software-animation/3.png" alt></p>
<ul>
<li>第一种旋转方案是以左上角的顶点为中心，逆时针旋转</li>
<li>第二种旋转方案是以矩形的中心为旋转点，逆时针旋转</li>
</ul>
<p>经仿真模拟，第二种方案在操作难度和展示效果两个方面均取得不错的效果。</p>
<p>那么，以此来设置旋转方案：</p>
<ul>
<li>设立向左旋转的角度self.left_angle和向右旋转的角度self.right_angle两个参数，均初始化为5度</li>
<li>向左旋转时，self.left_angle += 5, self.right_angle -= 5</li>
<li>同理，向右旋转时，self.left_angle -= 5, self.right_angle += 5</li>
<li>PyQt5默认的旋转方式是逆时针，所以向左旋转时，角度为(360 - self.left_angle)</li>
<li>scenePos()方法可以捕获当前物体左上角的坐标，因此坐标加上车身宽度的一半就是旋转点的横坐标，加上车身长度的一半就是旋转点的纵坐标</li>
<li>更严谨一点可以加上旋转角度来计算旋转点坐标的位置，因为实际的车库倒车中不会频繁的左右转动，但我选择了忽略这些误差。</li>
</ul>
<p>因此，不难得到旋转的代码：(旋转点的计算不够严谨)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">self.angle_left = <span class="number">5</span></span><br><span class="line">self.angle_right = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以车辆中心为旋转点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rorate_right</span><span class="params">(self)</span>:</span></span><br><span class="line">    pos = self.car.scenePos()</span><br><span class="line">    x = pos.x() + <span class="number">120</span></span><br><span class="line">    y = pos.y() + <span class="number">150</span></span><br><span class="line">    <span class="comment"># 设置旋转点</span></span><br><span class="line">    self.car.setTransformOriginPoint(QPointF(x, y))</span><br><span class="line">    self.car.setRotation(<span class="number">360</span> - self.angle_right)</span><br><span class="line">    self.angle_right += <span class="number">5</span></span><br><span class="line">    self.angle_left -= <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rorate_left</span><span class="params">(self)</span>:</span></span><br><span class="line">    pos = self.car.scenePos()</span><br><span class="line">    x = pos.x() + <span class="number">120</span></span><br><span class="line">    y = pos.y() + <span class="number">150</span></span><br><span class="line">    self.car.setTransformOriginPoint(QPointF(x, y))</span><br><span class="line">    self.car.setRotation(self.angle_left)</span><br><span class="line">    self.angle_left += <span class="number">5</span></span><br><span class="line">    self.angle_right -= <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>实现的效果如下。<a href="https://github.com/muyuuuu/Reversing-radar-on-Arduino/blob/master/code/Reverse-radar/rotation_test.py" target="_blank" rel="noopener">完整代码</a></p>
<p><img data-src="/2020/04/27/reverse-radar-software-animation/4.gif" alt></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>而接下来的就是读取车辆倒车时与后方障碍物的距离，根据距离信息更新动画中车辆的位置。这涉及了多线程的东西，将在下文给出实现方案。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>站在巨人的肩膀上，我们能更好的前行：</p>
<ol>
<li><a href="https://stackoverflow.com/questions/55277098/move-qgraphicsitem-continuously-in-qgraphicsscene-and-check-collision" target="_blank" rel="noopener">https://stackoverflow.com/questions/55277098/move-qgraphicsitem-continuously-in-qgraphicsscene-and-check-collision</a></li>
<li><a href="https://stackoverflow.com/questions/11147443/rotate-qgraphicspixmapitem-with-mouse" target="_blank" rel="noopener">https://stackoverflow.com/questions/11147443/rotate-qgraphicspixmapitem-with-mouse</a></li>
</ol>
]]></content>
      <tags>
        <tag>GUI</tag>
        <tag>microcomputer</tag>
      </tags>
  </entry>
  <entry>
    <title>循环神经网络的进化</title>
    <url>/2019/02/18/rnn1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>感觉一篇博客写太长也不是很好，所以把RNN拆成了两部分，在描述了经典的RNN结构之后，再来看看为了满足实际应用，RNN结构所作出的变化和适应。</p>
<p>本文收录内容：</p>
<ul>
<li>双向循环神经网络</li>
<li>深层的RNN模型</li>
<li>序列化与注意力</li>
</ul>
<p>还是在实际的背景下对于这些概念的理解，或者说是为了满足实际背景而产生了这些观念，学会变通和利用已有的知识进行问题转换。</p>
<a id="more"></a>
<h2 id="双向RNN"><a href="#双向RNN" class="headerlink" title="双向RNN"></a>双向RNN</h2><p>背景描述，来看下面的句子：</p>
<blockquote>
<center><span id="inline-blue">The mountain is four kilometers above sea level which named TEST</span></center>

</blockquote>
<p>大概意思是TEST山的海拔是四千米，当做提问模型的时候，问题是TEST mountain height is:，显然，对于RNN而言，需要了解前文的信息高度，和后文的信息名称，也就是需要综合考虑前后文的信息，这个时候，双向RNN问世了。</p>
<p>此时的网络结构为：</p>
<p><img data-src="/2019/02/18/rnn1/1.png" alt></p>
<p>即在正向传播的过程中会有中间信息$\overrightarrow{a^t}$，此时加入一个反向行走的信息$\overleftarrow{a^t}$，(我先吐槽一下mathjax真丑，功能不够强大)。当然俩个$a$和两个$a$所用的参数是不一样的，在预测$y$的时候，加入两个$a$的信息：</p>
<script type="math/tex; mode=display">\hat{y}=g(W_y[\overrightarrow{a^t},\overleftarrow{a^t}]+b_a)</script><p>简单的kears实现：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Activation</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Embedding</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> LSTM</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Bidirectional(LSTM(<span class="number">10</span>, return_sequences=<span class="literal">True</span>), input_shape=(<span class="number">5</span>, <span class="number">10</span>)))</span><br><span class="line">model.add(Bidirectional(LSTM(<span class="number">10</span>)))</span><br><span class="line">model.add(Dense(<span class="number">5</span>))</span><br><span class="line">model.add(Activation(<span class="string">'softmax'</span>))</span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>, optimizer=<span class="string">'rmsprop'</span>)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="深层RNN"><a href="#深层RNN" class="headerlink" title="深层RNN"></a>深层RNN</h2><p>这个时候总有些闲的蛋疼的人觉得原版的RNN不够舒服，想要去加深RNN的层数来追求精度(装x)效果。</p>
<p><img data-src="/2019/02/18/rnn1/2.png" alt></p>
<p>其实加入三个相互连接的层参数已经不少了，能达到绝大部分人的需求。</p>
<p>如果还想加深，那就么就是在单个输出的后面堆叠各种层，但是在后面堆叠的层中，第一个单词的层和第二个单词的层相互之间没有联系了，也就是三层之后的层中就没有$a$了，只是的单独的训练参数和预测。</p>
<h2 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h2><p>在机器翻译的过程中，或者说在人工阅读文本的过程中，更倾向的是阅读一小段文本然后翻译一小段，很少去翻译很长的句子，或者说在阅读的过程中，阅读下面的句子肯定很少记得上上文的信息。这就是注意力机制，把注意力放在附近的句子中，而不用注意很远的信息。</p>
<p>也就是，附近单词的注意力权重大，而距离越远的单词注意力权重越小。而且每个单词和每个单词所用的权重也是不一样的。</p>
<p>通俗理解：对每一个单词设立权重$\alpha$，对第一个单词而言，第一个单词与另外所有的单词$t$应该满足$\alpha_{11}$到$\alpha_{1t}$的和是1，然后第一次的记忆信息$c_1$为：</p>
<script type="math/tex; mode=display">c_1=\sum_t \alpha_{1t} a_t</script><p>为了满足记忆力的权重之和为1，借鉴softmax的处理方式，以$t$表示第$t$个输入的单词，$T$表述输入单词的长度，以$x$表示第$t$个单词和另外$x$个单词之间的联系：</p>
<script type="math/tex; mode=display">\alpha_{t,x}=\frac{\mathrm{exp}(e_{t,x})}{\sum_t^T \mathrm{exp}(e_{t,x})}</script><p>而$\mathrm{exp}(e_{t,x})$是由另外的全连接层$F$训练而来，$F$的输入为上时刻隐藏层的未激活值，即$\hat{y}$之前的值，和这一层的信息值$a_t$。即：</p>
<script type="math/tex; mode=display">e_{t,x}=f(s_{t-1};a_x)</script><p>在不断的训练后，计算出权重$\alpha_{t,x}$之后，就可以为所欲为啦～</p>
<hr>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年建模的时光</title>
    <url>/2019/04/19/romantic-time-of-modeling/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录这建模一年半至两年以来的收获，如果想学习建模请往他处，如果想看扯淡就点击阅读全文。未完待续。这篇文章始创于2018.12.03，当时写的未完待续，今天2019.4.19，想必可以结束了。</p>
<p>我为什么参加2019的美赛，当时我也问了我的老师，老师说：</p>
<blockquote>
<p>如果我不参加，那么他只带一个队(我校一个老师只能带两个队)，如果我参加，他就把最后一个名额留给我，别的队找他他都没同意。他知道我的实力，我可以找任何人参加比赛，只要我看着顺眼就行。</p>
</blockquote>
<p>当时感动了好久好久。就这样，带了一个没有建模经验的人参加了比赛(前提是什么都会的那种)，就这样，拿奖了我的建模之路也结束了。</p>
<p>获奖：</p>
<ul>
<li>2017校赛二等奖(三分之决策+层次分析)</li>
<li>2017亚太一等奖(高斯和模型+数理方程推导)</li>
<li>2018美赛二等(主成分分析+卷积模型)</li>
<li>2018泰迪杯二等(数据挖掘非数学建模，相似性分析+隐马尔科夫)</li>
<li>2018小美赛二等(逻辑分析)</li>
<li>2019美赛一等(pagerank+传染病模型+隐马尔科夫+信息熵)</li>
</ul>
<p>关于成功参赛：</p>
<ul>
<li>2017 mathorcup成功参赛(遗传算法+多目标规划)</li>
<li>2018 五一联赛成功参赛(支持向量机分类+经济和模型)</li>
<li>2017，2018两年国赛成功参赛(2017国赛博弈论+KNN分类+反距离加权，2018国赛优先级调度)</li>
<li>2018深圳杯弃赛(结果做的不尽人意)</li>
<li>电工杯，华中赛没来得及参加。</li>
</ul>
<p>关于赛前培训模拟：</p>
<ul>
<li>2011 国赛A题，城市表层土壤重金属污染分析(插值拟合+反距离加权)</li>
<li>2013 国赛B题，碎纸片拼接(模拟退火+部分手动)</li>
<li>2015 国赛A题，太阳影子定位(就各种优化算法算来算去)</li>
<li>2016 国赛A题，系泊系统的设计(各种方程写上去求解)</li>
<li>2015 美赛A题，埃博拉病毒的传播与治疗(设置规则，元胞自动机直接模拟)</li>
<li>2016 美赛C题，对大学的评估(数据清洗，评价，回归)</li>
<li>2018 美赛C题，能源分析(数据清洗，评价，预测)</li>
</ul>
<p>如果你要说，国赛做了这么多模拟题还是没拿奖，别的组抄或者造数据都能拿奖，那努力是不是没啥用。那我和你不是一类人，本文剩下的内容你也不必浪费时间。</p>
<p>每一道题我们都是认真做和讨论的，并不像其他组学生那样几天内完成，学生做不出来就去抄，没有任何意义。每一行代码都是我们自己认真写的，从不造结果；每一道模拟题我们也写了论文并让老师审查。写这篇文章的时候，真的发现自己已经老了，建模居然是很多年前的事情了。于 2022 年修改，记录当时的内心活动。</p>
<p>个人擅长数据挖掘类题目，队友编程也厉害。别的组还在费劲的用excel处理数据时，我们python已经得到所有想要的各种数据并有初步结果了；加上我丰富的对数据处理的想象力，大数据的题目很容易挖出花来。所以2019年美赛其他题都没看直接上C题，果然是一等奖。以下可能是以倒叙的方式来叙述我两年来的建模之旅。</p>
<a id="more"></a>
<h1 id="2018小美赛"><a href="#2018小美赛" class="headerlink" title="2018小美赛"></a>2018小美赛</h1><p>昨天刚刚结束了小美赛，依稀想起了考试太多去年小美赛直接弃赛的场景，当然这不是重点。一年前是在实验室呆的太晚，被锁在楼里跳窗户出去的，今年是在学院楼呆的太晚，同样被锁又跳了一次窗户。其中的某个事件承包了我一年的笑点，当然我是不会说的，我怕那孩子会火。</p>
<p>看到了凌晨一点的夜景，学校位于湿地所以空气湿度大，烟雨朦胧下有种江南烟雨的感觉，或者说是秋风萧瑟了北国的温柔。</p>
<p>把女生送回宿舍后（如果建模迫不得已熬夜，记得把女孩子送回去），具体翻墙跳窗户的细节就不说了，回了自己的寝室钻被窝睡了下去，才发现被窝竟如此舒服。第二天睡到了九点半，匆匆忙忙洗了个漱就去上课。留个纪念，凌晨一点朦胧的夜。</p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/3.jpg" alt></p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/4.jpg" alt></p>
<p>说正事，这次的小美赛做的B题。说实话没有做的出彩的地方，因为我实在想不到这个题能做的点在哪。大概去网上找了5个小时的资料，惊奇的事情发生了，第一问FIFA官方已经制定好了结果和步骤，你只需要描述一下就行；第二问官方也要求了时间和次数，在这个要求下只有一种答案；第三问官方给出了计算公式，连公式都不用学生写，抄上去算个数就行。所以我实在不知道这道题到底想干嘛，以至于一天半的时间这道题做完了，这一天半还包括上课的时间。这道题对我最大的挑战也就是写了5行代码解了个方程。其实算不上挑战，所有代码加起来抄不过五行，一分钟写完。也没有用什么工具箱求解，直接一个for循环暴力破解求出了答案。后来知道，官方要我讨论为什么出现垃圾比赛，简直蛋疼。</p>
<p>看着很轻松？其实不是。队友A写完论文后，我看了一眼，可以说是全程大改论文，因为她从最开始没有参与进来（有课），只是听我们说了这道题改怎么做，哪里该写什么。但是毕竟没有自己参与思考的过程，所以好多该注意的细节没有写，或者说写错了。</p>
<p>所以很排斥写论文的队友，（当然不是排斥这次写论文的小姐姐，我通常不会排斥长得好看的人），因为完全是在浪费时间，你要花时间给他描述，他写错了你要给他讲，还是写不对的话还要自己写，那为什么不自己写呢？以至于2018年国赛的时候，我把一道题所有的模型都建出来后，我花了半天时间就写完了论文，并没有浪费时间。同时论文写的也绝对比平时好，因为模型是我亲手建的，哪里是优点重点突出，哪里是缺点略写带过，模型之间的连接逻辑，指标之间的先后顺序与重要程度，我比谁都清楚。如果我复述一遍给别人听，第一是我可能忘了一部分细节，另外就是别人听不懂，或者听懂一点写不出来。所以我也提倡让负责模型建立的人去写论文，绝对是快准狠。选一首喜欢的音乐单曲循环，还能有什么不是一晚上解决不了的。</p>
<p>11点回宿舍后，我从凌晨3点改论文到凌晨7点。也许你想问我凌晨三点前在干嘛，11点到12点洗漱泡脚吃东西享受资本主义生活，12点后推了一个方程，初中生都会的等式：</p>
<script type="math/tex; mode=display">1-\frac{1}{1+x^{-t}}=\frac{1}{1+x^t}</script><p>恬不知耻的说，这个方程我居然推了3个小时，一直没推对。多年不学数学，数理方程的推导能力直线下降，还真是生气。</p>
<p>然后上午睡了一上午懒觉，下午过去完善一下收尾工作就没啥事了。最后那天我很佩服我的队友，把论文一句一句的翻译成了英文，我在旁边全程划水玩手机刷空间，英语我实在帮不上忙。等他们翻译好了后，我开始排版论文，我word用的还是相当熟练的调行间距、调公式、调图表分分钟搞定，写完了也就交了，整个过程很愉快。</p>
<h1 id="推荐使用-LaTeX"><a href="#推荐使用-LaTeX" class="headerlink" title="推荐使用$\LaTeX$"></a>推荐使用$\LaTeX$</h1><p>过程很愉快当然是假象。近期学了 $\LaTeX$，才发现word是多么的难用，难用到怀疑人生。第一，图表标题的编号难以调节，比如在4张图前面又插了一张图，后面的顺序都得改，中间的文字描述“图x”“表x”也得改，很累人；同理在文中插入了一个公式，后面公式的编号还得改；之后就是word的格式，最恶心人的一点，比如段前间距是几行，改一段其他段都得改；行间距是固定值还是单倍行间距，我个人喜欢固定值，因为每一行间距都一样，看起来整齐。毕竟word做不到在单倍行间距的情况下有公式和没公式行间距一样。但是固定值的情况下，公式的下标（mathtype）会显示不出来，又得重新调。不想调公式就得设置单倍行间距，但是单倍行间距看起来乱七八糟，一行宽一行窄，调来调去，很烦人，中间过程至少2-3小时。</p>
<p>当然我不是诋毁word，word的所见即所得，适合新手，拆分视图、试图大纲等功能还是很人性化的。word支持配置数学公式的字体，最新的2019版本对数学公式的排版也相当美观。如果想用就自己探索下，大学生应该具备基本的探索技能，老师讲的不一定是最好的。word有很强大的工具，比如参考文献管理、图片表格管理等，入门门槛低，但是上限很高，抱歉我没达到那个高度，我只能说精通了最底层的操作。如果还有人给你推荐用word2010，用word2003，不如一巴掌呼上去。</p>
<p>承接上文说一下MathType调公式的方法，MathType是上个世纪的技术，我很不推荐。在MathType界面里选中一个符号，按Ctrl+Shift+&gt;，或者按Ctrl+方向键，你会发现惊奇的事情，能解决公式乱飘的问题和固定值间距下不显示公式的问题，</p>
<h1 id="不要迷信学长老师"><a href="#不要迷信学长老师" class="headerlink" title="不要迷信学长老师"></a>不要迷信学长老师</h1><p>但是，这种方法很烂很难用。但是自古以来好像就是用这个软件，一味的听所谓学长学姐的经验，“用这个软件，这个软件能用”。为什么不自己探索一下呢？比如Axmath，比如 $\LaTeX$，好用程度和美观程度甩MathType几条街。至少在 $\LaTeX$里面，一键编译调格式，一键编译调公式、表格、图片的顺序，四次编译（使用BIBTEX）出参考文献，总共需要点4次按钮，一篇论文排好了，而且相当美观。</p>
<p>如果想学 $\LaTeX$，一定不要找所谓的学长和老师求经验要资料（他们学的是几十年前的技术，现在已经不适用。之前看到了一个培训机构教学 $\LaTeX$，只想说十几年前的东西居然好意思拿出来骗钱）。90%用$\LaTeX$的都是从事科研的人员或者名牌大学的研究生，因为名牌大学的研究生毕业条件是在国外知名期刊投几篇论文，而知名期刊90%是提供$\LaTeX$模板的，那种模板用word很难实现。 $\LaTeX$发展了近40年，有些代码和软件已经不能使用，请选择最新的软件，阅读官方文档，有问题使用国际版的必应搜索。百度搜索引擎和某程序员社区里的东西垃圾遍地，好多错误。</p>
<h1 id="2017校赛起步"><a href="#2017校赛起步" class="headerlink" title="2017校赛起步"></a>2017校赛起步</h1><p>继续前面的扯淡。2017年4月参加校赛，当时是4月底，队友A中途退出（那个队友居然拿手机建模，手机编辑，走了也好），队友B是我遇到的最好的队友，真的是具备强悍的编程能力，我要求的各种模型建立，从来没有一次写不出来代码。但是第一次合作不是很愉快，沟通上存在各种障碍，当时虽然想骂街，但是都忍了下来。</p>
<p>之后开启了两年搭档，各种比赛一路配合了下来。我记得是最后一晚，来了场暴雨，然而我没时间看窗外，也没时间听雨，只记得时间从晚上十点一点点走到了凌晨七点，交卷睡觉。一觉醒来阳光明媚春风醉人花香弥漫可惜缺个女朋友。我以为是上午十点，仔细一看居然是下午五点。还有老学长的一句话：所有的努力都不会白费。</p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/22.jpeg" alt></p>
<h1 id="2017mathorcup联想"><a href="#2017mathorcup联想" class="headerlink" title="2017mathorcup联想"></a>2017mathorcup联想</h1><p>之后是MathorCup，说说比完后的感受吧。第一点，刚学完好多模型还没消化，只是照着问题描述的样子强行套模型，多目标规划配遗传算法，实际并无卵用。因为多目标规划写的很烂，从模型根基就出了问题，后期模型在绚烂也只是瞎扯淡。当然也暴露出我的缺点，面对很繁琐但是不是很难的东西，我缺乏耐心，这个缺点也是致命的。之前说到的队友B写错了程序，导致结果从头错到尾，所以有必要和编程的伙伴仔细交流下处理的细节，他手中的结果掌握了你的命。结果不了了之，反正是个小比赛，结果也无所谓。</p>
<p>MathorCup后是个转折，我遇到了和我一起国赛美赛的两个队友，两场重要比赛一直没有换过。还有就是酷爱水群的我，不过我从来不水本校的群，没意思，相比之下我更愿意看看外面的世界。加了一个建模竞赛的群，没有任何广告，没有任何机构的一个纯技（深）术（夜）交（扯）流（蛋）群。我从来不关心学生的出身，双非也好四非也罢，有纯粹的兴趣爱好和乐趣便能够交流到一起。那些日子很少交流有关建模的东西，大多是在扯淡，比如日常学习，比如你的前任男友，比如你那里的学校，blabla闲聊起来无非也是这些。</p>
<p>不过我的确开阔了眼界，原来外面的世界是那样的，985学校是那样的，原来一个女孩建模起来是那么优雅和认真，原来那个女孩还会玩单片机，原来那个女孩爱逛街爱学习爱唱歌爱小动物，原来一个女孩能有这么多可爱的优点。</p>
<p>后来我的蠢蠢欲动的心被扼杀在了无尽的幻想中，死在了华北和江南的距离和直男癌入骨的我。当然有个幻想女友也很好，她会告诉你，抵住诱惑去外面更广阔的世界看一看，那里有更美丽的风景。后来，这个群里好多人都拿了奖，比我大一岁的去考研了，跟我一样大的继续在建模这条不归路上越走越远。</p>
<h1 id="2017暑期培训"><a href="#2017暑期培训" class="headerlink" title="2017暑期培训"></a>2017暑期培训</h1><p>按学校惯例，每年的国赛前和美赛前都必须有一个多月的培训，必须参加培训，不参加不给报名。每天上午八点半到十二点，中午一点半到五点，晚上六点半到九点，专人检查，而且坚决不放假，一直培训直到比赛。条件讲真跟高中比一点都不艰苦，还能忍，什么顶着大热天跑机房，什么零下几度吃不到一点热乎饭，这种垃圾鸡汤就不说了，这种条件都觉得累还有什么资格当学生，去饭店当服务生吗？</p>
<p>来匆忙的2017国赛和一个转专业考试以及匆匆忙忙的转专业后的实习中，那个群被解散了，幻想女友没了，国赛凉了，又回归了现实，学学习，看看书，跑跑步，日子平平淡淡波澜不惊。一个标准理工男的世界：比赛，学习，看书，跑步，然后再无其他，说出来你可能不信，我不玩游戏，这是上大学前立的flag，什么王者荣耀、英雄联盟、吃鸡一点不会，闲来无事也只是玩玩蜘蛛纸牌和看看电影。</p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/19.jpeg" alt></p>
<h1 id="2017国赛反思"><a href="#2017国赛反思" class="headerlink" title="2017国赛反思"></a>2017国赛反思</h1><p>2017国赛是怎么凉的呢？第一晚我兴奋了，我能说我一晚上把所有问题的模型都想好了吗，然后第二天开工，电脑面前直接刚了二十多个小时。然而还是我那个致命的缺点，面对繁琐没有难度的东西，我没耐心。导致的后果就是，前期没检查论文，而且错了一堆漏洞没有修改，后期在没完没了的修BUG。以至于我累的半死，队友也被我坑的半死，电脑面前硬钢24小时的代码。后来睡觉了还是被我硬生生的叫了起来。最后论文排版很差也没修改，国赛就打了水漂。所以这次的经验就是，别着急，饭一点一点吃，路一步一步走，问题一点一点解决。步子迈太大，容易扯到蛋。</p>
<blockquote>
<p>但是失败不可怕，作为一个24k纯理工男，当然是要收拾心情从头再战，重点是找失败的原因。我也是在这时候发现了建模三人分工太明确的缺点，尤其是写论文的人，如果只会写，那么写论文的人根本没有存在的必要。</p>
</blockquote>
<p>第二个重要的观念转变就是：感觉算法不是重点，重点是三个人从头开始看问题，根据问题去寻找合适的解决方法，一起讨论，而不是建模的人和编程的人打主攻，写论文的孩子不明觉厉。</p>
<p>之后，在我们学校的建模创新课程上，阅读了美赛官方的阅卷说明和其他四米五高巨佬的O奖论文，此时的建模观念印证了之前的观念。建模不是寻找解决问题的算法，什么粒子群什么极限学习机，名字很高大上而且我也看过，说实话并无卵用，粒子群说白了就是优化，简短到爆炸只有两步的EM算法也能优化而且被广泛采用；极限学习机说白了是神经网络的变种，在说白了就是一种拟合概率的训练模型，但是很荣幸极限学习机这种方法是华人提出来的。</p>
<blockquote>
<p>上面扯的算法是用来求解模型的工具，而不是用来建立模型的方法。</p>
<p>一个合理的顺着问题行走的方法（机理建模）才应该是你模型的核心内容。和我之前对建模的感觉发生了巨大冲突，之前的感觉大概就是以算法为核心，扔几百行代码处理几千万行数据做几个炫酷的图，但这只是听着很好听，哇，我刚写了几百行代码，处理了上千万的数据，有这本事去搞kaggle去搞ACM为国争光啊，在建模这瞎扯什么蛋，让女孩子更羡慕你吗？这不是建模，更多的像是应付，没有数学的灵魂在。</p>
</blockquote>
<h1 id="2018美赛开始"><a href="#2018美赛开始" class="headerlink" title="2018美赛开始"></a>2018美赛开始</h1><p>之后的故事，便是2017年的亚太赛，在某某杯的比赛中，我和组委会骂了一上午，很明显是抄题了，建模不是用来收钱糊弄拿奖和发水刊论文综测加分的工具，是一种思想，是对这个世界探索和分析的工具，是开阔眼界和启迪思维的方式。后来结果显而易见，涉嫌抄题公开道歉并退款，考试太多小美赛强行弃赛。</p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/7.jpeg" alt></p>
<p>之后便是美赛，在学校天寒地冻没热水没热乎饭的忍饥挨饿过了一个月，掉了一地的头发和瘦了几斤，重点是没热水半个多月没洗澡。不过都忍过来了，真正难受的还是比赛那几天。首先是被2018年美赛风格吓住了，一道题5问甚至8问，重点是搜数据的题没数据，给数据的题看不懂数据。我个人是擅长做大数据处理的，结果吃了英语的亏看不懂数据和问题太多换到了E题，一个交叉学科的题目，其实我并不擅长。</p>
<p>搜数据用了两天，对，没听错，四天的比赛两天在搜数据，以至于第二天晚上都在劝我们赶紧换题（旁边那组貌似换了4次题，而且第二天晚上凌晨三点开着120分贝的嗓门大吵一架，不过也好，吵一架总比憋着强，至少问题解决了，后来那俩吵架的也一直是关系很好的队友。）</p>
<p>JN在旁边说别换提稳住来得及，在第三天凌晨两点，比赛过去四分之三的时间我们终于开始做了，最后在斯坦福大学的图书馆搜到了想要的数据，还有搜到了一篇nature的论文，读完了论文他妈的思路大开从头到尾赶紧开始做，写到这里还是抑制不住内心的激动又爆了粗口。当然比赛期间我是全程骂街过来的，而且不洗脸不洗头丝毫不注意形象，反正我长得丑。队友可能都习惯了，跟我一个机房的人估计也习惯了，兴奋愤怒之时怎么能压制内心的激动而不骂街呢。</p>
<p>后来直接在电脑面前肝了30多个小时，每天凌晨4点到6点睡觉，中午睡半个小时，这是我美赛的真实作息，最后一天没时间吃饭靠面包泡热水解决，想想真的是亏了，早知道选C题，数据清洗完模型也就出来了，谁也不拦着我。。。</p>
<p>最后直接肝到了比赛截止前的20分钟，9点截止，我们8点40写完了论文，中途困的分不清东西南北迷迷糊糊的写了个摘要，交卷收拾东西赶紧回家，还差点错过回家的车。</p>
<p>比赛完距离过年只有一天，好在赶在除夕那天回到了家，回家真好。一年的建模生涯就画上了句号，累的我缓了三天终于缓了过来。不留悬念，美赛我的这篇论文完全是在根据问题设计思路去建模，全文没有一个算法，只有一个孤零零的卷积公式。做的很匆忙但是拿奖了，也证明了我之前理解的建模灵魂是对的，思路是关键，而不是算法。留一些辛苦搜集的照片留作日后的回忆杀。</p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/8.jpeg" alt></p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/11.jpeg" alt></p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/12.jpeg" alt></p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/13.jpeg" alt></p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/14.jpeg" alt></p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/15.jpeg" alt></p>
<h1 id="新一年的建模之旅"><a href="#新一年的建模之旅" class="headerlink" title="新一年的建模之旅"></a>新一年的建模之旅</h1><p>后来到了2018，我虽然又参加了建模但是感受不是很多，也没有遇到一个合适的队友，这里略写。五一联赛队友不在做的一波三折，泰迪杯数据挖掘从头设计思路和改算法，拿奖肯定稳，只是奖项高低的问题。深圳杯从开题到放弃，接着PAC图像处理的余热一个上午写完了大创的代码。此时有些许的想告别建模，但是想想还是算了，对别的东西不太感兴趣，于是趁下学期课少学了一波$\LaTeX$，反正以后总会用到，在《算法分析》的课上，实现了老师所有讲过的算法，扎实一下基本功，又看了几本书，一学期也很快过去了。</p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/28.jpg" alt></p>
<blockquote>
<p>我之前和老师交流过一个问题，建模到底水不水，从结果只看论文的角度，建模是水的，因为就算做不出来也能瞎写出来。但是值得骄傲的是，我所有参加过的建模比赛，所有结果都是认认真真做出来的，从不在结果上造假和瞎编，这离不开我编程实力强大的队友。这次国赛个人感觉做得很好，拿不拿奖无所谓了，2018年的国赛要求很高，让你提交所有结果，也许从今以后，建模再也不是层次分析加模糊综合评价加神经网络加遗传算法加回归分析XJB乱写能解决的问题，这是好事。</p>
</blockquote>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/5.jpeg" alt></p>
<h1 id="收获友谊"><a href="#收获友谊" class="headerlink" title="收获友谊"></a>收获友谊</h1><p>2018国赛又想起来一个事，拉上去年编程的小伙伴又随便叫了个人临时组的队。就在最后一小时，一切顺风顺水，编程的小伙伴来了一句，代码写错了，5000多行的代码(没听错2天写了五千行python代码，也是我之前说的，他是我见过编程能力最强的人)，一个小时根本来不及修改。另外的队友开始着急，大喊大叫说这样做少了中间过程肯定不对，blabla在那抱怨的总之很烦，还说我论文写的什么都不是。</p>
<p>我当然知道这么做不对，但是，作为一个成年人，况且比赛已经到尾声的尾声了，现在不是抱怨谁对谁错的时候，抱怨解决不了任何问题。当时心想：这是我亲队友，我信任他，大不了这次比赛就当打水漂了，我无所谓，不拿奖也没关系，不重要。或者说，作为一个队长或 leader，不要在关键时刻说自己人的不好，不要让和你并肩作战的队友有心理负担。我俩相视一笑，这一刻，和一年半以前第一次的合作障碍形成了鲜明的对比。可是没有结束之前，一切都来得及，尽管只有1个小时。那是我最冷静的时刻，十分钟，用了十分钟问清楚了代码怎么写，变量怎么设置，十分钟后，灵光一现。在写个子函数把那个关键的变量在关键时刻置为零，问题就解决了。这是我目前建模最开心的一刻，比任何拿奖都开心，这是你和队友的默契和信任，比任何奖项都重要的多。因为某些众所周知的原因，2018国赛死的很惨。不过我一大把年纪也看得开。以及2018国赛增加难度后大家的表情包以及合影。</p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/6.jpeg" alt></p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/20.jpeg" alt></p>
<h1 id="回归今日"><a href="#回归今日" class="headerlink" title="回归今日"></a>回归今日</h1><p>后来，时间来到现在，回到本文的开头，参加了小美赛。我老了，时刻准备退休，然后滚去考研，毕竟高考放水太严重，毕竟我这个专业还是读研比较好。这也就是我的经历，我是爱数学的，但是不爱数学竞赛那种刷题式数学，我更喜欢用数学去解决实际问题。比如高中学过的余弦定理能结果新闻分类的问题，比如线性代数学过的特征值和特征向量的物理含义很有趣，能够确定指标的重要程度甚至方向，比如高等代数学的SVD分解能够做语义分类用于自然语言处理，比如概率论学的贝叶斯公式能做分类也能做成贝叶斯网络，比如概率论中的全概率公式能解决智能推荐的问题。</p>
<p>而数理统计中的知识，搭建起了现代人工智能的世界，现在的新技术，无论是计算机视觉还是深度学习，背后都是一点点的公式和思想搭建而成。而这些，在任何一本教科书和试卷上都是找不到的知识。但是知识是有用的，最大熵模型在股票界的应用让人狂赚，简单的pagerank算法承担了谷歌搜索引擎的门面，一个算法占了谷歌公司收益的几个百分点，没错，就是简单的pagerank一波数据统计加几个矩阵相乘，就能带来上亿的收入。我这相信数学，相信数理方程与逻辑推导，相信大数据背后的挖掘，这也便是数学的魅力所在。（从我相信开始，借鉴了电影《美丽心灵》的上半部分结语，可惜暂时还不能说下半部分结语，电影不错，女主相当好看，值得看一看。）</p>
<p>刚才正在学习，突然之间有点感触，很多做技术的都想着自己哪天成为大牛，我自己也总是这样幻想，可是就在刚才自己突然想问自己，自己的努力有能让自己成为大牛的可能么？自己的回答是没有。“很多人的努力只是浅尝辄止” 这句话并没有错，适合很多人，也同样适合我，大牛没有突然之间形成的，都是靠技术一点一点累计而成的，当自己给自己说这件事明天干也行的时候，其实就是在给自己找借口，很多人都在说时间过的好快，是渐渐的我们都觉得每天过的好快，每周过的好快，每月过的好快，甚至觉得每一年过的也是那么快，似乎时间真的不够用了，似乎自己也总是很忙碌，可是距离自己称为大牛并没有近，我觉得成为技术大牛，不是说简单的学习知识就可以达到的，而是需要对技术的热情，那种无比的热情，而不仅仅是学习技术。其实这和自己打乒乓球是一样的，任何事情当反馈来的快的时候，人往往会特别喜欢，有人喜欢玩游戏，这是因为游戏能很快给他反馈，而技术，可能今天你努力了，不能看到效果，明天你接着努力，好像还是没有变化，因为，这是需要一个长期的，并且有热情的一件事，而不仅仅只是学习。当然这是一个长期的并且漫长的过程。</p>
<h1 id="其他留念"><a href="#其他留念" class="headerlink" title="其他留念"></a>其他留念</h1><p><img data-src="/2019/04/19/romantic-time-of-modeling/23.jpeg" alt></p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/25.jpeg" alt></p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/26.jpeg" alt></p>
<blockquote>
<p>可能在机房最后骂一次街，最后通一次宵，和队友最后为数不多的搭档，然后一年多的青春也就随风而逝。看过的电影，读过的书，考过的分数和跑过的步，终将归于天地，还于历史，而我终将追不上青春逝去的脚步。</p>
</blockquote>
<p>其实故事没有结束，等哪天有空我继续写。</p>
<h1 id="2019-4-19"><a href="#2019-4-19" class="headerlink" title="2019.4.19"></a>2019.4.19</h1><p>那么我为什么参加2019的美赛呢，当时我也问了我的老师，老师说：</p>
<blockquote>
<p>如果我不参加，那么他只带一个队(我校一个老师只能带两个队)，如果我参加，他就把最后一个名额留给我，别的队找他他都没同意。他相信我的实力，我可以找任何人参加比赛，只要我看着顺眼就行。就这样，决定再次出发，其实当时心里想的是捞个Outstanding。</p>
</blockquote>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/30.jpg" alt></p>
<p>查到了自己的美赛成绩，可能这辈子无缘Outstanding Winner了，也许自己也没有那个实力。</p>
<p>2019考试结束后距离比赛只有十天，好在队友极度强大，两天的培训后可以直接上手刷题了，大概是刷了一道题熟悉了一下，然后定制了一份$\LaTeX$模板，又刷了历史上美赛评委对论文的点评，涨了涨经验，休息一天去外面吃了顿好吃的买了零食，比赛就开始了。</p>
<p>整体很流畅，pagerank算法寻找起源，SIR分析影响，信息熵计算相关性，HMM算法作为扩展，最后融合一下就搞定了。我们的论文没有用机器翻译，全程自己手动翻译的。</p>
<p>最后值得一提的是，2019美赛全部的算法参考来源于《数学之美》这本书(第二版)，反正当时我推荐给好多人看过这本书，有没有好好看就不归我管了。事实证明多看点书还是有好处的，另外我的两个队友也都看过这本书，交流起来就很顺畅了。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>关于建模最后想说的：</p>
<ul>
<li>永远没有过时和low的算法，只要有理有据和相信自己，你的模型永远是最好的。模型负责把各个算法行云流水的组织起来使文章顺畅，读着舒服，其实很多队伍真的做不到这一点。比如看最好的O奖的英文论文也比看其他队的中文论文舒服，写论文的队友得确保很会写。</li>
<li>建模收获的友谊和师生情远比拿奖重要的多的多的多。</li>
<li>美赛官方评委的一句话，层次分析法很好；国内众多人的一句话，这算法太旧太简单，自己学会取舍。</li>
<li>不要全部相信学长和老师，学长可能给你推荐mathtype，但是他肯定不知道Axmath更好用；老师可能告诉你符号说明挑几个写，只写一部分，问题分析简写能概括就行，模型假设部分分要点简写；可是美赛官方评委说的是问题重述要写详细，甚至引用前人的工作，不然他不知道你是否理解题意，要把论文中所有用到的符号都写在符号说明里，模型假设一定写详细，写出为什么这么假设，这个假设用在了哪里，灵敏性分析要对假设进行检验。形如这些，国内的老师和国外的评委各执一词，自己要有选择的去相信。</li>
<li>如果参加美赛，仔细阅读官方说明，一定要看英文版说明，不要看中文版，英文版描述的内容更多，中文版说实话偷工减料了，美赛和国内任何建模比赛的要求都不一样。</li>
<li>致敬可以为了自己热爱的东西而不遗余力的理工生。包括ACM竞赛，包括飞思卡尔等等等等。</li>
</ul>
<p>以我第一次校赛结束一个老学长送我的话结尾：所有的努力都不会白费。我已经站在了人生的十字路口，面临着考研工作各种选择，而数学的思维，理性分析问题的本质，已经融入我的血液，会陪伴我走很长的路。我的确追不上青春逝去的脚步，如果可以重来，我想我还会建模吧。希望学校后继有人，能填补关于Outstanding的空白。</p>
<p><img data-src="/2019/04/19/romantic-time-of-modeling/27.jpg" alt></p>
<blockquote>
<p>一口堵了多年的气也烟消云散，只是希望在年轻的时候还勿忘初心。</p>
</blockquote>
<h1 id="日后回忆"><a href="#日后回忆" class="headerlink" title="日后回忆"></a>日后回忆</h1><ul>
<li>2022年4月16日回来修改了一次，我很怀念当初的日子。</li>
</ul>
]]></content>
      <tags>
        <tag>Life</tag>
        <tag>Modeling</tag>
      </tags>
  </entry>
  <entry>
    <title>临近开学的瞎折腾——软件开发(PyQt5)</title>
    <url>/2019/02/24/school-start/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本来打算剩余的几天寒假是好好看会儿高数的，结果吧，可能在家里实在是一点书都看不下去，昨晚看了俩小时高数骨头差点散架，学习这种事还是回学校再说吧。</p>
<p>倒是有一点记忆尤甚，空间中的点$(x,y,z)$到$x$轴的距离是多少，我居然脑子有坑算了向径的模，在和向径的$\alpha$角来了个正弦操作，晚上散步才想起来，这个距离不就是$y^2+z^2$嘛。。。</p>
<p>无聊到玩手机，还不如玩会儿带你闹，这几天的收获也较为丰富。</p>
<ul>
<li>自己没事瞎折腾，整理了<strong>windows</strong>窗口，任务栏，还安装了<strong>Mac</strong>系统下的dock栏，用(看)着很爽，但是，突然发现电脑的时间被我整没了，也就是我打开电脑看不了时间，很无语。于是就自己用所学知识(<strong>python+QT+pyinstaller</strong>)写了个图形化的小软件，可能这是我电脑上第一次运行自己安装的软件吧，当然这个过程遇到了一堆坑。</li>
</ul>
<p>爬虫的东西准备放下一篇博客了。</p>
<a id="more"></a>
<h2 id="前言传记"><a href="#前言传记" class="headerlink" title="前言传记"></a>前言传记</h2><p>电脑总体的折腾效果如下，这个dock真的比windows的任务栏舒服多了。</p>
<p><img data-src="/2019/02/24/school-start/1.png" alt></p>
<p>然后安排了一些新软件</p>
<ul>
<li>快速启动 Wox</li>
<li>快速查找 Everything</li>
<li>及时预览 Quciklook</li>
</ul>
<p>更多强大实惠的软件look这里：</p>
<blockquote>
<p><a href="https://camuseblog.top/2019-02-10-/software/" target="_blank" rel="noopener">https://camuseblog.top/2019-02-10-/software/</a></p>
</blockquote>
<hr>
<h2 id="软件开发记"><a href="#软件开发记" class="headerlink" title="软件开发记"></a>软件开发记</h2><p>回归正题，很早之前接触了QT也写过一些小程序，还解决了上学期的课设，感觉基本的问题应该能驾驭了，既然把自己电脑的时间折腾没了，就自己写一个时钟小程序吧。</p>
<p>思路很简单，调时间的库，把返回的时间截取为字符串，在窗口(QTextEdit)中显示就行了，然后用<code>pyinstaller</code>打包一下，结果到处是坑23333。</p>
<p>不过在各种谷歌和stackoverflow的帮助下还是解决了，没有谷歌和stackoverflow我可能真的生活不能自理。</p>
<p>软件效果如下，点击show time就可以显示时间啦</p>
<p><img data-src="/2019/02/24/school-start/2.png" alt></p>
<h3 id="控件线程的坑"><a href="#控件线程的坑" class="headerlink" title="控件线程的坑"></a>控件线程的坑</h3><p>QTextEdit这个控件如果想实现刷新功能，就是显示完上一时刻的时间后，清空控件，然后显示下一时刻的时间，得进行如下操作，仅仅<code>clear()</code>是不够的。</p>
<p>有时候需要处理一些跟界面无关的但非常耗时的事情，这些事情跟界面在同一个线程中，由于时间太长，导致界面无法响应，处于“假死”状态。例如：在应用程序中保存文件到硬盘上，从开始保存直到文件保存完毕，程序不响应用户的任何操作，窗口也不会重新绘制，从而处于“无法响应”状态，这是一个非常糟糕的体验 。</p>
<p>在这种情况下，有一种方法是使用多线程，即在子线程中处理文件保存，主线程负责界面相关。</p>
<p>而如果不想使用多线程，最简单的办法就是在文件保存过程中调用<code>QtWidgets.QApplication.processEvents()</code>，该函数的作用是让程序处理那些还没有处理的事件，然后再把使用权返回给调用者。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 刷新界面命令：</span></span><br><span class="line">QtWidgets.QApplication.processEvents()</span><br><span class="line">self.ui.results_window.clear()</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="字体的坑"><a href="#字体的坑" class="headerlink" title="字体的坑"></a>字体的坑</h3><p>导入北京时间后，截取字符串一切OK，可就是显示不到QT的窗口中去(QTextEdit)。其实也不是，当时怀疑是转义的问题，我当时用字符串测试了一下，22，33，44这些数字都能显示上去，唯独11这个数字显示不上去？？？得亏是11点写的这个程序，不然真的又是一个BUG。为什么呢？</p>
<p>其实原因很吐血，我随便换了个别的字体，就又能正常显示了，无语。可能原因：QTextEdit的字体我设置的是<code>palatino</code>，这个字体无法显示<code>11</code>这个字符串。</p>
<p>(虽然我知道可能不是字体的原因，但每个程序员都能碰到一些脑仁疼无法解释的玄学BUG)</p>
<hr>
<h3 id="pyinstaller的坑"><a href="#pyinstaller的坑" class="headerlink" title="pyinstaller的坑"></a>pyinstaller的坑</h3><p>很早之前听说过这个库，能把<code>.py</code>文件打包为可执行的<code>.exe</code>文件，我试了一下，又是一堆坑。</p>
<p>比如，GUI界面的程序打包姿势和命令行的程序打包姿势是不一样的，而且尤其是使用了PyQt5的情况下。</p>
<p>正确打包姿势为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyinstaller -F -w -i logo.ico clock.py</span><br></pre></td></tr></table></figure>
<p>如果使用了<code>QTdesigner</code>工具的话，<code>add-data</code>把外部的<code>ui</code>文件包含进来，不然的话：整个过程没有错误没有警告，但是程序就是不对让你找bug到怀疑人生。</p>
<p>而且，GUI文件是不需要输出命令行<code>console</code>的，所以后面使用<code>-w</code>取消<code>console</code>的输出，不然软件运行会有个大黑窗口。</p>
<p><code>pyinstaller</code>虽然是python的第三方库，也能<code>pip</code>安装，但是千万别<code>import pyinstaller</code>，没有这个操作，<code>pyinstaller</code>就是在<code>cmd</code>里面直接用的。（我以为是我<code>pip</code>错了包的原因，又瞎搜了半天，无语）。</p>
<p>而且，<code>pyinstaller</code>之后会生成<code>dist</code>文件，需要把程序执行所需要的图片，数据，copy一份到<code>dist</code>文件夹里面，和<code>.exe</code>文件在同一个目录。</p>
<p>经过了无数的坑，终于开发出了自己的<code>.exe</code>程序，自己留着用呗。但是这个是个很好的开始啊，比如给这个软件扩充功能，能显示地区，温度等信息，或者当个记事本，记录一些待解决事件，这的确是个好的开始，但是这些功能等着以后闲的没事在扩充吧。</p>
<hr>
<p>时钟程序如下：那些png文件什么的，自己寻找一个吧。那个<code>.ui</code>文件我是使用的QTdesigner，布局的话自己画一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 这里我们进行了一些必要模块的导入。最基础的widget组件</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QMainWindow, qApp, QApplication, \</span><br><span class="line">    QVBoxLayout, QToolTip, QMessageBox, QAction</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> uic, QtWidgets, QtGui</span><br><span class="line"><span class="comment"># 显示图标</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"><span class="comment"># 显示提示文字</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QFont</span><br><span class="line"><span class="comment"># 退出程序</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QCoreApplication, Qt</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta, timezone</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> PyQt5.QtGui</span><br><span class="line"></span><br><span class="line">Ui_MainWindow, QtBaseClass = uic.loadUiType(<span class="string">"mainWindow.ui"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.ui = Ui_MainWindow()</span><br><span class="line">        self.ui.setupUi(self)</span><br><span class="line">        <span class="comment"># 状态栏</span></span><br><span class="line">        self.statusBar().showMessage(<span class="string">'Ready'</span>)</span><br><span class="line">        <span class="comment"># 我们调用sender()方法来判断哪一个按钮是我们按下的。</span></span><br><span class="line">        <span class="comment"># self.ui.pushButton_3.clicked.connect(self.calculate_tax)</span></span><br><span class="line">        self.ui.pushButton.clicked.connect(self.calculate_time)</span><br><span class="line">        <span class="comment"># 鼠标位于按钮上显示的提示信息</span></span><br><span class="line">        <span class="comment"># self.ui.pushButton.setToolTip('task of calculate Button')</span></span><br><span class="line">        <span class="comment"># 这里我们设置了我们窗口的标题。这个标题显示在标题栏中。</span></span><br><span class="line">        self.setWindowTitle(<span class="string">'CLOCK'</span>)</span><br><span class="line">        <span class="comment"># 设置窗口透明度</span></span><br><span class="line">        self.setWindowOpacity(<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># window_pale = QtGui.QPalette() </span></span><br><span class="line">        <span class="comment"># window_pale.setBrush(self.backgroundRole(),QtGui.QBrush(QtGui.QPixmap())) </span></span><br><span class="line">        <span class="comment"># self.setPalette(window_pale)</span></span><br><span class="line">        <span class="comment"># 设置图片和窗口一样大</span></span><br><span class="line">        palette = QtGui.QPalette()</span><br><span class="line">        pix = QtGui.QPixmap(<span class="string">'test.jpg'</span>)</span><br><span class="line">        pix = pix.scaled(self.width(),self.height())</span><br><span class="line">        palette.setBrush(QtGui.QPalette.Background,QtGui.QBrush(pix))</span><br><span class="line">        self.setPalette(palette)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># QIcon对象接收一个我们要显示的图片路径作为参数。</span></span><br><span class="line">        self.setWindowIcon(QIcon(<span class="string">'icon.png'</span>))</span><br><span class="line">        QToolTip.setFont(QFont(<span class="string">'SansSerif'</span>, <span class="number">10</span>))</span><br><span class="line">        <span class="comment"># 鼠标位于整个界面内是显示的提示信息</span></span><br><span class="line">        self.setToolTip(<span class="string">'This is my Clock'</span>)</span><br><span class="line">        <span class="comment"># 点击即退出</span></span><br><span class="line">        <span class="comment"># self.ui.pushButton_2.clicked.connect(QCoreApplication.instance().quit)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 工具栏</span></span><br><span class="line">        exit_action = QAction(QIcon(<span class="string">'exit.png'</span>), <span class="string">'Exit'</span>, self)</span><br><span class="line">        exit_action.setShortcut(<span class="string">'Ctrl+Q'</span>)</span><br><span class="line">        exit_action.triggered.connect(qApp.quit)</span><br><span class="line">        self.ui.toolbar = self.addToolBar(<span class="string">'Exit'</span>)</span><br><span class="line">        self.ui.toolbar.addAction(exit_action)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 菜单栏</span></span><br><span class="line">        exit_action1 = QAction(QIcon(<span class="string">'exit.png'</span>), <span class="string">'&amp;Exit'</span>, self)</span><br><span class="line">        exit_action1.setShortcut(<span class="string">'Ctrl+Q'</span>)</span><br><span class="line">        exit_action1.setStatusTip(<span class="string">'Exit application'</span>)</span><br><span class="line">        exit_action1.triggered.connect(qApp.quit)</span><br><span class="line">        menu_bar = self.menuBar()</span><br><span class="line">        file_menu = menu_bar.addMenu(<span class="string">'&amp;退出'</span>)</span><br><span class="line">        file_menu.addAction(exit_action1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主要事件的处理函数，点击Esc键退出</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">keyPressEvent</span><span class="params">(self, e)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> e.key() == Qt.Key_Escape:</span><br><span class="line">            self.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭事件，练习消息盒</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        reply = QMessageBox.question(self, <span class="string">'Message'</span>, \</span><br><span class="line">                                     <span class="string">"Are you sure to quit?"</span>, \</span><br><span class="line">                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)</span><br><span class="line">        <span class="keyword">if</span> reply == QMessageBox.Yes:</span><br><span class="line">            event.accept()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            event.ignore()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将事件连接到一个槽中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_time</span><span class="params">(self)</span>:</span></span><br><span class="line">        time_number = <span class="number">0</span></span><br><span class="line">        self.ui.results_window.clear()</span><br><span class="line">        <span class="comment"># 我只想让他显示20秒就退出</span></span><br><span class="line">        <span class="keyword">while</span> time_number &lt; <span class="number">20</span>:</span><br><span class="line">            utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)</span><br><span class="line">            bj_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">8</span>)))</span><br><span class="line">            bj_dt = str(bj_dt)</span><br><span class="line">            bj_dt = bj_dt[<span class="number">0</span>:<span class="number">19</span>]</span><br><span class="line">            self.ui.results_window.setText(<span class="string">'              '</span>+bj_dt)</span><br><span class="line"></span><br><span class="line">            QtWidgets.QApplication.processEvents()</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            self.ui.results_window.clear()</span><br><span class="line">            time_number = time_number + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        QtWidgets.QApplication.processEvents()</span><br><span class="line">        self.ui.results_window.clear()</span><br><span class="line">        self.ui.results_window.setText(<span class="string">' I don\'t wanna to show time,try button again~'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 所有的PyQt5应用必须创建一个应用（Application）对象</span></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    <span class="comment"># Qwidget组件是PyQt5中所有用户界面类的基础类</span></span><br><span class="line">    window = MyApp()</span><br><span class="line">    <span class="comment"># show()**方法在屏幕上显示出widget**</span></span><br><span class="line">    window.show()</span><br><span class="line">    <span class="comment"># 一个widget对象在这里第一次被在内存中创建，并且之后在屏幕上显示。</span></span><br><span class="line">    <span class="comment"># 当我们调用应用的exec_()方法时，应用进入了主循环</span></span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h2><p><img data-src="/2019/02/24/school-start/3.png" alt></p>
<p><img data-src="/2019/02/24/school-start/4.png" alt></p>
<hr>
<h2 id="归结原因"><a href="#归结原因" class="headerlink" title="归结原因"></a>归结原因</h2><p>近期系统的学了一下PyQt5的知识后，总结了踩坑的原因：干活之前不读文档，吓折腾只会浪费更多时间。</p>
]]></content>
      <tags>
        <tag>GUI</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫系列（一）——简单的爬取与页面解析</title>
    <url>/2019/02/24/school-start1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开学前的瞎折腾第二弹，爬取博客数据，分析作者喜好。</p>
<p>在写这个的时候，突然想起来开学的英文单词怎么说来？百度翻译居然是open school，我自己瞎翻译的school start，话说正确的翻译应该是啥。</p>
<p>然后还是闲的没事开始写起了爬虫，恩，记得是上<strong>Web</strong>编程课的时候没兴趣听，自己开始在下面瞎鼓捣爬虫技术，当时爬了几个小例子但是也没搞太明白，不如实战一下。</p>
<p>回归正题，本文收录内容：使用爬虫爬取我自己的博客，当然给出最通用的爬虫分析和程序，内容如下：</p>
<ul>
<li>博客的主要发表时间</li>
<li>博客的数量，标题；</li>
<li>标签的数量种类，用户偏好等</li>
<li>使用<code>matplotlib</code>粗暴的绘图分析一下</li>
</ul>
<p>因不蒜子暂时没有开放第三方的API，所以没办法爬取每篇博客的访问量，分析博主哪类文章写的比较受欢迎，等不蒜子开放API后再来完善此工作。</p>
<p>注意，以下python程序最好在<code>jupyter lab</code>中运行，写一句看一句，而且后面的程序还会用到前面的变量。</p>
<a id="more"></a>
<h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><p>我最通俗的理解，一个程序，这个程序将想要访问的网址（一个或多个）下载下来，然后解析一下网址内容，获取里面想要的数据。当然也可能自己在海量的网页里手动下载数据，那么我在这里祝你长命百岁。</p>
<p>上面提到了两个概念，下载网页内容和解析网页内容，这个时候python依靠强大的计算生态很好的完成了任务，目前比较受欢迎的下载请求库为<code>requests</code>，解析库为<code>BeautifulSoup</code>。</p>
<p>一个简单的例子，在中国大学排名网中爬取前十名的学校。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">allUniv = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    encoding是编码方式</span></span><br><span class="line"><span class="string">    status_code属性是返回状态，200正常，404失败</span></span><br><span class="line"><span class="string">    text是文本对应页面内容</span></span><br><span class="line"><span class="string">    raise_for_status()是方法，与status_code相同</span></span><br><span class="line"><span class="string">    timeout是请求超时时间</span></span><br><span class="line"><span class="string">    get主要是获得数据</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = <span class="string">'utf-8'</span></span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span><span class="params">(soup)</span>:</span></span><br><span class="line">    <span class="comment"># 解析后 搜索所有的tr标签和td标签内容</span></span><br><span class="line">    <span class="comment"># 因为在网址中，我们发现想要的数据在&lt;tr&gt;&lt;td&gt;所组成的标签中</span></span><br><span class="line">    <span class="comment"># 网页中，tr表示换行，td表示换列，这俩组合起来就是一个表格</span></span><br><span class="line">    data = soup.find_all(<span class="string">'tr'</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> data:</span><br><span class="line">        ltd = tr.find_all(<span class="string">'td'</span>)</span><br><span class="line">        <span class="keyword">if</span> len(ltd) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        singleUniv = []</span><br><span class="line">        <span class="keyword">for</span> td <span class="keyword">in</span> ltd:</span><br><span class="line">            singleUniv.append(td.string)</span><br><span class="line">        allUniv.append(singleUniv)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span><span class="params">(num)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;:^4&#125;&#123;:^10&#125;&#123;:^5&#125;&#123;:^8&#125;&#123;:^10&#125;"</span>.format(<span class="string">"排名"</span>,<span class="string">"学校名称"</span>,<span class="string">"省市"</span>,<span class="string">"总分"</span>,<span class="string">"培养规模"</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        u = allUniv[i]</span><br><span class="line">        print(<span class="string">"&#123;:^4&#125;&#123;:^10&#125;&#123;:^5&#125;&#123;:^8&#125;&#123;:^10&#125;"</span>.format(u[<span class="number">0</span>],u[<span class="number">1</span>],u[<span class="number">2</span>],u[<span class="number">3</span>],u[<span class="number">6</span>]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html'</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    <span class="comment"># 直接解析网址内容</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br><span class="line">    fillUnivList(soup)</span><br><span class="line">    printUnivList(<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img data-src="/2019/02/24/school-start1/1.png" alt></p>
<hr>
<h2 id="爬取标题"><a href="#爬取标题" class="headerlink" title="爬取标题"></a>爬取标题</h2><p>先访问（下载）一下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">home_url = <span class="string">"https://muyuuuu.github.io/"</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">r = requests.get(home_url)</span><br></pre></td></tr></table></figure></p>
<p>访问成功后开始解析，访问不成功的话，抱歉我不知道怎么解决。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(r.text, <span class="string">"lxml"</span>)</span><br></pre></td></tr></table></figure>
<p>接下来借助正则表达式，来爬取博客的标题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 这个正则表达式能匹配所有的&lt;title&gt;在尖括号里面的标签</span></span><br><span class="line">p_ = re.compile(<span class="string">'&lt;[^&gt;]+&gt;'</span>)  </span><br><span class="line"><span class="comment"># 匹配之后，在soup.title里面去掉这个尖括号，得到的就是标题</span></span><br><span class="line">blog_title = p_.sub(<span class="string">""</span>, str(soup.title))</span><br><span class="line"><span class="comment"># 为了对比清晰，也输出一下soup.title</span></span><br><span class="line">print(str(home_url) + <span class="string">'Blog Title is : \n'</span> + str(blog_title))</span><br><span class="line">print(soup.title)</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<p><img data-src="/2019/02/24/school-start1/2.png" alt></p>
<hr>
<h2 id="爬取标签"><a href="#爬取标签" class="headerlink" title="爬取标签"></a>爬取标签</h2><p>在我的博客中，标签页是使用<code>tags</code>命名的，如果标签页不一样记得修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tags_url = home_url + <span class="string">r'tags/'</span></span><br></pre></td></tr></table></figure>
<p>然后开始访问标签页和解析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r_tags = requests.get(tags_url)</span><br><span class="line">soup = BeautifulSoup(r_tags.text, <span class="string">"lxml"</span>)</span><br><span class="line">body = soup.body</span><br></pre></td></tr></table></figure>
<h3 id="爬取标签数量"><a href="#爬取标签数量" class="headerlink" title="爬取标签数量"></a>爬取标签数量</h3><p>然后我们查看<code>body</code>中的内容，发现所有的标签是这样的，标签都位于<code>div</code>中类名是<code>tag-cloud-tags</code>里面，然后还需要获取标签的内容：标签都位于tag-cloud-tags中的a部分。图太大了，没截全。</p>
<p><img data-src="/2019/02/24/school-start1/3.png" alt></p>
<p>然后就毫不留情的获取这里的内容，看看这里有几个标签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = body.find(<span class="string">'div'</span>, &#123;<span class="string">'class'</span>:<span class="string">'tag-cloud-tags'</span>&#125;)</span><br><span class="line">a = data.find_all(<span class="string">'a'</span>)  </span><br><span class="line">print(str(home_url) + <span class="string">'Blog tag number : '</span> + str(len(a)))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img data-src="/2019/02/24/school-start1/4.png" alt></p>
<h3 id="爬取标签内容"><a href="#爬取标签内容" class="headerlink" title="爬取标签内容"></a>爬取标签内容</h3><p>首先我们来看看<code>a</code>里面的内容都是啥：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tag_size = []</span><br><span class="line">tag_name = []</span><br><span class="line">print(a[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/02/24/school-start1/5.png" alt></p>
<p>如果是这样的话，接着用上面的<code>p_</code>正则表达式去除尖括号，留下的就是标签内容啦：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p_ = re.compile(<span class="string">'&lt;[^&gt;]+&gt;'</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    tag_name.append(p_.sub(<span class="string">""</span>, str(a[i])))</span><br><span class="line">    </span><br><span class="line">print(tag_name)</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/02/24/school-start1/6.png" alt></p>
<p>然后细心的会发现，在<code>hexo-next</code>主题中，标签字的大小能体现出标签的数量多少，比如在上面的<code>a</code>中，我们发现，<code>Algorithm</code>的字体大小是<code>22.29px</code>，<code>C51</code>的大小是<code>12px</code>，因为我经常写算法的文章，自从参加完比赛写了个小车后就没碰过<code>C51</code>，所以<code>C51</code>的标签就比较少。</p>
<p>接着利用正则表达式匹配出这些数字来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p_size = re.compile(<span class="string">'\s\d&#123;2&#125;.*px'</span>)</span><br><span class="line">tag_size = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    tag_size.append(p_size.findall(str(a[i]))) </span><br><span class="line">print(tag_size)</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/02/24/school-start1/7.png" alt></p>
<p>发现这么处理都是字符串加列表，不利于后面写代码，稍微预处理一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用于匹配数字</span></span><br><span class="line">test = re.compile(<span class="string">r'\d+\.?\d+'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(tag_size)):</span><br><span class="line">    tag_size[i] = (test.findall(str(tag_size[i][<span class="number">0</span>])))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(tag_size)):</span><br><span class="line">    tag_size[i] = float(tag_size[i][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>然后一切正常：</p>
<p><img data-src="/2019/02/24/school-start1/8.png" alt></p>
<p>接下来画个图，统计一下标签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">name_list = tag_name</span><br><span class="line">num_list = tag_size</span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>))</span><br><span class="line">plt.bar(range(len(num_list)), num_list, width=<span class="number">0.8</span>, tick_label=name_list)</span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line">font2 = &#123;</span><br><span class="line"><span class="string">'weight'</span> : <span class="string">'normal'</span>,</span><br><span class="line"><span class="string">'size'</span>   : <span class="number">30</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># plt.xlabel(tag_name,font2)</span></span><br><span class="line"></span><br><span class="line">plt.tick_params(labelsize=<span class="number">23</span>)</span><br><span class="line">plt.xticks(rotation=<span class="number">270</span>)</span><br><span class="line">plt.savefig(<span class="string">'test.png'</span>, dpi=<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p>分析结果如下：</p>
<p><img data-src="/2019/02/24/school-start1/9.png" alt></p>
<hr>
<h2 id="爬取时间"><a href="#爬取时间" class="headerlink" title="爬取时间"></a>爬取时间</h2><p>在我的hexo-next主题下的博客中，使用了创建时间和更新时间，所以我能爬取到我每个博客的创建时间，如果博客没有创建时间的这个接口的话，就别瞎折腾了。</p>
<p>而且，每篇博客的创建时间在当前主页面中都有，也就是打开我博客第一页，第二页也好，都会发现五篇博客的创建时间。</p>
<p>同样，查看<code>home_url</code>返回的解析内容，发现创建时间位于<code>time</code>标签下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(home_url)</span><br><span class="line">soup = BeautifulSoup(r.text, <span class="string">"lxml"</span>)</span><br><span class="line">body = soup.body</span><br><span class="line"><span class="comment"># 搜索所有的time标签</span></span><br><span class="line">data = body.find_all(<span class="string">'time'</span>)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/02/24/school-start1/10.png" alt></p>
<p>然后利用正则表达式匹配创建时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">publish_time = []</span><br><span class="line">time = re.compile(<span class="string">'创建时间：\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;'</span>)</span><br><span class="line">publish_time.extend(time.findall(str(data)))</span><br><span class="line">print(publish_time)</span><br></pre></td></tr></table></figure>
<h3 id="爬取博客数量"><a href="#爬取博客数量" class="headerlink" title="爬取博客数量"></a>爬取博客数量</h3><p>因为目前我的博客页数为<code>6</code>页，每页最多<code>5</code>篇博客，所以，我需要让程序模拟人的行为，自动点击下一页，一共爬取这六页博客中的创建时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># page2表示第二页，模拟浏览器点击下一页</span></span><br><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">7</span>):</span><br><span class="line">    url = home_url + <span class="string">r'/page/'</span> + str(page) + <span class="string">r'/'</span></span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    soup = BeautifulSoup(r.text, <span class="string">"lxml"</span>)</span><br><span class="line">    body = soup.body</span><br><span class="line">    data = body.find_all(<span class="string">'time'</span>)</span><br><span class="line">    publish_time.extend(time.findall(str(data)))</span><br><span class="line">print(publish_time)</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/02/24/school-start1/11.png" alt></p>
<p>根据博客的创建时间，就能得到博客的数量(一个博客肯定，只能对应一个创建时间)：</p>
<p><img data-src="/2019/02/24/school-start1/12.png" alt></p>
<h3 id="分析时间因素"><a href="#分析时间因素" class="headerlink" title="分析时间因素"></a>分析时间因素</h3><p>然后就开始统计，博主经常在哪年哪月经常发博客了，其实上面对时间的正则匹配上，亦可以多匹配出时间点，就能分析出博主经常在几点发博客了，是上午发，下午发，还是标准的夜猫子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time_sub = re.compile(<span class="string">r'创建时间：'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(publish_time)):</span><br><span class="line">    publish_time[i] = time_sub.sub(<span class="string">""</span>, publish_time[i])</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/02/24/school-start1/13.png" alt></p>
<p>然后就从上面的结果中分离出年份和月份。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">year = []</span><br><span class="line">month = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配年</span></span><br><span class="line">year_pattern = re.compile(<span class="string">r'\d&#123;4&#125;'</span>)</span><br><span class="line"><span class="comment"># 匹配月</span></span><br><span class="line">month_pattern = re.compile(<span class="string">r'-\d&#123;2&#125;-'</span>)</span><br><span class="line"><span class="comment"># 删除月份中的短线</span></span><br><span class="line">month_sub = re.compile(<span class="string">r'-'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> date <span class="keyword">in</span> range(len(publish_time)):</span><br><span class="line">    year.extend(year_pattern.findall(publish_time[date]))</span><br><span class="line">    month.extend(month_pattern.findall(publish_time[date]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> date <span class="keyword">in</span> range(len(month)):</span><br><span class="line">    month[date] = month_sub.sub(<span class="string">""</span>,month[date])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配后是字符串，此处转换为数值</span></span><br><span class="line">year = list(map(eval, year))</span><br><span class="line">month = list(map(int, month))</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/02/24/school-start1/14.png" alt></p>
<p>然后就开始数据分析专场的开车了，是时候导入pandas了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">year_result = pd.value_counts(year)</span><br><span class="line"></span><br><span class="line">name_list = year_result.index</span><br><span class="line">num_list = year_result.values</span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>))</span><br><span class="line">plt.bar(range(len(num_list)), num_list, width=<span class="number">0.6</span>, tick_label=name_list)</span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line">font2 = &#123;</span><br><span class="line"><span class="string">'weight'</span> : <span class="string">'normal'</span>,</span><br><span class="line"><span class="string">'size'</span>   : <span class="number">30</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># plt.xlabel(tag_name,font2)</span></span><br><span class="line"></span><br><span class="line">plt.tick_params(labelsize=<span class="number">23</span>)</span><br><span class="line">plt.xticks(rotation=<span class="number">270</span>)</span><br><span class="line">plt.savefig(<span class="string">'test1.png'</span>, dpi=<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/02/24/school-start1/15.png" alt></p>
<p>没错，我2018年9月搭建的博客，所以目前2018年的博客数量最多。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">month_result = pd.value_counts(month)</span><br><span class="line"></span><br><span class="line">name_list = month_result.index</span><br><span class="line">num_list = month_result.values</span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>))</span><br><span class="line">plt.bar(range(len(num_list)), num_list, width=<span class="number">0.6</span>, tick_label=name_list)</span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line">font2 = &#123;</span><br><span class="line"><span class="string">'weight'</span> : <span class="string">'normal'</span>,</span><br><span class="line"><span class="string">'size'</span>   : <span class="number">30</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># plt.xlabel(tag_name,font2)</span></span><br><span class="line"></span><br><span class="line">plt.tick_params(labelsize=<span class="number">23</span>)</span><br><span class="line">plt.xticks(rotation=<span class="number">270</span>)</span><br><span class="line">plt.savefig(<span class="string">'test2.png'</span>, dpi=<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p><img data-src="/2019/02/24/school-start1/16.png" alt></p>
<p>看来目前集中在秋冬两季写博客。</p>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>留下三个坑等自己填吧：</p>
<ul>
<li><p>在时间分析的角度，可以更换正则表达式匹配，匹配出时间点，分析博主经常在几点发博客，进而分析作息规律。（貌似又回到了数据分析的老本行）</p>
</li>
<li><p>等待不蒜子开放第三方API，爬取每篇博客的访问人数，就能知道博主写的哪方面的博客最受欢迎了。</p>
</li>
<li><p>分析每篇博客的创建时间和更新时间，能够反映出博主对博客的维护程度与热爱与否。</p>
</li>
</ul>
<p>其实爬虫更像是数据结构的过程，先查看网页源代码，分析网页的结构，利用库解析结构后，怎么导出数据就看自己编程功底了。又是在变相的考察数据结构这个计算机的送命课。</p>
<hr>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Resptile</tag>
      </tags>
  </entry>
  <entry>
    <title>编程与数学的结晶：简易搜索引擎</title>
    <url>/2019/05/19/search-engine/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>内容简介：在阅读了数据结构的一本教材《大话数据结构》后，学到了新的姿势：用于搜索引擎的数据结构——倒排索引，又想起了曾经在《数学之美》上阅读过的如何在搜索引擎中取得高质量的网页和最相关的内容。涉及到了简单的分词、矩阵相乘、信息熵的简单应用，特来整理，即使我做不出一个搜索引擎。但是在现实世界中的应用多种多样，背后的数学思维却是可以借鉴的。（注明：本文只是将两书的内容融会贯通并整理。如有遗漏使得内容看起来不连贯，可以阅读原书，计算机专业推荐这两本书都读，非计算机专业只推荐阅读《数学之美》）</p>
<a id="more"></a>
<h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>以下内容只是简单的举例，先来看两个简单的句子：</p>
<ul>
<li><em>Iron Man</em> is a 2008 American superhero film based on the Marvel Comics character of the same name. </li>
<li><em>Captain</em> America is a fictional superhero appearing in American comic books published by Marvel Comics. </li>
</ul>
<p>假设上面两个句子是两个网页里面的内容吧。当创建新的网页部署到因特网上的时候，形如谷歌、必应等引擎会第一时间派遣爬虫机器人来获取你网页上的内容，比如各种单词的数量，单词内容等。将获取到的信息添加到谷歌内部的数据库里面。当某一用户使用谷歌搜索时，谷歌根据自己内部数据库的东西，进行各种算法，给出你想要的结果。</p>
<p>形如各种常用的搜索引擎，即使待推荐的网页里面有一万个单词，但是搜索的时间都不会很长。显然并没有去遍历每个网页来确定是否推荐，而是设立了一种合理的数据结构来加快搜索进程。这个数据结构就是倒排索引。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>对于上面两个句子，一共有二三十个单词。假设有33个单词吧，我懒得数了，那么我们就建立一个33长度的表。那么 Iron Man 是 1 中特有的单词，fictional 是 2 中特有的单词，superhero是 1 和 2 供有的单词，那么得到下面的表。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>索引</th>
</tr>
</thead>
<tbody>
<tr>
<td>Iron Man</td>
<td>1</td>
</tr>
<tr>
<td>fictional</td>
<td>2</td>
</tr>
<tr>
<td>superhero</td>
<td>1, 2</td>
</tr>
</tbody>
</table>
</div>
<p>当有新的网页时就增加第三个网页，记为 3 。当然在后期处理的时候，单词的过去式、正在进行时、被动词等可以视为一个单词。当用户在引擎中输入搜索的内容时，比如superhero，那么就会搜索superhero在哪里出现。superhero在1， 2 中出现，那么就把1， 2 推荐出去。由此可见，这个方式根据内容确立索引顺序，而别的排序方式（脑补斗地主整理牌是有顺序的）是根据索引顺序确定牌的位置。和别的排序方案的逻辑相反，因此称为倒排索引。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul>
<li>这个词表可以使用基数排序增加查询速度(基数排序就脑补新华字典的按拼音排序，一个道理)。</li>
<li>词表不仅仅存储单词在哪里出现，还可以包括单词在该网页中出现的频率等等。</li>
<li>这个表的后期维护也需要很大的努力，起码得精通数据结构中的查询、插入等操作吧。</li>
</ul>
<h1 id="筛选最相关"><a href="#筛选最相关" class="headerlink" title="筛选最相关"></a>筛选最相关</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>其实还有问题，比如搜索的问题是：application of time crystal 。相对而言，形如 of , a, an, the 等介词出现频率虽然很高但是并无卵用。application 和 time 是常用词，也是很多背景下的应用词。crystal 虽然是不常用词汇，出现频率也很低，但是却能体现查询的核心含义。如果关于crystal 的链接很少，pagerank出来的结果都是关于application of time的，那么这个查询岂不是要凉？接下来接着填坑，这个坑填完后一个简朴的搜索引擎就完成了，但是实际中的搜索引擎还需要很多细节的技术需要完善，比如是不是要考虑点击量。</p>
<p>假设查询application of time crystal, 有三个网页是关于时间晶体的，有100个网页是关于时间应用的。这103个网页都是高质量网页，但只有3个网页才是真正想要的网页。既然确定了目标，就想办法整俩公式把问题解决掉。然后传说中的TF-IDF算法诞生了。</p>
<ul>
<li>一个词预测主题的能力越强，它的权重就应该越大，反之权重越小。在网页中的“时间晶体”这个词，或多或少可以推测出查询内容。但是看到“应用”一词，还是不知道想要查询什么。</li>
<li>形如 “的” “啊” “和” 等停用词权重为零，日常修饰语在查询的时候没有用的。</li>
</ul>
<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>一个查询中的每一个关键词应该反应出：这个词对查询提供了多少信息。如果一个查询包括$N$个关键词，他们在一个网页中的出现频率是：$TF_1,…,TF_n$，$N$是语料库的大小。以每个词的信息熵作为它的权重。</p>
<script type="math/tex; mode=display">I(w)=-P(w)\log P(w)=\frac{TF(w)}{N}\log \frac{N}{TF(w)}</script><p>之后，如果两个词的频率相差无几，一个词（时间晶体）是某篇文章的常用词，另一个词（应用）分散在多篇文章中，显然前者的权重应该更大，提供更好的分辨率。那么开始下面的表演：</p>
<p>假设每篇文章的单词数是$M$，$D$是pagerank后的全部网页数量。则$M \cdot D = N$。</p>
<p>一个关键词在一个文献中出现的次数为：$c(w)=\frac{Avg(TF(w))}{D(w)}$。推导出：</p>
<script type="math/tex; mode=display">\frac{TF(w)}{N}\log \frac{N}{TF(w)}=TF(w)\log (\frac{D}{D(w)}\frac{M}{c(w)})=I(w)</script><p>继续，一个词的$I(w)$越大，相似性越大，一个词的平均出现次数越多，相似性越小。两者做个减法在做进一步处理，得到TFIDF的公式</p>
<script type="math/tex; mode=display">TF\cdot IDF=I(w)-TF(w)\log \frac{M}{c(w)}=TF(w)\log \frac{D}{D(w)}</script><p>看两个等号之间的式子，第一项越大越好，第二项越小越好，推导出了新的式子。</p>
<p>而新的式子$\mathrm{TFIDF}=TF(w)\log \frac{D}{D(w)}$也是现在最常用的方案。$TF(w)$是词频率，含义为某个词在文章中的次数除以文章总词数，而IDF的英文是inverse document frequency，逆文本频率指数，公式是$\log \frac{D}{D(w)}$，含义是语料库的文档总数除以含有该词汇的文档数后取对数。</p>
<p>其实是先给出的TF-IDF公式，多年后信息论发展起来才用信息熵证明了IDF公式为什么这么写，是用$\log$ 而为什么不是根号。本文是直接从证明开始，引出的IDF公式。没想到数学还能严谨到如此境界，我还是好好用数学吧，我这脑子研究不了数学。</p>
<p>最终，计算一篇文章每个词汇的$\mathrm{TFIDF}$并排序，取其中$\mathrm{TFIDF}$值最大的词汇，作为文章的关键词，即提取出一篇文章的几个关键词。</p>
<h1 id="计算相似性"><a href="#计算相似性" class="headerlink" title="计算相似性"></a>计算相似性</h1><p>既然求出了每篇文章的代表词汇或称为关键词，仅仅需要计算查询的词汇和每篇文章关键词的相似度即可。这里使用余弦定理进行计算，当然也可以使用自然语言处理。</p>
<p>众所周知余弦定理可以计算两个向量的相近程度，两向量重合，则相似度为1，两向量垂直，则认为没有相似性。利用这个原理，很可以推导出如何将句子映射为向量：</p>
<ul>
<li>句子A：我喜欢看电视，不喜欢看电影。</li>
<li>句子B：我不喜欢看电视，也不喜欢看电影。</li>
</ul>
<p>而后将两个句子合在一起进行分词：我，喜欢，看，电视，电影，不，也。</p>
<p>计算词频：</p>
<ul>
<li>句子A：我 1，喜欢 2，看 2，电视 1，电影 1，不 1，也 0。</li>
<li>句子B：我 1，喜欢 2，看 2，电视 1，电影 1，不 2，也 1。</li>
</ul>
<p>写出词向量：</p>
<ul>
<li>句子A：[1, 2, 2, 1, 1, 1, 0]</li>
<li>句子B：[1, 2, 2, 1, 1, 2, 1]</li>
</ul>
<p>而后就可以计算两个句子的相近程度了。如果你还不能理解，我在举个极端的例子。</p>
<ul>
<li>句子A：是。</li>
<li>句子B：否。</li>
</ul>
<p>很容易得到句子A的词向量是[1, 0]，而句子B的词向量是[0, 1]，这两个向量垂直，相似度为0。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>没有找到合适的数据，就自己创造的没有link的数据，所以本次代码因缺数据而没有加入pagerank算法的代码。</p>
<p><a href="https://github.com/muyuuuu/Search-Engine" target="_blank" rel="noopener">点我过去</a></p>
<p>倒排数据结构展示：</p>
<p><img data-src="/2019/05/19/search-engine/1.jpg" alt></p>
<p>查询结果输出展示，对输入的内容进行查询。</p>
<p><img data-src="/2019/05/19/search-engine/2.jpg" alt></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此，从开始的倒排索引寻找出所有满足需求的网页，再用pagerank从满足需求的网页中求出高质量网页，在用TF-IDF算法在高质量网页中求出和查询最相关的网页。一步步完善，将自然语言以恰当的方式转为数字进行处理。当然还需要更详细的处理步骤，比如网页的反作弊技术，比如点击量，如何屏蔽相似性很高的广告等等。</p>
<p>计算机和数学的应用层出不穷，即使也存在过时的技术，比如pagerank已经被谷歌淘汰，但背后的数学思维值得我们借鉴。比如2019年的美国大学生数学建模竞赛的C题，如何确定毒品的传播源头，不就是pagerank可以应用的场景吗。</p>
<p>其实还有坑的，比如使用中文查询：“什么是汇编语言的中断”，那么新的问题又来了。英文单词之间有分割，自动提取关键词。中文的是句子呀，怎么让计算机认识句子并从里面抠出关键词呢？下次再写吧，这就涉及到了一些中文的自然语言处理的知识了。</p>
<hr>
]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>面向长尾目标检测的 Seesaw Loss</title>
    <url>/2021/05/28/seesaw-loss/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>论文好像是 2020 年底传到 arxiv <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 的，还比较新。正好最近遇到的问题是类别数量是长尾分布，恰好最近看到 mmdetection 也支持了这个损失函数，索性来看一看这篇论文，算是做个论文笔记吧。不过为了能更容易理解论文的思想，没有按照原论文的内容结构进行整理。</p>
<a id="more"></a>
<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>在现实世界中，只有少部分类有充足的数据，大部分类别其实只有小部分数据，这就是类别数量呈现长尾分布。如下图 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 所示：</p>
<p><img data-src="https://z3.ax1x.com/2021/05/28/2FWClj.jpg" alt></p>
<p>而头部类实例在长尾数据集中占主导地位，这些实例为尾部类提供了大量的负样本。所以正样本和负样本在尾类上的梯度严重不平衡。说人话的意思是，含有尾部类别的样本本是正样本，头部类别的样本是负样本。由于负样本的数量大于正样本，所以负样本对尾部类别的影响大于正样本对尾部类别的影响，具体为啥可以看公式 $\eqref{why}$。由于交叉熵公式的原因，负样本的梯度在学习过程中起到了决定性影响，导致尾部类别被识别为背景或头部类别。如下图所示：</p>
<p><img data-src="https://z3.ax1x.com/2021/05/28/2FhmQJ.png" alt></p>
<ul>
<li>那些鸟明明是正样本，但目标小，类别少，导致不如右侧常见的负样本的梯度大。负样本梯度指：就是负样本对当前类别的惩罚。</li>
</ul>
<p>以传统的交叉熵损失函数为例：</p>
<p>\begin{equation}<br>L(z) = -\sum_{i=1}^C y_i \log(\sigma_i), \sigma_i = \frac{e^{z_i}}{\sum_{j=1}^Ce^{z_j}}<br>\end{equation}</p>
<p>$z$ 表示为网络的逻辑预测输出，$\sigma$ 表示网络对每个类别的预测概率。如果当前类别是 $i$，那么对 $z_i$ 和 $z_j$ 的梯度为：</p>
<p>\begin{equation}\label{why}<br>\frac{\partial L}{\partial z_i} = \sigma_i - 1, \frac{\partial L}{\partial z_j} = \sigma_j<br>\end{equation}</p>
<p>上述公式中可以看到，第 $i$ 类样本在分类时，也惩罚了类别 $j$，换句话说，类别 $j$ 的输出单元也要受到影响。如果类别 $i$ 是头部类别，类别 $j$ 是尾部类别，那么类别 $j$ 的输出单元、backbone 等网络参数将会在大多数样本中会受到惩罚，于是类别 $j$ 的预测就会受到抑制，导致上图所示的结果。<strong>务必看懂这一步，这也是论文要改进的点。</strong></p>
<p>现有的一些处理长尾分布的做法是（这部分就是 related works 抄来的，我没看里面的论文）：</p>
<ul>
<li>根据不同的类别统计，调整损失来重新计算权重</li>
<li>重采样技术，保证类别平衡</li>
<li>在预训练的模型上，用类平衡技术重新训练分类头</li>
<li>对不同的类别使用不同的分类器去预测</li>
</ul>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h2><ol>
<li>对于每一个类别，通过缓解（mitigation）因子 $M_{ij}$ 和补偿（compensation）因子 $C_{ij}$ 动态的重新平衡正负样本的梯度</li>
<li>$M_{ij}$ 在累积的训练过程中，在不同类别之间，减少对尾部类别的惩罚。</li>
<li>但是只减轻惩罚是不够的，因为其他类别的样本在被误分类为尾类时，尾部类别受到的惩罚仍然较小。说人话的意思是，类别 $j$ 相关的神经元受到的惩罚小，神经网络为了最小化损失，所以不管输入的是什么类，有可能直接输出第 $j$ 类，所以盲目地降低负样本的梯度会增加导致尾类假阳性的风险。所以增加 $C_{ij}$ 增加对<strong>错分类</strong>实例的惩罚，避免假阳性的出现，算是一种补偿机制。</li>
</ol>
<p>所以 seesaw loss 有以下优点：</p>
<ol>
<li>是动态的，它可以汇总全部训练集的信息，知道哪些是尾类，哪些被错分类，能够更好的调整损失</li>
<li>是自校准的，因为 $M_{ij}$ 和 $C_{ij}$ 能避免尾部类别被过度惩罚和假阳性</li>
<li>能更好的处理未知分布的数据集，毕竟在训练期间会统计各个类别的数目，所以能获得更好的正负样本梯度平衡</li>
</ol>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>文中定义的 seesaw loss 是：</p>
<p>\begin{equation}<br>L(z) = -\sum_{i=1}^C y_i \log(\hat{\sigma_i}), \hat{\sigma_i} = \frac{e^{z_i}}{\sum_{j\neq i}^CS_{ij}e^{z_j}+e^{z_i}}<br>\end{equation}</p>
<p>所以对 $z_j$ 的偏导数就是：</p>
<p>\begin{equation}<br>\frac{\partial L}{\partial z_j} = S_{ij} \frac{e^z_j}{e^z_i} \hat{\sigma_i}, S_{ij} = M_{ij} \cdot C_{ij}<br>\end{equation}</p>
<p>$S_{ij}$ 表示一种可调节的因子，表示类别为 $i$ 的正样本对类别 $j$ 的惩罚。其中，$M_{ij}$ 表示头部类别 $i$ 降低对尾部类别 $j$ 的惩罚，$C_{ij}$ 表示增加对类别 $j$ 的惩罚，当类别 $i$ 被误分类为 $j$ 时。</p>
<h3 id="缓和因子"><a href="#缓和因子" class="headerlink" title="缓和因子"></a>缓和因子</h3><p>seesaw loss 在训练期间，会统计类别 $i$ 的数量为 $N_i$，对于正样本，也就是当前网络正在处理的类别 $i$，通过缓解因子调整对其它类别的惩罚，公式如下：</p>
<p>\begin{equation}<br>M_{ij} =<br>\begin{cases}<br>    1, &amp; N_i \leq N_j \\\\<br>    \biggl(\frac{N_j}{N_i}\biggr)^p, &amp; N_i &gt; N_j<br>\end{cases}<br>\end{equation}</p>
<p>如上述公式，当类别 $i$ 的数量 $N_i$ 远远大于其它类别时，对其它类别的惩罚力度会降低。$p$ 是控制惩罚程度的超参数。需要注意的是，seesaw loss 会在训练期间统计类别数量，而不是事先统计。这样做有两个好处：</p>
<ul>
<li>能适应不可见数据集，如训练数据来自流数据</li>
<li>每个类别的训练样本能被其它类别的数据适度的影响，更加鲁棒。比如当前每个类只有 5 个数据，就算不上谁是尾部，谁是头部，惩罚力度可以都一样，能更加均匀的初始化和光滑的适应真实世界的数据</li>
</ul>
<p><img data-src="https://z3.ax1x.com/2021/05/28/2kVrNR.png" alt></p>
<h3 id="补偿因子"><a href="#补偿因子" class="headerlink" title="补偿因子"></a>补偿因子</h3><p>这个计算就和上面的公式类似了，假设当前类别是 $i$ 时，被误分类为 $j$，那么缓和因子的计算公式为：</p>
<p>\begin{equation}<br>C_{ij} =<br>\begin{cases}<br>    1, &amp; \sigma_j \leq \sigma_j \\\\<br>    \biggl(\frac{\sigma_j}{\sigma_i}\biggr)^q, &amp; \sigma_j &gt; \sigma_i<br>\end{cases}<br>\end{equation}</p>
<p>$q$ 仍然是控制惩罚程度的超参数，被误分类的程度越大，补偿惩罚的力度就越大。</p>
<p><img data-src="https://z3.ax1x.com/2021/05/28/2keIpt.png" alt></p>
<h3 id="标准化线性层与输入"><a href="#标准化线性层与输入" class="headerlink" title="标准化线性层与输入"></a>标准化线性层与输入</h3><ul>
<li>对于头部类别 $i$，与其相关的分类参数 $W_i$ 可能会比较大，抑制了其它类别的表达，所以对分类层进行 $L_2$ 正则化处理</li>
<li>输入也要做正则化处理，我好奇为啥不是标准化</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>不知道读到现在有没有发现论文的一个明显漏洞。在目标检测领域，从候选框到 ROI Pooling，到处都有背景类的存在，所以背景类会是头部类别，且数量远远大于其它类，对其它类产生抑制。所以，seesaw loss 会减少对<strong>所有</strong>前景类的抑制，但由于采样问题，背景类数量几乎不会低于前景类，所以不会有对前景类的<strong>补偿因子</strong>，这样，可能会将背景识别为前景。</p>
<p>所以论文的想法是，增加一个前景背景的二分类器，预测目标属于前景的概率 $\sigma_i^{obj}$ 还是背景的概率，背景会被抛弃，前景会被保留。而预测阶段，会保留这个二分类器。最终预测的目标概率就是：</p>
<p>\begin{equation}<br>\sigma_i = \sigma_i^{obj} \cdot \sigma_i^{class}<br>\end{equation}</p>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>这篇论文的想法讲真还是不错的。忙猜一下，会有论文说这篇论文的 $p,q$ 是手工设定的不太好，$M_{ij}$ 和 $C_{ij}$ 直接相乘不太好没有道理。然后写篇论文，用神经网络自适应的学习参数 $p,q$ 或 $M_{ij}$，然后说这是改进，性能好了一些。<del>这样的东西我见过太多了，没意思，不过都是为了混一碗饭。</del></p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/abs/2008.10032" target="_blank" rel="noopener">Seesaw Loss for Long-Tailed Instance Segmentation 论文</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://tianchi.aliyun.com/competition/entrance/531888/information" target="_blank" rel="noopener">长尾分布图片来源</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>半监督浅显入门</title>
    <url>/2022/01/30/semi-intro/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>寒假开始前还是把在学校里遗留的工作先搞完，所接项目的目标是实现半监督语义分割。既然是半监督，就先来看一下半监督的经典论文，我选了经典的、结构相似的三篇论文。</p>
<p>第一篇是：NIPS 2017 的 Mean teachers are better role models: Weight-averaged consistency targets improve semi-supervised deep learning results，因为我发现伪标签相关的论文或多或少有它的影子。</p>
<p>第二篇是：ICCV 2021 的 End-to-End Semi-Supervised Object Detection with Soft Teacher，微软出品的半监督目标检测，质量上还是比较让人相信的，且语义分割也可以借鉴目标检测的东西。</p>
<p>第三篇是：ECCV 2021 的 Semi-supervised Semantic Segmentation via Strong-weak Dual-branch Network，因为搜半监督语义分割，最新的进展论文就是它了。</p>
<p>文章最后有代码实现。<del>才发现好久没更新博客了。</del></p>
<a id="more"></a>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因为现实世界标注数据比较昂贵，但无标注的数据很容易获得，那么基于少量标注数据和大量无标注数据的训练，也就是半监督训练也成为了研究的热门。简单来说，半监督分为两类：</p>
<ul>
<li>伪标签，用有标签数据训练一个分类器，然后用这个分类器对无标签数据进行分类，这样就会产生伪标签(<code>pseudo label</code>)，挑选其中认为分类正确的无标签样本，把选出来的无标签样本用来训练分类器，这样就使用了无标签数据。</li>
<li>协同训练，假设每个数据可以从不同的视角（对应到 <code>torch</code> 的话，就是不同的 <code>torchvision.transform</code>）进行分类。不同视角可以训练出不同的分类器，分类器对不同视角的图片分类结果应该相同。然后用这些从不同视角训练出来的分类器对无标签样本进行分类，再选出认为可信的无标签样本加入训练集中。由于这些分类器从不同视角训练出来的，可以形成一种互补，而提高分类精度，就如同从不同视角可以更好地理解事物一样。</li>
</ul>
<h1 id="半监督图像分类"><a href="#半监督图像分类" class="headerlink" title="半监督图像分类"></a>半监督图像分类</h1><p>这篇论文还是很简单的：</p>
<p><img data-src="https://s4.ax1x.com/2022/01/30/HC2TpQ.png" alt></p>
<p>但论文中的训练过程写的不是很清楚，看了<a href="https://github.com/CuriousAI/mean-teacher/tree/546348ff863c998c26be4339021425df973b4a36/pytorch" target="_blank" rel="noopener">代码</a>了解了完整的训练流程：</p>
<ul>
<li>有标签输入学生的预测输出和 <code>one-hot label</code> 进行对比，这个是分类损失；和教师的输出使用 <code>consistency cost</code> 进行对比，论文中用的是两个模型输出的二阶范数，代码提供了 <code>mse</code> 和 <code>kl</code> 散度两个损失。第二个 <code>loss</code> 根据 <code>epoch</code> 调整权重，<code>epoch</code> 越大，权重越大。</li>
<li>两个权重相加，反向传播更新学生的模型，<code>exponential moving average (EMA)</code> 更新教师模型，能在每个 <code>batch</code> 后聚合信息而不是每个 <code>epoch</code> 后才聚合信息，这样能获取更好的表示。</li>
<li>最后使用教师模型进行预测。</li>
</ul>
<p>至于<a href="https://github.com/CuriousAI/mean-teacher/blob/546348ff863c998c26be4339021425df973b4a36/pytorch/mean_teacher/data.py#L72-L79" target="_blank" rel="noopener">无标签数据部分</a>，就是一批数据作两次变换，第一组视为有标签，第二组数视为无标签。</p>
<p>这篇论文的思想可以总结为：作为教师，用来产生学生学习时的目标；作为学生，则利用教师模型产生的目标来进行学习。</p>
<h1 id="半监督目标检测"><a href="#半监督目标检测" class="headerlink" title="半监督目标检测"></a>半监督目标检测</h1><p>如果说分类图像的数据难以标注，那么目标检测的数据更加难以标注。</p>
<p>半监督目标检测的重点是：提升伪标签质量，伪标签质量好了也利于后续的训练。传统的半监督目标检测是多阶段方法：使用标签数据训练一个检测器，之后对无标签数据生成伪标签，再次训练检测器。但是也很容易受到限制：如何保证伪标签的质量？标签数据和无标签数据分布不一致怎么办？且不是端到端的，多年前写 <code>MTCNN</code> 的时候就感觉不是端到端就很不方便。</p>
<p>同样类似 <code>mean teacher</code> 的结构，创建两个模型，并使用 <code>EMA</code> 更新教师模型。教师模型指导学生模型的训练，而不是简单的提供伪标签就结束了。在获取学生模型生成的预测后，得分大于某个阈值的视为前景，以此保证伪标签的质量，但即使这样仍然有很多预测结果是背景，后文会给出解决方案。</p>
<p>对于无标签数据，控制标签数据和无标签数据在一个 <code>batch</code> 中的比率，从 <code>0.5</code> 开始，衰减到最后的 <code>epoch</code> 为 0。</p>
<p><img data-src="https://s4.ax1x.com/2022/01/30/HC2bXn.png" alt></p>
<p>在图里可以看到：教师模型对无标签数据进行弱数据增强，并生成盒子的伪标签和类别的伪标签。学生模型读入有标签数据，得到一个损失 $L_u$ ，对无标签数据使用强数据增强，预测结果和教师模型生成的伪标签对比，又得到一个损失 $L_s$ 。最后的损失为 $L_s + \alpha L_u$。</p>
<p>对于 $L_u$ 的分类部分，与半监督分类的一致性分布损失相反，目标检测的伪标签相对复杂，无标签数据上能检测出上千个盒子，即使 <code>NMS</code> 之后也会留下很多盒子，所以选择前景分数大于某个阈值的作为盒子，但是阈值高导致召回率低，也就是说，学习模型的前景被匹配为背景。为了避免这个问题，在得到学生模型计算出的前景和背景后，前景直接和伪标签进行对比，背景使用可靠性分数进行加权。</p>
<p>对于 $L_u$ 的盒子部分，前景得分并没有提供很好的定位信息，也就是说使用得分作为阈值筛选教师提供的盒子伪标签没啥用，那么如何使盒子的定位信息更加可靠呢？论文是这么做的，在教师生成的标签盒子周围附近进行随机采样，再次得到预测的盒子，重复这个过程$N$（实验部分取 10）次得到多个盒子，计算这些盒子的标准差，标准茶大于 0.5 的才视为前景的盒子。</p>
<p>代码是用 mmdetection 写的，几年前我用过这个东西，暂时不考虑精读代码，这个并不是大众用户的东西，暂时不考虑精读代码。</p>
<h1 id="半监督语义分割"><a href="#半监督语义分割" class="headerlink" title="半监督语义分割"></a>半监督语义分割</h1><p><img data-src="https://s4.ax1x.com/2022/01/30/HC2xtU.png" alt></p>
<p>这篇论文的结构和上面两篇论文的结构很像，在这一瞬间仿佛世界线收束了，虽然这个论文没提供代码，但个人感觉这个方法是靠谱的。</p>
<p>它在语义分割的时候分为有标签样本和弱标签样本，弱标签样本是用别的方法生成的，我没有细看生成的方法。因为我准备在这篇论文的结构上在加一个教师网络，用教师网络生成伪标签，剩下的东西和半监督图像分类差不多了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码用的 <code>segmentation model pytorch</code>，我看了下代码，魔改成半监督的话还是比较简单的，思路有了，代码都好说。会在不久的将来开源程序和结果，预计三月初。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/437754834" target="_blank" rel="noopener">半监督目标检测 MMdetection 实现</a></p>
]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统『二』：简单的多线程编程</title>
    <url>/2021/02/18/simple-multithread/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>继承上文，通过一些<strong>极度简单</strong>的例子来理解多线程、多进程编程，承接理论接触，为后面的同步、死锁打下基础。</p>
<a id="more"></a>
<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><p>可以考虑python的multiprocessing库来实现多进程。</p>
<h2 id="进程不共享数据"><a href="#进程不共享数据" class="headerlink" title="进程不共享数据"></a>进程不共享数据</h2><p>众所周知，进程之间是不共享数据的，那么一探究竟。本例程的任务是，创建两个进程实现两个计算任务，完成计算任务1后才能完成计算任务2，这是明显的<strong>循序</strong>。首先，创建了两个子进程p和q，子进程p执行sum1函数，子进程q执行sum2函数。start()方法表示进程开始，join()方法表示等待进程结束。先执行完q进程，修改a和c的值，在执行p进程修改a的值，得到最后a的结果。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">a, b, c, d = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, b, c</span><br><span class="line">    print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line">    a = a + <span class="number">1</span> + c</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, c, d</span><br><span class="line">    print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line">    a = a + <span class="number">2</span></span><br><span class="line">    c = c + d</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    p = Process(target=sum1, args=(<span class="string">'a + b'</span>,))</span><br><span class="line">    q = Process(target=sum2, args=(<span class="string">'c + d'</span>,))</span><br><span class="line">    print(<span class="string">'Child process will start.'</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    q.start()</span><br><span class="line">    q.join()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'Child process end.'</span>)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
<p>执行结果输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Parent process 23843.</span><br><span class="line">Child process will start.</span><br><span class="line">Run child process a + b (23844)...</span><br><span class="line">5</span><br><span class="line">Run child process c + d (23845)...</span><br><span class="line">Child process end.</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>最后一条的数据结果表明现在的a是1（主进程的数据），即程序的主进程和创建的两个子进程之间不共享数据，证明了结论。即多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响。那如果就想让进程之间共享数据该如何操作呢？</p>
<h2 id="进程共享数据"><a href="#进程共享数据" class="headerlink" title="进程共享数据"></a>进程共享数据</h2><p>只需要特殊的声明变量即可，以下是数值类型的变量：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os, multiprocessing</span><br><span class="line"></span><br><span class="line">a = multiprocessing.Value(<span class="string">"d"</span>, <span class="number">1</span>)</span><br><span class="line">b = multiprocessing.Value(<span class="string">"d"</span>, <span class="number">2</span>)</span><br><span class="line">c = multiprocessing.Value(<span class="string">"d"</span>, <span class="number">3</span>)</span><br><span class="line">d = multiprocessing.Value(<span class="string">"d"</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, b, c</span><br><span class="line">    print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line">    a.value = a.value + <span class="number">1</span> + c.value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, c, d</span><br><span class="line">    print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line">    a.value = a.value + <span class="number">2</span></span><br><span class="line">    c.value = c.value + d.value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    p = Process(target=sum1, args=(<span class="string">'a + b'</span>,))</span><br><span class="line">    q = Process(target=sum2, args=(<span class="string">'c + d'</span>,))</span><br><span class="line">    print(<span class="string">'Child process will start.'</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    q.start()</span><br><span class="line">    q.join()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'Child process end.'</span>)</span><br><span class="line">    print(a.value)</span><br></pre></td></tr></table></figure>
<p>输出结果如下，a的值是7,表明此时多进程以共享数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Parent process 23949.</span><br><span class="line">Child process will start.</span><br><span class="line">Run child process a + b (23950)...</span><br><span class="line">Run child process c + d (23951)...</span><br><span class="line">Child process end.</span><br><span class="line">7.0</span><br></pre></td></tr></table></figure>
<p>顺手给出其他类型的数据共享的方法：</p>
<ul>
<li>数组型：<code>num=multiprocessing.Array(&quot;i&quot;,[1,2,3,4,5])</code></li>
<li>字典：<code>mydict=multiprocessing.Manager().dict()</code></li>
<li>列表：<code>mylist=multiprocessing.Manager().list(range(5))</code></li>
</ul>
<h2 id="多进程性能记录"><a href="#多进程性能记录" class="headerlink" title="多进程性能记录"></a>多进程性能记录</h2><p>在<a href="http://localhost:4000/2020/03/16/multi-process-thread/" target="_blank" rel="noopener">并行计算基础篇</a>提到，将两个进程分配给两个CPU核心，有利于提升程序的执行效率，那么来一探究竟。</p>
<p>这也要求了函数是<strong>平行</strong>的，即函数的执行没有明显的顺序关系。首先，创建两个进程，在创建两个函数。分别对比顺序执行两个函数和用两个进程执行两个函数的时间，以此来观察多进程是否提升了效率。其中计时函数利用python的<code>time.time()</code>方法，且只记录函数的执行时间。</p>
<h3 id="顺序执行两个函数"><a href="#顺序执行两个函数" class="headerlink" title="顺序执行两个函数"></a>顺序执行两个函数</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">a, b, c, d = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, b, c</span><br><span class="line">    a = a + <span class="number">1</span> + c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, c, d</span><br><span class="line">    a = a + <span class="number">2</span></span><br><span class="line">    c = c + d</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    sum1()</span><br><span class="line">    sum2()</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(end - start)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
<h3 id="两个进程分别执行"><a href="#两个进程分别执行" class="headerlink" title="两个进程分别执行"></a>两个进程分别执行</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os, multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">a, b, c, d = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, c</span><br><span class="line">    a = a + <span class="number">1</span> + c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, c, d</span><br><span class="line">    a = a + <span class="number">2</span></span><br><span class="line">    c = c + d</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    p = Process(target=sum1, args=(<span class="string">'a + b'</span>,))</span><br><span class="line">    q = Process(target=sum2, args=(<span class="string">'c + d'</span>,))</span><br><span class="line">    print(<span class="string">'Child process will start.'</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    p.start()</span><br><span class="line">    q.start()</span><br><span class="line">    q.join()</span><br><span class="line">    p.join()</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'Child process end.'</span>)</span><br><span class="line">    print(end - start)</span><br></pre></td></tr></table></figure>
<p>这两个程序不用对比了，顺序执行的比进程执行的要块的多，顺序执行大约0.00000009秒，线程执行大约0.002秒，根本不在一个数量级。</p>
<h2 id="修正"><a href="#修正" class="headerlink" title="修正"></a>修正</h2><p>也许你看到这里会疑问，为什么顺序执行会比多进程要快，多进程明明把两个进程分配给了两个核心，并行执行为啥还慢了好几个数量级？</p>
<p>因为，进程的创建、销毁也有额外的开销啊～当开销时间远远比执行时间少的时候，才能体现多进程的优势。既然这样，就额外增加程序的执行时间即可，让两个函数都延时两秒看看。</p>
<h3 id="延时的顺序执行"><a href="#延时的顺序执行" class="headerlink" title="延时的顺序执行"></a>延时的顺序执行</h3><p>通过time.sleep(2)方法给每个函数增加两秒的延时：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">a, b, c, d = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, b, c</span><br><span class="line">    a = a + <span class="number">1</span> + c</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, c, d</span><br><span class="line">    a = a + <span class="number">2</span></span><br><span class="line">    c = c + d</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    sum1()</span><br><span class="line">    sum2()</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(end - start)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
<h3 id="延时的多进程"><a href="#延时的多进程" class="headerlink" title="延时的多进程"></a>延时的多进程</h3><p>通过time.sleep(2)方法给每个函数增加两秒的延时：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os, multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">a, b, c, d = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, c</span><br><span class="line">    a = a + <span class="number">1</span> + c</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, c, d</span><br><span class="line">    a = a + <span class="number">2</span></span><br><span class="line">    c = c + d</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    p = Process(target=sum1, args=(<span class="string">'a + b'</span>,))</span><br><span class="line">    q = Process(target=sum2, args=(<span class="string">'c + d'</span>,))</span><br><span class="line">    print(<span class="string">'Child process will start.'</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    p.start()</span><br><span class="line">    q.start()</span><br><span class="line">    q.join()</span><br><span class="line">    p.join()</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'Child process end.'</span>)</span><br><span class="line">    print(end - start)</span><br></pre></td></tr></table></figure>
<p>我这里的对比结果是：顺序执行的需要4秒，而多进程仅需2秒。证明了多进程的确能有效提高程序的执行效率。</p>
<h1 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞/非阻塞"></a>阻塞/非阻塞</h1><p>通过操作系统，我们可以知道进程的状态转换：</p>
<p><img data-src="https://s3.ax1x.com/2021/02/21/yo7Zfe.png" alt></p>
<ul>
<li>新建，分配进程所需资源，在创建进程后，进程将被设为就绪态，所以创建时不可能为其分配CPU去执行</li>
<li>就绪，进程等待分配处理器，不会到阻塞态</li>
<li>运行，获取处理器后，指令在执行。中断、时间片用完后为就绪态；等待IO变为阻塞态；</li>
<li>阻塞，进程等待某个事件发生，事件完成后为就绪，不能到运行态。操作系统会把该线程阻塞起来，避免浪费CPU资源，等到得到了资源，再变成就绪状态，等待CPU调度运行</li>
<li>终止，进程执行完毕</li>
</ul>
<p>阻塞和非阻塞关注的是<strong>程序在等待调用结果时的状态</strong>：</p>
<ul>
<li>阻塞调用是指调用结果返回之前，<strong>当前线程会被挂起</strong>。它会一直阻塞着，也就是后面的代码都不会执行了，调用线程只有在得到结果之后才会返回。</li>
<li>非阻塞调用指在不能立刻得到结果之前，<strong>当前线程并不会阻塞</strong>，无需等待操作彻底完成，也就是后面的程序该执行就执行。</li>
</ul>
<p>举个例子，你打电话问书店老板有没有《分布式系统》这本书:</p>
<ul>
<li>阻塞式调用，你会一直把自己『挂起』，直到得到这本书有没有的结果；</li>
<li>如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了，当然你也要偶尔过几分钟检查一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</li>
</ul>
<blockquote>
<p>注：阻塞和挂起：阻塞是被动的，比如抢不到资源。挂起是主动的，线程自己调用 suspend() 把自己退出运行态了。</p>
</blockquote>
<h1 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h1><p>可以使用进程池实现对每个进程的管理，即：决定哪些进程可以在进程池内，等待进程池内的所有进程执行完毕才执行下一部分的程序。粗暴的理解：一个大池子，这个池子里有好多进程，通过这个池子实现对进程的统一管理。</p>
<h2 id="apply-async-方法"><a href="#apply-async-方法" class="headerlink" title="apply_async 方法"></a>apply_async 方法</h2><p>为了体现进程的<strong>并发</strong>，我特意在12个核的CPU内创建了13个进程。意思是：会有一个进程要等待其他进程释放一个CPU资源才能执行。进程池的close()方法会阻止其他进程在进入进程池，join()方法会等待进程池全部的进程执行完毕。创建13个进程，并使每个进程等待2秒观看执行效果：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    p = Pool(<span class="number">13</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">14</span>):</span><br><span class="line">    ​    p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    print(<span class="string">'Waiting for all subprocesses done...'</span>)</span><br><span class="line">    <span class="comment"># 不能在增加其他进程</span></span><br><span class="line">    p.close()</span><br><span class="line">    <span class="comment"># Wait for the worker processes to exit.</span></span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'All subprocesses done.'</span>)</span><br></pre></td></tr></table></figure>
<p><img data-src="https://s3.ax1x.com/2021/02/19/y49YKe.png" alt></p>
<p>可以看到，第13个进程很晚才创建，在3, 2, 1, 12, 0, 10, 4, 7, 11, 8这几个进程执行完毕后，第13个进程才刚刚创建。</p>
<p>在这13个进程中，每个进程都有一个主线程。CPU给线程分配时间片(也就是分配给线程的时间)，执行完时间片后会切换都另一个线程（不是时间片也可能是其他的调度算法）。这里的进程池可以阻塞也可以不阻塞：</p>
<ul>
<li><code>apply</code>：阻塞执行，同步，池子中第一个进程执行完才会执行第二个</li>
<li><code>apply_async</code>：阻塞执行，异步，返回的结果是异步的</li>
<li>由<a href="https://docs.python.org/3/library/multiprocessing.html" target="_blank" rel="noopener">官方文档</a>可知，两者都是阻塞的</li>
</ul>
<h2 id="map-方法"><a href="#map-方法" class="headerlink" title="map 方法"></a>map 方法</h2><p>普通的<code>map</code>方法只支持一个可迭代对象。这个方法会将可迭代对象分割为许多块，然后提交给进程池。对于很长的对象，可以使用<code>imap</code> 将 chunksize 设置为一个正整数从而（近似）指定每个块的大小。若想添加额外参数，可以使用 <code>starmap</code> 方法。同样，也都有对应的异步版本。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    nprocs = mp.cpu_count()</span><br><span class="line">    print(<span class="string">f"Number of CPU cores: <span class="subst">&#123;nprocs&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    pool = mp.Pool(processes=nprocs)</span><br><span class="line"></span><br><span class="line">    result = pool.map(square, range(<span class="number">20</span>))</span><br><span class="line">    print(result)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>
<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><p>假如机器本身安装了多个处理器，那么程序会运行得更快，毋需作出任何特殊的调校。多任务可以由多进程完成，也可以由一个进程内的多线程完成。</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=<span class="string">'Thread-1'</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure>
<p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程。current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用Thread-1命名子线程。输出结果如下（最后输出的是主进程的结束）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread MainThread is running...</span><br><span class="line">thread LoopThread is running...</span><br><span class="line">thread LoopThread ended.</span><br><span class="line">thread MainThread ended.</span><br></pre></td></tr></table></figure>
<p><code>join()</code>方法会阻塞调用线程，直到当前进程返回结果，所以这是阻塞调用。</p>
<h2 id="多线程共享数据"><a href="#多线程共享数据" class="headerlink" title="多线程共享数据"></a>多线程共享数据</h2><p>仿照上文中多进程的程序，仿一个多线程的。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">a, b, c, d = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, b, c</span><br><span class="line">    a = a + <span class="number">1</span> + c</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, c, d</span><br><span class="line">    a = a + <span class="number">2</span></span><br><span class="line">    c = c + d</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    p = threading.Thread(target=sum1)</span><br><span class="line">    q = threading.Thread(target=sum2)</span><br><span class="line">    print(<span class="string">'Child process will start.'</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    q.start()</span><br><span class="line">    q.join()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'Child process end.'</span>)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Child process will start.</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">Child process end.</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<h2 id="多核线程"><a href="#多核线程" class="headerlink" title="多核线程"></a>多核线程</h2><p>如果你不幸拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。如果写一个死循环的话，会出现什么情况呢？我们可以监控到一个死循环线程会100%占用一个CPU。</p>
<p>如果有两个死循环线程，在多核CPU中，可以监控到会占用200%的CPU，也就是占用两个CPU核心。要想把N核CPU的核心全部跑满，就必须启动N个死循环线程。</p>
<p>但python启动与CPU核心数量相同的N个线程跑死循环，在4核CPU上可以监控到CPU占用率仅有102%，也就是仅使用了一核。但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？</p>
<p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock。任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p>GIL最大的问题就是Python的多线程程序并不能利用多核CPU的优势 。在讨论普通的GIL之前，有一点要强调的是GIL只会影响到那些严重依赖CPU的程序（比如计算型的）。 如果你的程序大部分只会涉及到I/O，比如网络交互，那么使用多线程就很合适， 因为它们大部分时间都在等待。实际上，你完全可以放心的创建几千个Python线程， 现代操作系统运行这么多线程没有任何压力，没啥可担心的。</p>
<p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。所以，在Python中，可以使用多线程，但不要指望能有效利用多核。不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>
<h2 id="线程的变量"><a href="#线程的变量" class="headerlink" title="线程的变量"></a>线程的变量</h2><p>不同的线程调用函数，且需要处理一些局部变量时，也可以写成这样不断的传参，只是很麻烦罢了：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_student</span><span class="params">(name)</span>:</span></span><br><span class="line">  std = Student(name)</span><br><span class="line">  <span class="comment"># std是局部变量，但是每个函数都要用它，因此必须传进去：</span></span><br><span class="line">  do_task_1(std)</span><br><span class="line">  do_task_2(std)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_task_1</span><span class="params">(std)</span>:</span></span><br><span class="line">  do_subtask_1(std)</span><br><span class="line">  do_subtask_2(std)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_task_2</span><span class="params">(std)</span>:</span></span><br><span class="line">  do_subtask_2(std)</span><br><span class="line">  do_subtask_2(std)</span><br></pre></td></tr></table></figure>
<p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好（不是程序中的局部变量和全局变量，是线程里的局部变量和全局变量）。因为线程的局部变量只有线程自己能看见，不会影响其他线程。可以通过ThreadLocal实现避免局部变量的层层传递的问题：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建全局 ThreadLocal 对象:</span></span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_student</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取当前线程关联的 student:</span></span><br><span class="line">    std = local_school.student</span><br><span class="line">    print(<span class="string">'Hello, %s in %s'</span> % (std, threading.current_thread().name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_thread</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="comment"># 绑定 ThreadLocal 的 student:</span></span><br><span class="line">    local_school.student = string</span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target = process_thread, args=(<span class="string">'Alice'</span>,), name=<span class="string">'Thread-A'</span>)</span><br><span class="line">t2 = threading.Thread(target = process_thread, args=(<span class="string">'Bob'</span>,), name=<span class="string">'Thread-B'</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello, Alice in Thread-A</span><br><span class="line">Hello, Bob in Thread-B</span><br></pre></td></tr></table></figure>
<p>全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但每个线程都只能读写自己线程的独立副本，互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>通过多线程计算$\pi$，来演示串行代码和并行代码的时间差，展示并行计算的魅力。</p>
<script type="math/tex; mode=display">\pi=\int_0^1\frac{4}{1+x^2}\text{d}x</script><h2 id="串行代码"><a href="#串行代码" class="headerlink" title="串行代码"></a>串行代码</h2><p>学过积分应该能根据公式看懂代码吧，耗时大概 3 秒左右。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">nsteps = <span class="number">10000000</span></span><br><span class="line">dx = <span class="number">1.0</span> / nsteps</span><br><span class="line">pi = <span class="number">0.0</span></span><br><span class="line">since = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nsteps):</span><br><span class="line">    x = i / nsteps</span><br><span class="line">    pi += <span class="number">4.0</span> / (<span class="number">1.0</span> + x * x)</span><br><span class="line">pi *= dx</span><br><span class="line">end = time.time()</span><br><span class="line">print(pi / nsteps)</span><br><span class="line">print(end - since)</span><br></pre></td></tr></table></figure>
<h2 id="并行代码"><a href="#并行代码" class="headerlink" title="并行代码"></a>并行代码</h2><p>为了并行串行的代码，我们需要将<code>for</code>循环划分为几个子任务，并将它们分配给多个进程。所以需要提供每个进程的起始点、终止点和步长，且需要防止重复计算。然后把各个进程扔到进程池中，得到最后的返回结果后相加即可。为了使展示代码更清晰，我手动划分了两个进程。执行时间大概一秒左右。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing, time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_pi</span><span class="params">(start, end)</span>:</span></span><br><span class="line">    steps = end - start</span><br><span class="line">    pi = <span class="number">0</span></span><br><span class="line">    dx = <span class="number">1</span> / (end - start)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(steps):</span><br><span class="line">        x = i / steps</span><br><span class="line">        pi += <span class="number">4.0</span> / (<span class="number">1.0</span> + x * x)</span><br><span class="line">    <span class="keyword">return</span> pi * dx</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    num = <span class="number">2</span></span><br><span class="line">    p = multiprocessing.Pool(num)</span><br><span class="line">    inputs = [(<span class="number">1</span>, <span class="number">5000000</span>), (<span class="number">5000000</span>, <span class="number">10000000</span>)]</span><br><span class="line"></span><br><span class="line">    since = time.time()</span><br><span class="line">    multi_result = [p.apply_async(calc_pi, inp) <span class="keyword">for</span> inp <span class="keyword">in</span> inputs]</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    end = time.time()</span><br><span class="line">    </span><br><span class="line">    result = [p.get() <span class="keyword">for</span> p <span class="keyword">in</span> multi_result]</span><br><span class="line">    pi = sum(result) / <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    print(pi)</span><br><span class="line">    print(end - since)</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从保存线程A的状态到准备切换为线程B时，加载线程B的状态的这个过程就叫上下文切换，而上下切换时会消耗大量的CPU时间。因此，只有在特定的条件下开启多线程才会更合适。不可避免的线程开销包括：</p>
<ul>
<li>上下文切换消耗</li>
<li>线程创建和消亡的开销</li>
<li>线程需要保存维持线程本地栈，会消耗内存</li>
</ul>
<p>对于计算密集型的程序，程序主要为复杂的逻辑判断和复杂的运算，此时CPU的利用率高，不用开太多的线程，开太多线程反而会因为线程切换时切换上下文而浪费资源。计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p>
<p>对于IO密集型的程序，比如磁盘IO(读取文件)和网络IO(网络请求)。因为IO操作会阻塞线程，CPU利用率不高，可以开多点线程，一个线程阻塞时(网络延迟等)可以切换到其他就绪线程，提高CPU的利用率。这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p>
<p>我们介绍了多进程和多线程，这是实现多任务最常用的两种方式。虽然很水，在实际项目中能应用的概率四舍五入为0，但对于理解多线程、多进程还是有一定帮助的。现在，我们来讨论一下这两种方式的优缺点。</p>
<p>多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）。</p>
<p>多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p>
<p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？</p>
<p>因为进程或线程的切换是有代价的，操作系统在切换进程或者线程时需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</p>
<p>所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。</p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>应该是通信、MPI什么的吧，进程死锁、上下文切换开销对比什么的看有没有时间。</p>
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>一些对抗样本去噪算法</title>
    <url>/2021/08/05/some-adversarial-sample-denoise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>忙完了其它的，还是要回归科研做好整理，相当于论文笔记吧。对抗样本去噪算法算是告以段落，或者说叫对抗样本提纯。本文总结了一些近几年的、思路还行结果也还好的对抗样本去噪算法，就相当于写个类似的综述了，注意，并非详解。优缺点仅是个人分析，<del>其实论文读多了或者看了代码，总会有一些想法</del>。包含以下论文：</p>
<ol>
<li>Comdefend: An efficient image compression model to defend adversarial examples, CVPR 2019</li>
<li>Feature denoising for improving adversarial robustness, CVPR 2019</li>
<li>Defense against adversarial attacks using high-level representation guided denoiser, CVPR 2018</li>
<li>A Self-supervised Approach for Adversarial Robustness, CVPR 2020</li>
<li>Denoised Smoothing: A Provable Defense for Pretrained Classifiers, NIPS 2020</li>
<li>Stochastic Security: Adversarial Defense Using Long-Run Dynamics of Energy-Based Models, ICLR 2021</li>
<li>Online Adversarial Purification based on Self-Supervision, ICLR 2021</li>
<li>Adversarial Purification with Score-based Generative Models, ICML 2021</li>
</ol>
<a id="more"></a>
<h1 id="ComDefend"><a href="#ComDefend" class="headerlink" title="ComDefend"></a>ComDefend</h1><p>来自论文：Comdefend: An efficient image compression model to defend adversarial examples, CVPR 2019。</p>
<p><img data-src="https://z3.ax1x.com/2021/08/22/hpM6XR.png" alt></p>
<ul>
<li>核心思想，在目标模型之前训练一个编码器和解码器，编码器的目标是提取图像的结构信息，移除冗余信息；解码器的目标是重构输入的图像，移除扰动信息。</li>
<li>损失函数，对于编码器，使用更多的 0 来编码图像，因此损失为 $\lambda \Vert Com(\theta_1, x) \Vert^2$，使其尽可能的小；对于解码器要尽可能的重构原始图像，因此损失为 $\Vert Rec(\theta_2, Com(\theta_1, x)+\phi) -x \Vert^2$，$\phi$ 是高斯噪音。最终的损失是两者相加，两个模型的参数是同时训练和更新的。但是我在复现的时候，发现 $\lambda = 0.0001$，也能猜出这篇论文的大概效果。</li>
</ul>
<p><strong>对抗样本在输入层的扰动其实只是很小的一部分，微小的扰动会在模型隐层无限放大。这篇论文只是在输入层去除对抗样本的扰动信息，没有考虑在模型隐层去除扰动信息。</strong></p>
<h1 id="Feature-Denoising"><a href="#Feature-Denoising" class="headerlink" title="Feature Denoising"></a>Feature Denoising</h1><p>来自论文 Feature denoising for improving adversarial robustness, CVPR 2019。如下图所示，论文注意到了对抗样本在模型高层的巨大差异信息，所以，选择了在模型的高层对数据进行去噪，而不是输入层。</p>
<p><img data-src="https://z3.ax1x.com/2021/08/05/fZKpjA.png" alt></p>
<p>论文选择的去噪方式也很简单，对于特征图 $y$，对于一个区域 $L$，重新计算其表示：</p>
<p>\begin{equation}<br>y_i=\frac{1}{C(x)}\sum_{j \in L} f(x_i, x_j) \cdot x_j<br>\end{equation}</p>
<p>其中，$f(x)$ 有多种选择，论文中给出了：高斯函数、内积、和一些滤波器。</p>
<h1 id="HGD"><a href="#HGD" class="headerlink" title="HGD"></a>HGD</h1><p>来自论文：Defense against adversarial attacks using high-level representation guided denoiser, CVPR 2018。</p>
<p><img data-src="https://z3.ax1x.com/2021/08/22/hpQS3Q.png" alt></p>
<p>核心思想：基于干净样本和对抗样本在模型高维的差异来指导去噪器的训练。设 $x$ 为干净样本，$x^\star$ 为对抗样本，$\hat{x}$ 为对抗样本去噪后的样本。论文选择 U-Net 结构对样本进行去噪，输入为 $x^\star$，输出为同等大小的 $-d\hat{x}$，那么 $\hat{x}=x^\star - d\hat{x}$，使用 $L_1$ 范数作为 $\hat{x}$ 和 $x$ 的损失。第二个损为 $f_l(x)$ 与 $f_l(\hat{x})$ 的 $L_1$ 范数，即去噪样本和干净样本在模型第 $l$ 层的差异应尽可能接近。</p>
<p>我觉得这篇论文的思想是不错的，所以在我的工作中也借鉴了这篇论文的思想。分别在模型的输入层和隐层对对抗样本进行去噪，不过其他内容则不一样了。</p>
<h1 id="NRP"><a href="#NRP" class="headerlink" title="NRP"></a>NRP</h1><p>来自论文：A Self-supervised Approach for Adversarial Robustness, CVPR 2020。这篇论文我也<a href="https://github.com/muyuuuu/Paper-ReImplement" target="_blank" rel="noopener">复现</a>了，讲真复现结果很差。一方面是论文中给出的参数不合理，一方面是论文并没有对一些东西解释清楚，最重要的是不仅没给代码，还没说怎么实现他的代码，也没有说某些实验参数，所以我只能按照论文描述来实现代码了。那为什么还要写呢？因为这篇论文借鉴 GAN 的思想来去除扰动，还是感觉有一点点新意的。</p>
<p><img data-src="https://z3.ax1x.com/2021/08/22/hpQ3E6.png" alt></p>
<p>作者定义一个提纯网络 $P$ 用于去除噪音，定义判别网络 $C$ 来判断当前样本是对抗样本还是干净样本，定义 backbone $F$ 来提取对抗样本和干净样本的特征差异生成自监督扰动，将扰动叠加至干净样本生成对抗样本，作为 $P$ 的训练数据。$P$ 去噪后传送给 $C$，以此来定义 $P$ 去除扰动的好坏。损失函数由三个部分组成，最终带权相加组成最终的损失函数：</p>
<ul>
<li>对抗损失是 $P(\hat{x})$ 和 $x$ 在判别网络 $C$ 上的相似度</li>
<li>特征损失为 $F(x)$ 和 $F(\hat{x})$ 的欧式距离</li>
<li>像素损失为 $P(\hat{x})$ 和 $x$ 的欧氏距离</li>
</ul>
<h1 id="Denoised-smoothing"><a href="#Denoised-smoothing" class="headerlink" title="Denoised smoothing"></a>Denoised smoothing</h1><p>这篇论文来自 Denoised Smoothing: A Provable Defense for Pretrained Classifiers, NIPS 2020。</p>
<p>写这篇论文并不是因为这个论文发表的等级高、时间新。而是因为，我发现一些对抗去噪采纳了集成的思想，这篇论文就是其一。<strong>借助多个分类器的投票结果指导去噪器的训练</strong>，三个臭皮匠，赛过诸葛亮，何况分类器呢？如果你对集成感兴趣，可以考虑沿着这个方向做下去。这个论文还算是集成思想中比较保守的了。</p>
<p><img data-src="https://z3.ax1x.com/2021/08/22/hpQ6PS.png" alt></p>
<p>但是呢，我是比较反感堆叠模型这样的方案的，这就相当于应该花 3 年去准备高考，而你花了 21 年去准备，效果虽然好，但是成本太大了。应该设计算法去提高一个模型的准确度，而不是多个模型投机取巧，另外我也没这样大规模的算力。</p>
<p>这篇论文写了一个单独的<a href="https://www.microsoft.com/en-us/research/blog/denoised-smoothing-provably-defending-pretrained-classifiers-against-adversarial-examples/" target="_blank" rel="noopener">博客</a>，也给出了<a href="https://github.com/microsoft/denoised-smoothing" target="_blank" rel="noopener">程序</a>，思路还是比较清晰的，在损失函数上，先用去噪后的图像和原始图像的 MSE 作为损失，再用去噪后的图像和原始图像在高维的差异作为损失微调。</p>
<h1 id="EBM-defense"><a href="#EBM-defense" class="headerlink" title="EBM-defense"></a>EBM-defense</h1><p>论文来自 Stochastic Security: Adversarial Defense Using Long-Run Dynamics of Energy-Based Models, ICLR 2021。模型啥的也比较简单，但是我比较反感堆叠模型的操作，丑拒这样的 idea。</p>
<p><img data-src="https://z3.ax1x.com/2021/08/21/fze1BD.png" alt></p>
<h1 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h1><p>来自论文 Online Adversarial Purification based on Self-Supervision, ICLR 2021。这篇论文在模型、算法还是有一定创新度的，也是我重点复现的论文之一。不过这篇论文虽然有对抗样本提纯的概念，但严格意义来说，属于对抗训练的论文，应为这个算法会修改目标模型的参数。</p>
<p><img data-src="https://z3.ax1x.com/2021/08/22/hplmIf.png" alt></p>
<ul>
<li>在训练阶段，设计两个损失，第一个损失是目标模型的分类损失，第二个损失是子监督扰动的损失，企图网络能够去除自监督扰动，以此抵御对抗样本的攻击。</li>
<li>在推理阶段，通过子监督扰动损失的指导，去除对抗样本的扰动信息，之后再进行推理。（具体可以看代码）</li>
</ul>
<p>论文的目标损失是：</p>
<p>\begin{equation}<br>\min_\theta L_{\text{cls}}((g\circ f)(x;\theta_{\text{enc}}, \theta_{\text{cls}}), y) + \alpha L_{\text{aux}}((h\circ f)(x;\theta_{\text{enc}}, \theta_{\text{aux}}))<br>\end{equation}</p>
<p>$g$ 是分类器的前部分，$h$是辅助分支的模型，不过实际代码中这俩被合二为一了，也就是，一个神经网络有两个损失。</p>
<p>对于 $L_{\text{aux}}$ 损失，论文给出了三种选择，在实现时选择其中的一种即可。</p>
<ol>
<li>叠加噪音，即图像叠加噪音后，还是之前的图像。这里的损失使用了叠加噪音前后的 MSE 差异。</li>
<li>图像旋转，即图像旋转后，还是之前的图像。这里的损失使用了旋转后图像与真实标签的交叉熵作为损失。</li>
<li>标签持续性，即图像经过两种数据增强后，这两组图像的标签一致。这里的损失是两种数据增强后的 MSE 差异。</li>
</ol>
<p>在去噪阶段，论文提出了多部去噪，一定程度弥补了之前单步去噪的缺陷：</p>
<p><img data-src="https://z3.ax1x.com/2021/08/22/hptNng.png" alt></p>
<h1 id="ADP"><a href="#ADP" class="headerlink" title="ADP"></a>ADP</h1><p>来自论文 Adversarial Purification with Score-based Generative Models, ICML 2021。我复现了这篇论文，训练缓慢、预测缓慢，且不提供训练代码只提供预测代码，预测代码和论文算法描述不一致。前面的模型是别人的，如果没看到这一点，我都不知道怎么复现论文。如果一定有评价的话，那就是：呵，tui。</p>
<p>模型来自「Improved techniques for training score-based generative models」这篇发表在 NIPS 2020 的论文，所以网络结构直接看这篇论文的代码即可。损失函数的设计如下（前面那堆推导没啥用）：</p>
<p>\begin{equation}<br>L(\theta, \sigma) = \mathbb{E}_{q(\tilde{x}|x)p_{\text{data}}(x)}[\frac{1}{2\sigma^2} \Vert \tilde{x} + \sigma^2 s_\theta(\tilde{x}) -x \Vert^2]<br>\end{equation}</p>
<p>$q(\tilde{x}|x)$ 是以 $x$ 为中心，以 $\sigma$ 为均方差生成的噪音样本。这个损失的意思是，期望 $s_{\theta}$ 能够有效去除 $\tilde{x}$ 上含有的噪音信息，并且和原始图像差不多，以此来抵御对抗样本的攻击。</p>
<p>预测阶段极度风骚，来看伪码：</p>
<p><img data-src="https://z3.ax1x.com/2021/08/22/hpYaJx.png" alt></p>
<p>一步去噪不到位，居然用多步去噪……这样与其他算法对比并不公平，这就像之前举的参加高考的例子。当然这不是最离谱的，最离谱的是，代码和这个算法毫不相关。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(max_iter):</span><br><span class="line">    labels = torch.ones(x_pur.shape[<span class="number">0</span>], device=x_pur.device)</span><br><span class="line">    labels = labels.long().to(config.device.ebm_device)</span><br><span class="line">    grad = network_ebm(x_pur, labels) <span class="comment"># Get gradients</span></span><br><span class="line">    <span class="comment"># Get adaptive step size</span></span><br><span class="line">    x_eps = x_pur + lr_min*grad</span><br><span class="line">    <span class="comment">#print(torch.mean(torch.norm(grad.view(grad.shape[0],-1), p=2,dim=1)).item(), flush=True)</span></span><br><span class="line">    grad_eps = network_ebm(x_eps, labels)</span><br><span class="line">    z1 = torch.bmm(grad.view(grad.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">-1</span>), grad_eps.view(grad_eps.shape[<span class="number">0</span>], <span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">    z2 = torch.bmm(grad.view(grad.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">-1</span>), grad.view(grad.shape[<span class="number">0</span>], <span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">    z = torch.div(z1, z2)</span><br><span class="line">    <span class="keyword">if</span> mode==<span class="string">"attack"</span>:</span><br><span class="line">        step_lambda = config.attack.attack_lambda</span><br><span class="line">    <span class="keyword">elif</span> mode==<span class="string">"purification"</span>:</span><br><span class="line">        step_lambda = config.purification.purification_lambda</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    step_size = torch.clamp(step_lambda*lr_min/(<span class="number">1.</span>-z), min=min_step_lr, max=min_step_lr*<span class="number">10000.</span>).view(<span class="number">-1</span>)</span><br><span class="line">    cont_purification = torch.logical_and(cont_purification, (step_size&gt;config.purification.stopping_alpha))</span><br><span class="line">    <span class="keyword">if</span> torch.sum(cont_purification)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    step_size *= cont_purification</span><br><span class="line">    x_pur_t = x_pur.clone().detach()</span><br><span class="line">    x_pur = torch.clamp(transform_ebm_to_raw(x_pur_t+grad*step_size[:, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]), <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line">    step_sizes.append(step_size)</span><br><span class="line">    images.append(x_pur)</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>当然，还有一系列的其他算法，如 Feature squeezing, JPEG Compressionm，TVM 等算法，我感觉不如之前的论文有意思，所以没有详细的写，读者有兴趣的话可以自己去看一看。</p>
<p>接下来，会看一些攻击方向的经典论文而后复现，大概一周吧，之后会转入全新的领域：对抗训练，偏数据分布的处理，如果有兴趣欢迎联系（是妹子就更好了（误。</p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系列（二）——建立数据表的关系</title>
    <url>/2020/01/25/sqlalchemy-relation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>往一个领域里走的越深，发现设计的知识越多越难(<del>主要是自己知识过于贫瘠</del>)，虽然我很确信我还处于很浅的位置。今天又鼓捣了一天，发现涉及的内容太多了，一个文章放不下，还是单独成文，组成一个系列？算了，先整理下所学知识吧。</p>
<a id="more"></a>
<p>通过关系让不同表的字段之间建立联系，比如用外键去约束另一个表字段的取值，而这在实际开发中也是很常见的东西。</p>
<p>对两个表创立了联系，这样查询和操作起来也会方便很多：只在表中声明表之间的关系，之后每次使用就完全无需手动交叉搜索，而是像对待一个表中的数据一样直接使用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://segmentfault.com/a/1190000018006031" target="_blank" rel="noopener">relation 相关代码的参考</a> 这篇文章写的不错的。</p>
<h1 id="完整代码链接"><a href="#完整代码链接" class="headerlink" title="完整代码链接"></a>完整代码链接</h1><p><a href="https://github.com/muyuuuu/SQLAlchemy/tree/master/SQLAlchemy/relation" target="_blank" rel="noopener">https://github.com/muyuuuu/SQLAlchemy/tree/master/SQLAlchemy/relation</a></p>
<p>建议参考全部代码进行学习。</p>
<h1 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h1><p>外键是在<code>A</code>表中存储<code>B</code>表的主键，以便和<code>B</code>表建立联系的关系字段，且外键只能存储单一的数据。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A表：学号，姓名，专业</span><br><span class="line">B表：课程号，成绩，学号</span><br></pre></td></tr></table></figure>
<p>那么<code>B</code>表的学号是<code>B</code>表的外键，能确定<code>A</code>表唯一的学生，且取值受限于<code>A</code>表。</p>
<h1 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h1><p>比如一个作者可以写多篇文章，一个文章只能属于一个作者(不考虑科技论文的第一作者、第二作者等)，我们想查询一个作者的所有文章。</p>
<ul>
<li>如上，外键只能存储单一数据，所以外键要定义在<code>多</code>这一侧，所以外键定义在文章表内。</li>
<li>而关系属性在<code>出发侧</code>定义，所以关系定义在作者表内。代码如下(连接数据库那部分的就不写了，详情参考<a href="https://muyuuuu.github.io/2020/01/24/sqlalchemy/">这里</a>)：</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="comment"># __tablename__ 指定在 MySQL 中表的名字</span></span><br><span class="line">    __tablename__ = <span class="string">'authors'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)  </span><br><span class="line">    username = Column(String(<span class="number">64</span>), index=<span class="literal">True</span>)</span><br><span class="line">    email = Column(String(<span class="number">64</span>), unique=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 关系定义在出发侧，即 一对多 的 一 这一侧</span></span><br><span class="line">    <span class="comment"># 没有用column记录，可以返回集合关系属性</span></span><br><span class="line">    to_articles = relationship(<span class="string">'Article'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'articles'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    title = Column(String(<span class="number">50</span>), index=<span class="literal">True</span>)</span><br><span class="line">    body = Column(Text)</span><br><span class="line">    <span class="comment"># 定义外键 authors 对应表名 id 是字段名</span></span><br><span class="line">    <span class="comment"># 外键在 aricle 表存储 author 表的主键，和 author 表建立联系，所以外键在多的一侧</span></span><br><span class="line">    author_id = Column(Integer, ForeignKey(<span class="string">'authors.id'</span>))</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li><code>authors.id</code> 中的 authors 是表名，id是那个类里面的属性。</li>
<li><code>relationship</code> 定义了一个属性，参数为对应的要联系表的类名。</li>
</ul>
<p>在作者数据表中，没有使用<code>Column</code>去定义文章这一栏，是因为<code>relation</code>会将Author类和Article类建立联系，这个关系被调用时，会在关系的另一侧article内的外键字段内，查找所有外键字段为当前查询值（author表的主键id），并返回查询结果，即对应该作者的多篇文章。</p>
<h2 id="写入实例"><a href="#写入实例" class="headerlink" title="写入实例"></a>写入实例</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">lanling = Author(username = <span class="string">'lanling'</span>, email = <span class="string">'lanling@gmail.com'</span>)</span><br><span class="line">test1 = Article(title = <span class="string">'test1'</span>, body = <span class="string">'asdasdasd'</span>)</span><br><span class="line">test2 = Article(title = <span class="string">'test2'</span>, body = <span class="string">'eiubfefvwiev'</span>)</span><br><span class="line">session.add(lanling)</span><br><span class="line">session.add(test1)</span><br><span class="line">session.add(test2)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<h2 id="建立联系"><a href="#建立联系" class="headerlink" title="建立联系"></a>建立联系</h2><h3 id="从多的一侧建立联系"><a href="#从多的一侧建立联系" class="headerlink" title="从多的一侧建立联系"></a>从多的一侧建立联系</h3><p>设立当前文章的作者的id是1：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">test1.author_id = <span class="number">1</span></span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<p>查看数据库端的更改：</p>
<p><img data-src="/2020/01/25/sqlalchemy-relation/1.png" alt></p>
<h3 id="从少的一侧建立联系"><a href="#从少的一侧建立联系" class="headerlink" title="从少的一侧建立联系"></a>从少的一侧建立联系</h3><p>给lanling作者追加一篇文章：（lanling作者的id是1）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">lanling.to_articles.append(test2)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<p>再次查看数据库内是否修改：</p>
<p><img data-src="/2020/01/25/sqlalchemy-relation/2.png" alt></p>
<p>可以看到两篇文章的<code>author_id</code>表示作者都是lanling。</p>
<h2 id="查看联系结果"><a href="#查看联系结果" class="headerlink" title="查看联系结果"></a>查看联系结果</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = session.query(Author).filter(Author.id == <span class="number">1</span>)</span><br><span class="line">print(a[<span class="number">0</span>].username)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lanling.to_articles:</span><br><span class="line">    print(i.title)</span><br><span class="line">print(test1.author_id)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lanling.to_articles:</span><br><span class="line">    print(i.body)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">lanling</span><br><span class="line">test1</span><br><span class="line">test2</span><br><span class="line"><span class="number">1</span></span><br><span class="line">asdasdasd</span><br><span class="line">eiubfefvwiev</span><br></pre></td></tr></table></figure>
<h2 id="移除关系"><a href="#移除关系" class="headerlink" title="移除关系"></a>移除关系</h2><p>在<code>一</code>这一侧直接remove即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">lanling.to_articles.remove(test2)</span><br><span class="line">session.commit()</span><br><span class="line"><span class="comment"># 查看结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lanling.to_articles:</span><br><span class="line">    print(i.body)</span><br></pre></td></tr></table></figure>
<p>数据库端情况：（之后的创建实例、设置关系的操作均会影响数据库端，所以不再重复展示）。</p>
<p><img data-src="/2020/01/25/sqlalchemy-relation/3.png" alt></p>
<p>输出：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">asdasdasd</span><br></pre></td></tr></table></figure>
<h2 id="建立双向联系"><a href="#建立双向联系" class="headerlink" title="建立双向联系"></a>建立双向联系</h2><p>在两侧都添加关系属性，用于获取对方记录的关系称为双向关系。</p>
<p>比如：查询一个作者写了哪些书，查询书的作者是谁这样的双向查询。但在<code>多</code>的一侧，返回值是一个数据，即一本书的作者只能是单个人，不能以列表的形式去访问。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'writers'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>, index=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">10</span>))</span><br><span class="line">    <span class="comment"># writers是建立联系的类的属性</span></span><br><span class="line">    books = relationship(<span class="string">'Book'</span>, back_populates=<span class="string">'writers'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'books'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>, index=<span class="literal">True</span>)</span><br><span class="line">    publish = Column(String(<span class="number">10</span>))</span><br><span class="line">    writer_id = Column(Integer, ForeignKey(<span class="string">'writers.id'</span>))</span><br><span class="line">    <span class="comment"># 返回单个标量 可以直接掉属性 不能使用列表访问</span></span><br><span class="line">    writers = relationship(<span class="string">'Writer'</span>, back_populates=<span class="string">'books'</span>)</span><br></pre></td></tr></table></figure>
<p>其中<code>back_populates</code>用来连接对方，不连接只是简单的增加一个属性，操作关系的一方并不会影响另一方，但连接双方后，操作关系的一方，涉及到的另一方也会跟随变。</p>
<p>且参数必须严格设置为关系另一侧的类的属性值。</p>
<blockquote>
<p>Writer类的relationship属性名books，必须对应Book类的关系中的back_populates中的值。<br>Book类的relationship属性名writers，必须对应Writer类的关系中的back_populates中的值。</p>
</blockquote>
<p>加入实例：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">muyu = Writer(name=<span class="string">'muyu'</span>)</span><br><span class="line">test1 = Book(publish=<span class="string">'asde'</span>)</span><br><span class="line">test2 = Book(publish=<span class="string">'fwf'</span>)</span><br><span class="line">session.add(muyu)</span><br><span class="line">session.add(test1)</span><br><span class="line">session.add(test2)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<p>建立关系：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">test1.writers = muyu</span><br><span class="line">print(test1.writers.name)  <span class="comment"># 输出 muyu</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回对象不是单个表量 所以迭代访问</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> muyu.books:</span><br><span class="line">    print(i.publish)  <span class="comment"># 输出 asde</span></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新加一本书</span></span><br><span class="line">test2.writers = muyu</span><br><span class="line">print(test2.writers.name)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> muyu.books:</span><br><span class="line">    print(i.publish)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">muyu</span><br><span class="line">asde</span><br><span class="line">fwf</span><br></pre></td></tr></table></figure>
<p>因为设置了双向关系，所以将某个<code>book</code>的<code>writer</code>属性设为None，就会解除对应 Writer 对象的关系，此时在 writer 方查询，并不会查询到对应的 book 信息。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">test2.writers = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> muyu.books:</span><br><span class="line">    print(i.publish)</span><br></pre></td></tr></table></figure>
<p>只输出：asde。</p>
<h1 id="一对一关系"><a href="#一对一关系" class="headerlink" title="一对一关系"></a>一对一关系</h1><p>一个丈夫有一个妻子，一个妻子有一个丈夫，用这个例子吧(不考虑重婚和离婚)。此处不建立双向关系，与上个例子不同的是需要加入<code>uselist=False</code>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">husband</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'husband'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">10</span>))</span><br><span class="line">    <span class="comment"># 一对一 返回单个属性</span></span><br><span class="line">    wife = relationship(<span class="string">'wife'</span>, uselist=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">wife</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'wife'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">10</span>))</span><br><span class="line">    husband_id = Column(Integer, ForeignKey(<span class="string">'husband.id'</span>))</span><br><span class="line">    husband = relationship(<span class="string">'husband'</span>, uselist=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h2 id="加入实例"><a href="#加入实例" class="headerlink" title="加入实例"></a>加入实例</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name1 = husband(name=<span class="string">'name1'</span>)</span><br><span class="line">name2 = husband(name=<span class="string">'name2'</span>)</span><br><span class="line"></span><br><span class="line">name3 = wife(name=<span class="string">'name3'</span>)</span><br><span class="line">name4 = wife(name=<span class="string">'name4'</span>)</span><br><span class="line"></span><br><span class="line">session.add(name1)</span><br><span class="line">session.add(name2)</span><br><span class="line">session.add(name3)</span><br><span class="line">session.add(name4)</span><br><span class="line"></span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<h2 id="建立联系-1"><a href="#建立联系-1" class="headerlink" title="建立联系"></a>建立联系</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name1.wife = name3</span><br><span class="line">name2.wife = name4</span><br></pre></td></tr></table></figure>
<p>查看联系的结果：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(name1.wife.name) <span class="comment"># 输出 name3</span></span><br></pre></td></tr></table></figure>
<p>此外，即使在表内建立了联系，而不执行<code>session.commit()</code>，联系的更改不会提交的数据库：</p>
<p><img data-src="/2020/01/25/sqlalchemy-relation/4.png" alt></p>
<p>而在最后执行<code>session.commit()</code>后，更改会提交到数据库：</p>
<p><img data-src="/2020/01/25/sqlalchemy-relation/5.png" alt></p>
<h1 id="多对多联系"><a href="#多对多联系" class="headerlink" title="多对多联系"></a>多对多联系</h1><p>一个学生有多个老师，一个老师有多个学生，以这个例子说明。</p>
<p>在多对多关系中，每一个记录都可以与关系另一侧的多个记录建立关系，而不是一个。所以需要把多对多分拆成两个一对多关系。做法是：新创建一个表，专门存储映射关系。原本的两个表无需设置任何外键。</p>
<p>关系表一定要写在数据表前面：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">assocation_table = Table(<span class="string">'association'</span>, Base.metadata,</span><br><span class="line">    Column(<span class="string">'stu_id'</span>, Integer, ForeignKey(<span class="string">'students.id'</span>)),</span><br><span class="line">    Column(<span class="string">'teach_id'</span>, Integer, ForeignKey(<span class="string">'teachers.id'</span>)),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'students'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">10</span>))</span><br><span class="line">    teachers = relationship(<span class="string">'Teacher'</span>, secondary=assocation_table, back_populates=<span class="string">'students'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'teachers'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">10</span>))</span><br><span class="line">    <span class="comment"># 建立了双向联系</span></span><br><span class="line">    students = relationship(<span class="string">'Student'</span>, secondary=assocation_table, back_populates=<span class="string">'teachers'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">stu1 = Student(name=<span class="string">'name1'</span>)</span><br><span class="line">stu2 = Student(name=<span class="string">'name2'</span>)</span><br><span class="line">stu3 = Student(name=<span class="string">'name3'</span>)</span><br><span class="line">stu4 = Student(name=<span class="string">'name4'</span>)</span><br><span class="line"></span><br><span class="line">teach1 = Teacher(name=<span class="string">'teach1'</span>)</span><br><span class="line">teach2 = Teacher(name=<span class="string">'teach2'</span>)</span><br><span class="line">teach3 = Teacher(name=<span class="string">'teach3'</span>)</span><br><span class="line">teach4 = Teacher(name=<span class="string">'teach4'</span>)</span><br><span class="line"></span><br><span class="line">session.add(stu1)</span><br><span class="line">session.add(stu2)</span><br><span class="line">session.add(stu3)</span><br><span class="line">session.add(stu4)</span><br><span class="line"></span><br><span class="line">session.add(teach1)</span><br><span class="line">session.add(teach2)</span><br><span class="line">session.add(teach3)</span><br><span class="line">session.add(teach4)</span><br><span class="line"></span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<h2 id="建立联系-2"><a href="#建立联系-2" class="headerlink" title="建立联系"></a>建立联系</h2><p>同样，要使用append和remove去添加和删除。stu1 有两个老师，teach2 有 两个学生。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">stu1.teachers.append(teach1)</span><br><span class="line">stu1.teachers.append(teach2)</span><br><span class="line">teach2.students.append(stu3)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> teach2.students:</span><br><span class="line">    print(i.name)</span><br><span class="line">    <span class="comment"># 学生的老师也是对象 需要迭代访问</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i.teachers:</span><br><span class="line">        print(j.name)</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name1</span><br><span class="line">teach1</span><br><span class="line">teach2</span><br><span class="line">name3</span><br><span class="line">teach2</span><br></pre></td></tr></table></figure></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>感觉我还是描述的有些混乱，且，建议参考<a href="https://github.com/muyuuuu/SQLAlchemy/tree/master/SQLAlchemy/relation" target="_blank" rel="noopener">全部代码</a>进行练习。</p>
]]></content>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系列（一）——SQLAlchemy的使用(CRUD)</title>
    <url>/2020/01/24/sqlalchemy/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p><a href="https://www.runoob.com/mysql/mysql-install.html" target="_blank" rel="noopener">安装MySQL</a>，<a href="http://yshblog.com/blog/195" target="_blank" rel="noopener">MySQL忘记密码</a></p>
<p>python可以通过不同的第三方库去连接各种数据库。但程序可能会使用多个数据库，需要做到一次编写适配不同的DBMS。且直接用python调用SQL的写法并不是很好，容易收到注入攻击，所以有必要使用<code>ORM(Object Relational Mapping)</code>来简化代码和使代码便于维护，而python中最著名的ORM为<code>SQLAlchemy</code>，<code>pip install SQLalchemy</code>即可。</p>
<a id="more"></a>
<h1 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h1><p>什么是注入攻击？如python直接调用数据库并插入数据：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.query.execute(<span class="string">"insert into major values(\"&#123;&#125;\", \"&#123;&#125;\")"</span>.format(major_name, college_name))</span><br></pre></td></tr></table></figure></p>
<p>但<code>major_name</code>的字符内容为：<code>计算机&quot;self.query.execute(&quot;delete table;&quot;)&quot;</code>，很容易直接删除数据表或停止软件的运行，造成不可描述的后果。即：肯能执行用户的非法输入，而这在<code>Web</code>开发中更为致命，甚至可通过植入javascript代码操控你的浏览器，达到不可描述的行为。</p>
<p>更详细的数据库攻击、及其避免方式可以参考《Flask Web开发实战 入门、进阶与原理解析》这本书（作者是李辉），算是一本不错的技术书籍。</p>
<p>也可以粗暴的看看<a href="https://blog.csdn.net/tianjf0514/article/details/8394086" target="_blank" rel="noopener">这篇文章</a>的第一部分，了解为何不能用代码直接操作数据库。</p>
<h1 id="启动数据库"><a href="#启动数据库" class="headerlink" title="启动数据库"></a>启动数据库</h1><p>我是安装的便携版的<code>MySQL</code>，所以去对应文件的位置，命令行<code>mysql -uroot -p</code>启动即可：</p>
<p><img data-src="/2020/01/24/sqlalchemy/1.png" alt></p>
<h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><p>此部分的代码建议在<code>jupyter-lab</code>这款IDE内编写，因为涉及那种命令行交互的代码较多，就是写一句执行一句，不能从头开始全部执行。</p>
<p>首先导入必要工具库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, Table, Column, Integer, String, MetaData, ForeignKey</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br></pre></td></tr></table></figure>
<p>创建数据库<code>test</code>, 命令为：<code>CREATE DATABASE test;</code></p>
<p>Engine 是访问数据库的入口，通过它连接<code>test</code>数据库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个连接引擎 </span></span><br><span class="line"><span class="comment"># create_engine("数据库类型+数据库驱动://数据库用户名:数据库密码@IP地址:端口/数据库"，其他参数)</span></span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:MyNewPass@localhost:3306/test"</span>)</span><br></pre></td></tr></table></figure>
<h1 id="定义数据库表的Schema"><a href="#定义数据库表的Schema" class="headerlink" title="定义数据库表的Schema"></a>定义数据库表的Schema</h1><p>如果我们需要一张 users 的表，那么我们可以通过一个 User 类来声明它的元数据。</p>
<ul>
<li>primary_key 设置为 true 表示为主键</li>
<li>unique 设置为 true 后，表示这个字段不能重复</li>
<li>index 设置为 true ，表示对该字段建立索引</li>
<li>nullable 默认为 true，表示可空</li>
<li>default 设置该字段的默认值</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Base = declarative_base()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="comment"># __tablename__ 指定在 MySQL 中表的名字</span></span><br><span class="line">    __tablename__ = <span class="string">'users'</span></span><br><span class="line">    <span class="comment"># 每一个类都需要主键</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)  </span><br><span class="line">    username = Column(String(<span class="number">64</span>), index=<span class="literal">True</span>)</span><br><span class="line">    email = Column(String(<span class="number">64</span>), unique=<span class="literal">True</span>, index=<span class="literal">True</span>)</span><br><span class="line">    location = Column(String(<span class="number">128</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""定义 repr 让输出更加直观优雅"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;User &#123;&#125;&gt;'</span>.format(self.username)</span><br></pre></td></tr></table></figure>
<p>在代码中创建用户完毕后，将这个表映射到MySql数据库中：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Base.metadata.create_all(bind=engine)</span><br></pre></td></tr></table></figure>
<p>在MySql中查看创建信息，其中 <code>use test;</code>表示使用当前数据库，<code>show tables;</code>表示查看当前数据库的所有数据表。</p>
<p><img data-src="/2020/01/24/sqlalchemy/2.png" alt></p>
<p>此外，SQLAlchemy的数据类型和python的数据类型的对应关系如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>python数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Integer</td>
<td>int</td>
<td>整型</td>
</tr>
<tr>
<td>String</td>
<td>str</td>
<td>字符串</td>
</tr>
<tr>
<td>Float</td>
<td>float</td>
<td>浮点型</td>
</tr>
<tr>
<td>Boolean</td>
<td>bool</td>
<td>布尔型</td>
</tr>
<tr>
<td>Date</td>
<td>datetime.date</td>
<td>日期</td>
</tr>
<tr>
<td>DateTime</td>
<td>datetime.datetime</td>
<td>日期和时间</td>
</tr>
<tr>
<td>Time</td>
<td>datetime.time</td>
<td>时间</td>
</tr>
<tr>
<td>Text</td>
<td>str</td>
<td>文本类型</td>
</tr>
<tr>
<td>LongText</td>
<td>str</td>
<td>长文本类型</td>
</tr>
</tbody>
</table>
</div>
<h1 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h1><p>众所周知，数据库用户的核心功能就是增删改查这四大金刚，而<code>SQLalchemy</code>也很好的提供了支持。查询是其中最重要的功能，所以，关于SQLAlchemy中查询的官方文档如下：<a href="https://docs.sqlalchemy.org/en/13/orm/query.html" target="_blank" rel="noopener">https://docs.sqlalchemy.org/en/13/orm/query.html</a></p>
<p>通常情况下会使用<code>session</code>完成数据库的增删改查</p>
<ul>
<li>session创建和管理数据库连接的会话 </li>
<li>model object 通过session对象访问数据库，并把访问到的数据存入（或修改）提交到数据库中。任意数量的model object被创建，并绑定到session中，session会管理这些对象，而一旦session 里面的objects 有变化，便可以commit/rollback提交或者放弃changs。</li>
<li>rollback 的使用条件是：假如session第一次add了一个对象，第二次又add了<code>同一个</code>对象，此时一定要session.rollback()，直接commit会报错。</li>
</ul>
<p>一般来说，session在需要访问数据库的时候创建，在session访问数据库的时候，准确来说，应该是“add/update/delete”数据库的时候，会开启<code>database transaction</code>, 假设没有修改autocommit的默认值(False), 那么，<code>database transaction</code> 一直会保持，只有等到session rolled back, committed, or closed（完成状态）的时候才结束。</p>
<p>所以一般建议，当<code>database transaction</code>结束的时候，同时close session, 保证，每次发起请求，都创建一个新的session。</p>
<p>此外需要保证session是一个全局的对象，所以和数据库通信的session在任何时候只有一个，且管理一个session对象远比管理两个对象简单</p>
<p>推荐做法如下，而不是一个类创建一个session：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThingOne</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go</span><span class="params">(self, session)</span>:</span></span><br><span class="line">        session.query(FooBar).update(&#123;<span class="string">"x"</span>: <span class="number">5</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThingTwo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go</span><span class="params">(self, session)</span>:</span></span><br><span class="line">        session.query(Widget).update(&#123;<span class="string">"q"</span>: <span class="number">18</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_my_program</span><span class="params">()</span>:</span></span><br><span class="line">    session = Session()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ThingOne().go(session)</span><br><span class="line">        ThingTwo().go(session)</span><br><span class="line"></span><br><span class="line">        session.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        session.rollback()</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        session.close()</span><br></pre></td></tr></table></figure>
<h2 id="session线程安全"><a href="#session线程安全" class="headerlink" title="session线程安全"></a>session线程安全</h2><p>session 不是线程安全的。在保证session object是全局变量时，在多线程的环境中，默认情况下，多个线程将会共享同一个session， 试想一下，假设A线程正在使用session处理数据库，B线程已经执行完成，把session给close了，那么此时A在使用session就会报错。所以必须保证每个线程使用的session都不一样。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> scoped_session</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line">session_factory = sessionmaker(bind=some_engine)</span><br><span class="line">Session = scoped_session(session_factory)</span><br><span class="line">some_session = Session()</span><br><span class="line">some_other_session = Session()</span><br><span class="line">some_session <span class="keyword">is</span> some_other_session <span class="comment">#True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用Session()创建的session对象都是一样的，这可以保证代码在多次调用不同的session()依然获得到相同的session 对象。 </li>
<li>使用Session()创建的session对象 是 Thread-local, session在线程与线程之间没有任何联系。</li>
</ul>
<p>那么<code>session.remove()</code>即可关闭此次会话。session创建和管理对数据库的连接，当调用close的时候，注意，sqlalchemy不会关闭与mysql的连接，而是把连接返回到连接池。</p>
<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">test = User(username=<span class="string">'test'</span>, email=<span class="string">'lanling@gmail.com'</span>, location=<span class="string">'Beijing/China'</span>)</span><br><span class="line">print(test.__dict__)</span><br><span class="line">session = sessionmaker(bind=engine)()</span><br><span class="line">session.add(test)</span><br><span class="line">session.commit()  </span><br><span class="line"></span><br><span class="line">muyu = User(username=<span class="string">'muyu'</span>, email=<span class="string">'muyu@gmail.com'</span>, location=<span class="string">'TangShan/China'</span>)</span><br><span class="line">session.add(muyu)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(muyu.username)</span><br><span class="line">muyu.username = <span class="string">'muyu1'</span></span><br><span class="line">session.add(muyu)</span><br><span class="line"><span class="comment"># 看到修改的字段</span></span><br><span class="line">session.dirty </span><br><span class="line">session.commit()</span><br><span class="line"><span class="comment"># 输出 muyu1</span></span><br><span class="line">print(muyu.username) </span><br><span class="line"><span class="comment"># 不合法</span></span><br><span class="line">print(muyu1.username)</span><br></pre></td></tr></table></figure>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># muyu1 不合法</span></span><br><span class="line">session.delete(muyu) </span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>
<h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>session 接受到query查询语句, 执行的结果或保持或者关联到session中</p>
<p>首先<code>pip install faker</code>用于生成一些虚假数据。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 faker 这个模块来生成一些假数据</span></span><br><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker </span><br><span class="line"></span><br><span class="line">faker = Faker()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_data_generate</span><span class="params">(User, session)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        user = User(username=faker.name(), email=faker.email(), location=faker.address())</span><br><span class="line">        session.add(user)</span><br><span class="line">    session.commit()</span><br><span class="line">fake_data_generate(User, session)</span><br></pre></td></tr></table></figure>
<p>可以在命令行内<code>select *</code>一下，查看是否生成成功。</p>
<p><img data-src="/2020/01/24/sqlalchemy/4.png" alt></p>
<h3 id="返回所有查询结果"><a href="#返回所有查询结果" class="headerlink" title="返回所有查询结果"></a>返回所有查询结果</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">session.query(User).all()</span><br></pre></td></tr></table></figure>
<h3 id="增加查询条件"><a href="#增加查询条件" class="headerlink" title="增加查询条件"></a>增加查询条件</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> text</span><br><span class="line">query = session.query(User).filter(text(<span class="string">"id &gt; 1"</span>))</span><br><span class="line"><span class="comment"># 全部查询结果</span></span><br><span class="line">query.all()</span><br><span class="line"><span class="comment"># 查询结果的第一个</span></span><br><span class="line">query.first()</span><br><span class="line"><span class="comment"># 查询计数</span></span><br><span class="line">session.query(User).count()</span><br><span class="line"><span class="comment"># 查询单个</span></span><br><span class="line">a = session.query(User).filter(User.id == <span class="number">1</span>)</span><br><span class="line">print(a.all())</span><br><span class="line">print(a[<span class="number">0</span>].username)</span><br></pre></td></tr></table></figure>
<p>注意事项，<code>text</code>模式的查询，更多的用于打印查询命令。我尝试了在python3.8下，这个输出不了查询结果，但是别人的可以，所以我还是不要用<code>text</code>模式的查询了。</p>
<p><img data-src="/2020/01/24/sqlalchemy/3.png" alt></p>
<h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">bob = User(username=<span class="string">'test'</span>, email=<span class="string">'test@gmail.com'</span>, location=<span class="string">'BeiJing/China'</span>)</span><br><span class="line">session.add(bob)</span><br><span class="line">session.rollback()</span><br><span class="line"><span class="keyword">print</span> (blog <span class="keyword">in</span> session) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p><a href="https://sunnyingit.github.io/book/section_python/SQLalchemy-orm.html" target="_blank" rel="noopener">这里有更多的查询方式</a></p>
<h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p><a href="https://github.com/muyuuuu/SQLAlchemy" target="_blank" rel="noopener">https://github.com/muyuuuu/SQLAlchemy</a></p>
<p>后续的东西实在太多了，决定分开写了。</p>
<h1 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h1><p><a href="https://stackoverflow.com/questions/20353402/access-denied-for-user-testlocalhost-using-password-yes-except-root-user" target="_blank" rel="noopener">Access denied for user ‘test’@’localhost’ (using password: YES) except root user</a><br><a href="https://sunnyingit.github.io/book/section_python/SQLalchemy-session.html" target="_blank" rel="noopener">Session参考</a><br><a href="https://anyisalin.github.io/2017/03/18/python-sqlalchemy/" target="_blank" rel="noopener">SQLAlchemy参考</a><br><a href="https://blog.csdn.net/qianbin3200896/article/details/90180980" target="_blank" rel="noopener">vscode 中一键规范化 python 代码</a></p>
]]></content>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>一些攻击算法</title>
    <url>/2021/09/22/some-attack-methods/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>又又又摸了几天，写了个爬虫，还是回来看论文了。整理一些常见的基于生成的攻击算法，之后再看一些较新的论文，就开始写自己的论文了，<del>早日毕业吧</del>。</p>
<a id="more"></a>
<h1 id="Natural-ADV"><a href="#Natural-ADV" class="headerlink" title="Natural ADV"></a>Natural ADV</h1><p>GENERATING NATURAL ADVERSARIAL EXAMPLES，发表在 ICLR 2018。众所周知，神经网络的输入层含有的信息和和隐层含有的信息是不同的，且常见攻击算法生成的对抗样本并不具有语义特征。所以这篇论文尝试生成 natural 的对抗样本。</p>
<p>与传统算法不同的是：传统算法在输入空间搜索对抗样本，而本文的算法尝试在隐空间进行搜索。即输入的为干净样本的分布 $P(x)$，搜索一个 $z^\star$，并通过生成器将其映射回 $x^\star$，并期望对抗样本是合法且和原始输入较为接近。</p>
<p>为了达到这个目标，作者选用 WGAN 作为生成器。首先训练一个 $G$，可以由 $z$ 生成 $x$；同时训练一个与 $G$ 相反的 $I$，由 $x$ 生成 $z$。通过最小化重构 $x$ 和 $z$ 与 $I(G(z))$ 的误差作为损失函数训练模型。</p>
<p><img data-src="https://z3.ax1x.com/2021/09/22/4US1kF.png" alt></p>
<p>之后便是对抗样本的生成方法，使用生成器来判断当前的噪音是否能欺骗分类器，即在 $f(G(z’)) \neq f(x)$ 的情况下，选择一个 $z’$，这个 $z’$ 和 $I(x)$ 最为接近，那么对抗样本就是 $x^\star=G(z’)$。那么问题来了，如何搜索 $z’$ 呢？论文提出了两种搜索算法，都是直接在干净样本对应的隐向量 $z$ 上增加扰动，如果扰动可以成功的攻击分类器，那么就认为搜索到了 $z’$。</p>
<p><img data-src="https://z3.ax1x.com/2021/09/22/4U9gdf.png" alt></p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>关于程序调用和递归的理解</title>
    <url>/2019/09/22/stack/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h1><p>(1) 函数在调用处暂停执行;</p>
<p>(2) 调用时将实参复制给形参;</p>
<p>(3) 执行被调用的函数;</p>
<p>(4) 调用函数结束, 给出返回值, 函数回到调用前的暂停位置继续执行.</p>
<a id="more"></a>
<h1 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h1><p>调用栈函数调用时产生，描述了函数之间的调用关系。由多个栈帧组成，每个栈帧对应一个没有运行完的函数，栈帧保存了该函数的返回地址和局部变量。所以可以保证在执行完毕后找到返回地址。保证了不同函数的局部变量互不相干，因为不同函数对应了不同的栈帧。</p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>步骤与上述内容相同, 但是调用的函数为自己, 即自身调用自身。（如经典的非波那切数列）</p>
<p>以<code>Cpp</code>为例，编译后的可执行文件存放的内容中主要内容为段，段是指二进制文件内的区域。所有某种特定类型的信息保存在里面，<code>size</code>得到各个段的大小。执行如下指令会：</p>
<p><img data-src="/2019/09/22/stack/1.png" alt></p>
<p><code>text</code>：存储代码指令（也叫正文段）</p>
<p><code>data</code>：存储初始化的全局变量（也叫数据段）</p>
<p><code>bss</code>：存储未赋值的全局变量所需要的空间</p>
<p>可执行文件并不包括调用函数时的调用栈，而是在运行时创建。调用栈所在的段为堆栈段，也有自己的大小，不能被访问越界，否则会出现段错误（Segmentation Fault）。而每次递归会在调用栈里面添加一个栈帧，栈帧过多会越界，叫做堆栈溢出（Stack Overflow）。调用栈存放了函数的调用关系和局部变量。</p>
<h1 id="查看堆栈段的大小"><a href="#查看堆栈段的大小" class="headerlink" title="查看堆栈段的大小"></a>查看堆栈段的大小</h1><p><code>linux</code>下，栈大小并没有在可执行文件中，需要通过指令修改。<code>ulimit-a</code>，观察其中的<code>stack size</code>即为所求。</p>
<p><img data-src="/2019/09/22/stack/2.png" alt></p>
<p><code>ulimit -s 37629</code>进行修改：</p>
<p><img data-src="/2019/09/22/stack/3.png" alt></p>
<p>栈溢出不一定是递归太多，也可能是局部变量太大，总大小超出允许的范围，就会产生栈溢出。因此，较大数组存储在main函数之外，因为局部变量存放在堆栈段。（main函数中的变量同样为局部变量）</p>
]]></content>
      <tags>
        <tag>Computer</tag>
      </tags>
  </entry>
  <entry>
    <title>通用的子串匹配问题求解算法</title>
    <url>/2020/02/23/substring-match/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>19年夏天出去面试的时候，被考了一道子串匹配的问题。当时也没回答上来，当时的学长说可以用类似二叉树的方式去查找，一个分支走不通的时候开始回溯到另一个分支，当时实在是太饿了，大概只听懂了这些吧。今天在刷题的时候又再次遇到了这个题目，也想到了更为简易(时间复杂度$O(n)$)和通用的算法，记录于此。</p>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>字符串 <code>APPAPT</code> 中包含了两个单词 <code>PAT</code>，其中第一个 PAT 是第 2 位(P)，第 4 位(A)，第 6 位(T)；第二个 PAT 是第 3 位(P)，第 4 位(A)，第 6 位(T)。那么可以类比到：<code>PPPAAATTT</code>有27个<code>PAT</code>。现给定字符串，问一共可以形成多少个 <code>PAT</code>？由于结果可能比较大，只输出对 1000000007 取余数的结果。</p>
<h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><h2 id="一个常识"><a href="#一个常识" class="headerlink" title="一个常识"></a>一个常识</h2><script type="math/tex; mode=display">(a+b)\%c = a \% c + b \% c</script><p>如 $101 \% 100 + 50 \% 100 = (100 + 51) \% 100 = 51$</p>
<h2 id="错解思路"><a href="#错解思路" class="headerlink" title="错解思路"></a>错解思路</h2><p>当时的思路记不太清，我现在的想法是使用遍历的方法，先寻找<code>P</code>，在寻找<code>A</code>，在寻找<code>T</code>，当前字符不满足就跳到下一个字符，一条路走不通就走下一条路。以<code>APPAPT</code>第二位的<code>P</code>为例。从<code>P</code>开始，依次向后遍历字符，遇到错误的字符跳过，遇到正确的字符+1，如下图所示。</p>
<p><img data-src="/2020/02/23/substring-match/1.png" alt></p>
<p>第二位的<code>P</code>处理完毕后开始第三位<code>P</code>的处理，也很容易看出来，查找3个字符，复杂度为$O(n^3)$，查找4个字符，复杂度为$O(n^4)$，且代码维护不易容易超时。粗糙的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] != <span class="string">'P'</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.length(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] != <span class="string">'A'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; j &lt; s.length(); k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[k] == <span class="string">'T'</span>)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>既然容易超时，得想办法把时间复杂度给降下来，争取一次遍历在时间复杂度为$O(n)$内把问题解决掉。既然假设只能遍历一次，那么也可以理解为最终的个数是：有序字符<code>P,A,T</code>的排列组合数。</p>
<p>有序是指<code>P</code>要在<code>A</code>的前面，<code>A</code>要在<code>T</code>的前面，顺序错了的不能计算。最后，统计有几个有序的<code>P, A, T</code>，相乘一下即可解决。如<code>PPPAAATTT</code>中，有序的<code>P</code>是3个，<code>A</code>是3个，<code>T</code>是3个，那么最后的结果就是：$3\times3\times3=27$。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><code>T</code>的个数为<code>countt</code>，<code>P</code>的个数为<code>countp</code>，最终结果的个数为<code>result</code>。</p>
<ol>
<li>读取字符串，先统计<code>T</code>的个数。</li>
<li>开始遍历字符串：</li>
<li>遇到一个<code>P</code>，那么<code>P</code>的个数加一。</li>
<li>遇到一个<code>A</code>，开始计数，数量为<code>result += countt * countp</code>。</li>
<li>遇到一个<code>T</code>，<code>T</code>的个数减一。这样可以做到：<code>A</code>前面的<code>T</code>无效，遇到<code>A</code>后计算一次<code>P, T</code>的组合数，指针向后移动继续遍历，<code>T</code>的数量减少一个。如字符串<code>PPPAAAATTTTAT</code>，计算到倒数第二个<code>A</code>时，此时只有一个<code>T</code>。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> len = s.length(), result = <span class="number">0</span>, countp = <span class="number">0</span>, countt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'T'</span>)</span><br><span class="line">            countt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'P'</span>) countp++;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'T'</span>) countt--;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'A'</span>) result = (result + countp * countt) % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>如果题目要求是寻找有几个<code>PSAT</code>呢，如果是寻找有几个<code>PNSAT</code>呢。错误的思路只会无限制的增加循环次数，而正解仍然能够在$O(n)$内解决问题。只需要把<code>PS</code>看作一个整体，在增加一个<code>S</code>的计数变量即可。如寻找<code>PSSSATTAAT</code>中<code>PSAT</code>的个数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> len = s.length(), result = <span class="number">0</span>, countp = <span class="number">0</span>, countt = <span class="number">0</span>, counts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'T'</span>)</span><br><span class="line">            countt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'P'</span>) countp++;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'S'</span>) counts++;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'T'</span>) countt--;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'A'</span>) result = (result + countp * counts * countt) % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为15。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/liuchuo/PAT/tree/master/BasicLevel_C%2B%2B" target="_blank" rel="noopener">柳神的代码, 1040</a></p>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的应用——判断pop序列是否合理</title>
    <url>/2020/03/28/stack-pop-sequence/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>栈有着广泛的应用，比如逆波兰表达式，表达式求值，迷宫问题求解，程序调用等，不过这些问题今天都不涉及哈哈哈哈。关于程序执行期间，各个函数的相互调用使用的调用栈，可以<a href="https://muyuuuu.github.io/2019/09/22/stack/">参考这里</a>。</p>
<p>也许在上数据结构这门课的时候，经常遇到一个问题，一个栈压入一个序列，随缘pop，判断哪个是合理的pop，哪个是不合理的pop，之前都是脑内演算。很巧的今天我在刷题期间也遇到了，记录一下如何用代码判断pop序列是否合理。</p>
<a id="more"></a>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Given a stack which can keep $M$ numbers at most. Push $N$ numbers in the order of 1, 2, 3, …, $N$ and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. </p>
<p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): $M$ (the maximum capacity of the stack), $N$ (the length of push sequence), and $K$ (the number of pop sequences to be checked). Then $K$ lines follow, each contains a pop sequence of $N$ numbers. All the numbers in a line are separated by a space.</p>
<p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p>
<h2 id="示例输入"><a href="#示例输入" class="headerlink" title="示例输入"></a>示例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7 5</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">3 2 1 7 5 6 4</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">5 6 4 3 7 2 1</span><br><span class="line">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure>
<h2 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a>示例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<p>众所周知，栈是先进先出的一种数据结构，进栈为push，出栈为pop。题目的大概意思就是给定栈的最大空间，压入的序列和待检查的pop序列，因为栈是随缘pop的，判断哪个pop序列是正确的，哪个pop序列是错误的。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="脑内演算"><a href="#脑内演算" class="headerlink" title="脑内演算"></a>脑内演算</h2><ul>
<li>对于序列 1, 2, 3, 4, 5, 6, 7， 很容易得到栈是如何工作的，即压入一个元素立刻弹出即可。push 1，pop 1，push 2，pop 2，一直到push 7，pop 7。</li>
<li>对于序列 5, 6, 4, 3, 7, 2, 1，也可以得到栈的工作顺序为：push 1, 2, 3, 4, 5，而后pop 5，而后push 6 pop 6，pop 4，pop 3，push 7 pop 7，pop 2，pop 1。</li>
<li>对于序列 3, 2, 1, 7, 5, 6, 4，如果pop 7后，后面的顺序必然是 6，5，4而不可能是5，6，4。因此这个序列是错误的。</li>
<li>对于序列 7, 6, 5, 4, 3, 2, 1，在栈空间为5的情况下，不可能第一次就pop 7，因此这个序列是错误的。</li>
</ul>
<h2 id="一般化"><a href="#一般化" class="headerlink" title="一般化"></a>一般化</h2><p>在脑内演算后，也很容易发现题的难点在于不确定性的pop，可能在第一次pop，也可能在第三次pop，且每次pop几个元素也是不确定的。</p>
<p>我们实现知道了元素的进栈顺序，是1，2，3，4，…，$N$这样的顺序序列，所以，如果想办法<strong>按着它给出的序列模拟压栈和弹栈</strong>，如果能模拟出来，说明序列正确，模拟不出来说明序列错误。</p>
<ul>
<li><p>第一步，创建一个序列，读取题目示例输入的序列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，创建一个栈，并按元素的输入顺序组织元素进栈，开始按读取序列元素的顺序进行压栈和弹栈。</p>
</li>
<li><p>对输入序列设立标志位，并初始化标志位为1。当刚进栈的元素和输入序列标志位的元素相等时，说明此时元素要弹栈，则执行弹栈操作，且标志位自增向后移动；若不相等，则继续组织进栈，直到进栈元素和输入序列中标志位的元素相等。若一直不相等，则表明此序列错误。因此核心算法程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设立标志位</span></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">    <span class="comment">// 按元素顺序组织进栈</span></span><br><span class="line">    s.push(j);</span><br><span class="line">    <span class="comment">// 超过栈允许的最大空间</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() &gt; m) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 按序列元素的弹栈顺序开始模拟</span></span><br><span class="line">    <span class="comment">// 栈非空且栈顶元素和当前标志位的元素相等</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() == arr[pos]) &#123;</span><br><span class="line">        <span class="comment">// 弹栈</span></span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="comment">// 标志位自增</span></span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>得到最终的程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1002</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>, pos = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(i);</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; m) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() == arr[pos])</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                pos += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == n + <span class="number">1</span>) flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="/2020/03/28/stack-pop-sequence/1.png" alt></p>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>故宫的雪，雪的故宫</title>
    <url>/2020/01/07/the-palace-museum-in-snow/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>只是想出来走走，谁能想到来了北京就下雪了呢。雪后的故宫少了几分平时的端庄肃穆和威严，多了些许的轻快、明丽和舒适。就像传统的中国古风，生于盛世，站于城墙之上，俯览灯火通明的闹市，忙碌一天的官人手里攥着刚买的冰糖葫芦，腰间别着集市上刚买的香包，散步于角楼水畔，栖身在城市的夜景中也算是一天后的休息；遥想日出而作日落而息穿梭于大街小巷的常人，叫卖声走路声喜悦声甚至发呆的声音, 记录于画记录于诗也描述不了盛世的画卷，袅袅炊烟后的万家灯火，金谷鸣响后的烽烟四起，沧桑风雨后的山河依旧，像一曲悠长的古曲，跌宕起伏。</p>
<p>多年不读书不写作，大概不会写文字了。</p>
<a id="more"></a>
<p><img data-src="/2020/01/07/the-palace-museum-in-snow/1.jpg" alt><br><img data-src="/2020/01/07/the-palace-museum-in-snow/3.jpg" alt><br><img data-src="/2020/01/07/the-palace-museum-in-snow/4.jpg" alt><br><img data-src="/2020/01/07/the-palace-museum-in-snow/5.jpg" alt><br><img data-src="/2020/01/07/the-palace-museum-in-snow/6.jpg" alt><br><img data-src="/2020/01/07/the-palace-museum-in-snow/11.jpg" alt><br><img data-src="/2020/01/07/the-palace-museum-in-snow/17.jpg" alt><br><img data-src="/2020/01/07/the-palace-museum-in-snow/29.jpg" alt><br><img data-src="/2020/01/07/the-palace-museum-in-snow/31.jpg" alt><br><img data-src="/2020/01/07/the-palace-museum-in-snow/32.jpg" alt><br><img data-src="/2020/01/07/the-palace-museum-in-snow/39.jpg" alt><br><img data-src="/2020/01/07/the-palace-museum-in-snow/40.jpg" alt><br><img data-src="/2020/01/07/the-palace-museum-in-snow/42.jpg" alt></p>
]]></content>
      <categories>
        <category>北京印象</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch并行训练</title>
    <url>/2021/02/23/torch-parallel/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文以 pytorch 为框架，分别从数据并行训练的方法(DataParallel, DistributedDataParallel)、并行加载数据两个角度，阐述了本次实验中并行算法的设计思想，并对并行实现的原理进行了解析，包括多进程的工作流程和通信方法等。<del>语言这么正规的原因是：这是从大作业里面摘出来的。</del>神经网络那部分我就不写了，跑题，最后直接给代码。</p>
<a id="more"></a>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h2><ul>
<li>CPU：2个Intel(R) Xeon(R) Gold 5115 CPU \@ 2.40GHz，10核心20线程。</li>
<li>GPU：4路Tesla P40，每路显存容量22GB，共88GB。</li>
<li>内存：128GB。</li>
<li>外存：520TB可用，已用15TB。</li>
</ul>
<h2 id="软件环境与版本"><a href="#软件环境与版本" class="headerlink" title="软件环境与版本"></a>软件环境与版本</h2><ul>
<li>运行程序的系统为 CentOS Linux release 7.3.1611。</li>
<li>开发程序的系统为 Arch 5.9.6。</li>
<li>python：3.8.2：作为开发语言。</li>
<li>pytorch：1.6.0：作为模型实现的工具，借助其提供的API实现并行。</li>
<li>ssh：OpenSSH_8.3p1, OpenSSL 1.1.1h，实现远程登录功能，即本地登录到服务器。</li>
<li>scp：实现文件传输功能，将本地文件传输至服务器，或将服务器文件传输至本地。</li>
</ul>
<h1 id="并行加载数据"><a href="#并行加载数据" class="headerlink" title="并行加载数据"></a>并行加载数据</h1><p>在加载数据时，可以使用多进程来加载数据。不使用多线程的目的是：python 的多线程因为 GIL（Global Interpreter Lock）的存在，只能在单核运行。不能发挥多核处理器的优势，因此只适合 I/O 型任务，不适合密集计算型任务。</p>
<p>首先以 torch.utils.data.Dataset 为父类，创建一个加载数据集的子类：MiniImagenet。在 MiniImagenet中，设置__getitem__方法来支持数据集的切片访问，即批量加载数据。</p>
<p>在训练阶段，实例化加载数据集的类，得到一个实例对象。在 torch.utils.data.DataLoader 中传入实例对象来加载数据，并设置其他参数来提升加载数据的速度和数量。设置 num_workers=8 可以使用 8 进程来加载数据，设置 batch_size=batchsz 对应 MiniImagenet 类的 __getitem__ 切片访问，即一次获取的训练数据的大小。</p>
<p>在创建 num_workers 个进程之后，多个进程共享一份数据集，将指定 batch（一批待加载的目标数据）分配给指定 worker（一个进程），worker 将对应 batch 的数据加载进内存。因此增大 num_workers 的数量，内存的占用率也会增加。在第一个 batch 的数据加载完成后，会等待主进程将该 batch 取走并汇总，而后此 worker 开始加载下一个 batch，不断迭代。</p>
<p>主进程采集完最后一个 worker 的数据后，此时需要返回并采集第一个 worker 加载的第二个 batch。如果第一个 worker 此时没有加载完，主线程将阻塞等待当前 worker 的数据加载完毕。最后所有数据加载完毕后，汇总到一起供用户使用。</p>
<p>当 num_worker 设置的很大时，优点时可以快速的寻找目标 batch；缺点是内存开销大，也加重了 CPU 维护进程的开销，如创建、初始化、通信、分配任务、接受任务反馈和销毁进程等。num_workers 的经验设置值是服务器的 CPU 核心数，如果 CPU 性能强大且内存充足，可以设置为较大的数值。</p>
<h1 id="DataParallel"><a href="#DataParallel" class="headerlink" title="DataParallel"></a>DataParallel</h1><p>DataParallel 并行方式实现较为简单。首先将模型放到主 GPU 中，一般是 GPU-0；而后将模型复制得到副本，将模型副本放到另外的$n$张 GPU 中，将输入的batchsz大小的数据平均分为$n$份依次作为每个模型副本的输入。因此要求 batchsz 的大小要大于 GPU 的数量，否则数据无法分配，会导致有的模型副本得不到数据。</p>
<p>每个模型副本独立的进行前向计算，得到各自的 loss值。在$n$个GPU完成计算后，将 loss 汇总到 GPU-0 中，由 GPU-0 中的模型进行反向传播和更新参数。更新好参数后，由 GPU-0 将参数分发至其他$n$个 GPU 卡，开始新一轮的计算。DataParallel 并行结构示意图如图所示：</p>
<p><img data-src="https://s3.ax1x.com/2021/02/23/yLsmwD.png" alt></p>
<p>DataParallel基于单进程多线程实现，因为python的多线程无法利用多核处理器，只能在单核上进行任务调度和参数更新的通信，所以此种方式并行效率较低，且0号卡负担较大。</p>
<h1 id="DistributedDataParallel"><a href="#DistributedDataParallel" class="headerlink" title="DistributedDataParallel"></a>DistributedDataParallel</h1><p>DistributedDataParallel 并行方式实现较为复杂，且相对于 DataParallel 需要更大的显存空间。DistributedDataParallel 使用的进程数量一般和GPU数量相等，对每个进程创建一个 DistributedDataParallel 实例，通过进程通信来同步梯度，通信方式为 AllReduce 。</p>
<p>在任务初始化阶段，即并行程序执行之前首先要创建通信群组，通信群组中的每一个进程创建一个 DistributedDataParallel 实例。DistributedDataParallel 通过rank0（进程ID）将当前模型的结构和参数等状态通过广播通信的形式发送到进程组的所有进程中，确保其他进程中的模型副本和当前模型保持一致。而后，每个进程创建一个本地的Reducer，用于反向传播阶段同步参数的梯度。因此相比于DataParallel， DistributedDataParallel 需要更大的显存容量。为了提升通信效率，Reducer将参数放到多个桶中，每次以桶为单位进行通信。</p>
<p>模型参数需要额外附加 unready 和 ready 两种状态，默认为 unready 状态。若参数在反向传播阶段计算了梯度，则参数由 unready 状态变为 ready 状态，表示这个参数可以同步到其他模型；否则保持 unready 状态。当模型完成一次训练后，参数由 ready 状态变为 unready 状态，为下一次训练做准备。</p>
<p>因为在反向传播阶段，DistributedDataParallel 只会等待 unready 状态的参数更新，所以在前向计算阶段首先要分析计算图，将不进行梯度更新的参数状态永久设为 ready 状态，防止这些参数影响反向传播。DistributedDataParallel 在获取输入数据后，将输入数据分发到每个 GPU 中，模型副本开始前向计算得到各自的 loss 值，而后开始反向传播。</p>
<p>DistributedDataParallel 在初始化阶段会为每一个可求导的参数申请一个自动求导的钩子，来发射同步梯度的信号。在反向传播阶段，当一个参数计算梯度后会为 ready 状态，对应梯度的钩子就会发射信号，DistributedDataParallel 会标记该参数的状态，表示该参数的梯度可以用于同步。当一个桶内的参数全部由 unready 状态变为 ready 状态后，Reducer通过AllReduce的通信方式来更新桶内的参数，来计算所有模型副本中参数梯度的平均值。</p>
<p>以4个GPU为例，其 AllReduce 通信方式如下图所示。</p>
<p><img data-src="https://s3.ax1x.com/2021/02/23/yLsc0U.png" alt></p>
<p>在上图中，rank0 将自己模型副本的梯度 D0 发送给 rank1，rank2和rank3，其他进程同理。因此在 AllReduce 通信后，所有的模型副本的梯度值保持一致。</p>
<p>当所有的桶更新完毕后，Reducer 会阻塞等待 AllReduce 的所有操作结束，如重新将参数设为 unready 状态。因为所有模型副本的梯度值相同，所以在梯度更新阶段，只需更新本卡中的模型参数。因为所有的模型副本来自相同的初始状态，且具有相同的平均梯度值，所以在梯度更新后所的模型副本状态都会保持一致，以此来实现并行。</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>DataParallel 和 DistributedDataParallel 都属于数据并行的方法，在分析完各自的实现原理后，可以得到二者的对比。对比情况如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>DataParallel</th>
<th>DistributedParallel</th>
</tr>
</thead>
<tbody>
<tr>
<td>机器支持</td>
<td>只支持单机</td>
<td>可支持多机</td>
</tr>
<tr>
<td>模型支持</td>
<td>不支持拆分模型</td>
<td>可以将模型放到多张GPU中</td>
</tr>
<tr>
<td>通信方式</td>
<td>scatter input 和 gather output</td>
<td>scatter input 和 AllReduce</td>
</tr>
<tr>
<td>并行支持</td>
<td>只支持数据并行</td>
<td>支持数据并行和模型并行</td>
</tr>
<tr>
<td>进程与线程</td>
<td>单进程、多线程</td>
<td>多进程</td>
</tr>
</tbody>
</table>
</div>
<p>这里需要注意的是，如果将batchsz太小，由此可见，AllReduce在数据量很小的情况下，每一次梯度更新带来的进程通信、任务调度与分配的开销占比会增大，而用于数据通信的开销占比却很小，导致并行效率没有明显提升。因此AllReduce不适合数据量较小情况下的通信。这里我尝试过。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/muyuuuu/Algorithm/tree/master/meta-learning/Metric-based/Relation-Netowrk" target="_blank" rel="noopener">https://github.com/muyuuuu/Algorithm/tree/master/meta-learning/Metric-based/Relation-Netowrk</a></p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>Keras玩耍迁移学习(VGG16)</title>
    <url>/2019/02/17/transfer-learning/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>某天(今天)下午闲的没事干，想起了当初学了一堆的深度学习的数学概念，还看了Keras的官方文档，既然会写(抄)代码和懂了理念，不如自己折腾点东西玩玩。</p>
<p>说干就干.png，本来是想做个OCR系统在写个GUI界面弄个小软件的，因为种种原因放弃(不喜欢那个数据集)，猫狗大战的话数据量太大。挑来挑去选择了迁移学习，使用VGG16的结构去识别MNIST手写文字，怎么感觉有一个好的开始却选择了一个low的实现呢？其实也无所谓，重点是实现过程，有了这次过程实现以后的迁移学习就不是问题了。</p>
<hr>
<a id="more"></a>
<p>如果对本文有疑问或者想找男朋友，可以联系我，<a href="https://muyuuuu.github.io/about/">点击此处有我联系方式</a>。</p>
<h2 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h2><p>所谓迁移学习，是在数据样本较少或者没有GPU或者缺钱的情况下，直接使用别人训练好的参数权重而不是自己重新训练，毕竟自己穷的买不起GPU。当然，别人训练好的权重在自己的小数据集里面同样能取得很好的效果，因为前期的权重无非是提取些水平、数值、纹理特征，而这些基本特征与具体的数据集无关。</p>
<p>比如自己写了十层的网络，可以冻结前九层网络的参数使其不参与训练，在最后添加一层为自己的分类层，将数据带入前九层得到输出$y$，最后一层接收$y$为输入，只训练最后一层的权重预测输出，同时也能得到较好的结果。</p>
<p><span id="inline-blue"> 同样得到下面的结论： </span></p>
<blockquote>
<p>当数据越多，冻结的层数也越少(训练自己的特征)，当有相当可观的数据时，应该从头开始自己训练。</p>
</blockquote>
<h2 id="下载数据集"><a href="#下载数据集" class="headerlink" title="下载数据集"></a>下载数据集</h2><p>MNIST数据集的下载和导入：</p>
<ul>
<li><a href="https://s3.amazonaws.com/img-datasets/mnist.npz" target="_blank" rel="noopener">下载地址</a></li>
<li>numpy导入：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path=<span class="string">'examples/mnist.npz'</span></span><br><span class="line">f = np.load(path)</span><br><span class="line"></span><br><span class="line">x_train1, y_train = f[<span class="string">'x_train'</span>], f[<span class="string">'y_train'</span>]</span><br><span class="line">x_test1, y_test = f[<span class="string">'x_test'</span>], [<span class="string">'y_test'</span>]</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="下载VGG16权重"><a href="#下载VGG16权重" class="headerlink" title="下载VGG16权重"></a>下载VGG16权重</h2><p><a href="https://github.com/fchollet/deep-learning-models/releases" target="_blank" rel="noopener">来这里下载VGG16的权重</a></p>
<p>提示：</p>
<ul>
<li>vgg16_weights_tf_dim_ordering_tf_kernels.h5 表示全部VGG16权重。</li>
<li>vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5 表示不要最后全连接层的权重。</li>
</ul>
<p>要下载第二个，因为最后一层是自己要重新定义和训练的，所以不要VGG16原始的最后几层的权重。然而top一共是3层，权重参数的大小就从50MB突变到了500MB。可想最后3层得多少参数。</p>
<h2 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h2><ul>
<li>python 3.5</li>
<li>keras 2.2.2</li>
<li>代码执行的话，一段代码copy进一个jupyter lab的格子里执行就行。像下面那样，怎么总感觉在说废话。。。<br><img data-src="/2019/02/17/transfer-learning/5.png" alt></li>
</ul>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p><span id="inline-green"> 如果用的是其他数据选择性忽略这里。 </span></p>
<p>不幸的是VGG16能接受的图片大小至少是48，必须有RGB三通道，奈何MNIST数据集的大小是28，还没有RGB通道，只能使用numpy快速处理一下。</p>
<p>将图片填充为48 $\times$ 48和三个通道，三个通道就用自己本身复制三次代替，填充值为0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">path=<span class="string">'examples/mnist.npz'</span></span><br><span class="line">f = np.load(path)</span><br><span class="line"></span><br><span class="line">x_train1, y_train = f[<span class="string">'x_train'</span>], f[<span class="string">'y_train'</span>]</span><br><span class="line">x_test1, y_test = f[<span class="string">'x_test'</span>], f[<span class="string">'y_test'</span>]</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据填充</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这段代码写的不是很好，pad三个维度，将shape[0]个数组填充，实在是不会只能用for循环</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">x_train = np.ones((x_train1.shape[<span class="number">0</span>], <span class="number">48</span>, <span class="number">48</span>))</span><br><span class="line">x_test = np.ones((x_test1.shape[<span class="number">0</span>], <span class="number">48</span>, <span class="number">48</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">0</span>, x_train.shape[<span class="number">0</span>]):</span><br><span class="line">    x_train[i] = np.pad(x_train1[i], ((<span class="number">10</span>,<span class="number">10</span>),(<span class="number">10</span>,<span class="number">10</span>)), <span class="string">'constant'</span>, constant_values = (<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">0</span>, x_test1.shape[<span class="number">0</span>]):</span><br><span class="line">    x_test[i] = np.pad(x_test1[i], ((<span class="number">10</span>,<span class="number">10</span>),(<span class="number">10</span>,<span class="number">10</span>)), <span class="string">'constant'</span>, constant_values = (<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将单通道的图像填充为三通道</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gray2rgb</span><span class="params">(array)</span>:</span></span><br><span class="line">    number = array.shape[<span class="number">0</span>]</span><br><span class="line">    height = array.shape[<span class="number">1</span>]</span><br><span class="line">    width = array.shape[<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    array = np.repeat(array, <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    array = array.reshape(number, height, width, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">x_train = gray2rgb(x_train)</span><br><span class="line"><span class="comment"># y_train = gray2rgb(y_train)</span></span><br><span class="line">x_test = gray2rgb(x_test)</span><br><span class="line"><span class="comment"># y_test = gray2rgb(y_test)</span></span><br></pre></td></tr></table></figure>
<p>实际的训练数据有60000，我试了一下导入全部数据结果CPU和内存差点爆炸，因为我穷买不起GPU，所以只能用小部分数据做着玩玩，反正学的是思路，再说了迁移学习适合小数据，我只是选择了小部分数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 100个训练数据</span></span><br><span class="line">x_train = x_train[<span class="number">59900</span>:]</span><br><span class="line">y_train = y_train[<span class="number">59900</span>:]</span><br><span class="line"><span class="comment"># 10个测试数据</span></span><br><span class="line">x_test = x_test[<span class="number">9990</span>:]</span><br><span class="line">y_test = y_test[<span class="number">9990</span>:]</span><br></pre></td></tr></table></figure>
<h2 id="VGG16迁移"><a href="#VGG16迁移" class="headerlink" title="VGG16迁移"></a>VGG16迁移</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">height, width = x_train.shape[1], x_train.shape[2]</span><br><span class="line">channels = x_train.shape[-1]</span><br><span class="line"></span><br><span class="line">path=&apos;weights/vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5&apos;</span><br><span class="line"></span><br><span class="line">from keras.applications import vgg16</span><br><span class="line">base_model = vgg16.VGG16(weights = path,</span><br><span class="line">                         include_top = False, ## 是否保留顶层的3个全连接网络</span><br><span class="line">                         input_shape = (height, width, channels), ## 输入层的尺寸</span><br><span class="line">                        )</span><br><span class="line">base_model.summary()</span><br></pre></td></tr></table></figure>
<p>我们发现迁移过来的VGG16是长这样的：最后一层的输出是(1, 1, 512)。那么添加的下一层的全连接层的输入维度就是512。</p>
<p><img data-src="/2019/02/17/transfer-learning/2.png" alt></p>
<p><img data-src="/2019/02/17/transfer-learning/3.png" alt></p>
<h2 id="加入自定义层"><a href="#加入自定义层" class="headerlink" title="加入自定义层"></a>加入自定义层</h2><p>将原始图片导入VGG16得到现在开始加入自己自定义的层，我添加了一个100个节点的全连接层和10个节点的全连接层。记得第一层的输入维度是512哦～</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出VGG16的计算特征</span></span><br><span class="line">train_feature = base_model.predict(x_train, batch_size=<span class="number">32</span>)</span><br><span class="line">print(train_feature.shape)</span><br><span class="line"></span><br><span class="line">x_data = train_feature.copy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Activation</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line"><span class="comment"># 添加第一层</span></span><br><span class="line">model.add(Dense(<span class="number">100</span>, activation=<span class="string">'relu'</span>, input_dim=<span class="number">512</span>))</span><br><span class="line"><span class="comment"># 添加第二层</span></span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</span><br><span class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>,</span><br><span class="line">              loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure>
<h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>训练自己的自定义层，相信反向传播，相信优化器。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x_data = x_data.reshape(100, 512)</span><br><span class="line"></span><br><span class="line">y_label = y_train.reshape(100, 1)</span><br><span class="line"># Sequence模型接受类别的数据类型为one-hot或者词向量，这里只能使用one-hot。</span><br><span class="line">y_one_hot_labels = keras.utils.to_categorical(y_label, num_classes=10)</span><br><span class="line"># 开始训练</span><br><span class="line">model.fit(x_data, y_one_hot_labels, epochs=10, batch_size=32)</span><br></pre></td></tr></table></figure></p>
<h3 id="训练误差"><a href="#训练误差" class="headerlink" title="训练误差"></a>训练误差</h3><p><img data-src="/2019/02/17/transfer-learning/1.png" alt></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>训练完毕后就是在自己的测试数据上跑一跑，evaluate以下，同样用VGG16计算测试集的输出，将输出带入自定义网络进行预测，和标准数据对比。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test_feature = base_model.predict(x_test, batch_size=32)</span><br><span class="line"></span><br><span class="line">print(test_feature.shape)</span><br><span class="line"></span><br><span class="line">x_test_feature = test_feature.reshape(10, 512)</span><br><span class="line">y_test_label = keras.utils.to_categorical(y_test, num_classes=10)</span><br><span class="line"></span><br><span class="line">score = model.evaluate(x_test_feature, y_test_label, batch_size=32)</span><br></pre></td></tr></table></figure></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>实际上socre的得分不是很好，测试集上的准确率只有60%。这说明了什么呢？训练集的误差小，测试集的误差很大，归结下原因：</p>
<ul>
<li>对数据集的筛选，导致了训练集和测试集的来源不同，也就是测试集里面的数据网络没见过。</li>
<li>个人认为不是网络的原因，因为训练集的误差很小。就算是过拟合也是由样本太少导致的。</li>
</ul>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>修复双系统切换导致V2Ray无法使用的问题</title>
    <url>/2020/03/13/v2ray-date/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在给系统安装<code>Linux</code>后，也配置了<code>V2Ray</code>。但发现了一个问题：</p>
<ul>
<li>之前<code>windows</code>使用<code>V2Ray</code>是没有任何问题的；</li>
<li><code>Linux</code>使用<code>V2Ray</code>也是没有任何问题的；</li>
<li>但是，从<code>Linux</code>切换回<code>windows</code>，<code>windows</code>的<code>V2Ray</code>就不能用了，得关机、重启、过一段时间才能用。</li>
</ul>
<p>本文给出此类问题的修复方法。</p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装还请移步这里：<a href="https://toutyrater.github.io/" target="_blank" rel="noopener">https://toutyrater.github.io/</a></p>
<h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p>对于我这种不太行的程序员而言，在没有接触过这个领域的编程知识时，要想解决问题，通常只能<strong>排除变量</strong>。而在多次对系统开机、关机、重启来回切换于两系统寻找<code>BUG</code>期间，并没有发现配置文件不对的问题。意思就是，两个系统的配置文件（包括<code>SwitchOmega</code>）都是正确的，那为什么<code>windows</code>不能用但是<code>Linux</code>可以使用呢？</p>
<p>经过不断的切换，终于发现了唯一的一个不同点，系统的时间。如果<code>Linux</code>系统的时间是正常的话，正常的定义是，现在是北京时间<code>23:01:52</code>，那么<code>Linux</code>的时间也会是<code>23:01:52</code>，而<code>windows</code>的时间却提前了10个小时，是<code>13:01:52</code>。也就是往西边跑了几个时区。那么再来回顾<code>V2Ray</code>的配置注意事项：</p>
<ol>
<li><code>V2Ray</code>对于时间有比较严格的要求，要求服务器和客户端时间差绝对值不能超过 2 分钟，所以一定要保证时间足够准确。</li>
<li><code>V2Ray</code>并不要求时区一致。比如说自己电脑上的时间是北京时间（东 <code>8</code> 区）<code>2017-07-31 12:08:31</code>，但是 <code>VPS</code> 上的时区是东 <code>9</code> 区，所以 <code>VPS</code> 上的时间应该是<code>2017-07-31 13:06:31</code> 到 <code>2017-07-31 13:10:31</code> 之间才能正常使用 <code>V2Ray</code>。当然，也可以自行改成自己想要的时区。</li>
</ol>
<p>读到这里，很容易发现是<code>windows</code>系统的时间不对导致的<code>V2Ray</code>无法使用，这时候只需要修改<code>windows</code>系统的时间即可。</p>
<p>键盘<code>windows+s</code>输入设置，打开<code>时间和语言</code>，点击 <code>立即同步</code> 即可完成时间的修改，即将时间修复为所在时区的时间。而后就可以正常使用了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://toutyrater.github.io/prep/start.html" target="_blank" rel="noopener">https://toutyrater.github.io/prep/start.html</a></p>
]]></content>
      <tags>
        <tag>Computer</tag>
      </tags>
  </entry>
  <entry>
    <title>树的遍历算法及常见衍生问题的归纳整理</title>
    <url>/2020/02/29/tree-algorithm/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>树是数据结构中很重要的一种结构，在现实生活中常用于表达层次关系和非单一的映射关系，如一个老板下对应有多个员工。通过一段时间的算法练习，本文将树常见的算法收录整理，包括：</p>
<ul>
<li>求二叉树叶子节点的数量</li>
<li>求节点权重和</li>
<li>求距离根节点最近、最远的叶节点</li>
<li>求每一层节点的数量</li>
<li>遍历二叉树，求给定权值的路径</li>
<li>二叉查找树</li>
</ul>
<p>而对于红黑树、2-3-4树等较为复杂的树结构，本文暂时不收录，仅收录较为简单容易理解的，本文适用于：编程不太好、但了解基本数据结构的人，你仅仅需要知道深度优先遍历、广度优先遍历、二叉树的根节点、普通节点、叶子节点的区别即可。</p>
<a id="more"></a>
<p>一类通常题目：求树的叶子数量，求每一层的节点数量，求树的最大高度，求叶子权重的和，都可以归类为对二叉树的遍历，所以本文更多的是树的遍历算法(深度优先或广度优先)的应用。其次，先序、中序、后序遍历树，对遍历顺序有严格的要求，一般不用此类方法遍历树去求解上述问题，一般都是解决先序中序转后序此类需求，在后续会写出此类问题的求解算法。</p>
<p>警告：尽管文本做了详细的代码注释和讲解，但如果你只是准备靠本文的讲解企图理解代码，恐怕不太行，还需要自己多加练习和多思考。</p>
<h1 id="求二叉树叶子节点数量"><a href="#求二叉树叶子节点数量" class="headerlink" title="求二叉树叶子节点数量"></a>求二叉树叶子节点数量</h1><p>PAT甲级 1004，<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184" target="_blank" rel="noopener">Counting Leaves</a> 。看样子是一道很经典的题目，输出每一层的叶子节点数。也就是，遍历二叉树，计算每层几个叶子节点，不一定要层次遍历，深度遍历也行。如下图所示：第一层的叶子节点数为0，第二层的叶子节点数为2，分别是2号节点和5号节点，第三层的叶子节点数是2，分别是6号节点和7号节点。</p>
<p><img data-src="/2020/02/29/tree-algorithm/1.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>深度遍历二叉树，如果遍历到的节点没有孩子，那么这一层的叶子节点数自增，所以我们知道了需要：输入节点时需要一个<code>vector</code>数组，将此节点的孩子给<code>push_back</code>进来，如果这个节点的<code>size</code>为0，那么表明这是一个叶子节点，此外还需要记录层数和标记这个节点属于哪一层。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> maxdepth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 只有一个节点，那么他就是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (v[index].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这一层的孩子数 ++ </span></span><br><span class="line">        book[depth]++;</span><br><span class="line">        <span class="comment">// 记录层数，最后遍历输出</span></span><br><span class="line">        maxdepth = <span class="built_in">max</span>(depth, maxdepth);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有孩子，层次递归遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[index].<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// v[index][i] 是一个整数</span></span><br><span class="line">        <span class="comment">// 传进去就是第几号叶子节点</span></span><br><span class="line">        <span class="comment">// 如果有孩子，就继续这个循环</span></span><br><span class="line">        <span class="comment">// 向下递增，所以是深度优先</span></span><br><span class="line">        dfs(v[index][i], depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    <span class="keyword">int</span> node, num, node1;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;node, &amp;num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;node1);</span><br><span class="line">            <span class="comment">// 存入一个节点的孩子 </span></span><br><span class="line">            v[node].push_back(node1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点是1，深度是0，从根节点开始遍历</span></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, book[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxdepth; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d"</span>, book[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="求节点的权重和"><a href="#求节点的权重和" class="headerlink" title="求节点的权重和"></a>求节点的权重和</h1><p>甲级 1079，<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805388447170560" target="_blank" rel="noopener">Total Sales of Supply Chain</a>。问题描述（原题描述的太绕了，一个单词没读到，结果理解不了题意，花了半小时读懂题）：每一个叶子节点有一个权重，此外还需要乘以一个系数，而这个系数和到根节点的距离成正比，最后计算叶子节点的权重和。</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>和上文一样，仍然需要用一个<code>vector</code>数组来输入节点，将此节点的孩子给<code>push_back</code>进来，如果这个节点的<code>size</code>为0，那么表明这是一个叶子节点；遍历到叶子节点求权重即可。整体代码和上文差不多，如果这里看不懂请看上一节 <code>求二叉树叶子节点数量</code> 的代码注释即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> data;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">0</span>, r, p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v[index].child.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += v[index].data * <span class="built_in">pow</span>((<span class="number">1</span> + r), depth);</span><br><span class="line">        <span class="comment">// 递归的出口</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[index].child.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(v[index].child[i], depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num &gt;&gt; p &gt;&gt; r;</span><br><span class="line">    <span class="keyword">int</span> temp1; </span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">double</span> data;</span><br><span class="line">    r = r / <span class="number">100</span>;</span><br><span class="line">    v.resize(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; data;</span><br><span class="line">            v[i].data = data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp1);</span><br><span class="line">                v[i].child.push_back(temp1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, ans * p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="计算到根节点的距离"><a href="#计算到根节点的距离" class="headerlink" title="计算到根节点的距离"></a>计算到根节点的距离</h1><h2 id="求距离根节点最远的叶节点（DFS）"><a href="#求距离根节点最远的叶节点（DFS）" class="headerlink" title="求距离根节点最远的叶节点（DFS）"></a>求距离根节点最远的叶节点（DFS）</h2><p>甲级 1090 ，<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805376476626944" target="_blank" rel="noopener">Highest Price in Supply Chain</a>。除此之外还要求出有几个这样的节点存在。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>此时<code>for</code>循环遍历，判断是否为叶节点，如果是，那么判断深度，当前深度和最大深度相等，数量加一，以此来统计有几个这样的节点；如果当前深度大于最大深度，那么这样的节点又回归为一个。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v[index].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == maxdepth)</span><br><span class="line">        &#123;</span><br><span class="line">            maxnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt; maxdepth)</span><br><span class="line">        &#123;</span><br><span class="line">            maxdepth = depth;</span><br><span class="line">            maxnum = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[index].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(v[index][i], depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求距离根节点最近的叶节点"><a href="#求距离根节点最近的叶节点" class="headerlink" title="求距离根节点最近的叶节点"></a>求距离根节点最近的叶节点</h2><p>甲级 1106，<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805362341822464" target="_blank" rel="noopener">Lowest Price in Supply Chain</a>。</p>
<p>和上面的思路一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> level = <span class="number">100005</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v[index].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == level)</span><br><span class="line">        &#123;</span><br><span class="line">            num ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth &lt; level)</span><br><span class="line">        &#123;</span><br><span class="line">            level = depth;</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[index].<span class="built_in">size</span>(); i++)</span><br><span class="line">       dfs(v[index][i], depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="求每一层的节点数量"><a href="#求每一层的节点数量" class="headerlink" title="求每一层的节点数量"></a>求每一层的节点数量</h1><p>甲级 1094，<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805372601090048" target="_blank" rel="noopener">The Largest Generation</a> 。给定一棵树，有一层的节点数量是最多的，求出这一层，和这一层的节点数。</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>声明一个数组<code>gene</code>，当遍历到这一层时，<code>gene[depth]++</code>即可，因此遍历的时候传入当前深度<code>depth</code>参数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化问题，所有的初始化为0</span></span><br><span class="line"><span class="comment">// 如果v.resize()，除非能确定大小</span></span><br><span class="line"><span class="comment">// 往里面压入具体的数，否则没压进去的位置size()是异常值。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> gene[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gene[depth]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[index].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(v[index][i], depth+<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> temp1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp &gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp1;</span><br><span class="line">            v[temp].push_back(temp1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">-1</span>, maxn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">105</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (gene[i] &gt; <span class="built_in">max</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">max</span> = gene[i];</span><br><span class="line">            maxn = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; maxn ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BFS思路"><a href="#BFS思路" class="headerlink" title="BFS思路"></a>BFS思路</h2><p>对于广度优先遍历而言，一般会借助队列来实现。首先压入根节点，当队列非空时，弹出队列的第一个节点，而后压入节点的各个孩子，于此同时记录孩子数量和层数(即题目中的层数和每层几个孩子)。</p>
<ul>
<li><code>index</code>表示第几个节点；</li>
<li><code>level[index]</code>表示这个节点在第几层；</li>
<li><code>book[level[index]]</code>表示这层有几个节点；</li>
<li>更多解释参考程序注释。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> level[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a, k, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line">            v[a].push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 先压入根节点</span></span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 根节点是第一层</span></span><br><span class="line">    level[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="comment">// index 标记第几个孩子</span></span><br><span class="line">        <span class="keyword">int</span> index = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 记录这一层有几个孩子 level[index] 表示孩子处于第几层</span></span><br><span class="line">        book[level[index]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[index].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 当前孩子的层数 为 上一层的层数 + 1</span></span><br><span class="line">            level[v[index][i]] = level[index] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 压入当前孩子</span></span><br><span class="line">            q.push(v[index][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxnum = <span class="number">0</span>, maxlevel = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(book[i] &gt; maxnum) &#123;</span><br><span class="line">            maxnum = book[i];</span><br><span class="line">            maxlevel = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, maxnum, maxlevel);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="求给定权值的路径"><a href="#求给定权值的路径" class="headerlink" title="求给定权值的路径"></a>求给定权值的路径</h1><p>甲级 1053，<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805424153280512" target="_blank" rel="noopener">Path of Equal Weight</a> 。 给出树的结构和权值，找从根结点到叶子结点的路径上的权值相加之和等于给定目标数的路径，如果路径不止一条，按节点标号从大到小输出路径。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>在读入节点后对节点排序，这样深度优先出的路径也会默认排好顺序。对于符合权重的路径，首先判断路径的重点是不是叶子节点，如果不是，那么这条路径不符合要求；如果是，将临时路径记录的节点依次添加即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> weight_sum;</span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> temp_path[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> path_num;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">101</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> nodeNum, <span class="keyword">int</span> sum_temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 走过头了</span></span><br><span class="line">    <span class="keyword">if</span> (sum_temp &gt; weight_sum)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(sum_temp == weight_sum) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[index].<span class="built_in">size</span>() != <span class="number">0</span>)  <span class="comment">// 不是叶子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;   <span class="comment">// 0表示从根开始，记录经过的路径，nodeNum是最后一个</span></span><br><span class="line">            <span class="comment">// 深度优先，路径一定是竖着通到叶子节点的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeNum; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                path[path_num].push_back(weight[temp_path[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 标记一共有几条路径</span></span><br><span class="line">            path_num++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[index].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> node = v[index][i];</span><br><span class="line">        <span class="comment">// 走第二条路径的时候，里面的变量会被覆盖，因此没必要清空</span></span><br><span class="line">        temp_path[nodeNum] = v[index][i];</span><br><span class="line">        dfs(node, nodeNum + <span class="number">1</span>, sum_temp + weight[v[index][i]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight[a] &gt; weight[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, non;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; non &gt;&gt; weight_sum;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> id, num, a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; weight[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; non; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id &gt;&gt; num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">            v[id].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一个节点的孩子排序，之后深度优先会默认输出排序好的</span></span><br><span class="line">        sort(v[id].<span class="built_in">begin</span>(), v[id].<span class="built_in">end</span>(), cmp);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 1 是已经有一个节点，weight[0]是根节点的权重</span></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">1</span>, weight[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[i].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it = path[i].<span class="built_in">begin</span>(); it != path[i].<span class="built_in">end</span>(); it++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; *it ;</span><br><span class="line">                <span class="keyword">if</span> (it != path[i].<span class="built_in">end</span>() - <span class="number">1</span> ) <span class="comment">// 多输出了一个空格，全部错误</span></span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path[i+<span class="number">1</span>].<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>甲级 1115，<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805355987451904" target="_blank" rel="noopener">Counting Nodes in a BST</a>。大致要求是：给如数列，创建二叉查找树，求这个二叉查找树一共有几层，每层几个节点。 </p>
<p>递归创建二叉查找树的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>, *<span class="title">right</span>;</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">build</span><span class="params">(node *root, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> node();</span><br><span class="line">        root-&gt;v = v;</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt;= root-&gt;v)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = build(root-&gt;left, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = build(root-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node *root = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">    root = build(root, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时计数每层几个叶子、这个树有几层的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(node *root, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt; maxdepth)</span><br><span class="line">            maxdepth = depth;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录这层几个叶子</span></span><br><span class="line">    num[depth]++;</span><br><span class="line">    dfs(root-&gt;left, depth+<span class="number">1</span>);</span><br><span class="line">    dfs(root-&gt;right, depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文全部参考了<a href="https://github.com/liuchuo/PAT/tree/master/AdvancedLevel_C%2B%2B" target="_blank" rel="noopener">柳神，甲级</a>的程序，而非我本人的原创。但是我都花精力研究了程序、重写程序、最后做了归纳整理。我也不知道这算不算抄袭，如果本文帮助了你，且你想打赏，我会把文本的收益全部转送给柳神的支付宝，为什么不把她支付宝放在这里呢，因为我懒。就像创作本文的目的一样，只是整理所学知识，而不是盈利。</p>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2020/09/07/union-find-datastructure/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>继续啃算法，今天来看并查集。</p>
<a id="more"></a>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>并查集是一种数据结构，可以跟踪一组元素，它们分布在几个不相交（非重叠）子集合中。 它也被称为不相交集数据结构。这是什么意思呢？ 例如，并查集数据结构可以跟踪以下集合：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ a, b, f, k ]</span><br><span class="line">[ e ]</span><br><span class="line">[ g, d, c ]</span><br><span class="line">[ i, j ]</span><br></pre></td></tr></table></figure>
<p>这些集合是不相交的，因为它们没有共同的成员。并查集支持常见的两种基本操作：</p>
<ul>
<li><code>Union(A, B)</code>：将包含 <code>A</code> 和 <code>B</code> 的两个子集合并为一个子集。 例如，<code>union(d, j)</code> 表示将 <code>[g, d, c]</code> 和 <code>[i, j]</code> 组合成更大的集合 <code>[g, d, c, i, j]</code>。伪代码如下：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span>(faA != faB) father[faA] = faB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>也就是，直接更改父节点的指向就好了。</p>
<ul>
<li><code>Find(A)</code>：确定元素 <code>A</code> 所在的子集。例如，<code>find(d)</code> 将返回子集 <code>[ g, d, c ]</code>。伪代码如下：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x;</span><br><span class="line">    <span class="comment">// 寻找当前节点的根节点</span></span><br><span class="line">    <span class="comment">// x 就是要找的根节点</span></span><br><span class="line">    <span class="keyword">while</span>(x != father[x])</span><br><span class="line">        x = father[x];</span><br><span class="line">    <span class="comment">// 找到根节点后，把当前集合点的根节点都改为 x  </span></span><br><span class="line">    <span class="keyword">while</span>(a != father[a]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = a;</span><br><span class="line">        a = father[a];</span><br><span class="line">        father[z] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以详细的参考里面的注释，写的很详细了。</p>
<p>画成图就是这样的：右图的 <code>union</code> 表示两个集合合并后，更改一个节点的父节点(且左子树的父节点都要更改)；左图中的 <code>find</code> 表示绿色节点在找根节点是谁，并修改这条路上所有节点的根节点。</p>
<p><img data-src="/2020/09/07/union-find-datastructure/dsu1.png" alt></p>
<p>也许你会感觉抽象，但看几个题就明白什么意思了。或者，如果你的脑子和我的脑子一样的不好使，那就多动动手，手动模拟几次就知道并查集的工作流程是什么意思了。靠他人的讲解总是理解的不够到位。或者说，我从来也没企图靠他人的讲解去学会什么，找到好教材的背后，自己一定要多下功夫，多自学。</p>
<p><img data-src="https://static01.imgkr.com/temp/9519b94d9adb4b0197f4aabf8f7f288d.jpg" alt></p>
<h1 id="社区聚类-基础应用"><a href="#社区聚类-基础应用" class="headerlink" title="社区聚类(基础应用)"></a>社区聚类(基础应用)</h1><p>When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A social cluster is a set of people who have some of their hobbies in common. You are supposed to find all the clusters.</p>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. For each test case, the first line contains a positive integer $N (≤1000)$, the total number of people in a social network. Hence the people are numbered from $1$ to $N$. Then $N$ lines follow, each gives the hobby list of a person in the format:$K_i:h_i[1],h_i[2]…h_i[K_i]$, where $K_i (&gt;0)$ is the number of hobbies, and $h_i[j]$ is the index of the $j$-th hobby, which is an integer in $[1, 1000]$.</p>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">3: 2 7 10</span><br><span class="line">1: 4</span><br><span class="line">2: 5 3</span><br><span class="line">1: 4</span><br><span class="line">1: 3</span><br><span class="line">1: 4</span><br><span class="line">4: 6 8 1 5</span><br><span class="line">1: 4</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4 3 1</span><br></pre></td></tr></table></figure>
<p>题目意思很简单，每个人都有一些爱好，如果他们的爱好有相同的，就将这些人合并在一起。最后统计有几个社区，每个社区的人数是多少。直接来看代码就好，我会在一些容易迷惑的地方加上注释。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father, isRoot;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a &gt; b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找父节点，并更改相关节点的父节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x])</span><br><span class="line">        x = father[x];</span><br><span class="line">    <span class="comment">// 找到根节点后，把该集合内的节点的根节点都改为 x  </span></span><br><span class="line">    <span class="keyword">while</span>(a != father[a]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = a;</span><br><span class="line">        a = father[a];</span><br><span class="line">        father[z] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改父节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span>(faA != faB) father[faA] = faB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, t, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> course[<span class="number">1001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    father.resize(n + <span class="number">1</span>);</span><br><span class="line">    isRoot.resize(n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 初始化，每个人的父节点都是自己</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        father[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">            <span class="comment">// 如果当前爱好没有被分配，那么当前爱好就属于当前的社区</span></span><br><span class="line">            <span class="comment">// course[4] = 2，那么之后所有的 course[4] 都是 2，是合并的前提</span></span><br><span class="line">            <span class="keyword">if</span>(course[t] == <span class="number">0</span>)</span><br><span class="line">                course[t] = i;</span><br><span class="line">            <span class="comment">// 在输入样例中，第二个人和第四个人的爱好相同</span></span><br><span class="line">            <span class="comment">// 第二个人时 course[4] = 2，第四个人时 course[4] = 2</span></span><br><span class="line">            <span class="comment">// 那么合并 Union(4, 2)，得到的结果是 father[4] = 2</span></span><br><span class="line">            <span class="comment">// 如此，第四个人和第二个人就属于一类了</span></span><br><span class="line">            Union(i, findFather(course[t]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为要求出每个社区的人数，所以寻找每个节点的父亲，</span></span><br><span class="line">    <span class="comment">// 并使父节点编号对应的数值++</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        isRoot[findFather(i)]++;</span><br><span class="line">    <span class="comment">// 那么，不为 0 的数量就是社团的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isRoot[i] != <span class="number">0</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="comment">// 且，若数值表示该社区内有多少人</span></span><br><span class="line">    sort(isRoot.<span class="built_in">begin</span>(), isRoot.<span class="built_in">end</span>(), cmp1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, isRoot[i]);</span><br><span class="line">        <span class="keyword">if</span>(i != cnt - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复杂一些的题目"><a href="#复杂一些的题目" class="headerlink" title="复杂一些的题目"></a>复杂一些的题目</h1><p>This time, you are supposed to help us collect the data for family-owned property. Given each person’s family members, and the estate（房产）info under his/her own name, we need to know the size of each family, and the average area and number of sets of their real estate.</p>
<h2 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. For each case, the first line gives a positive integer $N(≤1000)$. Then $N$ lines follow, each gives the infomation of a person who owns estate in the format:</p>
<p><code>ID</code> <code>Father</code> <code>Mother</code> $k$ $Child_1$ $Child_2$ … $Child_k$ $M_\text{estate}$ <code>Area</code></p>
<p>where <code>ID</code> is a unique 4-digit identification number for each person; <code>Father</code> and <code>Mother</code> are the ID’s of this person’s parents (if a parent has passed away, -1 will be given instead); $k(0≤k≤5)$ is the number of children of this person; $Child_i$’s are the <code>ID</code>‘s of his/her children; $M_\text{estate}$ is the total number of sets of the real estate under his/her name; and <code>Area</code> is the total area of his/her estate.</p>
<h2 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each case, first print in a line the number of families (all the people that are related directly or indirectly are considered in the same family). Then output the family info in the format:</p>
<p><code>ID</code> <code>M</code> $\text{AVG}_\text{sets}$  $\text{AVG}_\text{area}$</p>
<p>​where <code>ID</code> is the smallest <code>ID</code> in the family; <code>M</code> is the total number of family members; $\text{AVG}_\text{sets}$ is the average number of sets of their real estate; and $\text{AVG}_\text{area}$ is the average area. The average numbers must be accurate up to 3 decimal places. The families must be given in descending order of their average areas, and in ascending order of the ID’s if there is a tie.</p>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">6666 5551 5552 1 7777 1 100</span><br><span class="line">1234 5678 9012 1 0002 2 300</span><br><span class="line">8888 -1 -1 0 1 1000</span><br><span class="line">2468 0001 0004 1 2222 1 500</span><br><span class="line">7777 6666 -1 0 2 300</span><br><span class="line">3721 -1 -1 1 2333 2 150</span><br><span class="line">9012 -1 -1 3 1236 1235 1234 1 100</span><br><span class="line">1235 5678 9012 0 1 50</span><br><span class="line">2222 1236 2468 2 6661 6662 1 300</span><br><span class="line">2333 -1 3721 3 6661 6662 6663 1 100</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">8888 1 1.000 1000.000</span><br><span class="line">0001 15 0.600 100.000</span><br><span class="line">5551 4 0.750 100.000</span><br></pre></td></tr></table></figure>
<p>道理还是一样的，就是数据操作上复杂了一点，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DATA</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, fid, mid, num, area;</span><br><span class="line">    <span class="keyword">int</span> cid[<span class="number">10</span>];</span><br><span class="line">&#125;data[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, people;</span><br><span class="line">    <span class="keyword">double</span> num, area;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">&#125;ans[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = x;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x])</span><br><span class="line">        x = father[x];</span><br><span class="line">    <span class="keyword">while</span>(a != father[a])&#123;</span><br><span class="line">    	<span class="keyword">int</span> z = a;</span><br><span class="line">    	a = father[a];</span><br><span class="line">    	father[z] = x;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并规则是：输出最小的ID </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="keyword">int</span> faB = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(faA &gt; faB)</span><br><span class="line">        father[faA] = faB;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(faA &lt; faB)</span><br><span class="line">        father[faB] = faA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.area != b.area)</span><br><span class="line">        <span class="keyword">return</span> a.area &gt; b.area;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        father[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;data[i].id, &amp;data[i].fid, &amp;data[i].mid, &amp;k);</span><br><span class="line">        visit[data[i].id] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 合并双亲的 id</span></span><br><span class="line">        <span class="keyword">if</span>(data[i].fid != <span class="number">-1</span>) &#123;</span><br><span class="line">            visit[data[i].fid] = <span class="literal">true</span>;</span><br><span class="line">            Union(data[i].fid, data[i].id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data[i].mid != <span class="number">-1</span>) &#123;</span><br><span class="line">            visit[data[i].mid] = <span class="literal">true</span>;</span><br><span class="line">            Union(data[i].mid, data[i].id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并孩子的 id</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data[i].cid[j]);</span><br><span class="line">            visit[data[i].cid[j]] = <span class="literal">true</span>;</span><br><span class="line">            Union(data[i].cid[j], data[i].id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;data[i].num, &amp;data[i].area);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每个根节点代表的家庭</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="built_in">find</span>(data[i].id);</span><br><span class="line">        <span class="comment">// 这个家的 id、人数、区域、flag用于计数一共有几个家庭</span></span><br><span class="line">        ans[id].id = id;</span><br><span class="line">        ans[id].num += data[i].num;</span><br><span class="line">        ans[id].area += data[i].area;</span><br><span class="line">        ans[id].flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 计算每个社区的人数</span></span><br><span class="line">        <span class="keyword">if</span>(visit[i])</span><br><span class="line">            ans[<span class="built_in">find</span>(i)].people++;</span><br><span class="line">        <span class="comment">// 计算有几个社区</span></span><br><span class="line">        <span class="keyword">if</span>(ans[i].flag)</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i].flag) &#123;</span><br><span class="line">            ans[i].num = (<span class="keyword">double</span>)(ans[i].num * <span class="number">1.0</span> / ans[i].people);</span><br><span class="line">            ans[i].area = (<span class="keyword">double</span>)(ans[i].area * <span class="number">1.0</span> / ans[i].people);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans, ans + <span class="number">10000</span>, cmp1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%04d %d %.3f %.3f\n"</span>, ans[i].id, ans[i].people, ans[i].num, ans[i].area);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>一些文字概念：<br><a href="http://andyron.com/2019/Swift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%B9%B6%E6%9F%A5%E9%9B%86.html" target="_blank" rel="noopener">http://andyron.com/2019/Swift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%B9%B6%E6%9F%A5%E9%9B%86.html</a><br>偷图：<a href="https://oi-wiki.org/ds/dsu/" target="_blank" rel="noopener">https://oi-wiki.org/ds/dsu/</a><br>第一题代码：<br><a href="https://github.com/liuchuo/PAT/blob/master/AdvancedLevel_C%2B%2B/1107.%20Social%20Clusters%20(30).cpp" target="_blank" rel="noopener">https://github.com/liuchuo/PAT/blob/master/AdvancedLevel_C%2B%2B/1107.%20Social%20Clusters%20(30).cpp</a><br>第二题代码：<br><a href="https://github.com/liuchuo/PAT/blob/master/AdvancedLevel_C%2B%2B/1114.%20Family%20Property%20(25).cpp" target="_blank" rel="noopener">https://github.com/liuchuo/PAT/blob/master/AdvancedLevel_C%2B%2B/1114.%20Family%20Property%20(25).cpp</a></p>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>关于六天掌握 Vim 这件事</title>
    <url>/2021/08/28/vim-learn/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学习 vim 的时候曾经4进4出一直没学会，这次下定决心要学一下了，也不求一口吃个胖子，每天学习一点点。首先从基础操作开始练习，先不要配置插件，也不管高亮和编程。<del>IDE是人类退步的阶梯</del>，沃茨基说的。</p>
<p>当然，这份文档不一定包含所有命令，只是教学的目的，遇到没有涵盖的命令自行查阅即可。有些命令是我自己的总结，不一定对。此外，本文涉及的命令之间可以任意组合实现各类高级功能，这个没办法统一列出。</p>
<p>此外，纸上得来终觉浅，学习 vim 一定多动手练习，在平时任务中多用 vim，自然而然就掌握了。我前后花了 6 天能使用 vim 应付日常开发工作，所以本文也叫六天掌握 vim。</p>
<a id="more"></a>
<p>这个是我参考的 vim 的学习笔记，感觉写的还是不错的：<a href="https://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">https://coolshell.cn/articles/5426.html</a></p>
<h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><p>我一点点的写vim，尝试着写点。</p>
<p>换行了。</p>
<pre><code>也能缩进。
</code></pre><p>第一步直接安装 vim，而后新建一个文件，就叫 <code>vim-prac.md</code>，每次练习都打开这个文件，直接写入。我直接新建了一个博客，每次的练习都写入到这个博客。</p>
<p>首先要知道的，在 <code>normal</code> 模式下，万物都是功能键，比如 <code>hjkl</code> 是方向键，<code>h</code> 表示左，<code>j</code> 表示下，<code>k</code> 表示上，<code>l</code> 表示右。其实也容易记忆，位于两侧的 <code>hl</code> 表示左右，而后左下、右上这样记忆，即和 <code>h</code> 紧挨着的是下，和 <code>l</code> 紧挨着的是上。</p>
<ul>
<li>如果想要打字，按一下键盘上的 <code>i</code> 进入 <code>insert</code> 模式，而后开始随心所欲的打字，和编辑 txt 文件一样没啥区别，上面那些文字都是我刚入门就打出来的。</li>
<li>在写完之后，按键盘左上角的 <code>esc</code> 退出插入模式，而后输入 <code>:wq</code> 表示写入并退出，这样写好的文件就被保存了。冒号的意思是进入命令模式，<code>w</code> 是写入单词的首字符，<code>q</code> 是退出单词的首字符。</li>
</ul>
<p>那么再来看一下其他操作：</p>
<ul>
<li><code>x</code>，<code>normal</code> 模式下，表示删除光标后面的字符。既然删除了，是不是要撤销？那么撤销操作是 <code>u</code>，如果回退到 3 次修改之前，可以输入 <code>3u</code>。这个可以直接在界面下操作，也可以<code>:u</code>。如果发现撤销过头了，就需要恢复，此时的快捷键是 <code>ctrl+R</code>，或者 <code>:red</code>。</li>
<li><code>dd</code>，同样是在 <code>normal</code> 模式下，表示删除当前行，并复制到剪切板中，<code>p</code>，粘贴剪切板中的内容。如果复制的是一行，<code>p</code> 会另起一行粘贴，如果复制的是个单词， <code>p</code> 会空格后粘贴，<code>P</code> 会避免这些。</li>
</ul>
<p>现在差不多可以编辑基本的文本了，今天的内容学习到此结束。如果今后在面对不忙的、简单的、凭借目前 vim 技术可以解决的工作，可以尝试开始用 vim。</p>
<h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><p>在编辑文本的时候发现，光标的移动不是很便捷，每次都要狂按方向键才能到想要的位置。那么今天就来学习下便捷的光标移动与插入。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ul>
<li><code>a</code>，在光标后插入，假设一段序列是 <code>abcd</code>，光标位于 <code>a</code> 后面，在 <code>normal</code> 模式下，那么输入 <code>a</code> 后会移动到 <code>b</code> 的后面，而后开始插入；</li>
<li><code>o</code>，当前行后插入一个新行；</li>
<li><code>O</code>，当前行前插入一个新行；</li>
</ul>
<h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ul>
<li><code>0</code>，移动到行头；</li>
<li><code>^</code>，当本行第一个不是空格、tab、回车、换行字符的位置，也就是一行开头的这些东西会被忽略；</li>
<li><code>$</code>，移动到本行的行尾；</li>
<li><code>g_</code>，到本行最后一个不是空格、tab、回车、换行字符的位置；</li>
<li><code>/pattern</code>，搜索 <code>pattern</code> 的字符串，如果有多个，按 <code>n</code> 到下一个。</li>
</ul>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>之前已经知道了 <code>p</code> 是粘贴，<code>dd</code> 是剪切当前行。如果不删除当前行直接复制呢？用的是 <code>yy</code>。</p>
<p>此外，有的时候还想不复制整行，只想复制一行中的某些文字。此时的命令是在 <code>normal</code> 模式下按 <code>v</code> 进入 <code>visual</code> 模式，而后移动光标（可以借助 <code>$</code> 等功能键）选中文本，按下 <code>y</code> 表示复制选中的文本。而后 <code>p</code> 表示在当前位置之后粘贴，即如果将一些内容复制到 <code>ABCDE</code> 的 <code>B</code> 后面，需要将光标放到 <code>A</code> 后面然后粘贴。</p>
<p>还有这里看着突兀的原因是，之前终端用的光标是 <code>Beam</code> 这样的细线，如果换成 <code>Block</code> 这样的光标块，能从视觉角度更好的理解复制和粘贴的位置。</p>
<p>还有诸如 <code>yG</code> 复制到当前文件结束，<code>y20G</code> 复制到第 20 行等操作，用到的时候再来整理。</p>
<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><ul>
<li><code>:e path</code>，表示打开指定 path 的文件</li>
<li><code>:wq, :x, XX</code>，保存并退出，<code>:x</code> 仅在有改动时保存</li>
<li><code>:q!</code>，强制退出不保存，<code>:qa!</code> 强制退出正在编辑的文件，即使有更改</li>
</ul>
<p>今天的练习结束，淘到了一个键盘，回宿舍洗一洗。</p>
<h1 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h1><p>一时技痒，偷着做了两件事情，一个是 <code>vim</code> 的配置文件，一个是 <code>vim</code> 的插件。</p>
<p>大概昨天尝试了一下使用 <code>vim</code> 安装插件，不得不说真香。我选择的插件管理器是 <code>vim-plug</code>，记得配置 <code>git</code> 的 <code>ssh</code> 和 <code>https</code> 代理，否则下载不下来。先装了一个 <a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener"><code>vim-airline</code></a> 还不错。之后等时间长了，配置一些编程用的插件。</p>
<p>而后是 <code>vim</code> 的配置文件，用户自己的配置文件位于 <code>~/.vimrc</code>，系统的配置文件位于 <code>/etc/.vimrc</code>。而后可以网上查一查如何配置，比如显示行号、设置缩进、显示文件名等。我的 <code>vim</code> 配置放到了我的 github 上：<a href="https://github.com/muyuuuu/my-vim-config" target="_blank" rel="noopener">https://github.com/muyuuuu/my-vim-config</a> 。</p>
<p>回到正题，今天额外学一些光标移动的操作，我也是使用了一段事件后才发现快速定位到某个位置真的是太有用了。</p>
<p>在配置文件中开启行号设置后，可以知道文件位于哪一行。在 <code>normal</code> 模式下，可以使用 <code>NG</code> 移动到第 <code>N</code> 行，<code>N</code> 是数字；<code>G</code> 是移动到最后一行。或者在 <code>command</code> 模式下，<code>:112</code> 会移动到 112 行。<code>ctrl+f</code> 向下翻页，<code>ctrl+b</code> 向上翻页；<code>ctrl+e</code> 逐行向下翻页；<code>ctrl+y</code> 逐行向上翻页。 </p>
<p>之后再来看一下行内的移动：</p>
<ul>
<li><code>w</code> 到下一个单词的开头，<code>b</code> 移动到上一个单词的开头，<code>e</code> 到当前单词的结尾。</li>
<li><code>%</code> 匹配括号移动，包括 <code>([{</code>，把光标移动到括号上面，按 <code>%</code> 就可以吧光标移动到匹配的位置。</li>
<li>单词移动，<code>*</code>（下一个） 和 <code>#</code>（上一个），匹配光标当前所在的单词，移动到上一个单词和下一个单词。</li>
<li><code>6l</code> 向右移动 6 个字符</li>
</ul>
<p>今天的学习到此结束。今天用 <code>vim</code> 写了一段代码，发现还是熟能生巧，得多用用。</p>
<h1 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h1><p>因为我的电脑屏幕比较大，所以启动终端只开一个 <code>vim</code> 窗口有些资源浪费，今天来学习一下如何分屏。</p>
<p>就像这张图一样，上面是文档，下面是代码。</p>
<p><img data-src="https://z3.ax1x.com/2021/08/30/hNeo7D.png" alt></p>
<ul>
<li><code>:split</code> 为垂直分屏，<code>:vsplit</code> 为水平分屏。</li>
<li><code>ctrl+w+hjkl</code> 用于切换分屏，还记得之前说过的方向键盘吗？</li>
<li><code>ctrl+w+</code> 增加尺寸，<code>ctrl+w-</code> 缩小尺寸。</li>
</ul>
<p>当然只是分屏还是不爽的，能不能直接在 <code>vim</code> 中编译或解释直接查看代码的执行结果而不是每次都要退出去？答案肯定还是有的，不过准备放到后面的打造 <code>vim</code> 了，这里还是以学习 <code>vim</code> 命令为主。</p>
<ul>
<li><code>.</code>，小数点是重复上次的命令</li>
<li><code>N&lt;cmd&gt;</code> 重复命令 N 次，这个命令不用进入 <code>normal</code> 模式</li>
<li>如写一百遍名字，命令就是 <code>100iname</code> </li>
</ul>
<p>此外，我发现复制粘贴用的还是比较多的，所以再来整理一些复制的命令。</p>
<ul>
<li><code>ye</code>，复制光标后面的单词，不含空格</li>
<li><code>yw</code>，复制光标后面的单词，含空格</li>
<li><code>yl</code>，复制光标后面的字符，<code>l</code> 是方向键的右</li>
<li><code>yh</code>，复制光标前面的字符，<code>h</code> 是方向键的左</li>
<li><code>4yy</code>，复制当前行及后面的3行共4行</li>
<li><code>4yl</code>，当前字符及后面的3个字符，共4个</li>
<li><code>4yh</code>，当前字符前面的4个字符，不包括当前字符</li>
</ul>
<p>同理，<code>d</code> 是剪切的命令，且大体和 <code>y</code> 相似：</p>
<ul>
<li><code>dd</code>，剪切当前行</li>
<li><code>4dd</code>，剪切当前行及后面的3行，共4行</li>
<li><code>dw</code>，剪切光标后面的单词，含空格</li>
</ul>
<p>今天学习内容结束，大概还差区域选择、块操作、宏录制和可视化选择；在之后就会尝试把 vim 打造成 IDE 了，一去不复返。</p>
<h1 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h1><p>我又额外补充了一些插件换了主题来提升效率。<code>wakatime</code> 记录编程时间，<code>nerdtree</code> 显示工作目录，<code>startify</code> 显示近期打开的文件，<code>onehalfdark</code> 作为主题。</p>
<p>在服务器上体验了一把裸敲 <code>vim</code> 的快感，首先补充一些光标移动的东西，快速定位到想要的位置，这玩意太重要了。</p>
<ul>
<li><code>fa</code> 移动到下一个为 <code>a</code> 的字符处；<code>3fa</code> 移动到第三个 <code>a</code> 的位置；<code>F</code> 与 <code>f</code> 的查找顺序刚好相反。</li>
<li><code>t,</code> 到逗号前的一个字符，这里暂不支持中文字符 <del>难道以后我写文档要用英文符号了？</del></li>
</ul>
<p>此外，在编程时候会常用块操作，比如注释某个函数，或者 <code>python</code> 中的某段内容全部缩进，就需要块操作来实现。</p>
<ul>
<li>光标定位到要操作的地方；</li>
<li><code>ctrl+v</code> 进入「块可视化」模式，选取要操作的行；</li>
<li><code>shift+i</code> 输入要插入的内容；</li>
<li><code>esc</code> 按两次，会在每行的选定的区域出现插入的内容。</li>
</ul>
<p>另外的内容是区域选择，命令为 <code>&lt;action&gt;a&lt;object&gt;</code> 或者 <code>&lt;action&gt;i&lt;object&gt;</code>，两者的区别是，前者会选中 <code>object</code>，后者则不会。给定字符串 <code>((a) + (&quot;b+c&quot;)</code>。</p>
<ul>
<li>光标位于 <code>b</code>，<code>vi&quot;</code> 会选中 <code>b+c</code>，<code>va&quot;</code> 会选中 <code>&quot;b+c&quot;</code>；</li>
<li>光标位于 <code>b</code>，<code>v2i)</code> 会选中 <code>(a) + (&quot;b+c&quot;)</code>，<code>v2a)</code> 会选中全部</li>
</ul>
<p>今天的学习内容到此结束，其实很多时候都在查漏不缺，每次都要花很多时间联系，所以虽然内容很少，但是内容很多（误。</p>
<h1 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h1><p>今天大概是最后一天了，是一些批处理的内容，宏录制和块选择。可惜最近学业繁忙，事情太多，不能学的尽兴。如果之后时间充裕或者不想学习，一定花时间继续打造我的 <code>vim</code>，主要包括：编程语言的支持、自动提示、以及如何不退出 <code>vim</code> 直接执行程序。</p>
<p>首先是宏录制，这个功能十分强大。这里只举一个例子，如何给文件每一行末尾添加逗号：<del>如果功能过于复杂，我第一反应肯定是写脚本处理。</del></p>
<ol>
<li>按 <code>q</code> 加 <code>a~z</code> 中的任意字符，如 <code>qc</code> 表示开始录制宏，这个宏的名字叫 <code>c</code>，而后可以使用 <code>c</code> 来调用宏；</li>
<li>比如对文件的每一行末尾条件逗号，那么就是如下操作 <code>$a,ESC,j</code>，注意结束时移动到下一行；</li>
<li>再次输入 <code>q</code>，表示退出宏录制；</li>
<li><code>n@c</code> 表示执行宏命令 <code>n</code> 次；</li>
</ol>
<p>注意，录制上面的宏时，会修改第一行的内容，不用担心。除了宏之外，可视化选择也提供了丰富的选择，例如第五天提到的批量注释。<del>其实录制宏也能实现。</del> 今天就来细看可视化模式。</p>
<p>首先，<code>v</code> 是进入字符可视化模式，<code>V</code> 进入行可视化模式，<code>ctrl+v</code> 进入块可视化模式。<code>gv</code> 可以选中上次可视化模式选中的文本；<code>o</code> 会移动到选中区域的另一侧。 </p>
<ul>
<li>对于 <code>v</code>，进入可视化模式后移动光标，使用 <code>4l</code> 选中右边的 4 个字符，按 <code>d</code> 删除</li>
<li>对于 <code>V</code>，进入行可视化模式，同样的是选中，而后操作</li>
<li>对于 <code>ctrl-v</code>，进入块可视化模式，可以使用 <code>2l</code> 和 <code>3j</code> 选择两行三列</li>
</ul>
<p>而按照上面三种方法选中文本后，都可以进行编辑，如 <code>C</code> 删除选中文本并插入新文本，<code>~</code> 进行大小写替换，<code>ctrl+v</code> 进入块可视化模式，选中行后<code>J</code> 将这些行连成一行，<code>&gt;</code> 向右缩进<code>&lt;</code> 向左缩进，<code>=</code> 自动缩进。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><code>vim</code> 学习的内容到此结束，我宣布第 5 次 <code>vim</code> 学习顺利结束，完结撒花。不保证本文覆盖全部内容，但至少能看懂常见的命令，以及遇到问题知道往哪个方向搜索。之后的插件配置会放到 <code>github</code> 仓库里面了，那些东西放到这里也没啥用。还是那句话，不会走就别着急学跑，<code>vim</code> 还没学会就打造 IDE 和装插件的意义也不大。</p>
]]></content>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>《呼啸山庄》读书笔记</title>
    <url>/2020/07/07/wuthering-heights/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>忘了谁推荐的了，寒假买了《呼啸山庄》这本书，拖延症到七月初，时隔六个月终于看完了，两点感受：</p>
<ol>
<li>放到现在这可能是青春狗血恋爱剧？属于堕胎、白血病那一流，虽然讲的是复仇的故事；</li>
<li>眼界狭窄不出去走走只能在周边的泥潭里越陷越深。所以眼光放长远，多出去走走，多看看外面世界。对于身边负能量爆炸、整日作死和不断需要他人安慰的人，还是趁早断联系。没意义且很累，且永远不知道她什么时候会反咬一口。</li>
<li>人还是要正能量一些，至少不能因为自己心情不好在宿舍发脾气，影响周围的人。</li>
</ol>
<a id="more"></a>
<h1 id="人物关系"><a href="#人物关系" class="headerlink" title="人物关系"></a>人物关系</h1><p>在此警告，近亲之间别结婚，乱伦需谨慎。</p>
<p><img data-src="/2020/07/07/wuthering-heights/1.png" alt></p>
<ul>
<li>凯瑟琳·恩肖：女主，呼啸山庄主人的女儿。和男主希思克利夫相爱，但嫁给了埃加德·林顿（画眉山庄的主人），以为这样可以避免哥哥亨德利·恩肖压迫男主。</li>
<li>希思克利夫：男主，呼啸山庄主人收养的孤儿。和女主相爱，不能娶女主而愤然离去，多年后回山庄展开一系列报复行动，成为呼啸山庄和画眉山庄的主人，最终绝食而死。</li>
<li>埃加德·林顿：画眉山庄主人，女主的丈夫，为人随和。</li>
<li>亨德利·恩肖：呼啸山庄主任的儿子，女主的哥哥，压迫希思克利夫，最终被希思克利夫迫害致死。</li>
<li>伊利贝拉·林顿：埃加德·林顿的妹妹，住在画眉山庄。和希思克利夫私奔结婚，结果成为了报复的对象，逃走后生下林顿·希思克利夫。</li>
<li>凯瑟琳·林顿：凯瑟琳·恩肖的女儿，先被迫嫁给林顿·希思克利夫，后嫁给哈里顿·恩肖，算有个好结局吧，复仇到这里也结束了。</li>
<li>哈里顿·恩肖：亨德利的儿子，被希思克利夫迫害，但本性不坏。</li>
<li>林顿·希思克利夫：性格古怪、矫情自私，还好死的早。</li>
<li>艾伦·丁恩：呼啸山庄和画眉山庄的女管家，讲故事的人。</li>
<li>约瑟夫：呼啸山庄的仆人，老古董。</li>
<li>洛克伍德：画眉山庄的房客，故事的讲述人。</li>
</ul>
<h1 id="故事情节"><a href="#故事情节" class="headerlink" title="故事情节"></a>故事情节</h1><p>作者对故事的把控很强，每章能讲完一个故事。但故事之前的转折笔墨很少，比如不需要一个人物时直接说他去世了，需要故事推进时，就强行推进。所以这并不适合拍电影，人物经历、故事转折的描写很少很少。而是直接的：人物咋样了，他回来干什么了，至于他经历了什么，并没有细说。所以个人感觉拍电影很难，毕竟观众喜欢从头到尾看到人物的心路历程，哪怕是黑化。</p>
<p>一下就按照章节故事介绍了，共 34 章。</p>
<ol>
<li>洛克伍德来租画眉山庄。</li>
<li>洛克伍德意外受伤，不得不借宿于呼啸山庄。</li>
<li>洛克伍德意外迷路，被冻伤，被迫留在山庄听艾伦·丁恩讲故事。故事由此开始，对，前三章都是送的。</li>
<li>呼啸山庄老主人恩肖收留了希思克利夫，恩肖的儿子亨德利·恩肖欺压希思克利夫，希思克利夫怀恨在心。</li>
<li>恩肖去世。</li>
<li>亨德利继承呼啸山庄，希思克利夫和凯瑟琳·恩肖（两人已经相爱）误打误撞进入画眉山庄，凯瑟琳·恩肖因受伤在画眉山庄住了五个星期，亨德利禁止希思克利夫和凯瑟琳·恩肖来往。</li>
<li>因亨德利的禁令，由此希思克利夫和凯瑟琳·恩肖之间出现隔阂，希思克利夫决定复仇。</li>
<li>亨德利儿子哈里顿出生，妻子因生产而死去，亨德利开始一蹶不振。希思克利夫早年的教育消失殆尽，遗憾而又痛苦。一来一往，画眉山庄的主人埃加德·林顿和凯瑟琳确定了恋人关系，但凯瑟琳·恩肖并不爱他。</li>
<li>凯瑟琳·恩肖去找艾伦·丁恩吐槽，但被希思克利夫听到，且只听到了一半，误会加深，希思克利夫离家出走。</li>
<li>多年后，希思克利夫挣了钱返乡，带着亨德利一起赌博，亨德利一直酗酒赌博，把田契压给了希思克利夫。伊利贝拉了·林顿爱上了希思克利夫。别问原因，问就是书上也没说，只有爱上后的结果。</li>
<li>希思克利夫开始教哈里顿下流的思想和语言，不允许哈里顿读书。希思克利夫和埃加德·林顿矛盾爆发，凯瑟琳·恩肖病倒。</li>
<li>因看护不严，希思克利夫和伊利贝拉·林顿私奔。</li>
<li>伊利贝拉·林顿发现自己只是希思克利夫的复仇工具，开始后悔。</li>
<li>希思克利夫让伊利贝拉明白了，从头开始，希思克利夫就不爱她，是伊利贝拉的一味追求。</li>
<li>凯瑟琳·恩肖病情加重，去世。</li>
<li>凯瑟琳·恩肖去世前生下了凯瑟琳·林顿，其他人安葬了凯瑟琳·恩肖。</li>
<li>伊利贝拉出逃，亨德利赌博家财散尽，契约地产都到了希思克利夫手下，哈里顿持续被压迫，寄人篱下。</li>
<li>十二年后，伊利贝拉即将因病去世，埃加德·林顿前去探望；凯瑟琳·林顿和希思克利夫、哈里顿相遇。</li>
<li>伊利贝拉去世，埃加德·林顿带着希思克利夫的儿子回来了，希思克利夫上门索要儿子。</li>
<li>希思克利夫得到了他的儿子。</li>
<li>希思克利夫讨厌他的儿子，性格诡异and病怏怏的，但安排了希思克利夫·林敦和凯瑟琳·林顿的相遇，并且持续写信，让凯瑟琳·林敦爱上希思克利夫，两人结婚后希思克利夫便迟早可以获取画眉山庄。写信被艾伦·丁恩发现后中断。</li>
<li>希思克利夫来画眉山庄，让通信继续。</li>
<li>希思克利夫·林敦卖惨，自此以后凯瑟琳·林敦便持续去呼啸山庄看望希思克利夫·林顿。</li>
<li>二人继续来往。</li>
<li>希思克利夫·林敦病危，希思克利夫准备加快抢夺画眉山庄的计划。</li>
<li>希思克利夫·林顿持续卖惨，凯瑟琳·林顿想分手。</li>
<li>希思克利夫·林顿的身体坚持不住，希思克利夫便强迫希思克利夫·林顿和凯瑟琳·林敦结婚，强行扣押。</li>
<li>埃加德·林顿去世，画眉山庄由希思克利夫的儿子继承，在希思克利夫的胁迫下，画眉山庄也到手了。</li>
<li>办完埃加德·林顿的丧事后，希思克利夫把凯瑟琳·林敦带回了呼啸山庄。</li>
<li>凯瑟琳·林顿讨厌呼啸山庄的所有人。</li>
<li>洛克伍德给帮艾伦·丁恩给凯瑟琳·林敦传信，结果失败。</li>
<li>凯瑟琳·林顿和埃利哈里顿化解，帮助哈里顿读书识字，两人相爱。</li>
<li>希思克利夫看到现在的哈里顿，仿佛看到了当年的自己，放下了仇恨。</li>
<li>希思克利夫绝食而死，葬在了凯瑟琳·恩肖旁边。</li>
</ol>
<p>我发誓，以后读一章就做一章的笔记，之后再去回顾可太困难了。</p>
<p>书中转折情节很少，只是两人突然相爱，仔细描写了相爱后干啥、相爱后的后果，并没有写为什么相爱。可能是故事情节太长，作者喜欢这样强行转折，而不是为故事转折去铺垫。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>故事讲完了，放到现在就是个狗血、恋爱、复仇、癌症和青春疼痛的故事吧，书中的人物文字深刻的反映了当时由于阶级差别所带来的人物性格上的扭曲。换句话说，如果当时有<code>QQ</code>和微信这类的社交工具，教育很普及，他们都能认识到更多的人和同学，也许就没这个故事了。</p>
<p>也许作者想说：“恨”消灭不了爱，只会让自己更加空虚落寞，“爱”比恨更有力量这个意思吧。</p>
]]></content>
      <tags>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>西出阳关</title>
    <url>/2020/01/16/yangguan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>晚上追着“劝君更进一杯酒，西出阳关无故人”这首诗来到了阳关，西出阳关便是沙漠，东进便是绿洲。走阳关大道，览汉唐胜迹，地势险要，风景壮阔。大漠孤烟，难怪有这么豪情的诗词。</p>
<p>“渭城朝雨泪轻尘，客舍青青柳色新。动君更尽一杯酒，西出阳关无敌人”，诗人王维的干古绝唱《渭城曲》让敦煌阳关成为中国人的精神故乡。——悲欢聚散一杯酒，南北东西万里程。</p>
<p><img data-src="/2020/01/16/yangguan/77.jpg" alt></p>
<a id="more"></a>
<p>这里曾雄关峨，商队络绎，使者相望于道；这里曾绿树成荫，街道纵横，天马驰骋于野。伴随蓬勃而出的大漠红日，阳关横亘在隔壁与沙漠之间。雄关高耸，简楼巍然。战旗猎猎，鼓角相闻，让人刹那间梦回汉唐。登高运眺、持牒出关、饮酒壮别、骑射练兵、刻石留名、漫步阳关，身受大汉雄风。</p>
<p>晚上吃得胡羊焖饼，羊排双吃，一口羊肉一口酸，肥而不腻，真的舒适。沙葱炒蛋，真好吃不贵。</p>
<p><img data-src="/2020/01/16/yangguan/79.jpg" alt><br><img data-src="/2020/01/16/yangguan/78.jpg" alt><br><img data-src="/2020/01/16/yangguan/80.jpg" alt><br><img data-src="/2020/01/16/yangguan/81.jpg" alt><br><img data-src="/2020/01/16/yangguan/82.jpg" alt><br><img data-src="/2020/01/16/yangguan/83.jpg" alt><br><img data-src="/2020/01/16/yangguan/84.jpg" alt><br><img data-src="/2020/01/16/yangguan/85.jpg" alt><br><img data-src="/2020/01/16/yangguan/86.jpg" alt><br><img data-src="/2020/01/16/yangguan/89.jpg" alt><br><img data-src="/2020/01/16/yangguan/93.jpg" alt><br><img data-src="/2020/01/16/yangguan/95.jpg" alt><br><img data-src="/2020/01/16/yangguan/97.jpg" alt><br><img data-src="/2020/01/16/yangguan/106.jpg" alt><br><img data-src="/2020/01/16/yangguan/107.jpg" alt><br><img data-src="/2020/01/16/yangguan/108.jpg" alt><br><img data-src="/2020/01/16/yangguan/109.jpg" alt><br><img data-src="/2020/01/16/yangguan/120.jpg" alt></p>
]]></content>
      <categories>
        <category>塞上西北行</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么梯度方向是函数的最速上升方向</title>
    <url>/2020/10/15/why-gradient-direction-is-the-fastest-ascent-direction/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在用神经网络的时候，权重的更新方向一直是沿着负梯度进行更新，可有想过为什么要沿着梯度进行更新吗？或者说，为什么负梯度方向就是函数下降最快的方向呢？</p>
<a id="more"></a>
<p>这学期选课有毒，在各种不可抗力影响下，选了《大数据建模优化》这门课，上了几周发现跟大数据丝毫不沾边，无论是数据存储、挖掘、分析、处理和代码等一个不讲，都在讲本科数学建模竞赛那些基本模型，线性规划、二分类、SVM什么的，就是现在手推公式我能看懂了。后来发现这课的老师之前是数学系的，带《工程优化》这门课，据说讲的很不错，后来的老师都继承了他的风格。好巧不巧，我也选了《工程优化》，也是线性规划、凸集那些。然后选了《数据驱动优化》这门课，我以为是数据分析，玩玩<code>hadoop</code>什么的，结果发现也是跟数据没关系，也是在约束条件下优化目标，遗传算法、粒子群算法，就是本科建模那些常见算法。我寻思能开个专题好好整理下了，就开了个 <code>Math</code> 的标签。</p>
<p><del>其实我想选《Linux 内核分析》这种只有计科人才能玩懂的直面怼代码的硬核课程，懂操作系统懂计算机原理才能写出好程序。</del></p>
<h1 id="偏导"><a href="#偏导" class="headerlink" title="偏导"></a>偏导</h1><p>对于一个多元函数$z=f(x_1,x_2,\ldots,x_n)$，对第$i$个分量$x_i$的偏导为$\frac{\partial f}{\partial x_i}$，可以写成：<br>\begin{equation}<br>\frac{\partial f}{\partial x_i}=\lim_{t\to 0} \frac{f(x+te_i)-f(x)}{t}<br>\end{equation}<br>其中，$e=(0,\ldots,1,\ldots,0)$，只有第$i$个元素为1。</p>
<h1 id="可微"><a href="#可微" class="headerlink" title="可微"></a>可微</h1><p>以二元函数为例（我懒，多元写着费劲），若函数$z=f(x,y)$在点$(x_0,y_0)$的全增量$\Delta z=f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)$可表示为$\Delta z =A\Delta x+B \Delta y +o(p)$，则$f(x,y)$在点$(x_0,y_0)$处可微，在这一点的全微分记作$\text{d} z=A\Delta x+B\Delta y$，等价于：</p>
<p>\begin{equation}<br>\lim_{||(\Delta x,\Delta y)|| \to 0} \frac{f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)-A\Delta x-B \Delta y}{||(\Delta x,\Delta y)||}=0<br>\end{equation}</p>
<p>记$x=(x,y)^T,\Delta x=(\Delta x,\Delta y)^T,l=(A,B)^T$，再次得到：</p>
<p>\begin{equation}<br>\lim_{\Delta x \to 0} \frac{f(x+\Delta x)-f(x)-l^T\Delta x}{||\Delta x||}=0<br>\end{equation}</p>
<h1 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h1><p>若函数$z=f(x,y)$在点$(x_0,y_0)$处可微，在该点的偏导必然存在，$\text{d}z$可以改写成$\text{z}=\frac{\partial z}{\partial x}|_{x=x_0}\Delta x+\frac{\partial z}{\partial y}|_{y=y_0}\Delta y$：</p>
<p>\begin{equation}<br>l=(A,B)^T=(\frac{\partial z}{\partial x}|_{x=x_0},\frac{\partial z}{\partial y}|_{y=y_0})^T<br>\end{equation}</p>
<p>则向量$l=(\frac{\partial z}{\partial x}|_{x=x_0},\frac{\partial z}{\partial y}|_{y=y_0})^T$称为函数$f(x,y)$在点$(x_0,y_0)$处的梯度。</p>
<p><strong>注：对于任意多元函数，以上的梯度和可微定理均成立。</strong></p>
<h1 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h1><p>设多元函数$f$在点$x$处可微，向量$p=te$，$t$是$p$的模，$e$是$p$的单位向量，函数$f$在点$x$沿$p$方向的方向导数记为：</p>
<p>\begin{equation}<br>\frac{\partial f(x)}{\partial p}=\lim_{t \to 0^+}\frac{f(x+p)-f(x)}{t}=\lim_{t \to 0^+}\frac{f(x+te)-f(x)}{t}<br>\end{equation}</p>
<ul>
<li>若$\frac{\partial f(x)}{\partial p}&lt;0$，可以得到$f(x+te)-f(x)&lt;0$，函数$f$在点$x$附近沿着$p$方向是下降的；</li>
<li>若$\frac{\partial f(x)}{\partial p}&gt;0$，可以得到$f(x+te)-f(x)&gt;0$，函数$f$在点$x$附近沿着$p$方向是上升的。</li>
</ul>
<p>则方向导数正负决定了函数升降；升降速度的快慢由方向导数绝对值大小来决定，绝对值越大升降速度越大。</p>
<h1 id="结论证明"><a href="#结论证明" class="headerlink" title="结论证明"></a>结论证明</h1><p>前面准备了那么多基础知识，现在可以证明标题的结论了：<strong>为什么梯度方向是函数的最速上升方向</strong>。</p>
<p>多元函数$f$在点$x$处可微，可以得到：</p>
<p>\begin{equation}<br>f(x+p)=f(x)+l^Tp=f(x)+\nabla f(x)^Tp<br>\end{equation}</p>
<p>将$p$替换为$te$，可以得到：</p>
<p>\begin{equation}<br>\frac{\partial f(x)}{\partial p}=\lim_{t\to 0^+}\frac{f(x+p)-f(x)}{t}=\lim_{t\to 0^+}\frac{t\nabla f(x)^Te}{t}=\nabla f(x)^Te<br>\end{equation}</p>
<p>继续：</p>
<p>\begin{equation}<br>\frac{\partial f(x)}{\partial p}=\nabla f(x)^T e \text{向量内积} =||\nabla f(x)||\cos \beta (e\text{的模是1})<br>\end{equation}</p>
<p>我们已经知道：<strong>方向导数正负决定了函数升降；升降速度的快慢由方向导数绝对值大小来决定，绝对值越大升降速度越大。</strong>所以：</p>
<ul>
<li>当夹角为$\beta =0$时，即方向导数和梯度重合，方向导数取得最大值；</li>
<li>当夹角为$\beta =180$时，即沿着负梯度方向，方向导数取得最小值；</li>
</ul>
<p>可见梯度方向即为函数的最速上升方向；负梯度方向即为函数的最速下降方向，从而梯度方向是函数具有最大变化率的方向。<del>忽然发现这种证明题也挺好玩（逃</del></p>
]]></content>
      <tags>
        <tag>Modeling</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLO目标检测从 V1 开始，细读代码</title>
    <url>/2021/08/26/yolo-v1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>忙里偷闲，写几篇长文，从 YOLO 的 v1 到 v5。没想到时隔多年会回来重新看 YOLO 系列的东西，相比两阶段检测，YOLO 真的太快了，加上一些训练的 trick，mAP 也不会很低。网上看了好多教程不明所以，索性还是直接去读原论文了，读了原论文有些东西还是不理解，索性又去读了源程序。不过为了便于理解，有的地方不会按照论文顺序进行整理。少问问题，读论文产生的疑问在代码里都有解答，不看代码永远不能被称为学会了。</p>
<a id="more"></a>
<p>如果对本文有疑问或者想找男朋友，可以联系我，<a href="https://muyuuuu.github.io/about/">点击此处有我联系方式</a>。</p>
<h1 id="YOLO-v1"><a href="#YOLO-v1" class="headerlink" title="YOLO v1"></a>YOLO v1</h1><ul>
<li>论文地址：<a href="https://arxiv.org/abs/1506.02640" target="_blank" rel="noopener">https://arxiv.org/abs/1506.02640</a></li>
<li>pytorch 程序地址：<a href="https://github.com/motokimura/yolo_v1_pytorch" target="_blank" rel="noopener">https://github.com/motokimura/yolo_v1_pytorch</a></li>
</ul>
<p>YOLO v1 将目标检测定义为回归问题，直接读入全部图像，回归出边界框和分类概率。与同时期的 Faster RCNN 对比，算法快了不少，也没有 RPN 以及后处理，也避免里滑动窗口这样的暴力检测。所以能用到一些实时系统中，也是我花精力看这一些列论文的原因。</p>
<p>但是对于 v1 的 YOLO 存在一些缺陷，作者在论文中也进行了阐述：准确率低、定位不准尤其是小目标的定位。</p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>首先将图片分为 $S\times S$ 个网格，论文中 $S=7$，如果一个物体的中心落入这个格子中，那么这个格子负责预测这个目标。设每个格子负责预测 $B$ 个物体的盒子参数和置信度得分，盒子参数指明物体的位置，置信度表示盒子含有目标且预测准确的可信程度。即对于图片的每个格子，会输出 $B$ 个 $(x,y,w,h,c)$，论文中 $B=2$。</p>
<p>既然有了输出，那么就需要 label 进行损失计算。$(x,y,w,h,c)$ 是人工标注的数据，$c$ 初始化为 1。论文定义网络输出的置信度标签是一个分段函数，如果格子没有目标，置信度是 0；如果有目标，置信度是预测框和真实框的 IOU 值，公式描述为 $\text{Pr(Object)} * \text{IOU}_{\text{pred}}^\text{truth}$。</p>
<p>目标检测和分类是分不开的，为了达到分类的目的，每个格子也会输出 $C$ 个类别的概率，公式表述为 $\text{Pr(Class}_i|\text{Object})$，即格子里面得是个目标，才能计算分类的概率和损失。而每个格子输出一组<a href="https://github.com/motokimura/yolo_v1_pytorch/blob/master/detect.py#L203-L206" target="_blank" rel="noopener">预测</a>，即使输出了 $B$ 组数据，这就限制了网络的表达。</p>
<p>在测试阶段，类别置信度的分数就是分类概率和置信度相乘，即盒子中「有这个类别的概率」和「网络预测这个类别的概率」的乘积：</p>
<p>\begin{equation}<br>\text{Pr(Class}_i|\text{Object})*\text{Pr(Object)}*\text{IOU}_{\text{pred}}^\text{truth}=\text{Pr(Class}_i) * \text{IOU}_{\text{pred}}^\text{truth}<br>\end{equation}</p>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p>这种东西还是代码清楚，只放了最关键的检测输出：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">nn.Linear(<span class="number">4096</span>, S * S * (<span class="number">5</span> * B + C))</span><br><span class="line">nn.Sigmoid()</span><br><span class="line">x.view(<span class="number">-1</span>, S, S, <span class="number">5</span> * B + C)</span><br></pre></td></tr></table></figure>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>\begin{aligned}<br>{ } &amp; \lambda_{coord} \sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{I}_{ij}^{\text{obj}} [(x_i-\hat{x}_i)^2 + (y_i-\hat{y}_i)^2] \\<br>{ } &amp;+ \lambda_{coord} \sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{I}_{ij}^{\text{obj}} [(\sqrt{w_i}-\sqrt{\hat{w}_i})^2+(\sqrt{h_i}-\sqrt{\hat{h}_i})^2] \\<br>{ } &amp;+ \sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{I}_{ij}^{\text{obj}} (C_i - \hat{C}_i)^2 \\<br>{ } &amp;+ \lambda_{noobj} \sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{I}_{ij}^{\text{noobj}} (C_i - \hat{C}_i)^2 \\<br>{ } &amp;+ \sum_{i=0}^{S^2} \mathbb{I}_{ij}^{\text{obj}} \sum_{c\in classes} (p_i(c)-\hat{p}_i(c))^2<br>\end{aligned}</p>
<ul>
<li>$\lambda_{coord}$ 是前景的权重，$\mathbb{I}_{ij}^{\text{obj}}$ 是指示函数，取值只有 0 和 1</li>
<li>前两行表示 bound box 的损失</li>
<li>第三行是前景置信度的损失</li>
<li>第四行是背景置信度的损失</li>
<li>第五行是分类的损失</li>
</ul>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ol>
<li>每个网格只能检测一个类别和两个目标，类间竞争严重，网络表达受限，对于密集群体的检测性能会下降；</li>
<li>定位不准确，因为网络直接预测 bounding box 的坐标，一开始的偏移可能会很大，导致定位不准确，读完代码能深刻理解这里的缺陷；</li>
<li>对于检测问题而言，大多情况背景居多，前景居少，也就是样本不均衡。YOLO v1 的损失中，并没有计算背景的 bound box 损失，只计算了前景的，YOLO v1 回避了样本不均衡的问题，这会影响网络的稳定性与背景的识别。</li>
</ol>
<h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><p>「如果对算法有疑问，就去读代码吧」这一经验帮助我理解了很多算法的困惑之处，不仅仅是 YOLO。如果要看懂一个深度学习的算法，核心有三要素，首先是网络模型，理解输入、输出和结构；其次是数据与损失，理解加载什么格式的数据，理解网络预测数据和加载的数据如何计算损失，所以这俩常常放在一起；最后是细枝末节，即数据增强、学习率策略、整体训练流程等。所以接下来整理网络模型和损失。<del>训练策略那些不是 YOLO 的重点。</del></p>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>我们知道网络的输出是 <code>x.view(-1, S, S, 5 * B + C)</code> 这种类型的格式，这是预测数据，即 $S \times S $ 组 $5 \times B + C$ 这样的数据，$C$ 是类别数量。那么可想而知，在训练阶段，同样需要提供同等尺寸大小的标签数据。</p>
<h2 id="数据与损失"><a href="#数据与损失" class="headerlink" title="数据与损失"></a>数据与损失</h2><p>YOLO 处理目标时，使用的是目标中心点的坐标相对图像大小的占比。如果一张图像的大小是 224 X 224，目标中心点位于 112 X 112，那么中心点的坐标是 $(0.5,0.5)$。这有两点好处：</p>
<ol>
<li>如果一个图像的尺寸是 1920 X 1080，目标中心点的坐标是 1000 X 1000，直接输出 1000 对于网络来说难以把控，会造成梯度爆炸的现象。而占比只需要输出 [0,1] 之间的小数，不会导致梯度爆炸。</li>
<li>方便图像的标准化处理。网络常常使用多个 batch 进行训练，每个 batch 的数据要求大小统一，对于不同尺寸的图像应选择 <code>resize</code>。如果直接用坐标，<code>resize</code> 后会导致坐标错位，而如果用占比，位于之前图像 (0.5, 0.5) 处的点在 <code>resize</code> 后的坐标仍然是 (0.5, 0.5)。</li>
</ol>
<p>由于 YOLO 最初设计的方案是：物体中心落到哪个格子，就由这个格子预测这个目标，这一观点需要仔细阅读代码才能理解。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 和网络输出同等大小的标签</span></span><br><span class="line">target = torch.zeros(S, S, N)</span><br><span class="line"><span class="comment"># S=7，表示每个格子的占比</span></span><br><span class="line">cell_size = <span class="number">1.0</span> / float(S)</span><br><span class="line"><span class="comment"># 计算宽度和高度</span></span><br><span class="line">boxes_wh = boxes[:, <span class="number">2</span>:] - boxes[:, :<span class="number">2</span>]</span><br><span class="line"><span class="comment"># x,y 的中心点坐标，此时已经除以图像大小</span></span><br><span class="line">boxes_xy = (boxes[:, <span class="number">2</span>:] + boxes[:, :<span class="number">2</span>]) / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于 b 和 batch 的盒子进行处理</span></span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> range(boxes.size(<span class="number">0</span>)):</span><br><span class="line">    xy, wh, label = boxes_xy[b], boxes_wh[b], int(labels[b])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算中心点位于哪个格子</span></span><br><span class="line">    ij = (xy / cell_size).ceil() - <span class="number">1.0</span></span><br><span class="line">    <span class="comment"># 取出 i j，用于 SXS 的填充</span></span><br><span class="line">    i, j = int(ij[<span class="number">0</span>]), int(ij[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 格子左上角的坐标</span></span><br><span class="line">    x0y0 = ij * cell_size</span><br><span class="line">    <span class="comment"># 相对格子左上角的坐标</span></span><br><span class="line">    <span class="comment"># 除以 cell_size 没啥用，这人代码写的有问题，后面损失计算的时候又乘了回来</span></span><br><span class="line">    xy_normalized = (xy - x0y0) / cell_size</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始填充</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(B):</span><br><span class="line">        s = <span class="number">5</span> * k</span><br><span class="line">        target[j, i, s  :s+<span class="number">2</span>] = xy_normalized <span class="comment"># 坐标</span></span><br><span class="line">        target[j, i, s+<span class="number">2</span>:s+<span class="number">4</span>] = wh            <span class="comment"># 大小</span></span><br><span class="line">        target[j, i, s+<span class="number">4</span>    ] = <span class="number">1.0</span>           <span class="comment"># 置信度</span></span><br><span class="line">    target[j, i, <span class="number">5</span>*B + label] = <span class="number">1.0</span>           <span class="comment"># 类别标签</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> target</span><br></pre></td></tr></table></figure>
<p>在损失计算阶段，代码真的太长了不便展示，这里只记录核心要素：</p>
<ol>
<li>对于有目标计算损失，无目标忽略这一点，是通过对真实标签进行掩码处理实现的，只取出真实标签中置信度为 1 的标签记录维度，并在 predict 中取出同维度的数据就算损失，其余数据忽略。假设这一步保留了 $X$ 个盒子。</li>
<li>对于 $X$ 个盒子中的 $B$ 组数据继续处理，对于每组数据而言，选择和真实标签 IOU 最大的盒子计算损失，其余盒子忽略，也就是没有正负样本的概念。这里需要注意，如果网络初期计算到 IOU 为 0，那么默认第一个盒子和真实标签进行损失计算。</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我已经正负样本划分、格子、bounding box、anchor box 的概念已经搞混了，论文里不会写这太细节的东西，不然我也不会来读代码。毕竟整理理论知识太简单了，也容易自欺欺人，并不清楚网络的流程。所以 YOLO v2, v3, v4, v5 和 x 的内容等下几篇博客了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/183261974" target="_blank" rel="noopener">你一定从未看过如此通俗易懂的YOLO系列(从v1到v5)模型解读</a></li>
<li><a href="https://fengweiustc.github.io/paper-reading/2020/06/17/yolo/" target="_blank" rel="noopener">YOLO v1/v2/v3/v4</a></li>
</ol>
]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOX 源码解析与小目标检测调优</title>
    <url>/2022/02/26/yolox/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近用 yolox 的发现了一个很神奇的现象，简而言之 <code>yolox-tiny</code> 在单目标检测的效果比 <code>yolox-small</code> 好上很多（3.2mAP%），且 <code>yolox-small</code> 能大幅提升检测精度的方法到了 <code>yolox-tiny</code> 也不起作用了。网上很多 yolox 的解读基本都是翻译论文，没啥价值，还是决定仔细读一下代码，这大概也是全网第一份从源代码的角度解析 yolox 的文章。</p>
<p>阅读源码后发现 yolox 的 SimOTA 机制存在一些漏洞，并使用对应的方法调优。调优过程明确不采用的方案：增大模型规模、模型融合和其他消耗算力的方法，专注算法本身。</p>
<a id="more"></a>
<h1 id="Model-部分"><a href="#Model-部分" class="headerlink" title="Model 部分"></a>Model 部分</h1><p>和其他检测模型一样，<code>model</code> 分为 <code>backbone</code>，<code>neck</code> 和 <code>head</code>。</p>
<h2 id="backbone"><a href="#backbone" class="headerlink" title="backbone"></a>backbone</h2><p><code>backbone</code> 采用 <code>CSPDarkNet</code>，包括 <code>stem</code>，<code>dark2</code>，<code>dark3</code>，<code>dark4</code> 和 <code>dark5</code>。</p>
<ul>
<li>数据经过增强处理并缩放到 <code>640X640</code> 大小后进入 <code>stem</code> 完成图像通道的升维，从 <code>3</code> 通道提升到 <code>X</code> 通道，<code>X</code> 取决于 <code>backbone</code> 规模的 <code>width_factor</code> 参数。图像经过这一层之前，会被均匀切分为左上、右上、左下和右下四个区域并按通道拼接得到 <code>160X160X12</code> 的数据，也就是 12 个通道，每个通道的图像大小占据原图像大小的 <code>1/4</code>，在经过卷积、<code>BN</code> 层和激活层，得到输出。</li>
<li><code>stem</code> 的输出进入 <code>dark2</code>，经过一个卷积模块，维度提升一倍后尺寸减半。而后经过 <code>CSPLayer</code>，<code>CSPLayer</code> 的结构和残差网络相似，一个分支只对输入卷积一次，另一个分支进行深度特征提取，深度的层数取决于 <code>backbone</code> 的 <code>depth_factor</code> 参数，而后两个分支的输出按照通道数拼接到一起，完成升维。</li>
<li><code>dark3, dark4, dark5</code> 的东西和 <code>dark2</code> 一致，无非是尺寸减半，通道数翻倍，同理得到 <code>dark3, dark4, dark5</code> 的输出。</li>
</ul>
<p><img data-src="https://s4.ax1x.com/2022/02/26/bZ86nH.png" alt></p>
<p>这里补充一下：</p>
<ul>
<li><code>dark3</code> 的输出维度：<code>256X80X80</code></li>
<li><code>dark4</code> 的输出维度：<code>512X40X30</code></li>
<li><code>dark5</code> 的输出维度：<code>1024X20X20</code></li>
</ul>
<h2 id="neck"><a href="#neck" class="headerlink" title="neck"></a>neck</h2><p>获取 <code>backbone</code> 的 <code>dark3, dark4, dark5</code> 的输出作为输入。这里用文字描述的话太复杂了，简单的画图展示一下大概结构，精细的结构还是要看源代码：</p>
<p><img data-src="https://s4.ax1x.com/2022/02/26/bZ8gHA.png" alt></p>
<p>也就是说，这三个输出都融合了模型深层的语义特征和模型浅层的细节特征。</p>
<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>因为 <code>neck</code> 有三组输出，所以 <code>head</code> 对 <code>neck</code> 的每一组输出都要进行处理。对每一个输入经过不同的 <code>stem</code> 把通道数降维到 256，而后接入解耦的任务分支，包括分类（<code>cls</code>）、位置框（<code>reg</code>）和前背景（<code>obj</code>）三个网络。</p>
<p>分类网络的输出通道数是类别数，这里假设为 2，回归网络的输出通道数是 4，负责预测中心点坐标和高宽尺寸，前背景网络的输出通道数是 1，因此输出的通道数是 2+4+1=7。将这三个网络的输出然后拼接到一起，放到一个列表中。因此，<code>head</code> 部分得到的输出为三组数据：<code>7X80X80, 7X40X40, 7X20X20</code>。以 <code>7X80X80</code> 为例，表示预测了 <code>80X80</code> 个目标，每个目标包括位置、类别和前背景共 7 个参数。</p>
<p><img data-src="https://s4.ax1x.com/2022/02/26/bZ8cBd.png" alt></p>
<h1 id="训练部分"><a href="#训练部分" class="headerlink" title="训练部分"></a>训练部分</h1><p>这一部分是难点，或者说，是任何目标检测算法的实现难点，代码量也是最大。</p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>在这一部分，将对 <code>head</code> 的三个输出进行一些转换并生成对应的 <code>grid</code> 信息，将预测输出对应到图像中的实际位置。<code>grid</code> 可以理解为特征点的位置吧，是固定的，如下图所示黑色的那一个个格子（其他颜色不用看，我实在找不到类似的图了）：</p>
<p><img data-src="https://s4.ax1x.com/2022/02/27/beHtnP.png" alt></p>
<p>这一部分大概分以下步骤：</p>
<ol>
<li>获取输出特征的的宽度和高度，如 80 和 80，或者 40 和 40，那么就生成对应的 <code>grid</code>，如 [0, 1] [0, 2] … [80, 80] 共 6400 个，维度是 [1, 6400, 2]</li>
<li>将预测结果 <code>reshape</code> 成 <code>Batch, HxW, C</code> 大小，坐标的 <code>x</code> 和 <code>y</code> 加上 <code>grid</code> 会映射到每个预测特征点的中心位置，在乘以 8，也就是理想情况下位置信息的运算结果会在 640 X 640 之间，也就是图像上目标的中心点</li>
<li>计算 <code>w</code> 和 <code>h</code> 的 $e$ 次方，再乘以 8，得到目标框的高度和宽度。此时返回得到的 <code>grid</code> 和变换过后的 <code>output</code>。（80 对应的扩张步是 8，40 对应的扩张步是 16，20 对应的扩张步是 32）</li>
</ol>
<p>将每一个输出经过上面 3 个步骤的处理后，按照 <code>dim=1</code> 拼接到一起，也就是会得到 <code>Batch, 8400, 7</code> 的输出。（80X80 + 40X40 + 20X20 = 8400）。</p>
<h2 id="计算损失"><a href="#计算损失" class="headerlink" title="计算损失"></a>计算损失</h2><p>针对 <code>batch</code> 中的每一个图像开始处理：</p>
<ul>
<li>如果真实标签显示这个图像没有目标，全部真实标签就是清一色的 0，分类个数全部是 0，位置参数是 4 个 0，有无目标是 8400 个 0，<code>fg_mask</code> 全部是 <code>false</code>。（<code>fg_mask</code> 的用途后面会讲）</li>
<li>否则，取出这个图像包含的全部真实目标框，与预测结果进行 SimOTA 样本分配，为预测结果分配标签，或者说为标签分配预测结果，因为 8400 个预测结果不可能同时参与训练，只选择部分样本视为正样本进行训练。</li>
</ul>
<h3 id="SimOTA"><a href="#SimOTA" class="headerlink" title="SimOTA"></a>SimOTA</h3><p>首先计算真实框覆盖的 <code>grid</code> 中心点，将这些 <code>grid</code> 中心点称为 <code>fg_mask</code> 也就是正样本，从所有的预测结果中通过 <code>fg_mask</code> 把正样本取出来，包括位置，类别和前背景。此外，选择落入真实目标框的周围的预测结果并记录下来，周围的度量方式是：当前特征点乘以 2.5 倍的步长所覆盖的格子。</p>
<ul>
<li>之后计算选中的位置和真实位置的 <code>iou</code> 得分和损失；</li>
<li>将类别的输出激活后和 <code>obj</code> 的激活输出相乘得到类别得分，以此得到类别损失；</li>
<li>将没有被选中的预测结果视为负样本，也就是上面没有落入真实目标框及周围的预测结果视为预测失败，计算预测失败的损失，有一个预测结果不在，损失就是1，有 100 个不在，就是 100，然后计算这三个损失的和。</li>
</ul>
<p>之后进行动态 k 分配，这里的 k 计算比较简单，在 10 和上一步骤选中的 <code>fg_mask</code> 数量取最小值就是 <code>k</code>，给每个真实框选取损失最小的 <code>k</code> 个预测结果。如果当某一个特征点指向多个真实框的时候，选取 <code>cost</code> 最小的真实框，之后对 <code>fg_mask</code> 进行更新。</p>
<h3 id="计算损失-1"><a href="#计算损失-1" class="headerlink" title="计算损失"></a>计算损失</h3><ul>
<li><code>obj</code> 损失是全部的预测结果和动态 k 分配后得到的 <code>fg_mask</code> 做交叉熵，提升检测到目标的能力</li>
<li><code>cls</code> 损失基于 <code>fg_mask</code> 选中的预测结果，将类别的 <code>one-hot</code> 向量与正样本和真实框的 iou 做乘积视为目标。比如预测框和真实框的 iou 是 0.4，那么对应的类别得分就是 0.4，毕竟相交面积小。预测结果和目标做交叉熵损失</li>
<li><code>reg</code> 损失是就是预测盒子和真实盒子的 iou 损失</li>
</ul>
<h1 id="问题分析与调优"><a href="#问题分析与调优" class="headerlink" title="问题分析与调优"></a>问题分析与调优</h1><p>如何解释开头的问题以及如何调优呢？通过一路 <code>debug</code> 找到了一些问题，我目前只发现了一点点问题，<del>等我彻底解决完毕回来填坑（因为又又又摸不到显卡了）。</del></p>
<ul>
<li>第一点，由于是单目标检测任务，也就是说只有一个目标，那么小模型参数少，很容易聚焦和收敛；而大模型参数大，解空间也会更多，相对小模型难以探索到更好的解，因此一些常见的 <code>trick</code> （比如预训练 <code>backbone</code>）才会有效的提升大模型的检测效果，而对小模型而言，参数少，搜索空间小，很容易找到更优的解，因此一些 <code>trick</code> 并不会起到很大的作用。</li>
<li>第二点，由于检测任务绝大多数目标是小目标，而 yolox-tiny 模型尺寸小，输出的通道数也少，底层的特征信息的保留程度好于大模型，因为模型越深，对图像细节的保留程度就越低。</li>
<li>第三点，也是最重要的一点，由于 YOLOX 选取正样本的机制是：预测结果落入真实框，或者落入真实框的周围，这些落入真实框周围的正样本在模型初期会侥幸存活下来并通过 <code>SimOTA</code> ，但是，由于大部分都是小目标，会导致预测结果和真实目标毫不相交的场景，这就 <code>reg</code> 分支的 IoU Loss 不起作用，我们换成 CIoU Loss 就可以了。</li>
</ul>
<p><img data-src="https://s4.ax1x.com/2022/02/27/beHJXt.png" alt></p>
<p>如图所示，红色是真实框，绿色是落入真实框周围的预测结果（正样本），灰色表示不参与训练。可以看到，由于目标较小，预测结果和真实标签毫不相交，IoU Loss 的损失是 0，这显然是不合理的，应该是一个很大的数，而 CIoU Loss 能很好的解决这一点。</p>
<p>如果你要从发论文的角度调优 yolox，那么建议改动它的 SimOTA 机制，但是这也只能是为了毕业而发的一篇普通的论文，还远远达不到 yolov6 问世的高度。如果是工程的角度，那么 CIoU Loss 会很适合你。结果也显示，使用 CIoU Loss 的 mAP 要远远高于不使用和 yolox-tiny，提升 4.1 的 mAP。</p>
]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLO V2，细读代码</title>
    <url>/2021/08/28/yolo-v2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>还是老样子，不看代码永远不能称为学会了。况且 YOLO V2 有一些优化还是很常见的，如 Anchor Box 和多尺度训练。我之前也只是听说过这些名词，并不知道如何在程序中使用，索性直接读了程序了解一下，程序写的还是比较精彩的。另外：这是第一篇用 vim 写的博客。</p>
<a id="more"></a>
<h1 id="YOLO-v2"><a href="#YOLO-v2" class="headerlink" title="YOLO v2"></a>YOLO v2</h1><p>论文地址：<a href="https://arxiv.org/abs/1612.08242" target="_blank" rel="noopener">https://arxiv.org/abs/1612.08242</a><br>提供两个代码地址：第一个适合看模型、损失和多尺度训练，第二个适合看 anchor box 如何用到模型中，但是需要注意的是有 bug，但写的比第一个容易理解。</p>
<ol>
<li><a href="https://github.com/longcw/yolo2-pytorch" target="_blank" rel="noopener">https://github.com/longcw/yolo2-pytorch</a></li>
<li><a href="https://github.com/uvipen/Yolo-v2-pytorch/tree/master" target="_blank" rel="noopener">https://github.com/uvipen/Yolo-v2-pytorch/tree/master</a></li>
</ol>
<p>作者基于之前的 YOLO v1，提出了一些改进的策略，快速的同时准确率也大幅度提升。训练检测网络的同时，在 ImageNet 数据集上进行训练，提升了网络的分类能力。文章的一开始，作者指出了检测存在的几个问题：</p>
<ol>
<li>小目标检测能力受限</li>
<li>目标检测数据集的类别远远小于分类数据集的类别，且，不可能对检测数据集进行标注。所以能不能使用多个分类的数据集提升网络能识别的类别数呢？</li>
</ol>
<h2 id="Better"><a href="#Better" class="headerlink" title="Better"></a>Better</h2><p>作者进行了一些尝试来提升网络的性能：</p>
<ul>
<li>Batch Normalization，在卷积层后、激活层前加入 BN 层，大约提升了 2%。BN 层帮助网络实现正则化，能移除之前的 droupout层。</li>
<li>提高分辨率，将 v1 的 224 尺寸变为 448 尺寸，并先在 ImageNet 上训练 10 次，使得网络适应高分辨率，而后在检测任务中进行微调。</li>
<li>使用 Anchor Box 提升定位精准度，预测相对 anchor box 的坐标偏移，预测偏移相对直接预测坐标会简单些。这样提升了网络的召回率。此外，图片的 Ground Truth 一般都是正方形，1:2 的长方形或者 2:1 的长方形，预先准备几个几率比较大的 bounding box，再以它们为基准进行预测。</li>
<li>为了设置合适的 Anchor Box 的大小，对数据集的盒子进行 K-means 聚类，筛选出合适的 bounding box 大小。K-means 没有使用 欧拉距离，而是 $1-\text{IOU(box, center)}$，即盒子的 IOU 越大，距离越小。</li>
</ul>
<p>以上都是微小的改进，下面的三点改进是比较大的。</p>
<h3 id="Direct-location-prediction"><a href="#Direct-location-prediction" class="headerlink" title="Direct location prediction"></a>Direct location prediction</h3><p>作者使用 Anchor Box 的时候发现早期的网络不稳定，原因来自 $(x,y)$ 的预测。在 RPN 网络中，预测出 $t_x$ 和 $t_y$，$(x,y)$ 的计算为：</p>
<p>\begin{aligned}<br>x &amp;= (t_x * w_a) + x_a \\<br>y &amp;= (t_y * h_a) + y_a \\<br>\end{aligned}</p>
<p>由于 $t_x,t_y$ 的输出值不受限制，$(x,y)$ 能忽略 Anchor Box 的存在而而满天飞。所以网络增加了 sigmoid 函数限制 $t_x,t_y$ 的取值在 0 到 1 之间。具体一点，就是更改网络的输出为 $(t_x, t_y, t_w, t_h, t_o)$。由于 YOLO 的预测的尺寸、中心点的坐标都是相对图片的占比，比如一个目标位于图片的正中心，那么 $(x,y)=(0.5,0.5)$ 。如果当前格子相对图片的偏移是 $(c_x,c_y)$，Anchor Box 之前的宽和高是 $(p_w,p_h)$，那么预测的 bounding box 输出为：</p>
<p><img data-src="https://z3.ax1x.com/2021/08/26/hncDq1.png" alt></p>
<p>此外，置信度的输出替换为 $\sigma (t_o)$。</p>
<h3 id="Fine-Grained-Features"><a href="#Fine-Grained-Features" class="headerlink" title="Fine-Grained Features"></a>Fine-Grained Features</h3><p>为了提升小目标的检测精度，增加了 passthrough layer，用类似残差连接的方式传递前几层的特征到网络后面，堆叠高层特征和低层特征到不同通道上。</p>
<p><img data-src="https://z3.ax1x.com/2021/08/26/huFwqg.jpg" alt></p>
<h3 id="Multi-Scale-Training"><a href="#Multi-Scale-Training" class="headerlink" title="Multi-Scale Training"></a>Multi-Scale Training</h3><p>为了使模型适应不同的尺寸，不再单一的固定单张图片的大小。而是在网络迭代 10 个 batch 后，网络通过下采样来产生新的输入尺寸来读取图像。这样简单的操作，使得模型适应不同尺寸的图像。</p>
<h2 id="Faster"><a href="#Faster" class="headerlink" title="Faster"></a>Faster</h2><p>这里的快是为了保证准确率而尽可能快，所以未必会比 YOLO v1 快。作者提出了 DarkNet-19 （黑暗网络，好中二的名称）作为模型的 backbone，相比 VGG16 还是比较快的。之后：</p>
<ol>
<li>ImageNet 预训练 160 个 epoch，训练期间使用了随机裁剪、旋转、颜色变换等增强方式；</li>
<li>ImageNet 的尺寸是 224，为了适应高分辨率的图像，将输入层的尺寸调为 448，再次在 ImageNet 上训练 10 个 epoch；</li>
<li>更改网络结构，移除分类层添加检测头。对于 VOC 数据集而言，每个格子输出 5 组参数，也就是预先有 5 个 Anchor Box，每组参数是 20 个类别的得分 5 个盒子参数，所以每个盒子一共 125 个参数。而后 passthrough layer 预测小目标的输出。</li>
</ol>
<p>用检测数据进行训练时，训练了 160 个 epoch ，也使用了随机裁剪、旋转、颜色变换等增强方式。</p>
<h2 id="Stronger"><a href="#Stronger" class="headerlink" title="Stronger"></a>Stronger</h2><p>数据比模型更重要。那么有没有办法把 classification 数据集也利用起来？毕竟它们虽然没有提供坐标信息，但是也提供了类别信息，这部分类别信息能够显著拓展检测的类别数。当输入是 detection 数据时，按照正常的训练过程进行反向传播；当输入的是 classification 数据时，只计算和更新类别对应的 loss 和网络参数。</p>
<p>与 Faster 训练方式不同的是，将分类数据集和检测数据集进行联合训练。此时存在的问题是，分类数据集和检测数据集不是同一个数据集，如果检测数据集的标签是「狗」，那么分类数据集的标签很可能是「泰迪、田园犬」等，所以要合并这些标签。论文采用树的结构融合这些标签，得到具有 1396 个节点的树。针对每一个 anchor，预测出长度为 1396 的矢量，对该矢量按照层级关系进行同层级的 softmax 得到条件概率，根据全概率公式连乘即可得到所属类别的条件概率。</p>
<p><img data-src="https://z3.ax1x.com/2021/08/26/hnHwtJ.png" alt></p>
<p>经过这种弱监督式的融合数据集训练后，YOLO v2得以检测超过9000种类别，因此得名为YOLO 9000。</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><h2 id="模型部分"><a href="#模型部分" class="headerlink" title="模型部分"></a>模型部分</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 anchor 个 [类别，x, y, w, h] 这样的数据</span></span><br><span class="line">out_channels = cfg.num_anchors * (cfg.num_classes + <span class="number">5</span>)</span><br><span class="line">self.conv5 = net_utils.Conv2d(c4, out_channels, <span class="number">1</span>, <span class="number">1</span>, relu=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 x 和 y 激活处理，学习偏移量</span></span><br><span class="line">xy_pred = F.sigmoid(global_average_pool_reshaped[:, :, :, <span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 对 w 和 h 进行映射，用来乘以之前 anchor 的宽和高，得到预测的宽和高</span></span><br><span class="line">wh_pred = torch.exp(global_average_pool_reshaped[:, :, :, <span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">bbox_pred = torch.cat([xy_pred, wh_pred], <span class="number">3</span>)</span><br><span class="line"><span class="comment"># IOU 预测，YOLO V1 中是置信度</span></span><br><span class="line">iou_pred = F.sigmoid(global_average_pool_reshaped[:, :, :, <span class="number">4</span>:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类别预测，共 anchor 个类别</span></span><br><span class="line">score_pred = global_average_pool_reshaped[:, :, :, <span class="number">5</span>:].contiguous()</span><br><span class="line">prob_pred = F.softmax(score_pred.view(<span class="number">-1</span>, score_pred.size()[<span class="number">-1</span>])).view_as(score_pred)</span><br></pre></td></tr></table></figure>
<h2 id="数据与损失"><a href="#数据与损失" class="headerlink" title="数据与损失"></a>数据与损失</h2><p>对于加载数据部分，由于是多尺度训练，所以先要把图像 <code>resize</code> 到指定的输入尺寸，而后对标签中的宽度、中心点进行放缩，而后返回盒子、类别标签即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">batch[<span class="string">'images'</span>].append(images)</span><br><span class="line">batch[<span class="string">'gt_boxes'</span>].append(gt_boxes)</span><br><span class="line">batch[<span class="string">'gt_classes'</span>].append(classes)</span><br><span class="line">batch[<span class="string">'dontcare'</span>].append(dontcare)</span><br><span class="line">batch[<span class="string">'origin_im'</span>].append(origin_im)</span><br></pre></td></tr></table></figure>
<p>众所周知，对于卷积神经网络而言，输入图像的尺寸大小不同，输出的图像尺寸也不会一样。而网络超参数始终是固定的，适应多尺度训练是在损失函数中进行的，将标签数据的尺寸适配到网络输出的尺寸，这样就实现了多尺度训练。而后开始计算损失和反向传播，也就是<a href="https://github.com/longcw/yolo2-pytorch/blob/17056ca69f097a07884135d9031c53d4ef217a6a/darknet.py#L40" target="_blank" rel="noopener">这个函数</a>所做的。</p>
<p>之后就是损失函数部分了，重点是来看看是如何基于 <code>anchor box</code> 进行预测的，不过仍然可以确定的是，不管是分类损失，还是 IOU 损失或 bounding box 损失，使用的都是 MSE 损失函数。</p>
<p>对于标签数据而言，重要的是看懂<a href="https://github.com/uvipen/Yolo-v2-pytorch/blob/9589413b5dce0476eb9cccc41945cf30cf131b34/src/loss.py#L89-L145" target="_blank" rel="noopener">这里</a>的流程：</p>
<ol>
<li>遍历当前的 batch size，处理每一个 batch；</li>
<li>对预测输出和真实标签进行 IOU 计算，筛选出大于阈值的 bounding box 作为正样本，其余样本忽略；</li>
<li>筛选出与真实标签大小最为接近的 anchor box，基于 anchor box 计算和真实框的偏移量。anchor box 是预先设置的，anchor box 没有位置的概念，不是基于某个框生成的，anchor box 在整个训练期间是不变的。假设是第 2 个 anchor box 最接近。由于标签数据的维度和网络输出的维度相同，将标签数据的第 2 维填充为对应标签。这样，其余数据回被忽略。这一部分<a href="https://github.com/uvipen/Yolo-v2-pytorch/blob/9589413b5dce0476eb9cccc41945cf30cf131b34/src/loss.py#L89-L145" target="_blank" rel="noopener">代码</a>。</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这一部分代码还是耐心读吧……我也读了一晚上。也确实没发现网上有哪篇博客写的比代码还要详细清晰。读完了代码，我也知道了代码中如何实现多尺度训练和使用 anchor box。据说 YOLO v3/v4/v5 都是一些工程上的 trick 了。应该只会读那些具有创新点的代码，其他代码会选择性了略过了。</p>
]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
</search>
