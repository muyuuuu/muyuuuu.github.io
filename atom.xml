<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just for Life.</title>
  
  <subtitle>明月更几时</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muyuuuu.github.io/"/>
  <updated>2021-08-28T14:33:55.481Z</updated>
  <id>https://muyuuuu.github.io/</id>
  
  <author>
    <name>兰铃</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>YOLO V2，细读代码</title>
    <link href="https://muyuuuu.github.io/2021/08/28/yolo-v2/"/>
    <id>https://muyuuuu.github.io/2021/08/28/yolo-v2/</id>
    <published>2021-08-28T14:16:45.000Z</published>
    <updated>2021-08-28T14:33:55.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>还是老样子，不看代码永远不能称为学会了。况且 YOLO V2 有一些优化还是很常见的，如 Anchor Box 和多尺度训练。我之前也只是听说过这些名词，并不知道如何在程序中使用，索性直接读了程序了解一下，程序写的还是比较精彩的。另外：这是第一篇用 vim 写的博客。</p><a id="more"></a><h1 id="YOLO-v2"><a href="#YOLO-v2" class="headerlink" title="YOLO v2"></a>YOLO v2</h1><p>论文地址：<a href="https://arxiv.org/abs/1612.08242" target="_blank" rel="noopener">https://arxiv.org/abs/1612.08242</a><br>提供两个代码地址：第一个适合看模型、损失和多尺度训练，第二个适合看 anchor box 如何用到模型中，但是需要注意的是有 bug，但写的比第一个容易理解。</p><ol><li><a href="https://github.com/longcw/yolo2-pytorch" target="_blank" rel="noopener">https://github.com/longcw/yolo2-pytorch</a></li><li><a href="https://github.com/uvipen/Yolo-v2-pytorch/tree/master" target="_blank" rel="noopener">https://github.com/uvipen/Yolo-v2-pytorch/tree/master</a></li></ol><p>作者基于之前的 YOLO v1，提出了一些改进的策略，快速的同时准确率也大幅度提升。训练检测网络的同时，在 ImageNet 数据集上进行训练，提升了网络的分类能力。文章的一开始，作者指出了检测存在的几个问题：</p><ol><li>小目标检测能力受限</li><li>目标检测数据集的类别远远小于分类数据集的类别，且，不可能对检测数据集进行标注。所以能不能使用多个分类的数据集提升网络能识别的类别数呢？</li></ol><h2 id="Better"><a href="#Better" class="headerlink" title="Better"></a>Better</h2><p>作者进行了一些尝试来提升网络的性能：</p><ul><li>Batch Normalization，在卷积层后、激活层前加入 BN 层，大约提升了 2%。BN 层帮助网络实现正则化，能移除之前的 droupout层。</li><li>提高分辨率，将 v1 的 224 尺寸变为 448 尺寸，并先在 ImageNet 上训练 10 次，使得网络适应高分辨率，而后在检测任务中进行微调。</li><li>使用 Anchor Box 提升定位精准度，预测相对 anchor box 的坐标偏移，预测偏移相对直接预测坐标会简单些。这样提升了网络的召回率。此外，图片的 Ground Truth 一般都是正方形，1:2 的长方形或者 2:1 的长方形，预先准备几个几率比较大的 bounding box，再以它们为基准进行预测。</li><li>为了设置合适的 Anchor Box 的大小，对数据集的盒子进行 K-means 聚类，筛选出合适的 bounding box 大小。K-means 没有使用 欧拉距离，而是 $1-\text{IOU(box, center)}$，即盒子的 IOU 越大，距离越小。</li></ul><p>以上都是微小的改进，下面的三点改进是比较大的。</p><h3 id="Direct-location-prediction"><a href="#Direct-location-prediction" class="headerlink" title="Direct location prediction"></a>Direct location prediction</h3><p>作者使用 Anchor Box 的时候发现早期的网络不稳定，原因来自 $(x,y)$ 的预测。在 RPN 网络中，预测出 $t_x$ 和 $t_y$，$(x,y)$ 的计算为：</p><p>\begin{aligned}<br>x &amp;= (t_x * w_a) + x_a \\<br>y &amp;= (t_y * h_a) + y_a \\<br>\end{aligned}</p><p>由于 $t_x,t_y$ 的输出值不受限制，$(x,y)$ 能忽略 Anchor Box 的存在而而满天飞。所以网络增加了 sigmoid 函数限制 $t_x,t_y$ 的取值在 0 到 1 之间。具体一点，就是更改网络的输出为 $(t_x, t_y, t_w, t_h, t_o)$。由于 YOLO 的预测的尺寸、中心点的坐标都是相对图片的占比，比如一个目标位于图片的正中心，那么 $(x,y)=(0.5,0.5)$ 。如果当前格子相对图片的偏移是 $(c_x,c_y)$，Anchor Box 之前的宽和高是 $(p_w,p_h)$，那么预测的 bounding box 输出为：</p><p><img data-src="https://z3.ax1x.com/2021/08/26/hncDq1.png" alt></p><p>此外，置信度的输出替换为 $\sigma (t_o)$。</p><h3 id="Fine-Grained-Features"><a href="#Fine-Grained-Features" class="headerlink" title="Fine-Grained Features"></a>Fine-Grained Features</h3><p>为了提升小目标的检测精度，增加了 passthrough layer，用类似残差连接的方式传递前几层的特征到网络后面，堆叠高层特征和低层特征到不同通道上。</p><p><img data-src="https://z3.ax1x.com/2021/08/26/huFwqg.jpg" alt></p><h3 id="Multi-Scale-Training"><a href="#Multi-Scale-Training" class="headerlink" title="Multi-Scale Training"></a>Multi-Scale Training</h3><p>为了使模型适应不同的尺寸，不再单一的固定单张图片的大小。而是在网络迭代 10 个 batch 后，网络通过下采样来产生新的输入尺寸来读取图像。这样简单的操作，使得模型适应不同尺寸的图像。</p><h2 id="Faster"><a href="#Faster" class="headerlink" title="Faster"></a>Faster</h2><p>这里的快是为了保证准确率而尽可能快，所以未必会比 YOLO v1 快。作者提出了 DarkNet-19 （黑暗网络，好中二的名称）作为模型的 backbone，相比 VGG16 还是比较快的。之后：</p><ol><li>ImageNet 预训练 160 个 epoch，训练期间使用了随机裁剪、旋转、颜色变换等增强方式；</li><li>ImageNet 的尺寸是 224，为了适应高分辨率的图像，将输入层的尺寸调为 448，再次在 ImageNet 上训练 10 个 epoch；</li><li>更改网络结构，移除分类层添加检测头。对于 VOC 数据集而言，每个格子输出 5 组参数，也就是预先有 5 个 Anchor Box，每组参数是 20 个类别的得分 5 个盒子参数，所以每个盒子一共 125 个参数。而后 passthrough layer 预测小目标的输出。</li></ol><p>用检测数据进行训练时，训练了 160 个 epoch ，也使用了随机裁剪、旋转、颜色变换等增强方式。</p><h2 id="Stronger"><a href="#Stronger" class="headerlink" title="Stronger"></a>Stronger</h2><p>数据比模型更重要。那么有没有办法把 classification 数据集也利用起来？毕竟它们虽然没有提供坐标信息，但是也提供了类别信息，这部分类别信息能够显著拓展检测的类别数。当输入是 detection 数据时，按照正常的训练过程进行反向传播；当输入的是 classification 数据时，只计算和更新类别对应的 loss 和网络参数。</p><p>与 Faster 训练方式不同的是，将分类数据集和检测数据集进行联合训练。此时存在的问题是，分类数据集和检测数据集不是同一个数据集，如果检测数据集的标签是「狗」，那么分类数据集的标签很可能是「泰迪、田园犬」等，所以要合并这些标签。论文采用树的结构融合这些标签，得到具有 1396 个节点的树。针对每一个 anchor，预测出长度为 1396 的矢量，对该矢量按照层级关系进行同层级的 softmax 得到条件概率，根据全概率公式连乘即可得到所属类别的条件概率。</p><p><img data-src="https://z3.ax1x.com/2021/08/26/hnHwtJ.png" alt></p><p>经过这种弱监督式的融合数据集训练后，YOLO v2得以检测超过9000种类别，因此得名为YOLO 9000。</p><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><h2 id="模型部分"><a href="#模型部分" class="headerlink" title="模型部分"></a>模型部分</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 anchor 个 [类别，x, y, w, h] 这样的数据</span></span><br><span class="line">out_channels = cfg.num_anchors * (cfg.num_classes + <span class="number">5</span>)</span><br><span class="line">self.conv5 = net_utils.Conv2d(c4, out_channels, <span class="number">1</span>, <span class="number">1</span>, relu=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 x 和 y 激活处理，学习偏移量</span></span><br><span class="line">xy_pred = F.sigmoid(global_average_pool_reshaped[:, :, :, <span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 对 w 和 h 进行映射，用来乘以之前 anchor 的宽和高，得到预测的宽和高</span></span><br><span class="line">wh_pred = torch.exp(global_average_pool_reshaped[:, :, :, <span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">bbox_pred = torch.cat([xy_pred, wh_pred], <span class="number">3</span>)</span><br><span class="line"><span class="comment"># IOU 预测，YOLO V1 中是置信度</span></span><br><span class="line">iou_pred = F.sigmoid(global_average_pool_reshaped[:, :, :, <span class="number">4</span>:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类别预测，共 anchor 个类别</span></span><br><span class="line">score_pred = global_average_pool_reshaped[:, :, :, <span class="number">5</span>:].contiguous()</span><br><span class="line">prob_pred = F.softmax(score_pred.view(<span class="number">-1</span>, score_pred.size()[<span class="number">-1</span>])).view_as(score_pred)</span><br></pre></td></tr></table></figure><h2 id="数据与损失"><a href="#数据与损失" class="headerlink" title="数据与损失"></a>数据与损失</h2><p>对于加载数据部分，由于是多尺度训练，所以先要把图像 <code>resize</code> 到指定的输入尺寸，而后对标签中的宽度、中心点进行放缩，而后返回盒子、类别标签即可。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">batch[<span class="string">'images'</span>].append(images)</span><br><span class="line">batch[<span class="string">'gt_boxes'</span>].append(gt_boxes)</span><br><span class="line">batch[<span class="string">'gt_classes'</span>].append(classes)</span><br><span class="line">batch[<span class="string">'dontcare'</span>].append(dontcare)</span><br><span class="line">batch[<span class="string">'origin_im'</span>].append(origin_im)</span><br></pre></td></tr></table></figure><p>众所周知，对于卷积神经网络而言，输入图像的尺寸大小不同，输出的图像尺寸也不会一样。而网络超参数始终是固定的，适应多尺度训练是在损失函数中进行的，将标签数据的尺寸适配到网络输出的尺寸，这样就实现了多尺度训练。而后开始计算损失和反向传播，也就是<a href="https://github.com/longcw/yolo2-pytorch/blob/17056ca69f097a07884135d9031c53d4ef217a6a/darknet.py#L40" target="_blank" rel="noopener">这个函数</a>所做的。</p><p>之后就是损失函数部分了，重点是来看看是如何基于 <code>anchor box</code> 进行预测的，不过仍然可以确定的是，不管是分类损失，还是 IOU 损失或 bounding box 损失，使用的都是 MSE 损失函数。</p><p>对于标签数据而言，重要的是看懂<a href="https://github.com/uvipen/Yolo-v2-pytorch/blob/9589413b5dce0476eb9cccc41945cf30cf131b34/src/loss.py#L89-L145" target="_blank" rel="noopener">这里</a>的流程：</p><ol><li>遍历当前的 batch size，处理每一个 batch；</li><li>对预测输出和真实标签进行 IOU 计算，筛选出大于阈值的 bounding box 作为正样本，其余样本忽略；</li><li>筛选出与真实标签大小最为接近的 anchor box，基于 anchor box 计算和真实框的偏移量。anchor box 是预先设置的，anchor box 没有位置的概念，不是基于某个框生成的，anchor box 在整个训练期间是不变的。假设是第 2 个 anchor box 最接近。由于标签数据的维度和网络输出的维度相同，将标签数据的第 2 维填充为对应标签。这样，其余数据回被忽略。这一部分<a href="https://github.com/uvipen/Yolo-v2-pytorch/blob/9589413b5dce0476eb9cccc41945cf30cf131b34/src/loss.py#L89-L145" target="_blank" rel="noopener">代码</a>。</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这一部分代码还是耐心读吧……我也读了一晚上。也确实没发现网上有哪篇博客写的比代码还要详细清晰。读完了代码，我也知道了代码中如何实现多尺度训练和使用 anchor box。据说 YOLO v3/v4/v5 都是一些工程上的 trick 了。应该只会读那些具有创新点的代码，其他代码会选择性了略过了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还是老样子，不看代码永远不能称为学会了。况且 YOLO V2 有一些优化还是很常见的，如 Anchor Box 和多尺度训练。我之前也只是听说过这些名词，并不知道如何在程序中使用，索性直接读了程序了解一下，程序写的还是比较精彩的。另外：这是第一篇用 vim 写的博客。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>Vim 学习记录</title>
    <link href="https://muyuuuu.github.io/2021/08/28/vim-learn/"/>
    <id>https://muyuuuu.github.io/2021/08/28/vim-learn/</id>
    <published>2021-08-28T14:15:36.000Z</published>
    <updated>2021-08-30T03:19:06.952Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学习 vim 的时候曾经4进4出一直没学会，这次下定决心要学一下了，也不求一口吃个胖子，每天学习一点点。首先从基础操作开始练习，先不要配置插件，也不管高亮和编程。<del>IDE是人类退步的阶梯</del>，沃茨基说的。</p><p>这个是我参考的 vim 的学习笔记，感觉写的还是不错的：<a href="https://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">https://coolshell.cn/articles/5426.html</a></p><p>当然，这份文档不一定包含所有命令，只是教学的目的，遇到没有涵盖的命令自行查阅即可。</p><a id="more"></a><h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><p>我一点点的写vim，尝试着写点。</p><p>换行了。</p><pre><code>也能缩进。</code></pre><p>第一步直接安装 vim，而后新建一个文件，就叫 <code>vim-prac.md</code>，每次练习都打开这个文件，直接写入。我直接新建了一个博客，每次的练习都写入到这个博客。</p><p>首先要知道的，在 <code>normal</code> 模式下，万物都是功能键，比如 <code>hjkl</code> 是方向键，<code>h</code> 表示左，<code>j</code> 表示下，<code>k</code> 表示上，<code>l</code> 表示右。其实也容易记忆，位于两侧的 <code>hl</code> 表示左右，而后左下、右上这样记忆，即和 <code>h</code> 紧挨着的是下，和 <code>l</code> 紧挨着的是上。</p><ul><li>如果想要打字，按一下键盘上的 <code>i</code> 进入 <code>insert</code> 模式，而后开始随心所欲的打字，和编辑 txt 文件一样没啥区别，上面那些文字都是我刚入门就打出来的。</li><li>在写完之后，按键盘左上角的 <code>esc</code> 退出插入模式，而后输入 <code>:wq</code> 表示写入并退出，这样写好的文件就被保存了。冒号的意思是进入命令模式，<code>w</code> 是写入单词的首字符，<code>q</code> 是退出单词的首字符。</li></ul><p>那么再来看一下其他操作：</p><ul><li><code>x</code>，<code>normal</code> 模式下，表示删除光标后面的字符。既然删除了，是不是要撤销？那么撤销操作是 <code>u</code>，如果回退到 3 次修改之前，可以输入 <code>3u</code>。这个可以直接在界面下操作，也可以<code>:u</code>。如果发现撤销过头了，就需要恢复，此时的快捷键是 <code>ctrl+R</code>，或者 <code>:red</code>。</li><li><code>dd</code>，同样是在 <code>normal</code> 模式下，表示删除当前行，并复制到剪切板中，<code>p</code>，粘贴剪切板中的内容。</li></ul><p>现在差不多可以编辑基本的文本了，今天的内容学习到此结束。如果今后在面对不忙的、简单的、凭借目前 vim 技术可以解决的工作，可以尝试开始用 vim。</p><h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><p>在编辑文本的时候发现，光标的移动不是很便捷，每次都要狂按方向键才能到想要的位置。那么今天就来学习下便捷的光标移动与插入。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ul><li><code>a</code>，在光标后插入，假设一段序列是 <code>abcd</code>，光标位于 <code>a</code> 后面，在 <code>normal</code> 模式下，那么输入 <code>a</code> 后会移动到 <code>b</code> 的后面，而后开始插入；</li><li><code>o</code>，当前行后插入一个新行；</li><li><code>O</code>，当前行前插入一个新行；</li></ul><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ul><li><code>0</code>，移动到行头；</li><li><code>^</code>，当本行第一个不是空格、tab、回车、换行字符的位置，也就是一行开头的这些东西会被忽略；</li><li><code>$</code>，移动到本行的行尾；</li><li><code>g_</code>，到本行最后一个不是空格、tab、回车、换行字符的位置；</li><li><code>/pattern</code>，搜索 <code>pattern</code> 的字符串，如果有多个，按 <code>n</code> 到下一个。</li></ul><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>之前已经知道了 <code>p</code> 是粘贴，<code>dd</code> 是剪切当前行。如果不删除当前行直接复制呢？用的是 <code>yy</code>。</p><p>此外，有的时候还想不复制整行，只想复制一行中的某些文字。此时的命令是在 <code>normal</code> 模式下按 <code>v</code> 进入 <code>visual</code> 模式，而后移动光标（可以借助 <code>$</code> 等功能键）选中文本，按下 <code>y</code> 表示复制选中的文本。而后 <code>p</code> 表示在当前位置之后粘贴，即如果将一些内容复制到 <code>ABCDE</code> 的 <code>B</code> 后面，需要将光标放到 <code>A</code> 后面然后粘贴。</p><p>还有诸如 <code>yG</code> 复制到当前文件结束，<code>y20G</code> 复制到第 20 行等操作，用到的时候再来整理。</p><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><ul><li><code>:e path</code>，表示打开指定 path 的文件</li><li><code>:wq, :x, XX</code>，保存并退出，<code>:x</code> 仅在有改动时保存</li><li><code>:q!</code>，强制退出不保存，<code>:qa!</code> 强制退出正在编辑的文件，即使有更改</li></ul><p>今天的练习结束，淘到了一个键盘，回宿舍洗一洗。</p><h1 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h1><p>一时技痒，偷着做了两件事情，一个是 <code>vim</code> 的配置文件，一个是 <code>vim</code> 的插件。</p><p>大概昨天尝试了一下使用 <code>vim</code> 安装插件，不得不说真香。我选择的插件管理器是 <code>vim-plug</code>，记得配置 <code>git</code> 的 <code>ssh</code> 和 <code>https</code> 代理，否则下载不下来。先装了一个 <a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener"><code>vim-airline</code></a> 还不错。之后等时间长了，配置一些编程用的插件。</p><p>而后是 <code>vim</code> 的配置文件，用户自己的配置文件位于 <code>~/.vimrc</code>，系统的配置文件位于 <code>/etc/.vimrc</code>。而后可以网上查一查如何配置，比如显示行号、设置缩进、显示文件名等。我的 <code>vim</code> 配置放到了我的 github 上：<a href="https://github.com/muyuuuu/my-vim-config" target="_blank" rel="noopener">https://github.com/muyuuuu/my-vim-config</a> 。、</p><p>回到正题，今天额外学一些光标移动的操作，我也是使用了一段事件后才发现快速定位到某个位置真的是太有用了。</p><p>在配置文件中开启行号设置后，可以知道文件位于哪一行。在 <code>normal</code> 模式下，可以使用 <code>NG</code> 移动到第 <code>N</code> 行，<code>N</code> 是数字；<code>G</code> 是移动到最后一行。或者在 <code>command</code> 模式下，<code>:112</code> 会移动到 112 行。</p><p>之后再来看一下行内的移动：</p><ul><li><code>w</code> 到下一个单词的开头，<code>b</code> 移动到上一个单词的开头，<code>e</code> 到当前单词的结尾。</li><li><code>%</code> 匹配括号移动，包括 <code>([{</code>，把光标移动到括号上面，按 <code>%</code> 就可以吧光标移动到匹配的位置。</li><li>单词移动，<code>*</code>（下一个） 和 <code>#</code>（上一个），匹配光标当前所在的单词，移动到上一个单词和下一个单词。</li></ul><p>今天的学习到此结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习 vim 的时候曾经4进4出一直没学会，这次下定决心要学一下了，也不求一口吃个胖子，每天学习一点点。首先从基础操作开始练习，先不要配置插件，也不管高亮和编程。&lt;del&gt;IDE是人类退步的阶梯&lt;/del&gt;，沃茨基说的。&lt;/p&gt;
&lt;p&gt;这个是我参考的 vim 的学习笔记，感觉写的还是不错的：&lt;a href=&quot;https://coolshell.cn/articles/5426.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://coolshell.cn/articles/5426.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当然，这份文档不一定包含所有命令，只是教学的目的，遇到没有涵盖的命令自行查阅即可。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Vim" scheme="https://muyuuuu.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>YOLO目标检测从 V1 开始，细读代码</title>
    <link href="https://muyuuuu.github.io/2021/08/26/yolo-v1/"/>
    <id>https://muyuuuu.github.io/2021/08/26/yolo-v1/</id>
    <published>2021-08-26T11:06:48.000Z</published>
    <updated>2021-08-27T13:01:52.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>忙里偷闲，写几篇长文，从 YOLO 的 v1 到 v5。没想到时隔多年会回来重新看 YOLO 系列的东西，相比两阶段检测，YOLO 真的太快了，加上一些训练的 trick，mAP 也不会很低。网上看了好多教程不明所以，索性还是直接去读原论文了，读了原论文有些东西还是不理解，索性又去读了源程序。不过为了便于理解，有的地方不会按照论文顺序进行整理。少问问题，读论文产生的疑问在代码里都有解答，不看代码永远不能被称为学会了。</p><a id="more"></a><p>如果对本文有疑问或者想找男朋友，可以联系我，<a href="https://muyuuuu.github.io/about/">点击此处有我联系方式</a>。</p><h1 id="YOLO-v1"><a href="#YOLO-v1" class="headerlink" title="YOLO v1"></a>YOLO v1</h1><ul><li>论文地址：<a href="https://arxiv.org/abs/1506.02640" target="_blank" rel="noopener">https://arxiv.org/abs/1506.02640</a></li><li>pytorch 程序地址：<a href="https://github.com/motokimura/yolo_v1_pytorch" target="_blank" rel="noopener">https://github.com/motokimura/yolo_v1_pytorch</a></li></ul><p>YOLO v1 将目标检测定义为回归问题，直接读入全部图像，回归出边界框和分类概率。与同时期的 Faster RCNN 对比，算法快了不少，也没有 RPN 以及后处理，也避免里滑动窗口这样的暴力检测。所以能用到一些实时系统中，也是我花精力看这一些列论文的原因。</p><p>但是对于 v1 的 YOLO 存在一些缺陷，作者在论文中也进行了阐述：准确率低、定位不准尤其是小目标的定位。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>首先将图片分为 $S\times S$ 个网格，论文中 $S=7$，如果一个物体的中心落入这个格子中，那么这个格子负责预测这个目标。设每个格子负责预测 $B$ 个物体的盒子参数和置信度得分，盒子参数指明物体的位置，置信度表示盒子含有目标且预测准确的可信程度。即对于图片的每个格子，会输出 $B$ 个 $(x,y,w,h,c)$，论文中 $B=2$。</p><p>既然有了输出，那么就需要 label 进行损失计算。$(x,y,w,h,c)$ 是人工标注的数据，$c$ 初始化为 1。论文定义网络输出的置信度标签是一个分段函数，如果格子没有目标，置信度是 0；如果有目标，置信度是预测框和真实框的 IOU 值，公式描述为 $\text{Pr(Object)} * \text{IOU}_{\text{pred}}^\text{truth}$。</p><p>目标检测和分类是分不开的，为了达到分类的目的，每个格子也会输出 $C$ 个类别的概率，公式表述为 $\text{Pr(Class}_i|\text{Object})$，即格子里面得是个目标，才能计算分类的概率和损失。而每个格子输出一组<a href="https://github.com/motokimura/yolo_v1_pytorch/blob/master/detect.py#L203-L206" target="_blank" rel="noopener">预测</a>，即使输出了 $B$ 组数据，这就限制了网络的表达。</p><p>在测试阶段，类别置信度的分数就是分类概率和置信度相乘，即盒子中「有这个类别的概率」和「网络预测这个类别的概率」的乘积：</p><p>\begin{equation}<br>\text{Pr(Class}_i|\text{Object})*\text{Pr(Object)}*\text{IOU}_{\text{pred}}^\text{truth}=\text{Pr(Class}_i) * \text{IOU}_{\text{pred}}^\text{truth}<br>\end{equation}</p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p>这种东西还是代码清楚，只放了最关键的检测输出：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nn.Linear(<span class="number">4096</span>, S * S * (<span class="number">5</span> * B + C))</span><br><span class="line">nn.Sigmoid()</span><br><span class="line">x.view(<span class="number">-1</span>, S, S, <span class="number">5</span> * B + C)</span><br></pre></td></tr></table></figure><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>\begin{aligned}<br>{ } &amp; \lambda_{coord} \sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{I}_{ij}^{\text{obj}} [(x_i-\hat{x}_i)^2 + (y_i-\hat{y}_i)^2] \\<br>{ } &amp;+ \lambda_{coord} \sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{I}_{ij}^{\text{obj}} [(\sqrt{w_i}-\sqrt{\hat{w}_i})^2+(\sqrt{h_i}-\sqrt{\hat{h}_i})^2] \\<br>{ } &amp;+ \sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{I}_{ij}^{\text{obj}} (C_i - \hat{C}_i)^2 \\<br>{ } &amp;+ \lambda_{noobj} \sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{I}_{ij}^{\text{noobj}} (C_i - \hat{C}_i)^2 \\<br>{ } &amp;+ \sum_{i=0}^{S^2} \mathbb{I}_{ij}^{\text{obj}} \sum_{c\in classes} (p_i(c)-\hat{p}_i(c))^2<br>\end{aligned}</p><ul><li>$\lambda_{coord}$ 是前景的权重，$\mathbb{I}_{ij}^{\text{obj}}$ 是指示函数，取值只有 0 和 1</li><li>前两行表示 bound box 的损失</li><li>第三行是前景置信度的损失</li><li>第四行是背景置信度的损失</li><li>第五行是分类的损失</li></ul><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ol><li>每个网格只能检测一个类别和两个目标，类间竞争严重，网络表达受限，对于密集群体的检测性能会下降；</li><li>定位不准确，因为网络直接预测 bounding box 的坐标，一开始的偏移可能会很大，导致定位不准确，读完代码能深刻理解这里的缺陷；</li><li>对于检测问题而言，大多情况背景居多，前景居少，也就是样本不均衡。YOLO v1 的损失中，并没有计算背景的 bound box 损失，只计算了前景的，YOLO v1 回避了样本不均衡的问题，这会影响网络的稳定性与背景的识别。</li></ol><h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><p>「如果对算法有疑问，就去读代码吧」这一经验帮助我理解了很多算法的困惑之处，不仅仅是 YOLO。如果要看懂一个深度学习的算法，核心有三要素，首先是网络模型，理解输入、输出和结构；其次是数据与损失，理解加载什么格式的数据，理解网络预测数据和加载的数据如何计算损失，所以这俩常常放在一起；最后是细枝末节，即数据增强、学习率策略、整体训练流程等。所以接下来整理网络模型和损失。<del>训练策略那些不是 YOLO 的重点。</del></p><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>我们知道网络的输出是 <code>x.view(-1, S, S, 5 * B + C)</code> 这种类型的格式，这是预测数据，即 $S \times S $ 组 $5 \times B + C$ 这样的数据，$C$ 是类别数量。那么可想而知，在训练阶段，同样需要提供同等尺寸大小的标签数据。</p><h2 id="数据与损失"><a href="#数据与损失" class="headerlink" title="数据与损失"></a>数据与损失</h2><p>YOLO 处理目标时，使用的是目标中心点的坐标相对图像大小的占比。如果一张图像的大小是 224 X 224，目标中心点位于 112 X 112，那么中心点的坐标是 $(0.5,0.5)$。这有两点好处：</p><ol><li>如果一个图像的尺寸是 1920 X 1080，目标中心点的坐标是 1000 X 1000，直接输出 1000 对于网络来说难以把控，会造成梯度爆炸的现象。而占比只需要输出 [0,1] 之间的小数，不会导致梯度爆炸。</li><li>方便图像的标准化处理。网络常常使用多个 batch 进行训练，每个 batch 的数据要求大小统一，对于不同尺寸的图像应选择 <code>resize</code>。如果直接用坐标，<code>resize</code> 后会导致坐标错位，而如果用占比，位于之前图像 (0.5, 0.5) 处的点在 <code>resize</code> 后的坐标仍然是 (0.5, 0.5)。</li></ol><p>由于 YOLO 最初设计的方案是：物体中心落到哪个格子，就由这个格子预测这个目标，这一观点需要仔细阅读代码才能理解。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和网络输出同等大小的标签</span></span><br><span class="line">target = torch.zeros(S, S, N)</span><br><span class="line"><span class="comment"># S=7，表示每个格子的占比</span></span><br><span class="line">cell_size = <span class="number">1.0</span> / float(S)</span><br><span class="line"><span class="comment"># 计算宽度和高度</span></span><br><span class="line">boxes_wh = boxes[:, <span class="number">2</span>:] - boxes[:, :<span class="number">2</span>]</span><br><span class="line"><span class="comment"># x,y 的中心点坐标，此时已经除以图像大小</span></span><br><span class="line">boxes_xy = (boxes[:, <span class="number">2</span>:] + boxes[:, :<span class="number">2</span>]) / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于 b 和 batch 的盒子进行处理</span></span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> range(boxes.size(<span class="number">0</span>)):</span><br><span class="line">    xy, wh, label = boxes_xy[b], boxes_wh[b], int(labels[b])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算中心点位于哪个格子</span></span><br><span class="line">    ij = (xy / cell_size).ceil() - <span class="number">1.0</span></span><br><span class="line">    <span class="comment"># 取出 i j，用于 SXS 的填充</span></span><br><span class="line">    i, j = int(ij[<span class="number">0</span>]), int(ij[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 格子左上角的坐标</span></span><br><span class="line">    x0y0 = ij * cell_size</span><br><span class="line">    <span class="comment"># 相对格子左上角的坐标</span></span><br><span class="line">    <span class="comment"># 除以 cell_size 没啥用，这人代码写的有问题，后面损失计算的时候又乘了回来</span></span><br><span class="line">    xy_normalized = (xy - x0y0) / cell_size</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始填充</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(B):</span><br><span class="line">        s = <span class="number">5</span> * k</span><br><span class="line">        target[j, i, s  :s+<span class="number">2</span>] = xy_normalized <span class="comment"># 坐标</span></span><br><span class="line">        target[j, i, s+<span class="number">2</span>:s+<span class="number">4</span>] = wh            <span class="comment"># 大小</span></span><br><span class="line">        target[j, i, s+<span class="number">4</span>    ] = <span class="number">1.0</span>           <span class="comment"># 置信度</span></span><br><span class="line">    target[j, i, <span class="number">5</span>*B + label] = <span class="number">1.0</span>           <span class="comment"># 类别标签</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> target</span><br></pre></td></tr></table></figure><p>在损失计算阶段，代码真的太长了不便展示，这里只记录核心要素：</p><ol><li>对于有目标计算损失，无目标忽略这一点，是通过对真实标签进行掩码处理实现的，只取出真实标签中置信度为 1 的标签记录维度，并在 predict 中取出同维度的数据就算损失，其余数据忽略。假设这一步保留了 $X$ 个盒子。</li><li>对于 $X$ 个盒子中的 $B$ 组数据继续处理，对于每组数据而言，选择和真实标签 IOU 最大的盒子计算损失，其余盒子忽略，也就是没有正负样本的概念。这里需要注意，如果网络初期计算到 IOU 为 0，那么默认第一个盒子和真实标签进行损失计算。</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我已经正负样本划分、格子、bounding box、anchor box 的概念已经搞混了，论文里不会写这太细节的东西，不然我也不会来读代码。毕竟整理理论知识太简单了，也容易自欺欺人，并不清楚网络的流程。所以 YOLO v2, v3, v4, v5 和 x 的内容等下几篇博客了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/183261974" target="_blank" rel="noopener">你一定从未看过如此通俗易懂的YOLO系列(从v1到v5)模型解读</a></li><li><a href="https://fengweiustc.github.io/paper-reading/2020/06/17/yolo/" target="_blank" rel="noopener">YOLO v1/v2/v3/v4</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;忙里偷闲，写几篇长文，从 YOLO 的 v1 到 v5。没想到时隔多年会回来重新看 YOLO 系列的东西，相比两阶段检测，YOLO 真的太快了，加上一些训练的 trick，mAP 也不会很低。网上看了好多教程不明所以，索性还是直接去读原论文了，读了原论文有些东西还是不理解，索性又去读了源程序。不过为了便于理解，有的地方不会按照论文顺序进行整理。少问问题，读论文产生的疑问在代码里都有解答，不看代码永远不能被称为学会了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>C++ 多线程</title>
    <link href="https://muyuuuu.github.io/2021/08/12/cpp-thread-safe/"/>
    <id>https://muyuuuu.github.io/2021/08/12/cpp-thread-safe/</id>
    <published>2021-08-12T10:05:47.000Z</published>
    <updated>2021-08-13T16:29:10.787Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>rush 项目的时候，有些地方可以并行化，可以借助 C++ 的多线程来加速程序的执行。多线程的基本概念在一年前整过了，这里只是来看一下 C++ 的多线程该怎么写，顺便查漏补缺。</p><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>在多线程进入 C++ 标准之前，人们使用 C++ 编写多线程的程序，只能依赖操作系统提供的 API。比如在 Linux 环境下就只能使用 pthread 库实现多线程，因此也一直被诟病。但有了 C++11 的 <code>std::thread</code> 以后，可以通过标准库在语言层面编写多线程程序了，直接的好处就是多线程程序的跨平台移植提供了便利。但是在编译的时候需要注意链接平台相关的线程库，如 <code>g++ demo.cpp -lpthread -o test.o</code>。</p><h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::thread t&#123;show_info, s&#125;;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上述程序为例，来详细的剖析一下多线程期间到底发生了什么：</p><ol><li>首先引入头文件 <code>thread</code>，在这个头文件中，C++ 11 提供了创建、管理线程的类和方法；</li><li>使用 <code>std::thread</code> 创建线程，并通过列表初始化传入函数名作为构造函数的参数。传入的函数会作为子线程的入口函数，也就是说，当子线程准备就绪之后，就会开始执行这个入口函数。由于函数名表示函数的地址，子线程可以快捷的找到函数地址进而执行。<blockquote><p>我们知道，每个程序都有一个入口。当程序被装载到内存，处于系统态完成一些初始化的工作之后，控制权就转交给程序入口，并以此为标志进入用户态，这是一个程序的开始。同样地，线程也需要有「开始」的地方。作为线程入口的函数，就是线程函数，也就是例子中的 show_info。线程函数必须在启动线程之前，就准备好，否则线程去执行什么呢？并在线程初始化后立即执行。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p></blockquote></li><li>当线程函数返回时，线程也就随之终止了，上述程序中使用 <code>join</code> 衔接方法确保主线程在子线程退出之后才退出，因为主线程会阻塞住，直到该子线程退出为止。如果程序员没有显式的说明线程结束该如何处理，那么线程对象在被销毁时调用的析构函数中，会调用 <code>std::terminate()</code> 函数，销毁当前对象。如果程序写多了，应该不至于犯主线程退出子线程还没结束的低级错误。</li></ol><h2 id="detach"><a href="#detach" class="headerlink" title="detach"></a>detach</h2><p>前面说过线程的 <code>join</code> 会阻塞调用线程，可以使用 <code>detach</code> 来避免，但一定要做好控制：避免主线程退出子线程还没结束的低级错误。一个 cppreference 官网的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">independentThread</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Starting concurrent thread.\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exiting concurrent thread.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCaller</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Starting thread caller.\n"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(independentThread)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exiting thread caller.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    threadCaller();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Starting thread caller.</span></span><br><span class="line"><span class="comment">// Starting concurrent thread.</span></span><br><span class="line"><span class="comment">// Exiting thread caller.</span></span><br><span class="line"><span class="comment">// Exiting concurrent thread.</span></span><br></pre></td></tr></table></figure><h1 id="可调用类型"><a href="#可调用类型" class="headerlink" title="可调用类型"></a>可调用类型</h1><p>在创建线程对象时，传入的参数不仅是可被调用执行的函数，类的对象如果能被调用，也是可以作为线程对象的参数，用于构造函数初始化线程对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">()</span></span>=<span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> a)</span> : cnt</span>&#123;a&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;cnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread t&#123;Task&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为要调用对象，所以重载了 <code>()</code> 运算符，不然线程不知道去哪个地址执行。此外，构造函数传入的是一个类类型的对象，所以对象会被拷贝到线程的存储空间，而后再开始执行。因此，<strong>类必须做好足够的拷贝控制</strong>，不然将出现难以调试的 bug，<del>我大概只知道深浅拷贝，等有时间了去看下移动语义</del>。</p><p>当然，不重载 <code>()</code> 运算符，选择类中的函数执行也是可以的，不过需要注意以下两点：</p><ul><li>必须显式地使用函数指针，作为 <code>std::thread</code> 构造函数的第一个参数；知道执行哪个函数。</li><li>非静态成员函数的第一个参数，实际上是类实例的指针。所以在创建线程时，需要显式地填入这个参数；知道执行的函数在哪个对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">()</span></span>=<span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> t)</span> : a</span>&#123;t&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::thread t&#123;&amp;A::show_info, &amp;a&#125;;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他要注意的数据类型"><a href="#其他要注意的数据类型" class="headerlink" title="其他要注意的数据类型"></a>其他要注意的数据类型</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>如果子线程函数的参数是引用类型，也需要格外注意。由于子线程的数据是主线程的拷贝，因此子线程函数得到的拷贝实际是「线程存储空间中的拷贝的引用」，并不是主线程中的变量，应该使用 <code>std::ref()</code> 来生成正确的引用绑定，否则会报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::thread t&#123;show_info, <span class="built_in">std</span>::ref(s)&#125;;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>右值引用和移动语义等我后期开坑了。</del></p><h1 id="锁与线程安全"><a href="#锁与线程安全" class="headerlink" title="锁与线程安全"></a>锁与线程安全</h1><p>众所周知，<del>写代码的人都学过操作系统，学过操作系统都知道线程同步</del>。线程同步一般有三种机制：互斥量、信号量和条件变量，这三者到底什么已经在<a href="https://muyuuuu.github.io/2021/02/19/process-synchronization/">这篇博客</a>中详细的描写过了，所以不再多说。不过当时是用 C 语言写的，现在来了解下 C++ 的写法。</p><h2 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123;</span><br><span class="line">        mtx.lock();</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1</span>));</span><br><span class="line">        counter++;</span><br><span class="line">        mtx.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(increase, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(increase, <span class="number">100</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"counter:"</span> &lt;&lt; counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>引入 <code>mutex</code> 头文件，创建 <code>std::mutex</code> 对象 <code>mtx</code></li><li>对于 <code>mtx</code> 对象，任意时刻最多允许一个线程对其进行上锁，上锁后操作变量，就不会出错</li><li><code>mtx.try_lock()</code> 是尝试上锁，如果上锁不成功，当前线程不阻塞</li><li>在用完锁之后一定记得释放锁，否则会发生死锁现象</li></ol><h2 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h2><p>为了避免 <code>mutex</code> 忘记解锁等情况，可以使用 <code>std::lock_guard</code>，<a href="https://en.cppreference.com/w/cpp/thread/lock_guard" target="_blank" rel="noopener">这个类</a>只有构造函数和析构函数，搭配 <code>mutex</code> 使用，在创建这个对象时传入锁，调用锁的 <code>lock</code> 函数；变量销毁会调用析构函数，此时调用锁的 <code>unlock</code> 函数，这也就是传说中的 RAII 机制 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p><p>如下述程序 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> ，避免一个线程意外退出没来得及释放锁，导致另一个线程无法获取资源而死锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase_proxy</span><span class="params">(<span class="keyword">int</span> time, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"throw excption...."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前线程休眠1毫秒</span></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1</span>));</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> time, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        increase_proxy(time, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt; <span class="string">", "</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(increase, <span class="number">100</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(increase, <span class="number">100</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"counter:"</span> &lt;&lt; counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lock-guard-与-adopt-lock"><a href="#lock-guard-与-adopt-lock" class="headerlink" title="lock_guard 与 adopt_lock"></a>lock_guard 与 adopt_lock</h2><p>还有一种为了防止死锁的方式是一次性申请所有临界资源的互斥量，只有申请到才能进行之后的操作，而 <code>std::lock</code> 提供了这种实现 <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>。此外，为了防止没有锁定或提前释放互斥量导致危险，可以使用 <code>lock_guard</code> 并传入 <code>std::adopt_lock</code>，前者保证当变量销毁时释放互斥量，后者保证线程已经上锁成功时不再调用 <code>lock()</code> 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bank_account</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bank_account</span><span class="params">(<span class="keyword">int</span> balance)</span> : <span class="title">balance</span><span class="params">(balance)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> balance;</span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(bank_account &amp;from, bank_account &amp;to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// avoid deadlock in case of self transfer</span></span><br><span class="line">    <span class="keyword">if</span>(&amp;from == &amp;to) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    <span class="comment">// lock both mutexes without deadlock</span></span><br><span class="line">    <span class="built_in">std</span>::lock(from.m, to.m);</span><br><span class="line">    <span class="comment">// make sure both already-locked mutexes are unlocked at the end of scope</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock1</span><span class="params">(from.m, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock2</span><span class="params">(to.m, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    from.balance -= amount;</span><br><span class="line">    to.balance += amount;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">bank_account <span class="title">my_account</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">bank_account <span class="title">your_account</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(transfer, <span class="built_in">std</span>::ref(my_account), <span class="built_in">std</span>::ref(your_account), <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(transfer, <span class="built_in">std</span>::ref(your_account), <span class="built_in">std</span>::ref(my_account), <span class="number">5</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>adopt_lock</code> 之外，还有 <code>try_to_lock</code>，<code>defer_lock</code>，他们都有不同的应用场景，还可以配合使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_block</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//unique_lock有多组构造函数, 这里std::defer_lock不设置锁状态</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">my_lock</span> <span class="params">(mtx, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">//尝试加锁, 如果加锁成功则执行</span></span><br><span class="line">    <span class="comment">//(适合定时执行一个job的场景, 一个线程执行就可以, 可以用更新时间戳辅助)</span></span><br><span class="line">    <span class="keyword">if</span>(my_lock.try_lock()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他锁的内容实在是太多了，还有时间锁、递归锁、<code>lock_unique</code>，读写锁的 <code>shared_lock</code> 等等，等哪天用到在整理这些，这里只整理最简单的，详情可以参考 cppreference <sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>。</p><h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p>如果按照之前 <code>C</code> 语言的写法，条件变量需要注意的是 <code>wait</code> 那边的判断一定是 <code>while</code> 循环。<a href="https://blog.7rule.com/2018/11/24/thread.html" target="_blank" rel="noopener"><code>C</code> 语言风格的代码</a>。</p><p>当然，如果按照 <code>C++</code> 的写法，我们发现条件变量的 <code>wait</code> 方法有<a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait" target="_blank" rel="noopener">两个参数</a>，第二个参数用于接受一个变量，如果继续等待，那么那个变量的取值是 <code>false</code>，如果不需等待，那么那个变量返回 <code>true</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex g_mutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable g_cond;</span><br><span class="line"><span class="keyword">int</span>  g_i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> g_running = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>; </span><br><span class="line">      ++g_i;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"plus g_i by func thread "</span> </span><br><span class="line">                &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待被唤醒</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"wait for exit"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  g_cond.wait(lock, [=] &#123;<span class="keyword">return</span> g_running;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func thread exit"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(ThreadFunc, n)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">      ++g_i;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"plus g_i by main thread "</span> </span><br><span class="line">                &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 唤醒</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">    g_running = <span class="literal">true</span>;</span><br><span class="line">    g_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  t1.join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g_i = "</span> &lt;&lt; g_i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">plus g_i by func thread 140476623930944</span><br><span class="line">plus g_i by func thread 140476623930944</span><br><span class="line">wait for exit // 表示子线程等待唤醒</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">func thread exit // 子线程被唤醒</span><br><span class="line">g_i = 200</span><br></pre></td></tr></table></figure><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>因为一开始我也不知道该怎么去写信号量，所以打开了万能的搜索引擎，看到了关于 C++ 不支持信号量这样的东西 <sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>。如果想实现信号量，可以通过互斥量和条件变量来实现。而关于信号量和互斥量的区别，在<a href="https://muyuuuu.github.io/2021/02/19/process-synchronization/">这篇文章</a>中已经写明了。那么来实现一个信号量的类 <sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::mutex mutex_;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable cv_;</span><br><span class="line">  <span class="keyword">int</span> count_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> count = <span class="number">0</span>)</span> : <span class="title">count_</span><span class="params">(count)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    ++count_;</span><br><span class="line">    cv_.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="comment">// 第二个参数，如果返回 false 继续等待, 如果为 true，可以继续申请资源</span></span><br><span class="line">    cv_.wait(lock, [=] &#123; <span class="keyword">return</span> count_ &gt; <span class="number">0</span>; &#125;);</span><br><span class="line">    --count_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">FormatTimeNow</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">time_t</span> now_c = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(now);</span><br><span class="line">  <span class="built_in">std</span>::tm* now_tm = <span class="built_in">std</span>::localtime(&amp;now_c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">std</span>::strftime(buf, <span class="keyword">sizeof</span>(buf), format, now_tm);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Semaphore <span class="title">g_semaphore</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// 防止同时抢占输出资源</span></span><br><span class="line"><span class="built_in">std</span>::mutex g_io_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  g_semaphore.Wait();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::thread::id thread_id = <span class="built_in">std</span>::this_thread::get_id();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> now = FormatTimeNow(<span class="string">"%H:%M:%S"</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_io_mutex)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; thread_id &lt;&lt; <span class="string">": wait succeeded"</span> </span><br><span class="line">              &lt;&lt; <span class="string">" ("</span> &lt;&lt; now &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Sleep 1 second to simulate data processing.</span></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  g_semaphore.Signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    v.emplace_back(&amp;Worker);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::thread&amp; t : v) &#123;</span><br><span class="line">    t.join();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>信号量的值为 3，表示能同时申请 3 个资源</li><li>当一个线程申请资源后，即执行了 <code>wait</code> 操作，<code>count_</code> 取值递减，表示有一个资源被占用</li><li>当 <code>count_</code> 取值小于 0 时，调用条件变量的 <code>wait</code> 方法，当先线程等待有了资源被唤醒</li><li>当一个线程释放资源后，执行了 <code>signal</code> 操作，<code>count_</code> 取值递增，表示有一个资源被释放，并执行 <code>notify_one</code> 方法，即唤醒一个等待的线程</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://liam.page/2017/05/16/first-step-on-multithread-programming-of-cxx/" target="_blank" rel="noopener">线程函数</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zhuanlan.zhihu.com/p/34660259" target="_blank" rel="noopener">RAII机制</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zhuanlan.zhihu.com/p/91062516" target="_blank" rel="noopener">线程异常退出导致死锁</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://en.cppreference.com/w/cpp/thread/lock" target="_blank" rel="noopener">std::lock申请多个互斥量</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;"><a href="https://en.cppreference.com/w/cpp/thread/lock_tag_t" target="_blank" rel="noopener">cppreference_lock</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.boost.org/doc/libs/1_31_0/libs/thread/doc/faq.html" target="_blank" rel="noopener">C++不支持信号量</a></span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;"><a href="https://segmentfault.com/a/1190000006818772" target="_blank" rel="noopener">信号量实现</a></span><a href="#fnref:7" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;rush 项目的时候，有些地方可以并行化，可以借助 C++ 的多线程来加速程序的执行。多线程的基本概念在一年前整过了，这里只是来看一下 C++ 的多线程该怎么写，顺便查漏补缺。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
      <category term="OS" scheme="https://muyuuuu.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>花样繁多的GAN</title>
    <link href="https://muyuuuu.github.io/2021/08/11/GAN-basic/"/>
    <id>https://muyuuuu.github.io/2021/08/11/GAN-basic/</id>
    <published>2021-08-11T01:39:51.000Z</published>
    <updated>2021-08-13T16:35:18.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在做对抗样本的时候，我发现对抗防御和 GAN 在某种程度上很像：</p><ul><li>对抗防御：内部生成对抗样本攻击分类器，分类器更新参数防御攻击；</li><li>GAN：生成器 $G$ 生成样本欺骗判别器，判别器更新防御 $G$ 的欺骗。</li></ul><p>所以说，这俩在某种程度上真的很像，所以决定整理一下 GAN 的知识，开拓一下思路，视频内容来自<a href="https://www.bilibili.com/video/BV1JE411g7XF?from=search&amp;seid=17206901754423397958" target="_blank" rel="noopener">这里</a>。警告：里面有大量数学公式的推导，而我就不一样了，<del>不仅有公式推导</del>还有代码。</p><a id="more"></a><h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>我发现我在看论文或者别人的博客的时候，经常发现数据分布、概率分布等，然而时间长了竟然不知道所谓的分布是什么，这里来提前说一下：</p><ul><li>数据分布：可以理解为字面意思，数据的分布。比如一个数据集：<code>1,2,3</code>，只有三条数据，可能是 1，可能是 2，可能是 3，这就是数据的分布；</li><li>概率分布：可以理解为字面意思，概率的分布。比如一枚硬币，正面朝上的概率是 50%，反面朝上的概率也是 50%，这就是概率分布，类似的，正态分布、泊松分布等都是概率分布。</li></ul><h1 id="朴素-GAN"><a href="#朴素-GAN" class="headerlink" title="朴素 GAN"></a>朴素 GAN</h1><p><img data-src="https://z3.ax1x.com/2021/08/11/fNaeNF.png" alt></p><p>以图像为例，GAN 的生成器 $G$ 输入为某种随机分布的数据，输出为一张图像；而判别器 $D$ 的输入是一张图像，输出是一个数字，数字越大表示当前图像的质量越高，我们设置 $G$ 生成的图片是假的。两者相互博弈，$G$ 企图去欺骗 $D$，$D$ 防止来自 $G$ 的欺骗。</p><ul><li>$G$ 只适合生成，不适合做判别，因为 $G$ 的主要任务是生成图像。如果 $G$ 要判别图像的好坏，如何定义生成图像的好坏？生成图像的每个像素点的位置、偏移、颜色、旋转，以及像素点之间的联系将会很复杂，模型将会很复杂，所以由 $D$ 来做判别；</li><li>$D$ 只适合判别，不适合生成。$D$ 的判别是宏观角度的判断当前图像好不好，并不会纠结于某个像素的颜色、旋转、偏移的好坏。如果 $D$ 要做生成，那么需要遍历所有数据 $x$，来看看哪个数据使得网络的输出得分最高。这样虽然可以生成，但枚举所有数据是不可能的操作。</li></ul><p>或者说，这是一种<strong>另类的小样本</strong>，网络不可能见过所有生成的数据，但是要求 $D$ 能判断没见过的数据是好是坏。此外，<strong>足够强的 $D$ 才能迫使 $G$ 生成的图片足够逼真，足够好的 $G$ 才会使 $D$ 的判别越来越准。</strong> 在接下来的实验中将见识到这一点。</p><p><img data-src="https://z3.ax1x.com/2021/08/11/fN64Kg.png" alt></p><p>如上图所示：横坐标为 $G$ 和 $D$ 的演化过程，纵坐标表示概率分布，红色曲线表示 $G$，红色的点表示 $G$ 生成的数据，绿色的线表示 $D$,绿色的点表示真实数据。</p><ol><li>首先，图的最左侧，$G$ 生成的数据和真是数据不符，那么判别器抑制 $G$ 把数据生成到其他分布，并希望 $G$ 生成的数据分布和真实数据的分布较为接近；</li><li>其次，图的中间，因为 $G$ 的目的是无限度找 $D$ 的漏洞，虽然相比左图，生成数据的分布和真实数据的分布接近了，但是把更多的数据生成到了另外的分布，这也是不行的；</li><li>经过多次的博弈，最终达到右侧图的效果。</li></ol><h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><h3 id="G-的目标"><a href="#G-的目标" class="headerlink" title="$G$ 的目标"></a>$G$ 的目标</h3><p>我们的目标可以用公式表述为：通过 $G$，寻找数据 $x$ 的分布 $P_G(x)$，但是目前只有数据 $x$，也就是知道近似的 $P(x)$。可以通过极大似然估计来求解问题，使 $P_G(x)$ 逐渐逼近 $P(x)$，即在 $P(x)$ 中采 $m$ 个样本，使得 $\prod_{i=1}^mP_G(x_i;\theta)$ 的概率最大，逐步采样与迭代求出模型的参数 $\theta$。</p><p>\begin{aligned}<br>\theta &amp;= \arg \max_\theta \prod_{i=1}^mP_G(x_i;\theta) \\<br>       &amp;\Leftrightarrow \arg \max_\theta \log \prod_{i=1}^mP_G(x_i;\theta) \\<br>       &amp;= \arg \max_\theta \sum_{i=1}^m \log P_G(x_i;\theta) \\<br>       &amp;\Leftrightarrow \arg \max_\theta \mathbb{E}_{x\sim p(x)} \bigl[ \log P_G(x;\theta) \bigr] \\<br>       &amp;\Leftrightarrow \arg \max_\theta \int_x p(x) \log P_G(x;\theta) dx - \int_x p(x) \log P(x) dx \\<br>       &amp;= \arg \min_\theta KL(P(x) || P_G(x;\theta))<br>\end{aligned}</p><p>也就是说，生成模型的求出的 $P_G(x;\theta)$ 最好情况就是与真是数据的分布 $P(x)$ 的 $KL$ 散度距离最小。当然你也可以用其他距离，详情可以参考 f-GAN <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 这篇论文，不过究其到底，都可以描述为寻找一个 $P_G(x;\theta)$，使其生成的数据分布和 $P(x)$ 最为接近， $G^\star=\arg\min_G D(P_G(x;\theta), P(x))$。</p><p>当然在模型参数过多的情况下，极大似然估计求解困难，可以使用神经网络的反向传播，来求解出模型的参数。</p><h3 id="D-的目标"><a href="#D-的目标" class="headerlink" title="$D$ 的目标"></a>$D$ 的目标</h3><p>对于 $D$ 而言，其目标是期望真实数据的评分很高，$G$ 生成数据的评分很低，以此来鼓励 $G$ 生成更加逼真的数据达到内卷的目的。那么 $D$ 的目标可以描述为：</p><p>\begin{equation}\label{D}<br>\max \mathbb{E}_{x\sim P(x)} \bigl[ \log D(x) \bigr] + \mathbb{E}_{x\sim P_G(x;\theta)} \bigl[ \log(1-D(x)) \bigr]<br>\end{equation}</p><p>此时固定 $G$，训练 $D$，式 $\eqref{D}$ 继续推导：</p><p>\begin{aligned}<br>\eqref{D} &amp;= \int_x P(x) \log (D(x)) dx+ \int_x P_G(x) \log (1 - D(x)) dx \\<br>&amp;= \int_x P(x) \log (D(x)) + P_G(x) \log (1 - D(x)) dx\\<br>\end{aligned}</p><p>为了使积分最大，可以等价转换为使积分内部的元素取值最大，即对于以下公式求对 $D(x)$ 微分，微分等于0的时候，取得极值，且下述公式是极大值：</p><p>\begin{equation}<br>f(D(x)) = P(x) \log (D(x)) + P_G(x) \log (1 - D(x))<br>\end{equation}</p><p>此时求出的 $D(x)$：</p><p>\begin{equation}<br>D(x) = \frac{P(x)}{P(x)+P_G(x)}<br>\end{equation}</p><p>把 $D(x)$ 带回式 $\eqref{D}$ ：</p><p>\begin{aligned}<br>\eqref{D} &amp;= \mathbb{E}_{x\sim P(x)} \bigl[ \log \frac{P(x)}{P(x)+P_G(x)} \bigr] + \mathbb{E}_{x\sim P_G(x)} \bigl[ \log \frac{P_G(x)}{P(x)+P_G(x)} \bigr] \\<br>&amp;= \int_x P(x)\log \frac{P(x)}{P(x)+P_G(x)} dx + \int_x P_G(x)\log \frac{P_G(x)}{P(x)+P_G(x)} dx \\<br>&amp;= -2\log 2 + KL(P(x) || \frac{P(x) + P_G(x)}{2}) + KL(P_G(x) || \frac{P(x) + P_G(x)}{2}) \\<br>&amp;= -2\log 2 + 2 JS(P(x) || P_G(x))<br>\end{aligned}</p><p>而 JS 散度的取值范围是 $[0, \log2]$，因此 式 $\eqref{D}$ 的最大值为 0。而这里的代码实现可以使用 <code>torch.BCE</code>，但要按照负梯度进行反向传播，所以损失那里直接加了负数，因此代码的损失是正数不要感到意外。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>既然有了模型结构和公式推导，那么来看一下代码改怎么写，以 <code>MNIST</code> 数据集为例，全部代码在 <a href="https://github.com/muyuuuu/colab/blob/main/GAN/minmaxGAN.ipynb" target="_blank" rel="noopener"><code>github</code></a>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment"># g_input_dim = 100, g_output_dim=784</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, g_input_dim, g_output_dim)</span>:</span></span><br><span class="line">        super(Generator, self).__init__()       </span><br><span class="line">        self.fc1 = nn.Linear(g_input_dim, <span class="number">256</span>)</span><br><span class="line">        self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features*<span class="number">2</span>)</span><br><span class="line">        self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features*<span class="number">2</span>)</span><br><span class="line">        self.fc4 = nn.Linear(self.fc3.out_features, g_output_dim)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span> </span><br><span class="line">        x = F.leaky_relu(self.fc1(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.leaky_relu(self.fc2(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.leaky_relu(self.fc3(x), <span class="number">0.2</span>)</span><br><span class="line">        <span class="keyword">return</span> torch.tanh(self.fc4(x))</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment"># d_input_dim = 784</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d_input_dim)</span>:</span></span><br><span class="line">        super(Discriminator, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(d_input_dim, <span class="number">1024</span>)</span><br><span class="line">        self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features//<span class="number">2</span>)</span><br><span class="line">        self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features//<span class="number">2</span>)</span><br><span class="line">        self.fc4 = nn.Linear(self.fc3.out_features, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = F.leaky_relu(self.fc1(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.dropout(x, <span class="number">0.3</span>)</span><br><span class="line">        x = F.leaky_relu(self.fc2(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.dropout(x, <span class="number">0.3</span>)</span><br><span class="line">        x = F.leaky_relu(self.fc3(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.dropout(x, <span class="number">0.3</span>)</span><br><span class="line">        <span class="keyword">return</span> torch.sigmoid(self.fc4(x))</span><br><span class="line"></span><br><span class="line">n_epoch = <span class="number">200</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, n_epoch+<span class="number">1</span>):           </span><br><span class="line">    D_losses, G_losses = [], []</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (x, _) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            D_train(x)</span><br><span class="line">        D_losses.append(D_train(x))</span><br><span class="line">        G_losses.append(G_train(x))</span><br></pre></td></tr></table></figure><p>$D$ 为什么要比 $G$ 多训练两次？因为只有去够好的 $D$，此案能使得 $G$ 也好，$G$ 好了 $D$ 也会好；否则 $D$ 很差，$G$ 也懒得更新，生成的结果会很差。此外，如果两者都只训练一次，我发现 $D$ 的损失是逐步上升的。如下图所示，右侧是 $D$ 训练三次的，左侧是 $D$ 训练一次的效果，明显发现右侧的效果要好一些。</p><p><img data-src="https://z3.ax1x.com/2021/08/11/fNru9O.png" alt></p><h1 id="WGAN-GP"><a href="#WGAN-GP" class="headerlink" title="WGAN-GP"></a>WGAN-GP</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过前文我们可以了解到，如果 $D$ 训练得太弱，指示作用不显著，则 $G$ 不能进行有效的学习；但是，如果 $D$ 训练得太好， $G$ 就无法得到足够的梯度继续优化，这样一来， $D$ 的训练火候就非常难把控，这就是 GAN 训练难的根源。如下图所示：</p><p><img data-src="https://z3.ax1x.com/2021/08/11/fUlFNn.png" alt></p><ul><li>左侧的 $D$ 很弱，$G$ 也不知道哪边好哪边弱；</li><li>右侧的 $D$ 很强，存在梯度消失和梯度爆炸问题，即在区域 $G$ 获取到的梯度近似为0而无法获得有效的更新。</li></ul><blockquote><p>说点通俗的话，你在学习，你的老师太弱，你学不出来；你的老师太强，无论你怎么学老师都说你是错的，即使进步是有效的，但还是被你的老师说没用，那么之前的进步也可能会回退，你还是学不出来。</p></blockquote><h2 id="朴素-GAN-的缺陷"><a href="#朴素-GAN-的缺陷" class="headerlink" title="朴素 GAN 的缺陷"></a>朴素 GAN 的缺陷</h2><p>虽然有着完备的理论推导，但是朴素 GAN 仍有以下的缺陷：</p><ul><li>对于 $D$ 的目标，经过推导会发现竟然要最大化 $P(x)$ 和 $P_G(x;\theta)$ 的距离，显然违背了 $D$ 的初衷，或者说，不是这样判别的；关于 $D$ 计算距离的缺陷，这里 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> 有详细公式推导。</li><li>对于 $G$ 的目标，如果一味的最小化 $P_G(x;\theta)$ 和 $P(x)$ 的距离，会使生成的数据只有安全性，没有多样性，这显然也是不好的。</li></ul><h2 id="Wasserstein-距离"><a href="#Wasserstein-距离" class="headerlink" title="Wasserstein 距离"></a>Wasserstein 距离</h2><p>于是，如何巧妙的<strong>衡量生成分布与真实分布之间的距离</strong>，WGAN 定义了 Wasserstein 距离。即：</p><p>\begin{equation}<br>W(P(x), P_G(x;\theta))=\inf_{\gamma\sim\prod(P(x), P_G(x;\theta))} \mathbb{E}_{(x,y)\sim \gamma} \bigl[ \Vert| x-y \Vert \bigr]<br>\end{equation}</p><p>$\prod(P(x), P_G(x;\theta))$ 是 $P(x)$ 和 $P_G(x;\theta)$ 联合分布的集合，对于每一个联合分布 $\gamma$ 从中取样，得到一个真实样本 $x$ 和一个虚假样本 $y$，并计算联合分布 $\gamma$ 中两两样本的距离 $\Vert x-y \Vert$，这也就是 Wasserstein 距离。意思是，从 $y$ 移动到 $x$ 需要多远，即便两个分布没有重叠，Wasserstein 距离仍然能够反映它们的远近。</p><p>既然如此，那么就把 Wasserstein 距离用到 GAN 中，由于 $\inf$ 是最大下确界，所以：</p><p>\begin{aligned}<br>W(P(x), P_G(x;\theta)) &amp; \leq \int_{P(x), P_G(x;\theta)} \Vert x-y \Vert d\gamma \\<br>{ }&amp; = \mathbb{E}_{(x,y)\sim \gamma} \bigl[ \Vert x-y \Vert \bigr] \\<br>&amp;= \mathbb{E}_{x\sim P(x)} D(x) - \mathbb{E}_{x\sim P_G(x;\theta)} D(G(x))<br>\end{aligned} </p><p>至此，真实分布与生成分布之间的 Wasserstein 距离融入到了 GAN 中。朴素 GAN 的 $D$ 做的是真假二分类任务，所以最后一层是 sigmoid，但是现在 WGAN 中的 $D$ 做的是近似拟合 Wasserstein 距离，属于回归任务，所以要把 $D$ 最后一层的 sigmoid 拿掉。</p><p>接下来 $G$ 要最小化 Wasserstein 距离，$D$ 要最大化 Wasserstein 距离的优良性质，也不需要担心 $D$ 导致的梯度消失的问题，这样就得到了WGAN的两个loss，$G$ 的 loss 是 $- \mathbb{E}_{x\sim P_G(x;\theta)} D(G(x))$，$D$ 的 loss 是 $-\mathbb{E}_{x\sim P(x)} D(x) + \mathbb{E}_{x\sim P_G(x;\theta)} D(G(x))$ （距离最小，取负号）。</p><p>为了使距离不在梯度消失问题和梯度爆炸，后续有论文进行了改进 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，并不是直接对 $D$ 的权重进行裁剪限制在某个范围内，而是加入了惩罚项，因此 $D$ 的损失函数变为：</p><p>\begin{equation}<br>-\mathbb{E}_{x\sim P(x)} D(x) + \mathbb{E}_{x\sim P_G(x;\theta)} D(G(x)) + \lambda \mathbb{E}_{\hat{x}\sim P(\hat{x})} \bigl( \Vert \nabla_\hat{x} D(\hat{x}) \Vert_2 - 1 \bigr)^2<br>\end{equation}</p><p>$\hat{x}$ 是真实数据和虚假数据的随机采样，也就是说，希望 $D$ 对 $\hat{x}$ 数据的梯度保持在都是 1 左右，这样就不用再考虑梯度消失问题和梯度爆炸问题，虚假数据也好往真实数据去移动。最终的算法如下所示：</p><p><img data-src="https://z3.ax1x.com/2021/08/11/fU5bh4.png" alt></p><p>WGAN 有以下优势：</p><ul><li>不再需要纠结如何平衡 $G$ 和 $D$ 的训练程度，大大提高了GAN 训练的稳定性,$D$ 训练得越好，对提升 $G$ 就越有利。</li><li>即使网络结构设计得比较简陋，WGAN 也能展现出良好的性能，包括避免了样本不够多样性的现象，体现了出色的鲁棒性。</li><li>$D$ 的 loss 很准确地反映了 $G$ 生成样本的质量，因此可以作为展现 GAN 训练进度的定性指标。</li></ul><h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><p>完整代码在 <a href="https://github.com/muyuuuu/colab/blob/main/GAN/WGAN-GP.ipynb" target="_blank" rel="noopener"><code>github</code></a>，这里只展示计算惩罚项的部分：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_gradient_penalty</span><span class="params">(D, real_samples, fake_samples)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># [0, 1] 之间的随机数</span></span><br><span class="line">    alpha = torch.rand(<span class="number">1</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成 \hat&#123;x&#125;</span></span><br><span class="line">    x = (alpha * real_samples + ((<span class="number">1</span> - alpha) * fake_samples)).requires_grad_(<span class="literal">True</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># D 对生成数据的梯度控制为 1 左右，所以计算梯度</span></span><br><span class="line">    interpolates = D(x)</span><br><span class="line"></span><br><span class="line">    fake = torch.ones(bs, <span class="number">1</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算 D(x) 对 interpolates 的梯度</span></span><br><span class="line">    gradients = torch.autograd.grad(</span><br><span class="line">        outputs=interpolates, <span class="comment"># 用来求导的</span></span><br><span class="line">        inputs=x,             <span class="comment"># 被求导的梯度值</span></span><br><span class="line">        grad_outputs=fake,    <span class="comment"># 求梯度时对输出的权重</span></span><br><span class="line">        create_graph=<span class="literal">True</span>,    <span class="comment"># 创建计算图</span></span><br><span class="line">    )[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    gradient_penalty = ((gradients.norm(<span class="number">2</span>, dim=<span class="number">1</span>) - <span class="number">1</span>) ** <span class="number">2</span>).mean()</span><br><span class="line">    <span class="keyword">return</span> gradient_penalty</span><br></pre></td></tr></table></figure><p>可能是我网络设置的比较简单，效果并不是很好：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><center> After 100 epochs </center></th><th style="text-align:center"><center>After 200 epochs</center></th><th style="text-align:center"><center>After 300 epochs</center></th><th style="text-align:center"><center>After 400 epochs</center></th><th style="text-align:center"><center>After 500 epochs</center></th></tr></thead><tbody><tr><td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwc9JA.png" alt></td><td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwcnij.png" alt></td><td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwclQ0.png" alt></td><td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwcBy6.png" alt></td><td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwcseO.png" alt></td></tr></tbody></table></div><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文涉及了大量的公式推导，从朴素的 GAN 推到了 WGAN-GP。此外，还有啥 conditional GAN，infoGAN，BigGAN，cycleGAN，XGAN 等等等等，不过那些东西脱离了我要做的内容，所以，等哪天空闲了，会简单的整理这些模型的框架和 idea，如果不忙会尝试复现一个 photo shop。</p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/pdf/1606.00709.pdf" target="_blank" rel="noopener">f-GAN论文</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/pdf/1704.00028.pdf" target="_blank" rel="noopener">Improved WGAN</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zhuanlan.zhihu.com/p/25071913" target="_blank" rel="noopener">判别器JS散度距离缺陷</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做对抗样本的时候，我发现对抗防御和 GAN 在某种程度上很像：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对抗防御：内部生成对抗样本攻击分类器，分类器更新参数防御攻击；&lt;/li&gt;
&lt;li&gt;GAN：生成器 $G$ 生成样本欺骗判别器，判别器更新防御 $G$ 的欺骗。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以说，这俩在某种程度上真的很像，所以决定整理一下 GAN 的知识，开拓一下思路，视频内容来自&lt;a href=&quot;https://www.bilibili.com/video/BV1JE411g7XF?from=search&amp;amp;seid=17206901754423397958&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。警告：里面有大量数学公式的推导，而我就不一样了，&lt;del&gt;不仅有公式推导&lt;/del&gt;还有代码。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>一些对抗样本去噪算法</title>
    <link href="https://muyuuuu.github.io/2021/08/05/some-adversarial-sample-denoise/"/>
    <id>https://muyuuuu.github.io/2021/08/05/some-adversarial-sample-denoise/</id>
    <published>2021-08-05T05:45:59.000Z</published>
    <updated>2021-08-22T13:24:05.593Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>忙完了其它的，还是要回归科研做好整理，相当于论文笔记吧。对抗样本去噪算法算是告以段落，或者说叫对抗样本提纯。本文总结了一些近几年的、思路还行结果也还好的对抗样本去噪算法，就相当于写个类似的综述了，注意，并非详解。优缺点仅是个人分析，<del>其实论文读多了或者看了代码，总会有一些想法</del>。包含以下论文：</p><ol><li>Comdefend: An efficient image compression model to defend adversarial examples, CVPR 2019</li><li>Feature denoising for improving adversarial robustness, CVPR 2019</li><li>Defense against adversarial attacks using high-level representation guided denoiser, CVPR 2018</li><li>A Self-supervised Approach for Adversarial Robustness, CVPR 2020</li><li>Denoised Smoothing: A Provable Defense for Pretrained Classifiers, NIPS 2020</li><li>Stochastic Security: Adversarial Defense Using Long-Run Dynamics of Energy-Based Models, ICLR 2021</li><li>Online Adversarial Purification based on Self-Supervision, ICLR 2021</li><li>Adversarial Purification with Score-based Generative Models, ICML 2021</li></ol><a id="more"></a><h1 id="ComDefend"><a href="#ComDefend" class="headerlink" title="ComDefend"></a>ComDefend</h1><p>来自论文：Comdefend: An efficient image compression model to defend adversarial examples, CVPR 2019。</p><p><img data-src="https://z3.ax1x.com/2021/08/22/hpM6XR.png" alt></p><ul><li>核心思想，在目标模型之前训练一个编码器和解码器，编码器的目标是提取图像的结构信息，移除冗余信息；解码器的目标是重构输入的图像，移除扰动信息。</li><li>损失函数，对于编码器，使用更多的 0 来编码图像，因此损失为 $\lambda \Vert Com(\theta_1, x) \Vert^2$，使其尽可能的小；对于解码器要尽可能的重构原始图像，因此损失为 $\Vert Rec(\theta_2, Com(\theta_1, x)+\phi) -x \Vert^2$，$\phi$ 是高斯噪音。最终的损失是两者相加，两个模型的参数是同时训练和更新的。但是我在复现的时候，发现 $\lambda = 0.0001$，也能猜出这篇论文的大概效果。</li></ul><p><strong>对抗样本在输入层的扰动其实只是很小的一部分，微小的扰动会在模型隐层无限放大。这篇论文只是在输入层去除对抗样本的扰动信息，没有考虑在模型隐层去除扰动信息。</strong></p><h1 id="Feature-Denoising"><a href="#Feature-Denoising" class="headerlink" title="Feature Denoising"></a>Feature Denoising</h1><p>来自论文 Feature denoising for improving adversarial robustness, CVPR 2019。如下图所示，论文注意到了对抗样本在模型高层的巨大差异信息，所以，选择了在模型的高层对数据进行去噪，而不是输入层。</p><p><img data-src="https://z3.ax1x.com/2021/08/05/fZKpjA.png" alt></p><p>论文选择的去噪方式也很简单，对于特征图 $y$，对于一个区域 $L$，重新计算其表示：</p><p>\begin{equation}<br>y_i=\frac{1}{C(x)}\sum_{j \in L} f(x_i, x_j) \cdot x_j<br>\end{equation}</p><p>其中，$f(x)$ 有多种选择，论文中给出了：高斯函数、内积、和一些滤波器。</p><h1 id="HGD"><a href="#HGD" class="headerlink" title="HGD"></a>HGD</h1><p>来自论文：Defense against adversarial attacks using high-level representation guided denoiser, CVPR 2018。</p><p><img data-src="https://z3.ax1x.com/2021/08/22/hpQS3Q.png" alt></p><p>核心思想：基于干净样本和对抗样本在模型高维的差异来指导去噪器的训练。设 $x$ 为干净样本，$x^\star$ 为对抗样本，$\hat{x}$ 为对抗样本去噪后的样本。论文选择 U-Net 结构对样本进行去噪，输入为 $x^\star$，输出为同等大小的 $-d\hat{x}$，那么 $\hat{x}=x^\star - d\hat{x}$，使用 $L_1$ 范数作为 $\hat{x}$ 和 $x$ 的损失。第二个损为 $f_l(x)$ 与 $f_l(\hat{x})$ 的 $L_1$ 范数，即去噪样本和干净样本在模型第 $l$ 层的差异应尽可能接近。</p><p>我觉得这篇论文的思想是不错的，所以在我的工作中也借鉴了这篇论文的思想。分别在模型的输入层和隐层对对抗样本进行去噪，不过其他内容则不一样了。</p><h1 id="NRP"><a href="#NRP" class="headerlink" title="NRP"></a>NRP</h1><p>来自论文：A Self-supervised Approach for Adversarial Robustness, CVPR 2020。这篇论文我也<a href="https://github.com/muyuuuu/Paper-ReImplement" target="_blank" rel="noopener">复现</a>了，讲真复现结果很差。一方面是论文中给出的参数不合理，一方面是论文并没有对一些东西解释清楚，最重要的是不仅没给代码，还没说怎么实现他的代码，也没有说某些实验参数，所以我只能按照论文描述来实现代码了。那为什么还要写呢？因为这篇论文借鉴 GAN 的思想来去除扰动，还是感觉有一点点新意的。</p><p><img data-src="https://z3.ax1x.com/2021/08/22/hpQ3E6.png" alt></p><p>作者定义一个提纯网络 $P$ 用于去除噪音，定义判别网络 $C$ 来判断当前样本是对抗样本还是干净样本，定义 backbone $F$ 来提取对抗样本和干净样本的特征差异生成自监督扰动，将扰动叠加至干净样本生成对抗样本，作为 $P$ 的训练数据。$P$ 去噪后传送给 $C$，以此来定义 $P$ 去除扰动的好坏。损失函数由三个部分组成，最终带权相加组成最终的损失函数：</p><ul><li>对抗损失是 $P(\hat{x})$ 和 $x$ 在判别网络 $C$ 上的相似度</li><li>特征损失为 $F(x)$ 和 $F(\hat{x})$ 的欧式距离</li><li>像素损失为 $P(\hat{x})$ 和 $x$ 的欧氏距离</li></ul><h1 id="Denoised-smoothing"><a href="#Denoised-smoothing" class="headerlink" title="Denoised smoothing"></a>Denoised smoothing</h1><p>这篇论文来自 Denoised Smoothing: A Provable Defense for Pretrained Classifiers, NIPS 2020。</p><p>写这篇论文并不是因为这个论文发表的等级高、时间新。而是因为，我发现一些对抗去噪采纳了集成的思想，这篇论文就是其一。<strong>借助多个分类器的投票结果指导去噪器的训练</strong>，三个臭皮匠，赛过诸葛亮，何况分类器呢？如果你对集成感兴趣，可以考虑沿着这个方向做下去。这个论文还算是集成思想中比较保守的了。</p><p><img data-src="https://z3.ax1x.com/2021/08/22/hpQ6PS.png" alt></p><p>但是呢，我是比较反感堆叠模型这样的方案的，这就相当于应该花 3 年去准备高考，而你花了 21 年去准备，效果虽然好，但是成本太大了。应该设计算法去提高一个模型的准确度，而不是多个模型投机取巧，另外我也没这样大规模的算力。</p><p>这篇论文写了一个单独的<a href="https://www.microsoft.com/en-us/research/blog/denoised-smoothing-provably-defending-pretrained-classifiers-against-adversarial-examples/" target="_blank" rel="noopener">博客</a>，也给出了<a href="https://github.com/microsoft/denoised-smoothing" target="_blank" rel="noopener">程序</a>，思路还是比较清晰的，在损失函数上，先用去噪后的图像和原始图像的 MSE 作为损失，再用去噪后的图像和原始图像在高维的差异作为损失微调。</p><h1 id="EBM-defense"><a href="#EBM-defense" class="headerlink" title="EBM-defense"></a>EBM-defense</h1><p>论文来自 Stochastic Security: Adversarial Defense Using Long-Run Dynamics of Energy-Based Models, ICLR 2021。模型啥的也比较简单，但是我比较反感堆叠模型的操作，丑拒这样的 idea。</p><p><img data-src="https://z3.ax1x.com/2021/08/21/fze1BD.png" alt></p><h1 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h1><p>来自论文 Online Adversarial Purification based on Self-Supervision, ICLR 2021。这篇论文在模型、算法还是有一定创新度的，也是我重点复现的论文之一。不过这篇论文虽然有对抗样本提纯的概念，但严格意义来说，属于对抗训练的论文，应为这个算法会修改目标模型的参数。</p><p><img data-src="https://z3.ax1x.com/2021/08/22/hplmIf.png" alt></p><ul><li>在训练阶段，设计两个损失，第一个损失是目标模型的分类损失，第二个损失是子监督扰动的损失，企图网络能够去除自监督扰动，以此抵御对抗样本的攻击。</li><li>在推理阶段，通过子监督扰动损失的指导，去除对抗样本的扰动信息，之后再进行推理。（具体可以看代码）</li></ul><p>论文的目标损失是：</p><p>\begin{equation}<br>\min_\theta L_{\text{cls}}((g\circ f)(x;\theta_{\text{enc}}, \theta_{\text{cls}}), y) + \alpha L_{\text{aux}}((h\circ f)(x;\theta_{\text{enc}}, \theta_{\text{aux}}))<br>\end{equation}</p><p>$g$ 是分类器的前部分，$h$是辅助分支的模型，不过实际代码中这俩被合二为一了，也就是，一个神经网络有两个损失。</p><p>对于 $L_{\text{aux}}$ 损失，论文给出了三种选择，在实现时选择其中的一种即可。</p><ol><li>叠加噪音，即图像叠加噪音后，还是之前的图像。这里的损失使用了叠加噪音前后的 MSE 差异。</li><li>图像旋转，即图像旋转后，还是之前的图像。这里的损失使用了旋转后图像与真实标签的交叉熵作为损失。</li><li>标签持续性，即图像经过两种数据增强后，这两组图像的标签一致。这里的损失是两种数据增强后的 MSE 差异。</li></ol><p>在去噪阶段，论文提出了多部去噪，一定程度弥补了之前单步去噪的缺陷：</p><p><img data-src="https://z3.ax1x.com/2021/08/22/hptNng.png" alt></p><h1 id="ADP"><a href="#ADP" class="headerlink" title="ADP"></a>ADP</h1><p>来自论文 Adversarial Purification with Score-based Generative Models, ICML 2021。我复现了这篇论文，训练缓慢、预测缓慢，且不提供训练代码只提供预测代码，预测代码和论文算法描述不一致。前面的模型是别人的，如果没看到这一点，我都不知道怎么复现论文。如果一定有评价的话，那就是：呵，tui。</p><p>模型来自「Improved techniques for training score-based generative models」这篇发表在 NIPS 2020 的论文，所以网络结构直接看这篇论文的代码即可。损失函数的设计如下（前面那堆推导没啥用）：</p><p>\begin{equation}<br>L(\theta, \sigma) = \mathbb{E}_{q(\tilde{x}|x)p_{\text{data}}(x)}[\frac{1}{2\sigma^2} \Vert \tilde{x} + \sigma^2 s_\theta(\tilde{x}) -x \Vert^2]<br>\end{equation}</p><p>$q(\tilde{x}|x)$ 是以 $x$ 为中心，以 $\sigma$ 为均方差生成的噪音样本。这个损失的意思是，期望 $s_{\theta}$ 能够有效去除 $\tilde{x}$ 上含有的噪音信息，并且和原始图像差不多，以此来抵御对抗样本的攻击。</p><p>预测阶段极度风骚，来看伪码：</p><p><img data-src="https://z3.ax1x.com/2021/08/22/hpYaJx.png" alt></p><p>一步去噪不到位，居然用多步去噪……这样与其他算法对比并不公平，这就像之前举的参加高考的例子。当然这不是最离谱的，最离谱的是，代码和这个算法毫不相关。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(max_iter):</span><br><span class="line">    labels = torch.ones(x_pur.shape[<span class="number">0</span>], device=x_pur.device)</span><br><span class="line">    labels = labels.long().to(config.device.ebm_device)</span><br><span class="line">    grad = network_ebm(x_pur, labels) <span class="comment"># Get gradients</span></span><br><span class="line">    <span class="comment"># Get adaptive step size</span></span><br><span class="line">    x_eps = x_pur + lr_min*grad</span><br><span class="line">    <span class="comment">#print(torch.mean(torch.norm(grad.view(grad.shape[0],-1), p=2,dim=1)).item(), flush=True)</span></span><br><span class="line">    grad_eps = network_ebm(x_eps, labels)</span><br><span class="line">    z1 = torch.bmm(grad.view(grad.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">-1</span>), grad_eps.view(grad_eps.shape[<span class="number">0</span>], <span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">    z2 = torch.bmm(grad.view(grad.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">-1</span>), grad.view(grad.shape[<span class="number">0</span>], <span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">    z = torch.div(z1, z2)</span><br><span class="line">    <span class="keyword">if</span> mode==<span class="string">"attack"</span>:</span><br><span class="line">        step_lambda = config.attack.attack_lambda</span><br><span class="line">    <span class="keyword">elif</span> mode==<span class="string">"purification"</span>:</span><br><span class="line">        step_lambda = config.purification.purification_lambda</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    step_size = torch.clamp(step_lambda*lr_min/(<span class="number">1.</span>-z), min=min_step_lr, max=min_step_lr*<span class="number">10000.</span>).view(<span class="number">-1</span>)</span><br><span class="line">    cont_purification = torch.logical_and(cont_purification, (step_size&gt;config.purification.stopping_alpha))</span><br><span class="line">    <span class="keyword">if</span> torch.sum(cont_purification)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    step_size *= cont_purification</span><br><span class="line">    x_pur_t = x_pur.clone().detach()</span><br><span class="line">    x_pur = torch.clamp(transform_ebm_to_raw(x_pur_t+grad*step_size[:, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]), <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line">    step_sizes.append(step_size)</span><br><span class="line">    images.append(x_pur)</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>当然，还有一系列的其他算法，如 Feature squeezing, JPEG Compressionm，TVM 等算法，我感觉不如之前的论文有意思，所以没有详细的写，读者有兴趣的话可以自己去看一看。</p><p>接下来，会看一些攻击方向的经典论文而后复现，大概一周吧，之后会转入全新的领域：对抗训练，偏数据分布的处理，如果有兴趣欢迎联系（是妹子就更好了（误。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;忙完了其它的，还是要回归科研做好整理，相当于论文笔记吧。对抗样本去噪算法算是告以段落，或者说叫对抗样本提纯。本文总结了一些近几年的、思路还行结果也还好的对抗样本去噪算法，就相当于写个类似的综述了，注意，并非详解。优缺点仅是个人分析，&lt;del&gt;其实论文读多了或者看了代码，总会有一些想法&lt;/del&gt;。包含以下论文：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Comdefend: An efficient image compression model to defend adversarial examples, CVPR 2019&lt;/li&gt;
&lt;li&gt;Feature denoising for improving adversarial robustness, CVPR 2019&lt;/li&gt;
&lt;li&gt;Defense against adversarial attacks using high-level representation guided denoiser, CVPR 2018&lt;/li&gt;
&lt;li&gt;A Self-supervised Approach for Adversarial Robustness, CVPR 2020&lt;/li&gt;
&lt;li&gt;Denoised Smoothing: A Provable Defense for Pretrained Classifiers, NIPS 2020&lt;/li&gt;
&lt;li&gt;Stochastic Security: Adversarial Defense Using Long-Run Dynamics of Energy-Based Models, ICLR 2021&lt;/li&gt;
&lt;li&gt;Online Adversarial Purification based on Self-Supervision, ICLR 2021&lt;/li&gt;
&lt;li&gt;Adversarial Purification with Score-based Generative Models, ICML 2021&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>从代码角度理解局部敏感哈希算法</title>
    <link href="https://muyuuuu.github.io/2021/08/04/LSH-consine/"/>
    <id>https://muyuuuu.github.io/2021/08/04/LSH-consine/</id>
    <published>2021-08-04T08:13:44.000Z</published>
    <updated>2021-08-05T13:44:44.143Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为开发图像检索系统的需要，需要学习局部敏感哈希算法。我在网上看了很多局部敏感哈希算法的讲解，也没有一个能讲清楚的。什么打乱表格、计数 1 最开始出现的索引、minHash 等没啥用的东西把人说的云里雾里。</p><p>而如何设计哈希函数、如何把相似内容放到同一个桶中、计算相似度则闭口不谈。所以，关于数学理论推导，本文就不描述了，网上其他博客多的是，本文从代码的角度来理解局部敏感哈希算法，相对更清晰，附 <code>C++</code> 程序实现。</p><a id="more"></a><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p><img data-src="https://z3.ax1x.com/2021/08/04/fAhTfK.png" alt></p><p>如上图所示有两张不同的哈希表。在查询阶段，对于输入的每条数据，都会在这两个哈希表中进行查询，因此更多的查询结果可以保证查询的召回率。但是，也会带来查询时间、构建哈希表时间线性增加的弊端。会在文末给出如何设置合理的哈希表数目，这里只需要理解哈希表多了、少了的优缺点即可。</p><p>在程序中，我们设置哈希表为三维容器，维度为 $T \times 2^{F} \times 0$，$T$ 表示哈希表的数量，$F$ 表示哈希函数的数量，用 $2^F$ 表示桶的数量，$0$ 是每个桶的容量，初始化为 0, 后期桶内添加数据时容量会增加，维度也会随即发生变化。</p><h1 id="哈希函数与哈希过程"><a href="#哈希函数与哈希过程" class="headerlink" title="哈希函数与哈希过程"></a>哈希函数与哈希过程</h1><p>对于任何局部敏感哈希函数 $f(x)$ 而言，它都应该实现：在处理数据库数据时，相似的特征放入同一个桶，不相似特征放入不同的桶中，每个桶可以有多个结果。在处理查询数据时，同样通过哈希函数 $f(x)$，将当前查询的向量映射到桶中，而后在那个桶中返回最接近的 $K$ 个向量。此时，会触发 $f(x)$ 的隐藏条件，在处理数据库数据和查询数据的时候，$f(x)$ 保持不变。</p><p>在程序中，我使用了二级哈希，也就是有两个哈希函数：</p><ul><li>一级哈希函数 $f_1$ 是一个二维矩阵，维度是 $T \times F$，每个元素都是 $[0, F)$ 区间内的随机整数。之后会讲述这么做的原因是为了防止越界。</li><li>二级哈希函数 $f_2$ 是一个二维矩阵，维度是 $F \times D$，$D$ 是数据的维度数，其元素取值为以 0 为均值，以 0.2 为方差的服从正太分布的随机数。</li></ul><h2 id="哈希运算"><a href="#哈希运算" class="headerlink" title="哈希运算"></a>哈希运算</h2><p>重点来了，在对数据进行哈希时，按照表、哈希函数、数据维度的顺寻进行三层遍历，程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历哈希表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="keyword">this</span>-&gt;n_tables; t++) &#123;</span><br><span class="line">    <span class="comment">// 遍历这些哈希函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> f = <span class="number">0</span>; f &lt; <span class="keyword">this</span>-&gt;n_functions; f++) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;n_dim; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;bFile &gt;&gt; x;</span><br><span class="line">            <span class="comment">// 一级哈希，this-&gt;f_1[t][f]，哈希到某个哈希函数</span></span><br><span class="line">            <span class="comment">// 二级哈希，this-&gt;f_2 访问当前哈希函数的第 i 个值</span></span><br><span class="line">            sum += x * <span class="keyword">this</span>-&gt;f_2[ <span class="keyword">this</span>-&gt;f_1[t][f] ][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">            pos += <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>, f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>, <span class="keyword">this</span>-&gt;n_functions))</span><br><span class="line">        pos = <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>, <span class="keyword">this</span>-&gt;n_functions) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 容器追加，避免处理哈希冲突</span></span><br><span class="line">    <span class="comment">// 追加到第 t 个表的第 pos 个桶中</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;hashTables[t][pos].push_back(line);</span><br></pre></td></tr></table></figure><ul><li>一级哈希 <code>this-&gt;f_1[t][f]</code> ，确定使用哪个哈希函数 $i$，因此取值范围是 $[0, F)$</li><li>二级哈希，使用第 $i$ 个哈希函数，对当前数据进行哈希，哈希的运算为乘积并求和。这里需要注意的是，「查询数据处理的阶段」和「数据库数据处理阶段」的哈希形式必须一致，否则无法保证查到近似结果。因此，查询阶段的哈希运算也是乘积并求和。</li><li>针对哈希结果，确定将当前数据放入哪个桶中，也就是 <code>pos</code></li></ul><p>至于上述程序中为何 <code>sum &gt; 0</code> 和 <code>pos += std::pow(2, f);</code>，都是哈希函数的机制，也可以自己定义新的运算，这个没有统一的标准。</p><h1 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段"></a>查询阶段</h1><p>对于查询数据，首先要查找当前数据位于哪个桶，而 <code>pos</code> 的计算和上述的哈希运算完全一致：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LSH::hash_query</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> sum&#123;<span class="number">0</span>&#125;, x&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> pos&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;n_functions; i++) &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>-&gt;n_dim; j++) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;qFile &gt;&gt; x;</span><br><span class="line">      sum += x * <span class="keyword">this</span>-&gt;hashFunction[<span class="keyword">this</span>-&gt;amplifyFunction[t][i]][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">      pos += <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取这个桶后，遍历这个桶内的所有元素，按照相似性距离压入优先级队列，这样就可以逐个访问最相似的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t 是当前哈希表，pos 是查询到的桶</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i: <span class="keyword">this</span>-&gt;hashTables[t][pos]) &#123;</span><br><span class="line">    <span class="keyword">double</span> dis = <span class="keyword">this</span>-&gt;calcute_cosine_distance(i, line);</span><br><span class="line">    <span class="comment">// 距离与项，按照第一项进行排序</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;res.emplace(dis, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算相似度"><a href="#计算相似度" class="headerlink" title="计算相似度"></a>计算相似度</h2><p>也就是上述程序中的 <code>calcute_cosine_distance</code> 函数，这个还是比较容易实现的。$\text{cos}$ 相似性计算为：</p><p>\begin{equation}<br>\text{sim}= \frac{x \cdot y}{ \Vert x \Vert \Vert y \Vert}<br>\end{equation}</p><p>分子是内积，分母是模长。</p><h1 id="关于参数设置"><a href="#关于参数设置" class="headerlink" title="关于参数设置"></a>关于参数设置</h1><p>如何确定哈希函数、哈希表的数量呢？</p><ul><li>一个极端的假设，我有很多的哈希函数和哈希表，这无疑会增加建立哈希表的复杂度</li><li>一个极端的假设，我只有一个哈希函数和一个哈希表，在查询阶段会查询到大量无关的结果</li></ul><p>那么，假设数据库里面有 10000 条数据，那么我可以设置 10 个哈希函数，因为 $2^{10}=1024$，这样就有了 1024 个桶。而如果 10000 数据分布均匀，每个桶就可以有 10 条左右的数据，查询也快。至于哈希表，2个，3个都是可以的，但是不能太多。</p><p>此外还要注意的是，每个哈希桶内的元素数最好是均匀的，这样查询时间也更稳定。所以要设置合理的哈希函数的机制，也就是 <code>pos</code> 的分布一定要均匀。</p><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>我自己实现了一份<a href="https://github.com/muyuuuu/SeetaFace-Retri/tree/main/CosineLSH" target="_blank" rel="noopener">局部敏感哈希程序</a>，我是 C++ 初学者，代码写的不是很难，相信你看完代码是可以理解局部敏感哈希算法的。计算相似度是使用的余弦距离，因为欧拉距离会面临维灾。<code>modules</code> 里面的 <code>config.cpp</code> 可以忽略，那个是为了衔接其他业务设计的。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>处理 <code>13466 X 2048</code> 大小的数据，即 13466 条数据，每条数据的维度是 2048 维。构建 1024 个哈希函数，两张哈希表。log 日志显示每秒哈希 50 条数据。 对 100 条数据进行查询，每条数据返回最接近的 5 条数据。每条数据的平均查询时间为 0.86 秒，最低时间为 0.34 秒，召回率接近 100% 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为开发图像检索系统的需要，需要学习局部敏感哈希算法。我在网上看了很多局部敏感哈希算法的讲解，也没有一个能讲清楚的。什么打乱表格、计数 1 最开始出现的索引、minHash 等没啥用的东西把人说的云里雾里。&lt;/p&gt;
&lt;p&gt;而如何设计哈希函数、如何把相似内容放到同一个桶中、计算相似度则闭口不谈。所以，关于数学理论推导，本文就不描述了，网上其他博客多的是，本文从代码的角度来理解局部敏感哈希算法，相对更清晰，附 &lt;code&gt;C++&lt;/code&gt; 程序实现。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Algorithm" scheme="https://muyuuuu.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Arch 折腾全记录，彻底告别 Windows</title>
    <link href="https://muyuuuu.github.io/2021/07/31/Arch-config/"/>
    <id>https://muyuuuu.github.io/2021/07/31/Arch-config/</id>
    <published>2021-07-31T11:51:26.000Z</published>
    <updated>2021-08-29T13:38:37.524Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>想来想去，以壮士断腕的决心决定抛弃垃圾 <code>windows</code> 了，实在是 <code>TMD</code> 卡的要死，但是以我电脑的配置，不可能卡的。加上 <code>C</code> 盘的无理由暴增，<code>TMD</code> 空间锐减，加上每次系统动不动更新，每次更新都 <code>TMD</code> 出 <code>bug</code> 直接卡死。我宁肯花一周的时间打造一款我的主力 <code>Arch Linux</code> ，再 <code>TMD</code> 也不向 <code>windows</code> 低头了。以本文记录 <code>Arch Linux</code> 的折腾全记录。</p><p>包括：代理、终端、字体、换源更新、软件、甚至是博客迁移等。最重要的是，关于向这个世界的妥协，如何使安装 QQ、微信和 word 等非必要但深入人心的软件。毕竟老板让你微信给他发文件还是很常见的，毕竟老板没手没脚，发一次不接收必须发第 $N$ 次，毕竟他用 LaTeX 也要手动编号。</p><a id="more"></a><h1 id="关于代理"><a href="#关于代理" class="headerlink" title="关于代理"></a>关于代理</h1><p>我用的是 <code>clash</code>，直接 <code>sudo pacman -s clash</code> 即可，而后将其设置为开机启动，后台自己执行。<a href="https://github.com/Sitoi/SystemdClash" target="_blank" rel="noopener">相关参考</a>。</p><p>不过刚到新系统，一般会面临先有鸡还是先有蛋的问题，即：代理服务在国外，没有代理买不了服务，没有服务就出不去。所以，提前找同学接好代理，注意：有些代理只能在 <code>windows</code> 使用，一定要看好 <code>linux</code> 是否可以用。</p><h1 id="关于输入法"><a href="#关于输入法" class="headerlink" title="关于输入法"></a>关于输入法</h1><p><a href="https://www.cnblogs.com/qscgy/p/13385905.html" target="_blank" rel="noopener">文章推荐</a>，关于安装和配置就这个写的比较好，网上其他教程太垃圾且过时。在配置输入法的时候记得选择里面的 <code>pinyin</code>，其他的中文输入不行，然后重启即可。</p><h1 id="关于更新与换源"><a href="#关于更新与换源" class="headerlink" title="关于更新与换源"></a>关于更新与换源</h1><p><code>sudo pacman -Syu</code>，同步仓库即同步本地软件和仓库中软件的最新状态，更新所有系统上被 <code>pacman</code> 管理的的软件。<code>Su</code> 升级系统；<code>Syy</code> 会只刷新数据库。</p><p><strong>Arch Linux 中文社区仓库</strong> 是由 Arch Linux 中文社区驱动的非官方软件仓库，包含许多官方仓库未提供的额外的软件包，以及已有软件的 git 版本等变种。一部分软件包的打包脚本来源于 AUR，但也有许多包与 AUR 不一样。以清华大学的源为例，在 <code>/etc/pacman.conf</code> 文件末尾添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><p>因为所有软件包都是经过开发者私钥签名，验证签名需要导入对应的公钥，即：安装 <code>archlinuxcn-keyring</code> 包以导入 GPG key。</p><p>当然，有些软件不一定在 archlinuxcn 源中，所以其它软件的换源方式为：编辑 /etc/pacman.d/mirrorlist，文件顶端添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><p>更新软件包缓存：<code>sudo pacman -Syy</code>。</p><h1 id="关于浏览器"><a href="#关于浏览器" class="headerlink" title="关于浏览器"></a>关于浏览器</h1><p>我使用的浏览器是 <code>google-chrome-stable</code>，因为 <code>chromium</code> 不支持登录谷歌帐号，插件、书签无法同步，且 <code>chromium wiki</code> 上提供的解决方案也是曲线救国，我不喜欢。</p><p><img data-src="https://z3.ax1x.com/2021/07/31/Wv01K0.png" alt></p><p>在 <code>pacman -S google-chrome-stable</code> 后，因为浏览器不能使用代理而无法为了科学上网。我查了一下可以使用 <code>proxychains</code>，但是配合 <code>google-chrome-stable</code> 使用时会直接 <code>core dumped</code>，查了一下据说是这俩软件水火不容。而后我又查到了其它用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google-chrome-stable --proxy-server=&quot;socks5://127.0.0.1:7891&quot;</span><br></pre></td></tr></table></figure><p>这样开启的浏览器是有代理的，然后登录 <code>chrome</code>，登录谷歌，直接同步，一切都很舒服。</p><h1 id="关于字体"><a href="#关于字体" class="headerlink" title="关于字体"></a>关于字体</h1><p>掏出万能的 wiki 文档，发现安装字体的三种方式：</p><ul><li>如果有人打包，那么 <code>sudo pacman -S ttf-lxgw-wenkai</code>，这是一款我比较喜欢的字体，这样通过包管理器的方式安装；</li><li>如果没人打包，可以手动下载字体，将字体移动到 <code>/usr/share/fonts/</code> 目录，所有用户可用；如果是个人用户可用，那么就放到 <code>~/.local/share/fonts</code>，而后使用 <code>fc-cache -vf</code> 刷新字体缓存。字体权限是 <code>644</code>，-rw-r—r— 1。</li></ul><p>安装完毕后，可以在设置-&gt;字体中，配置自己喜欢的字体，如果没有立即生效，记得重启。关于 <code>latex</code> 如何调用系统的字体，时而文件名、时而字体名，时而镜像中克隆的名字，等改天单独写吧。</p><p>一般而言，<code>sans serif</code> 表示无衬线字体，<code>Serif</code> 表示衬线字体，<code>Noto</code> 表示谷歌命名的字体，<code>Mono</code> 是等宽字体。我一般使用的字体是：思源宋体黑体、<code>source code pro</code> 和 <code>IBM Plex Mono</code>，落霞孤鹜等。</p><p>此外，还会遇到终端、软件里面时而衬线字体时而非衬线字体等极度丑陋的情况，这个时候需要进行一些配置，可以参考<a href="https://szclsya.me/zh-cn/posts/fonts/linux-config-guide/" target="_blank" rel="noopener">这篇博客</a>。</p><h1 id="关于终端"><a href="#关于终端" class="headerlink" title="关于终端"></a>关于终端</h1><ul><li>更改系统默认终端：<code>sudo chsh -s /usr/bin/bash</code>，如果切换失败，可以尝试进入 <code>root</code> 切换或 <code>usermod -s /usr/bin/fish lanling</code> 命令，查看系统默认终端：<code>cat /etc/shells</code>；</li><li><code>shell</code> 用的是 <code>fish</code> 毕竟是真的舒服，<code>oh my zsh</code> 太乱了。系统自带的 <code>konsole</code> 配和 <code>oh my zsh</code> 时常乱码，但是，不可否认，<code>konsole</code> 分屏、配色、标签页等各个方面都极度强大。</li></ul><p><img data-src="https://z3.ax1x.com/2021/07/31/Wv07dS.jpg" alt></p><p>所以我决定抛弃 <code>zsh</code>。注意切换终端时需要注意：进入 <code>root</code> 切换，不能在当前用户切换，否则下次重启电脑无法进入系统（并不是密码错误，我确实遇到了这个问题）。然后我登录了 <code>root</code> 用户，发现切换到子用户时：<code>failed to execute /bin/zsh</code>，说明 <code>shell</code> 没切换成功，而后两种方案，一种是装回 <code>zsh</code> ，一种是在 <code>root</code> 端切换为 <code>bash</code>，这样用户端就能进入系统了。</p><ul><li>而后选择的新 <code>shell</code> 是 <code>fish</code>，<code>sudo pacman -S fish</code> 即可，在终端执行 <code>ish_config</code>，进入 <code>web</code> 端的颜色配置。</li><li><code>set -U fish_prompt_pwd_dir_length 0</code> 会在终端现实全部的路径，如 <code>code/github/Face/Detect</code>，否则是 <code>c/g/F/D</code> 很难看。</li></ul><h1 id="关于软件"><a href="#关于软件" class="headerlink" title="关于软件"></a>关于软件</h1><p>列出我使用的软件，对于如何安装 QQ，微信和 word，将在文末给出。</p><ul><li><code>telegram</code>，吹水与交流技术</li><li><code>peek</code>，录制 <code>gif</code></li><li><code>visual-studio-code-bin</code>，写代码</li><li><code>clash</code>，懂得都懂</li><li><code>google-chrome-stable</code>，浏览器</li><li><code>typora</code>，写 <code>markdown</code> 的东西</li><li><code>flameshot</code>，截图工具，比深度截图好用一百倍</li></ul><p>此外，还设置了一些软件开启自启动：<code>flameshot</code>，<code>clash</code> 等。</p><p>软件的快捷键自己设置吧，我只设置了终端、浏览器，截图的快捷键。位于设置、自定义快捷键、编辑、新建、全局快捷键、命令。</p><h1 id="关于美化"><a href="#关于美化" class="headerlink" title="关于美化"></a>关于美化</h1><p>众所周知，不美化还怎么写代码，但是我友情提示一下：以我多年美化的经验而言，美化的尽头绝对是系统默认。</p><ul><li>底部的 <code>dock</code> 栏可以使用 <code>plank</code> 这个软件，但是无法和状态栏配合双屏使用，于是卸载。</li><li>设置、外观里面设置主题。</li><li>如果设置无法打开，那么查看是否有 <code>systemsettings5</code> 进程没彻底杀死，如果有，杀死即可。</li><li>而后自己折腾吧，<code>i3wm</code> 有点无从下手的样子。我尝试折腾了一下，直接黑屏，除了鼠标啥都没有，然后不知道动了哪个配置文件，<code>KDE</code> 都回不去了，系统会自动退出到登陆界面，登陆后还是退出，一个死循环。无奈，删除账户，新建账户，第六次重装系统。</li></ul><h1 id="关于博客搬家"><a href="#关于博客搬家" class="headerlink" title="关于博客搬家"></a>关于博客搬家</h1><p>我的博客是基于 <code>hexo</code> 的，而之前的博客在 windows 上，所以要进行博客搬家。博客搬家倒是很容易，先安装必要依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nodejs</span><br><span class="line">sudo pacman -S npm</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>而后在安装 <code>hexo</code> 的时候有坑，有坑的是传统方案：<code>npm install -g hexo-cli</code>，这样会发现没权限，而后 <code>sudo npm install -g hexo-cli</code>，但这是很烂的行为，因为 <code>Arch</code> 的包最好用 <code>pacman</code> 管理起来，而 <code>npm</code> 安装的并不会被管理。所以，掏出万能的 <code>AUR</code>，发现里面有 <code>hexo</code>，安装即可。</p><p>之后的东西就简单了，新建博客路径，拷贝原始博客的文件到新的路径下：</p><ol><li>博客配置文件./_config.yml</li><li>主题配置文件夹./theme/</li><li>文章及相关内容的文件夹./source/</li><li>模板文件夹./scaffolds/</li><li>记录博客所有的插件的文件./package.json</li></ol><p>最后进入博客目录，执行 <code>npm install</code>，而后就可以使用博客了，这也是我换系统后的第一篇博客。</p><h1 id="关于善后"><a href="#关于善后" class="headerlink" title="关于善后"></a>关于善后</h1><p><code>word, excel, ppt, qq, wechat</code> 等软件如何使用或者寻找替代品也是必须要妥协的，毕竟很多人都在用，毕竟大部分人都不知道 latex 和 telegram 的存在。</p><h2 id="wps"><a href="#wps" class="headerlink" title="wps"></a>wps</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/Software/AUR</span><br><span class="line">cd ~/Software/AUR</span><br><span class="line">git clone https://aur.archlinux.org/wps-office-cn.git</span><br><span class="line">cd wps-office-cn</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure><p>而后按下 <code>meta</code> 键，就可以搜到了。再把字体从自己的 <code>windows</code> 系统拷贝过来，这样 <code>wps</code> 就有字体了，我是把字体拷贝到了 <code>/usr/share/fonts</code>。注意，安装完毕之后，<code>Software/AUR</code> 是可以删除的。</p><h2 id="qq"><a href="#qq" class="headerlink" title="qq"></a>qq</h2><p>无论是安装 QQ 还是 Tim，我试了网上和 wiki 说的那些什么用 <code>yay</code> 安装 <code>qq, deepin, office, wine, light</code> 乱七八糟的无法装成功，不如直接用官方构建好的包。去 <a href="https://im.qq.com/pcqq" target="_blank" rel="noopener">官方</a> 下载对应的发行版的包，<code>arch</code> 就下载 <code>pacman</code> 的，而后 <code>sudo pacman -U linuxqq_2.0.0-b2-1089_x86_64.pkg.tar</code>。</p><h2 id="wechat"><a href="#wechat" class="headerlink" title="wechat"></a>wechat</h2><p>既然 QQ 都安装成功了，那么也就通过这种方式安装 wechat 吧。去 github 下载别人<a href="https://github.com/countstarlight/deepin-wine-wechat-arch" target="_blank" rel="noopener">打包好的</a>，安装方式同 QQ。因为 3.0+ 的不能发文件且我在 issue 里面也没看到啥特别好修复方法。建议下载 <code>2.9.5</code> 版本的，然后将 wine 替换为 deepin-wine5 修理一下，可以参考<a href="https://www.jianshu.com/p/11231b51ece0" target="_blank" rel="noopener">这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想来想去，以壮士断腕的决心决定抛弃垃圾 &lt;code&gt;windows&lt;/code&gt; 了，实在是 &lt;code&gt;TMD&lt;/code&gt; 卡的要死，但是以我电脑的配置，不可能卡的。加上 &lt;code&gt;C&lt;/code&gt; 盘的无理由暴增，&lt;code&gt;TMD&lt;/code&gt; 空间锐减，加上每次系统动不动更新，每次更新都 &lt;code&gt;TMD&lt;/code&gt; 出 &lt;code&gt;bug&lt;/code&gt; 直接卡死。我宁肯花一周的时间打造一款我的主力 &lt;code&gt;Arch Linux&lt;/code&gt; ，再 &lt;code&gt;TMD&lt;/code&gt; 也不向 &lt;code&gt;windows&lt;/code&gt; 低头了。以本文记录 &lt;code&gt;Arch Linux&lt;/code&gt; 的折腾全记录。&lt;/p&gt;
&lt;p&gt;包括：代理、终端、字体、换源更新、软件、甚至是博客迁移等。最重要的是，关于向这个世界的妥协，如何使安装 QQ、微信和 word 等非必要但深入人心的软件。毕竟老板让你微信给他发文件还是很常见的，毕竟老板没手没脚，发一次不接收必须发第 $N$ 次，毕竟他用 LaTeX 也要手动编号。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Computer" scheme="https://muyuuuu.github.io/tags/Computer/"/>
    
  </entry>
  
  <entry>
    <title>C++踩坑记录：构造与析构函数</title>
    <link href="https://muyuuuu.github.io/2021/07/21/constructor-and-destructor-with-inheritance/"/>
    <id>https://muyuuuu.github.io/2021/07/21/constructor-and-destructor-with-inheritance/</id>
    <published>2021-07-21T02:22:11.000Z</published>
    <updated>2021-07-21T20:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我是练习时长一年的 <code>C++</code> 个人练习生，喜欢野指针、模板报错和未定义行为（undefined behavior）。之前在写设计模式的『工厂模式』时，一脚踩到了构造、继承和 <code>new</code> 组合起来的坑，现在也有时间来整理一下了。</p><a id="more"></a><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>众所周知：在创建对象时，防止有些成员没有被初始化导致不必要的错误，在创建对象的时候自动调用构造函数（无声明类型），完成成员的初始化。即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c <span class="comment">// 隐式，默认构造函数</span></span><br><span class="line">Class c = Class() <span class="comment">// 显示，默认构造函数</span></span><br><span class="line">Class c = Class(<span class="string">"name"</span>) <span class="comment">// 显示，非默认构造函数 </span></span><br><span class="line">Class* c = <span class="keyword">new</span> Class <span class="comment">// 隐式，默认构造函数</span></span><br></pre></td></tr></table></figure><ul><li>构造函数执行前，对象不存在</li><li>构造函数创建对象后，对象不能调用构造函数</li><li>类中如果不定义构造函数，编译器提供有默认的构造函数，无参数，也不执行任何额外的语句</li><li>如果提供非默认构造函数，没有默认构造函数将会出错。所以要定义一个不接受任何参数的构造函数，并为成员定义合理的值</li><li>一般而言，默认的构造函数是用来对所有类成员做隐式初始化的</li><li>自己定义的构造函数一般用使用列表初始化来初始化参数</li><li>通过构造函数对成员赋值，要优于通过函数为成员赋值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by default creator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    Stone(<span class="keyword">int</span> w, <span class="keyword">double</span> r) : weight&#123;w&#125;, radius&#123;r&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by custom creator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;radius &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 隐式，成员有默认值</span></span><br><span class="line">    Stone s1;</span><br><span class="line">    s1.showInfo();</span><br><span class="line">    <span class="comment">// 显式，通过列表初始化，为成员赋值</span></span><br><span class="line">    Stone s2 = Stone(<span class="number">12</span>, <span class="number">3.3</span>);</span><br><span class="line">    s2.showInfo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过构造函数实现的类型转换"><a href="#通过构造函数实现的类型转换" class="headerlink" title="通过构造函数实现的类型转换"></a>通过构造函数实现的类型转换</h2><p>观察以下的代码，我们发现 <code>Stone s2;s2 = 3.3;</code> 这样将一个 <code>double</code> 类型的数据赋值给类类型并没有出错，这是隐式类型转换，从参数类型到类类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by default creator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 都关闭</span></span><br><span class="line">    Stone(<span class="keyword">double</span> r) : radius&#123;r&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by parameter radius"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stone(<span class="keyword">int</span> w) : weight&#123;w&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by parameter weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;radius &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Stone s2;</span><br><span class="line">    s2 = <span class="number">3.3</span>;</span><br><span class="line">    s2.showInfo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为：接受一个参数的构造函数允许使用赋值语法来为对象赋值。<code>s2=3.3</code> 会创建 <code>Stock(double)</code> 临时对象，临时对象初始化后，逐成员赋值的方式复制到对象中，在几个构造函数中加入了 <code>cout &lt;&lt; this</code> 的语句，由对象的地址不同，可以判断该赋值语句额外生成了临时对象。</p><p>为了防止隐式转换带来的危险，可以使用关键字 <code>explicit</code> 关闭这一特性，这样就得显式完成参数类型到类类型的转换：<code>s = Stock(1.3)</code>；不过，得保证没有二义性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by default creator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 都关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Stone</span><span class="params">(<span class="keyword">double</span> r)</span> : radius</span>&#123;r&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by parameter radius"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Stone</span><span class="params">(<span class="keyword">int</span> w)</span> : weight</span>&#123;w&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by parameter weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;radius &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Stone s2;</span><br><span class="line">    s2 = Stone(<span class="number">3</span>);</span><br><span class="line">    s2.showInfo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，如果 <code>Stone(int w)</code> 没有被关闭，那么 <code>s2=3.3</code> 将调用这一构造函数。所以构造函数建议都加上 <code>explicit</code> 声明。</p><h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h2><p>派生类要注意的是：派生类被构造之前，通过调用一个基类的构造函数，创建基类完成基类数据成员的初始化；也就是说，基类对象在程序进入派生类构造函数之前被创建。那么，可以通过初始化列表传递给基类参数，不传递的话，调用基类的默认的构造函数，如下述程序中的：<code>Gem(){}:Stone()</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This object was in address: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    Stone(<span class="keyword">int</span> w, <span class="keyword">double</span> r) : weight&#123;<span class="number">2</span>&#125;, radius&#123;r&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">    auto getRadius() -&gt; double &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gem</span> :</span> <span class="keyword">public</span> Stone &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Gem()&#123;&#125;;</span><br><span class="line">    Gem(<span class="keyword">double</span> p, <span class="keyword">int</span> w, <span class="keyword">double</span> r) : Stone(w, r), price&#123;p&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;getWeight() &lt;&lt; <span class="string">", Radius"</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;getRadius();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Gem g1; <span class="comment">// call default</span></span><br><span class="line">    Gem g2 = Gem(<span class="number">1300</span>, <span class="number">1</span>, <span class="number">2.3</span>); <span class="comment">// call custom </span></span><br><span class="line">    <span class="comment">// g.setWeight(130);</span></span><br><span class="line">    g2.show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先创建基类对象</li><li>派生类通过初始化列表（只能用在构造函数）将基类信息传递给基类的构造函数</li><li>派生类构造函数可以为派生类初始化新的成员</li></ul><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>对象过期时，程序会调用对象的析构函数完成一些清理工作，如释放变量开辟的空间等。如构造函数使用了 <code>new</code> 来申请空间，析构就需要 <code>delete</code> 来释放空间。如果没有特别声明析构函数，编译器会为类提供默认的析构函数，在对象作用域到期、被删除时自动被调用。</p><p>如 <code>stock1 = Stock()</code>，这种就申请了一个临时变量，变量消失时会调用析构函数。此外，这种局部变量放在栈区，先入后出，也就是，最后被申请的变量最先被释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This object was in address: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" Object was deleted."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Stone s1;</span><br><span class="line">        Stone s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承中的析构函数"><a href="#继承中的析构函数" class="headerlink" title="继承中的析构函数"></a>继承中的析构函数</h2><p>继承类比较容易理解，毕竟都学过面向对象。公有继承的时候，基类的公有成员也是派生类的共有成员；私有成员也是派生类的一部分，不过需要共有或保护方法来访问。但是但是但是，派生类和基类的析构函数之间，也是一个坑。在继承中：</p><ul><li>如果一个方法不是虚方法，那么将根据引用类型或指针类型选择执行的方法</li><li>如果一个方法是虚方法，将根据指针或引用指向对象的类型选择执行的方法</li></ul><p>在继承中，对象的销毁顺序和创建相反。创建时先创建基类，而后创建子类；销毁时，先调用子类的析构函数，而后自动调用基类的析构函数。因此，对于基类而言，建议将析构函数写成虚方法。如果析构不是虚方法，对于以下情况，只有基类的析构被调用；如果析构是虚方法，子类、基类的析构方法都被调用。可以尝试删除下述代码的 <code>virtual</code> 来观察结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This object was in address: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    Stone(<span class="keyword">int</span> w, <span class="keyword">double</span> r) : weight&#123;<span class="number">2</span>&#125;, radius&#123;r&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">    auto getRadius() -&gt; double &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stone class was deleted."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gem</span> :</span> <span class="keyword">public</span> Stone &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Gem() &#123;&#125;;</span><br><span class="line">    Gem(<span class="keyword">double</span> p, <span class="keyword">int</span> w, <span class="keyword">double</span> r) : Stone(w, r), price&#123;p&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;getWeight() &lt;&lt; <span class="string">", Radius"</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;getRadius();</span><br><span class="line">    &#125;</span><br><span class="line">    ~Gem() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Gem class was deleted."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Stone* s1 = <span class="keyword">new</span> Gem(<span class="number">2.3</span>, <span class="number">2</span>, <span class="number">3.2</span>);</span><br><span class="line">    <span class="keyword">delete</span> s1;</span><br><span class="line">    <span class="comment">// Gem* g1 = new Gem(2.3, 2, 1.2);</span></span><br><span class="line">    <span class="comment">// delete g1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>大概常见的坑在上面都记录好了，来看一段我写的危险的程序（我大概抽象了一下），覆盖了：野指针和为定义行为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()&#123;</span><br><span class="line">        <span class="keyword">delete</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">int</span>* b = a.create();</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>每次调用 create 都会 new 一次，但只 delete 了一次。</li><li>如果没有调用 create 直接析构，未定义行为</li><li>如果 b 持有了 a.create() 的指针，然后 a 提前析构，那么 b 是野指针</li><li>delete b 是没必要的。这样会 double free，也是未定义行为</li><li>上述代码没有区分类里面 new 且 返回的东西要在哪删除合适</li><li>可以让类来管理这一个 new，修改一下 create 的实现或者干脆在构造 new，在析构 delete</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是练习时长一年的 &lt;code&gt;C++&lt;/code&gt; 个人练习生，喜欢野指针、模板报错和未定义行为（undefined behavior）。之前在写设计模式的『工厂模式』时，一脚踩到了构造、继承和 &lt;code&gt;new&lt;/code&gt; 组合起来的坑，现在也有时间来整理一下了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++函数进阶：内联、重载和模板</title>
    <link href="https://muyuuuu.github.io/2021/07/18/cpp-advanced-function/"/>
    <id>https://muyuuuu.github.io/2021/07/18/cpp-advanced-function/</id>
    <published>2021-07-18T07:11:53.000Z</published>
    <updated>2021-07-18T22:07:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++ 细节逐步填坑中，还有几个大坑预计 8 月前结束。普通的函数没啥意思了，本文涉及函数的进阶使用，包括：函数的默认参数、内联函数、函数重载和函数模板。</p><a id="more"></a><h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><p>也就是某些教材上常说的函数声明，如果没有函数原型，那么函数首次使用前出现的整个函数定义充当了函数原型。函数由三部分组成：</p><ul><li>函数原型，约定好返回值的类型与接受参数的类型。这就描述了函数到编译器的接口，将参数类型和数量提前告知编译器。这样当函数的返回值放到某个寄存器时，编译器也知道检索多少个字节来解释返回值。如果不告知函数原型，<code>main</code> 函数的编译只能终止然后去寻找函数原型，这样会导致效率不高，甚至有些文件没有搜索的权限，这样会报错。而 <code>C++</code> 的编程风格，习惯将 <code>main</code> 函数放在前面，这样更需要函数原型。</li><li>函数定义，函数头 + 函数体，实现完整的函数功能。</li><li>函数调用，主函数调用子函数完成功能。</li></ul><p>因此，函数原型有以下的作用：</p><ul><li>正确处理函数的返回值</li><li>检查参数的数目、类型是否正确；如果不正确，尽可能转换为正确类型</li></ul><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>常规函数和内联函数的<strong>主要区别</strong>不在于编写方式不同，更多的是程序组合到程序中的方式不同。</p><ul><li><p>对于普通函数而言，程序在执行到函数调用指令时，存储当前指令的地址（保护现场），将函数参数复制到堆栈帧，跳转到子函数起始的内存地址，执行子函数，执行的临时变量放入堆栈帧。执行完毕后，跳回指令被保存的地址处（恢复现场），继续往下执行。使用子函数会造成来回的记录和跳转，造成一定的开销。</p></li><li><p>内联函数会代替函数调用，内联函数直接被插入到主函数中，这样就无需跳转而是顺序执行。执行速度快，但是需要更大的内存。</p></li></ul><blockquote><p>如果函数执行的时间远大于跳转时间，则内联函数的意义不大；如果代码执行时间很短，且需要多次调用，那么内联调用会节省很多时间；如果节省的时间所占执行的时间并不大，或者很少调用，则不需要内联函数。注意，内联函数不能递归。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a&#123;<span class="number">12.3</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="built_in">sqrt</span>(a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p>这个倒是不难，就是为一些参数提供默认值。如果一个参数有默认值，那么，它右边的参数必须也要有默认值，且赋值的时候不允许跳过。按照 <code>main</code> 函数放前面这样的编程风格来试一下，默认值在函数原型中提供，函数定义不需要，否则报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span> a=<span class="number">1</span>, <span class="keyword">int</span> b=<span class="number">2</span>, <span class="keyword">int</span> c=<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d&#123;<span class="number">12</span>&#125;, e&#123;<span class="number">13</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">11</span>&#125;;</span><br><span class="line">    show_info(d, e, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="string">" "</span> &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>对于一个打印函数 <code>print</code> ，可能传入 <code>int</code> 类型的数据，也可能传入 <code>double</code> 类型的数据，这个时候就需要函数重载。函数重载的重点是函数的特征标，也就是函数的参数列表，也就是参数的数目、类型和排列顺序。比如可以这样重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> str, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> str, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a&#123;<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> b&#123;<span class="number">1.23</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"void"</span>;</span><br><span class="line">    print(str, <span class="number">1</span>);</span><br><span class="line">    print(a, <span class="number">1</span>);</span><br><span class="line">    print(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果调用函数出现了未匹配的类型，很可能错误，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a&#123;<span class="number">12</span>&#125;;</span><br><span class="line">print(a, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><code>double</code> 和 <code>int</code> 都可以接受 <code>unsigned int</code> 的参数，二义性的程序会导致错误。</p><h2 id="const-重载"><a href="#const-重载" class="headerlink" title="const 重载"></a>const 重载</h2><p><code>const</code> 可以构成重载，不过只能是指针，非指针不构成重载。这也很容易理解，对于非指针而言，<code>const</code> 或非 <code>const</code> 都不重要，因为原数据无法修改，因此不构成重载；指针则不一样，<code>const</code> 表示原数据或指针不修改，非 <code>const</code> 表示原数据或指针任意修改。这是两个含义的特征标，因此可以构成重载。而编译器根据实参是否为 <code>const</code> 来决定匹配的原型函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>* a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="string">"---"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="string">"==="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* a = &amp;p;</span><br><span class="line">    *a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* b = &amp;p;</span><br><span class="line">    print(a);</span><br><span class="line">    print(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>void print(const int* a)</code> 这样的函数，如果没有重载，那么这个函数是可以接收非 <code>const</code> 数据的。</p><blockquote><p>此外，对于没有任何参数的函数，且不希望函数修改任何变量，可以将 <code>const</code> 关键字放到函数括号的后面。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用重载"><a href="#引用重载" class="headerlink" title="引用重载"></a>引用重载</h2><p>引用无法构成重载，因为无论是否引用，都可以接收参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>&amp; x)</span></span></span><br></pre></td></tr></table></figure><p>但是引用加上 <code>const</code>，含义改变，就可以重载。而对于引用的重载，调用最为匹配的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>&amp; x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 右值引用，没有的话就调用 print(const double&amp; x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>&amp;&amp; x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> x</span>&#123;<span class="number">33.3</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> y&#123;<span class="number">12.3</span>&#125;;</span><br><span class="line">print(x);      <span class="comment">// print(double&amp; x)</span></span><br><span class="line">print(y);      <span class="comment">// print(const double&amp; x)</span></span><br><span class="line">print(x + y);  <span class="comment">// print(double&amp;&amp; x)</span></span><br></pre></td></tr></table></figure><h2 id="如何实现重载"><a href="#如何实现重载" class="headerlink" title="如何实现重载"></a>如何实现重载</h2><p><code>C++</code> 通过名称修饰来跟踪重载函数，根据函数原型的函数特征标对函数进行加密。也就是根据特征标对函数进行编码，在函数上添加一组符号后，函数换了个名字作为自己的内部表示，不同特征标的函数名也不一样，不过使用者看不到这一层。具体如何修饰，这取决于编译器。</p><p>重载诱人，但使用时一定要注意类型，只有用相同的形式处理不同类型的数据，才会考虑重载。</p><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>模板比重载还要更省事一点。使用泛型来定义函数，也就是，类型作为参数传递给模板代码，编译器生成指定类型的函数。也就是说，模板通过泛型（参数化类型）来解决任务。使用背景一般是：同一算法需要处理多种类型的参数。</p><p>重载也可以完成这些任务，比如说要交换两个同类型的数，<code>int, double, float, const, char, str, vector</code> 等等等等，重载可以，但是写很多遍会很累。</p><p>模板例子：使用 <code>template &lt;typename T&gt;</code> 来建立模板，编译器检查传入的类型参数，生成相应的函数以供执行。程序员看不到生成的代码，但代码确实被生成以及被使用。且最终生成的代码不包含模板，只包含为程序生成的实际代码。如下所示的模板，交换任意简单类型的数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a&#123;<span class="number">1.2</span>&#125;, b&#123;<span class="number">2.1</span>&#125;;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> c&#123;<span class="number">1</span>&#125;, d&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    swap(c, d);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">" "</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般而言，对不同类型使用相同算法会考虑模板。但是，不是所有类型用相同的算法都能实现，比如，对象、数组等会涉及深浅拷贝、地址等，并不像简单数据类型那样容易处理。</p><p>举个例子，以交换函数而言，如果是数值类型，就交换；如果是数组类型，交换前 2 个元素；如果是类，有的成员交换有的成员不交换。总之，模板具有局限性，判断相等时，数组不能直接用等号。所以编写的模板很可能无法处理某些类型，大概有两种解决方案：</p><ul><li>在类中重载运算符，如大小、相等的比较；</li><li>为特定类型提供具体化的模板定义</li></ul><p>但是这部分坑准备留在类的重载运算符、移动语义和深浅拷贝之后了，方便对比。</p><h2 id="模板重载"><a href="#模板重载" class="headerlink" title="模板重载"></a>模板重载</h2><p>如果重载模板，函数的特征标同样不能相同。注意，泛型并不是所有参数都得是模板参数类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T a[], T b[], <span class="keyword">int</span> i = <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a&#123;<span class="number">1.2</span>&#125;, b&#123;<span class="number">2.1</span>&#125;;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">4</span>] = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    swap(c, d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c[i] &lt;&lt; <span class="string">" &lt;=&gt; "</span> &lt;&lt; d[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T a[], T b[], <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    T t[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        t[j] = a[j];</span><br><span class="line">        a[j] = b[j];</span><br><span class="line">        b[j] = t[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板的发展"><a href="#模板的发展" class="headerlink" title="模板的发展"></a>模板的发展</h2><p>在 <code>C++98</code> 中，编写模板函数时会一个问题，不知道该声明为哪一种类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T1 x, T2 y)</span> </span>&#123;</span><br><span class="line">    z = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的 <code>z</code> 是什么类型呢？而 <code>C++11</code> 新增的关键字 <code>decltype</code> 提供了解决方案，按照给定的 <code>expression</code> 类型创建指定类型的变量，即 <code>decltype (x) y</code>，<code>y</code> 和 <code>x</code> 同类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x&#123;<span class="number">12.3</span>&#125;;</span><br><span class="line">    <span class="keyword">decltype</span> (x) y;</span><br><span class="line">    <span class="comment">// d</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(y).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么上述模板代码就有了解决方案。而 <code>decltype (expr) var</code> 为确定 <code>var</code> 的类型，遍历一个核对表，只要有一项匹配，那么类型确定完毕，不用在判断后面的。</p><ol><li><code>expr</code> 是一个没有括号标识符，那么 <code>var</code> 与 <code>expr</code> 相同；</li><li><code>expr</code> 是一个函数，<code>var</code> 与函数返回值类型相同；</li><li>如果 <code>expr</code> 是一个左值，<code>var</code> 为 <code>expr</code> 类型的引用，以 <code>double</code> 为例， <code>decltype ((x)) y</code>，<code>y</code> 就是 <code>double</code> 类型的引用；</li><li>如果不满足以上，那么 <code>expr</code> 与 <code>var</code> 同类型，如 <code>int&amp; x, int&amp; y, decltype (x+y) z</code>，<code>z</code> 是 <code>int</code> 类型，不是引用类型；</li></ol><p>但是尽管解决了函数中对变量类型的赋值，但是没有解决模板返回值的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">? gt (T1 x, T2 y)</span><br></pre></td></tr></table></figure><p>函数的返回值类型和 <code>T1</code> 和 <code>T2</code> 相关，但是要运算后才知道。但是返回值区域， <code>x,y</code> 还不在作用域内就无法使用，这就成了先有鸡还是先有蛋的问题，那么如何提前知道运算结果的类型呢？即使在函数内部知道了返回值类型，也没办法反馈到函数的声明中。</p><p>这个可以通过后置返回值类型 (tailing return type) 可以实现，写法：<code>auto f1(int x, float y) -&gt; double</code>，对应到函数声明，写法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto f1(T1 x, T2 y) -&gt; decltype(x + y)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ 细节逐步填坑中，还有几个大坑预计 8 月前结束。普通的函数没啥意思了，本文涉及函数的进阶使用，包括：函数的默认参数、内联函数、函数重载和函数模板。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的引用</title>
    <link href="https://muyuuuu.github.io/2021/07/15/Cpp-refer/"/>
    <id>https://muyuuuu.github.io/2021/07/15/Cpp-refer/</id>
    <published>2021-07-15T14:49:24.000Z</published>
    <updated>2021-07-17T09:08:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>引用是 C++ 中一个比较神奇的东西。在这之前或者说 C 语言中，一般是使用指针来减少传参所带来的不必要的开销。如函数传递的参数是数组或结构体时，使用指针会省很多事，毕竟传递的是地址。而 C++ 中引用变量的主要用途也是函数传参，子函数直接操作原始数据，而不是其副本，这样处理大型数据结构也会佷便捷。</p><a id="more"></a><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>以一维数组为例。众所周知数组名是是数组首元素的地址。因此调用子函数时，主函数传递的是数组首元素的地址，所以子函数接收的是地址，无法预知数组的长度，需要增加额外的参数指明数组元素的数量。</p><p>对于函数，一般用 <code>int arr[]</code> 这样的形式指明 <code>arr</code> 接收的是数组，这样的可读性强；换一种方法，因为传递的是数组首元素的地址，而数组首元素为 <code>int</code> 类型，地址是 <code>int*</code> 类型，因此可以用 <code>int* arr</code> 来接收一个数组，但是这样表意不明确。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        t += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    sum(arr, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>升级到二维数组，二维数组的类型本质就是指向『多个 <code>int</code> 组成的数组』的指针，因此参数的形式为 <code>int (*arr)[4]</code>，而不是 <code>int* arr[4]</code>。</p><ul><li>前者是一个『由 4 个指向 int 的指针』组成的数组；即一个数组，数组元素是四个 int 指针；</li><li>后者是一个指向『由 4 个 int 组成数组』的指针；即一个指针，指向 4 个 int 的数组。为了更好的可读性，一般声明如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">4</span>], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            t += arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 数组有三个元素，每个元素是数组</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line">    sum(arr, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>二维数组的指针是不是感觉有点晕？先来看一下简单的引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a&#123;<span class="number">11</span>&#125;;</span><br><span class="line"><span class="comment">// 类型是 int&amp;，指向 int 的引用</span></span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br></pre></td></tr></table></figure><p>这样 <code>b</code> 和 <code>a</code> 就指向了相同的值和内存单元，只是名字不一样。此外，引用必须在声明的时候进行初始化，否则这个变量不知道指向哪个内存单元和值，但是指针可以先声明在赋值。</p><p>此外，声明一旦绑定，就无法在修改。可以通过初始化声明来设置引用，不能通过赋值来设置。如下所示的程序，只是对引用 <code>b</code> 进行了赋值，而不是修改引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a&#123;<span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line"><span class="keyword">int</span> c&#123;<span class="number">32</span>&#125;;</span><br><span class="line">b = c;</span><br></pre></td></tr></table></figure><h2 id="引用传参"><a href="#引用传参" class="headerlink" title="引用传参"></a>引用传参</h2><p>回到主题，一般将引用用做函数传参时。主函数中的变量名是被调用函数中对应变量的别名，在调用时用实参初始化形参，因此引用参数被初始化为：函数调用时传递过来的实参。如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n1&#123;<span class="number">12</span>&#125;, n2&#123;<span class="number">21</span>&#125;;</span><br><span class="line">swap(n1, n2);</span><br></pre></td></tr></table></figure><p>此外，传递引用时对类型的限制更加严格，以求和函数为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">12</span>&#125;;</span><br><span class="line"><span class="comment">// 临时变量</span></span><br><span class="line">sum(a);</span><br><span class="line">sum(<span class="number">6.2</span>);</span><br><span class="line"><span class="comment">// 临时变量</span></span><br><span class="line">sum(a + <span class="number">6.3</span>);</span><br></pre></td></tr></table></figure><p>换句话说，当实参和形参的类型不匹配时，将会生成临时变量传给形参。但是引用则不行，限制相对严格，<code>sum(a + 6.3)</code> 会报错，传递的实参是表达式不是变量，而引用不能绑定到表达式上，且此时不会生成临时变量。</p><p>但是当参数为 const 引用时，会创建一个临时的无名变量，临时变量的值初始化为 <code>a + 6.3</code>，而后再将无名变量赋给引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a&#123;<span class="number">10</span>&#125;;</span><br><span class="line">    sum(a + <span class="number">6.3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许你会有疑问，这个时候为什么会生成临时变量？<code>const</code> 为什么合理呢？如果引用参数是 <code>const</code>，两种情况会生成临时变量：</p><ul><li>实参类型正确，但不是左值，如 <code>a + 6.3</code> 这样的表达式</li><li>实参类型不正确，但可以转为正确类型，如 <code>int</code> 隐式转换为 <code>double</code>；<code>double</code> 到 <code>int</code> 则错误</li></ul><blockquote><p>左值：左值是可以被引用的数据对象，变量、数组、元素等，非左值有字面常量，多项的表达式等。或者说，可以放在赋值语句左侧 and 能访问地址的就是左值，也就是说，赋值语句左侧是可修改的内存块，const 变量也是左值，只是不可修改。</p></blockquote><p>回到原问题，如果形参加上 <code>const</code> 修饰，意思是函数只使用这个值，不修改这个值。即使因类型不匹配生成了临时变量，引用参数引用这个临时变量，都不会造成任何不好的副作用。但此时就是值传递而不是地址传递，因为要用临时变量来存储数值。所以也推荐尽可能使用 <code>const</code>：</p><ul><li>避免无意修改数据造成结果错误</li><li>能更好的接收实参，生成并使用临时变量</li></ul><h2 id="返回值为引用"><a href="#返回值为引用" class="headerlink" title="返回值为引用"></a>返回值为引用</h2><p>对于传统的调用函数而言，返回结果的这个值被复制到临时位置，也就是产生值的副本，调用程序将使用这个值。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    len += <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// len 复制到临时位置</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">// 从临时位置获取值</span></span><br><span class="line">a = sum(a);</span><br></pre></td></tr></table></figure><p>而返回引用的函数实际上是返回被引用变量的别名。返回引用值时，并不产生值的副本。而是将返回值直接复制给接收函数的变量或对象，言简意赅，当函数返回引用类型时，没有复制返回值创建临时变量，相反，返回的是对象本身，并复制到接收变量那里。</p><p>对于一个大型的数据结构如结构体，将结构体复制到额外的地址的开销会很大；如果返回引用，将返回的引用的结构体直接赋值给接收值，避免额外的开销。</p><p>但是，避免返回指向临时变量的引用，临时变量在执行完毕后会消失，引用会指向乱七八糟的地址，就跟避免指向临时变量的指针一样。有两种解决方法：</p><ul><li>使用 new，将数据放到堆区，不过内存模型的坑准备后续开</li><li>传递一个额外的参数，传递给函数的引用，将该参数返回。因此返回引用时，要求在函数的参数中，包含有以引用方式需要被返回的参数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">double</span> value&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 返回变量 t 的引用</span></span><br><span class="line"><span class="function">node&amp; <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len, node&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        n.value += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    node t;</span><br><span class="line">    <span class="comment">// a 被 t 的引用给赋值</span></span><br><span class="line">    node a = sum(<span class="number">5</span>, t);</span><br><span class="line">    <span class="comment">// 修改 a 不会修改 t</span></span><br><span class="line">    a.value = <span class="number">13.2</span>;</span><br><span class="line">    <span class="comment">// a 是 t 的引用，修改 a 也会修改 b</span></span><br><span class="line">    <span class="comment">// node&amp; a = sum(5, t);</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.value &lt;&lt; <span class="string">" "</span> &lt;&lt; t.value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，非引用函数的返回值类型是右值，这种语句位于表达式的右侧，也无法通过地址访问这个值，也无法放到复制语句的左侧。因为返回值的地址在执行完毕后就消失了，也就是说无法引用。如果一定要引用返回值，将返回值类型声明为引用，这样返回的就是左值，就可以引用。</p><p>总结一下：当返回结果需要做为左值时，就要用引用返回。即重载函数的返回结果需要出现在赋值语句左边时，必须用引用返回。如果不用引用返回，那么重载函数的返回结果会是一个临时变量，临时变量是不能放在赋值语句左边的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误，右值不能在赋值语句左侧</span></span><br><span class="line"><span class="function">node <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len, node&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        n.value += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">5</span>, t).value = <span class="number">12.3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t.value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，返回的引用是左值</span></span><br><span class="line"><span class="function">node&amp; <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len, node&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        n.value += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">5</span>, t).value = <span class="number">12.3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t.value;</span><br></pre></td></tr></table></figure><p>如果不想返回的引用被修改，就加 <code>const</code> 修饰：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">double</span> value&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 返回变量 t 的引用</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> node&amp; <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len, node&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        n.value += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    node t;</span><br><span class="line">    <span class="comment">// 将 t 引用的值赋值给 a，所以可以修改 a</span></span><br><span class="line">    node a = sum(<span class="number">5</span>, t);</span><br><span class="line">    a.value = <span class="number">13</span>;</span><br><span class="line">    <span class="comment">// b 引用 t，不可修改</span></span><br><span class="line">    node&amp; b = sum(<span class="number">5</span>, t);</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    b.value = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引用是 C++ 中一个比较神奇的东西。在这之前或者说 C 语言中，一般是使用指针来减少传参所带来的不必要的开销。如函数传递的参数是数组或结构体时，使用指针会省很多事，毕竟传递的是地址。而 C++ 中引用变量的主要用途也是函数传参，子函数直接操作原始数据，而不是其副本，这样处理大型数据结构也会佷便捷。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>python __init__.py 文件的用法</title>
    <link href="https://muyuuuu.github.io/2021/07/11/python-init-file/"/>
    <id>https://muyuuuu.github.io/2021/07/11/python-init-file/</id>
    <published>2021-07-11T11:09:07.000Z</published>
    <updated>2021-07-11T20:14:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近 <code>rush</code> 代码遇到一些问题，如一种典型的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-main/</span><br><span class="line">|----test1/</span><br><span class="line">|--------module1.py</span><br><span class="line">|----test2/</span><br><span class="line">|--------module2.py</span><br></pre></td></tr></table></figure><p>如上，想在 <code>module2.py</code> 中调用 <code>module1.py</code> 中的某个类，如果在 <code>module2.py</code> 中写：<code>from ..test1 import module1</code>，在 <code>test2</code> 文件夹下执行 <code>python module2.py</code> 会提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: attempted relative import with no known parent package</span><br></pre></td></tr></table></figure><p>会遇到这样的错误。那么，如何解决呢？如果你只想看如何解决问题，直接翻到文末即可；网上大概搜了一下，需要 <code>__init__.py</code> 来解决下这个问题，但是网上搜了一圈，没啥写的特别好的教程，实在是烂的可以，特此来填坑。</p><a id="more"></a><h1 id="init-py-是什么-1"><a href="#init-py-是什么-1" class="headerlink" title="__init__.py 是什么 1"></a>__init__.py 是什么 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h1><p>假设此时的路径结构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-main/</span><br><span class="line">|----__init__.py</span><br><span class="line">|----test1/</span><br><span class="line">|--------__init__.py</span><br><span class="line">|--------module1.py</span><br><span class="line">|----test2/</span><br><span class="line">|--------__init__.py</span><br><span class="line">|--------module2.py</span><br></pre></td></tr></table></figure><p>在 <code>test1</code> 目录下的 <code>__init__.py</code> 中写入：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'module1 was called'</span>)</span><br></pre></td></tr></table></figure><p>在 <code>test2</code> 目录下的 <code>__init__.py</code> 中写入：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'module2 was called'</span>)</span><br></pre></td></tr></table></figure><p>在 <code>main</code> 目录下的 <code>__init__.py</code> 中写入：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'parent package was called'</span>)</span><br><span class="line"><span class="comment"># 导入 [] 里面定义的模块</span></span><br><span class="line">__all__ = [<span class="string">'test1'</span>, <span class="string">'test2'</span>]</span><br></pre></td></tr></table></figure><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>通俗来说，<code>__init__.py</code> 可以将文件封装成包，将多个文件合并到一个逻辑命名空间。但是这么说太突兀了，由浅入深，一点一点来。先来看看文件夹中添加 <code>__init__.py</code> 会发生什么。假设此时的路径为 <code>main</code> 文件夹下，尝试导入模块，会发现上述信息被打印：</p><p><img data-src="https://z3.ax1x.com/2021/07/11/WCmmuT.png" alt></p><p>同理，在 <code>main</code> 文件夹的 <strong>上一级路径</strong> 下执行导入，也会有同样的效果，但是不会导入子模块。</p><p><img data-src="https://z3.ax1x.com/2021/07/11/WCm05d.png" alt></p><p>如果想导入单个子模块，可以 <code>import main.test1</code>，此时会打印 <code>module1 was called</code>；如果再次调用 <code>import main.test1</code>，也就是在模块已经导入的情况下再次导入，则不会打印任何信息。</p><p>如果导入全部子模块，也是可以的。因为声明了 <code>__all__</code>，所以子模块被导入。</p><p><img data-src="https://z3.ax1x.com/2021/07/11/WCmyxP.png" alt></p><p>但是你也许会有疑问，我经常写 <code>import math</code>，而 <code>math.sin</code> 等函数是导入的，且可以使用，为什么这里就不行了呢？如果想行，也是可以的，只需要在 <code>main</code> 目录下的 <code>__init__.py</code> 中写入以下信息就可以了，也就是 <code>import main; main.test1</code> 可用。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'parent package was called'</span>)</span><br><span class="line"><span class="comment"># 删除 __all__</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> test1</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> test2</span><br></pre></td></tr></table></figure><p>通过以上例子，我们可以看出，<code>__init__.py</code> 会起到以下作用：</p><ul><li>导入模块时初始化一些信息，如 <code>web</code> 项目中，启动 <code>session</code> 等</li><li>在父目录中，导入多个子模块</li></ul><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>也许你会觉得以上功能比较弱，或者说没啥用。那么来看一些实用的简化工作量的写法 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 。此时的目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├─ main.py</span><br><span class="line">└─ network</span><br><span class="line">       ├─ __init__.py</span><br><span class="line">       ├─ msg</span><br><span class="line">       │    └─ info</span><br><span class="line">       │           └─ send.py</span><br><span class="line">       └─ parse.py</span><br></pre></td></tr></table></figure><p>在 <code>send.py</code> 中，定义如下函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'send:'</span>, msg)</span><br></pre></td></tr></table></figure><p>如果想在 <code>main.py</code> 中调用这个函数，需要以下写法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> network.msg.info <span class="keyword">import</span> send</span><br><span class="line">send.send_msg(<span class="string">'hello'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># from network.msg.info.send import send_msg</span></span><br><span class="line"><span class="comment"># send_msg('hello')</span></span><br></pre></td></tr></table></figure><p>但无论那种方法，都要写长长的路径，甚为不便。这个时候，我们可以在 <code>network</code> 文件夹下面创建一个 <code>__init__.py</code> 文件，并在里面填写如下内容：<code>from .msg.info.send import send_msg</code>。而 <code>main.py</code> 文件中的内容可以修改为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> network <span class="keyword">import</span> send_msg</span><br><span class="line">send_msg(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure><p>是不是简短了很多。这是因为，当一个文件夹里面有 <code>__init__.py</code> 以后，这个文件夹就会被 <code>python</code> 作为一个包 <code>package</code> 来处理。此时，对于这个包里面层级比较深的函数、常量、类，我们可以先把它们导入到 <code>__init__.py</code> 中。这样以来，包外面再想导入这些内容时，就可以用 <code>from 包名 import 函数名</code> 来导入了。</p><p>这样做有很多好处，由于调用包的其他模块所在的绝对路径是千变万化的，当有一些代码会在很多地方被使用时，我们可以把这些代码打包起来，作为一个公共的接口提供给其他模块调用，这会方便很多。</p><p>所以在<strong>包的内部</strong>调用自身其他文件中的函数、常量、类，就不应该使用相对路径，而是绝对路径。这里以添加新功能为例，如下所示，在 <code>parse.py</code> 文件中添加以下内容：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两种都可以</span></span><br><span class="line"><span class="comment"># from .msg.info.send import send_msg</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> send_msg</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_msg</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'parse:'</span>, msg)</span><br><span class="line">    send_msg(msg)</span><br></pre></td></tr></table></figure><p>可以看到，在包里面的一个文件调用这个包里面的另一个文件，只需要知道另一个文件的相对位置就可以了，不用关心这个包被放在哪里。上 面<code>parse.py</code> 中导入 <code>send_msg</code> 函数的代码还可以进一步简化，由于 <code>send_msg</code> 函数已经被导入到了 <code>__init__.py</code> 中，所以我们可以直接从 <code>.</code> 里面导入 <code>send_msg</code> 函数。</p><p>之后在 <code>__init__.py</code> 中追加：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .parse <span class="keyword">import</span> parse_msg</span><br></pre></td></tr></table></figure><p>此时，<code>main.py</code> 的写法可以如下，可以看到，即使追加了新的模块，<code>main.py</code> 调用起来也会很方便，并不需要知道 <code>parse_msg</code> 这个方法的任何位置信息。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> network <span class="keyword">import</span> parse_msg</span><br><span class="line">parse_msg(<span class="string">'hhh'</span>)</span><br></pre></td></tr></table></figure><p>此外，当一个文件夹里面包含 <code>__init__.py</code> 时，这个文件夹会被 <code>python</code> 认为是一个包 <code>package</code>，此时，包内部的文件之间互相导入可以使用相对导入，并且通过提前把函数、常量、类导入到 <code>__init__.py</code> 中再在其他文件中导入，可以精简代码。</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>既然了解了 <code>__init__.py</code> 的用法，那么去解决文章最开始提到的问题。目录结构如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">├─ main.py</span><br><span class="line">├─ test1</span><br><span class="line">│    ├─ __init__.py</span><br><span class="line">│    └─ m1.py</span><br><span class="line">└─ test2</span><br><span class="line">       └─ m2.py</span><br></pre></td></tr></table></figure><p>实现的想法也很简单，<code>m2.py</code> 调用 <code>m1.py</code> 中的函数。</p><p><code>m1.py</code> 定义如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure><p><code>m2.py</code> 定义如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> m1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    m1.send(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure><p>距离成功只差一步，那就是修改 <code>test1</code> 中的 <code>__init__.py</code> 的内容，把 <code>test1</code> 看成一个 <code>package</code>，暴露其中的 <code>m1</code> 即可。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> m1</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># from . import m1</span></span><br></pre></td></tr></table></figure><p>这样，在外部的 <code>main</code> 函数中：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test2.m2 <span class="keyword">as</span> m2</span><br><span class="line">m2.run()</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># from test2 import m2</span></span><br><span class="line"><span class="comment"># m2.run()</span></span><br></pre></td></tr></table></figure><p>就可以了。</p><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">https://zhuanlan.zhihu.com/p/130927618</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">https://www.kingname.info/2020/03/23/init-in-python/</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近 &lt;code&gt;rush&lt;/code&gt; 代码遇到一些问题，如一种典型的结构&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;|-main/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|----test1/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|--------module1.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|----test2/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|--------module2.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如上，想在 &lt;code&gt;module2.py&lt;/code&gt; 中调用 &lt;code&gt;module1.py&lt;/code&gt; 中的某个类，如果在 &lt;code&gt;module2.py&lt;/code&gt; 中写：&lt;code&gt;from ..test1 import module1&lt;/code&gt;，在 &lt;code&gt;test2&lt;/code&gt; 文件夹下执行 &lt;code&gt;python module2.py&lt;/code&gt; 会提示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ImportError: attempted relative import with no known parent package&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;会遇到这样的错误。那么，如何解决呢？如果你只想看如何解决问题，直接翻到文末即可；网上大概搜了一下，需要 &lt;code&gt;__init__.py&lt;/code&gt; 来解决下这个问题，但是网上搜了一圈，没啥写的特别好的教程，实在是烂的可以，特此来填坑。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="https://muyuuuu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>对抗训练篇：MART 防御算法论文笔记</title>
    <link href="https://muyuuuu.github.io/2021/06/22/MART/"/>
    <id>https://muyuuuu.github.io/2021/06/22/MART/</id>
    <published>2021-06-22T13:26:54.000Z</published>
    <updated>2021-07-22T09:20:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MART(Misclassification Aware adveRsarial Training) 是 2020 年提出的最好的对抗防御算法。传统对抗训练算法中 min-max 时不会考虑当前样本是否被正确分类，统一制作对抗样本。而作者抓住了这一点，发现对于 max 制作对抗样本期间没有被网络正确分类的样本，对结果的影响很大。换句话说，<strong>网络连干净样本都不认识，何谈认识它的对抗样本？</strong> MART 算法的创新点在于区别对待错分类和正确分类的样本。</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>MART 防御的仍然是微小扰动的图像，也就是人眼察觉不出来的那种。论文用$p$ 范数满足这一限制：$\Vert x’-x \Vert_p \leq \epsilon$。对抗训练可以视为使用对抗样本进行数据增强，解决的是以下优化问题：</p><p>\begin{equation}<br>\min_\theta \frac{1}{n} \sum_{i=1}^{n} \max_{\Vert x’-x \Vert_p \leq \epsilon} L(h_\theta(x_i’), y_i)<br>\end{equation}</p><p>$n$ 是一个 batch 的大小，$L$ 是分类的损失函数。内部通过最大化损生成对抗样本，外部最小化对抗样本的分类损失来训练更好的 DNN，如 <a href="https://muyuuuu.github.io/2021/04/26/DNN-safe-basic/">PGD</a> 就是使用的这种方案。</p><p>而本文的关注点在对抗训练的对抗样本上，其实许多对抗训练算法忽略了一点，有些样本被正确分类，有些样本被错误分类，但无论哪种样本，都在 min-max 中直接制作对抗样本。因此本文也就抛出例如下疑问：</p><blockquote><p>由错分类样本和正确分类的样本产生的对抗样本，对模型的鲁棒性贡献程度是一样的吗？如果不是，如何利用这个差异，来提升模型的鲁棒性？</p></blockquote><p>本文针对这个被忽略的一点做了一些探索，发现被错分类和正确分类的样本对最终模型的鲁棒性的确有不同的影响。</p><p>本文做了这样的实验，在 CIFAR-10 数据集上做白盒攻击，扰动值 $\epsilon=8/255$。使用 PGD-10 算法制作对抗样本，以对抗训练的形式训练得到的网络的准确率是 87%。然后选择被错分类的样本记为 $S^-$，在选择被正确分类的样本记为 $S^+$。之后使用这两类样本，用不同的方式训练上述网络，最后用 PGD-20 算法制作的对抗样本评估最终模型的鲁棒性。结果如下图所示：</p><p><img data-src="https://z3.ax1x.com/2021/06/22/RmVckj.png" alt></p><p>在图 a 中：错分类样本对鲁棒性有明显影响。</p><ol><li>蓝色的线是标准对抗训练的对抗鲁棒性</li><li>绿色的线表示没有对 $S^-$ 制作对抗样本，其它样本仍然是对抗样本，鲁棒性降低很大；</li><li>橙色的线表示没有对 $S^+$ 制作对抗样本，其它样本仍然是对抗样本，鲁棒性变换其实不大。</li></ol><p>图 b 中：为了更深理解『错分类样本和其它样本』的影响是不同的，外部 min 采用交叉熵，内部 max 采用攻击强度很弱的 <a href="https://muyuuuu.github.io/2021/04/26/DNN-safe-basic/">FGSM</a> 算法：</p><ol><li>蓝色的线是标准对抗训练的对抗鲁棒性</li><li>绿色的线表示在 $S^-$ 上产生的对抗样本对鲁棒性几乎没有提升。这可以说明不同的 max 方法在 $S^-$ 上会对模型鲁棒性有不同程度的影响。然而，</li><li>橙色的线表示，低强度的攻击算法在 $S^+$ 上制作的对抗样本会使鲁棒性退化。</li></ol><p>图 c 中，内部 max 选择 PGD-10 算法，外部 min 尝试不同的函数。发现对错分类的样本使用不同的 min 方法，对最终鲁棒性的结果影响也很大。</p><ol><li>蓝色的线是，对传统对抗训练，外部 min 使用交叉熵函数</li><li>绿色的线是，对错分类样本添加额外的 KL 散度作为正则化项，鲁棒性有明显的提升</li><li>绿色的线是，将同样的 KL 散度作为正则化项添加到正确分类的样本上，鲁棒性也有提升，但不如绿色的线明显。</li></ol><p>基于以上实验发现，论文考虑了错分类样本对鲁棒性的影响，提出了一个新的防御算法，以一种动态的方式实现对抗训练。主要贡献是：</p><ul><li>研究了错分类和正确分类的样本对『对抗训练』最终鲁棒性的影响，结果表明，在 min-max 框架下，对错分类样本的处理对模型最终鲁棒性的影响佷大，且 min 方法比 max 方法更为关键。</li><li>提出一种正则化的对抗风险，将错误分类的样本做显式区分，作为正则化项添加到损失函数中。</li></ul><h1 id="MART-算法"><a href="#MART-算法" class="headerlink" title="MART 算法"></a>MART 算法</h1><p>临时通知一周后期末考试，去准备期末考试了，考完了回来填坑。其实这个算法的缺陷显而易见，可以尝试往 GAN 那边走一走。考完了，回来填坑。</p><h2 id="前期定义"><a href="#前期定义" class="headerlink" title="前期定义"></a>前期定义</h2><p>对于一个 $K$ 分类问题，给定数据集 $(x_i,y_i)$，深度模型 $h_\theta$，对于每个样本而言，网络的输出如下：</p><p>\begin{equation}<br>\begin{aligned}<br>h_\theta(x_i) &amp;= \arg \max p_k(x_i, \theta) \\<br>p_k(x_i, \theta) &amp;= \exp(z_k(x_i,\theta)) / \sum_{j=1}^K \exp(z_j(x_i,\theta))<br>\end{aligned}<br>\end{equation}</p><p>其中，$z_k(x_i,\theta)$ 是网络的逻辑输出，<code>softmax</code> 后获得类别标签。对抗风险定义为：一个 batch 中被分类错误的样本数除以 batch 数。对抗样本的制作为：</p><p>\begin{equation}<br>\hat{x} = \arg\max \mathbb{I}(h_\theta(x_i) \neq y_i)<br>\end{equation}</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote><p>注，原文第二章写了一些0-1损失，后面又说不用这个，所以我没有写0-1损失</p></blockquote><p>首先将训练样本分为正样本 $S^+_{h\theta}$ 和错样本 $S^-_{h\theta}$，即能被网络正确识别的样本和不能被正确识别的样本。</p><ul><li>对于 $S^-_{h\theta}$ 而言，添加正则化项，使得网络能稳定的防御错分类对抗样本。因为对抗样本的分类需要更强的分类器和更光滑的决策边界，损失函数定义为 $\mathbb{I}(h_\theta(\hat{x_i}) \neq y_i) + \mathbb{I}(h_\theta(x_i) \neq h_\theta(\hat{x_i}))$，意思是，第一项优化的目标是，使对抗样本被分类正确；第二项优化的目标是，使网络认识原始样本和对抗样本。</li><li>对于 $S^+_{h\theta}$ 而言，正则化不会明显提升网络鲁棒性。在这种情况下，已经有 $h_\theta(x_i)=y_i$，因此此时的优化目标是 $\mathbb{I}(h_\theta(x_i) \neq h_\theta(\hat{x}))=\mathbb{I}(h_\theta(\hat{x_i})\neq y_i)$，也就是说，网络将干净样本和对抗样本视为两个类别且对抗样本分类错误的概率。</li><li>其中 $\mathbb{I}$ 是指示函数，意思是，错了损失值为1，正确损失值为0。</li></ul><p>但是这个指示函数难以优化，本文提出 BCE(boosted cross entropy) 损失函数，用于代替 $\mathbb{I}(h(\hat{x} \neq y))$，定义如下：</p><p>\begin{equation}<br>\begin{aligned}<br>\text{BCE}(p(\hat{x}, \theta), y_i) &amp;= -\log(p_{y_i}(\hat{x},\theta)) - \log (1-\max_{k\neq y_i}p_k(\hat{x}, \theta))<br>\end{aligned}<br>\end{equation}</p><p>第一项是普通的交叉熵损失函数，第二项用于提升模型决策边界的间隙。</p><p>使用 $KL$ 散度代替 $\mathbb{I}(h_\theta(x) \neq h_\theta(\hat{x}))$，定义如下：</p><p>\begin{equation}<br>\text{KL}(p(x_i,\theta)||p(\hat{x}, \theta))=\sum_{k=1}^K p_k{(x_i,\theta)} \log \frac{p_k(x_i,\theta)}{p_k(\hat{x_i},\theta)}<br>\end{equation}</p><p>对于制作对抗样本使用的指示函数 $\mathbb{I}(h_\theta(x_i) \neq y_i)$，通过 $1-p_{y_i}(x_i, \theta)$ 的形式选择对抗样本。因此，内部最大化的损失定义如下，攻击方式选择 PGD。</p><p>\begin{equation}<br>\hat{x} = \arg \max \text{CE} (p(x_i, \theta), y_i)<br>\end{equation}</p><p>将两中损失结合起来到对抗训练的框架中，最终的损失函数为：</p><p>\begin{equation}<br>L = \text{BCE}(p(\hat{x}, \theta), y_i) + \lambda \text{KL} (p(x_i,\theta)||p(\hat{x}, \theta))(1-p_{y_i}(x_i, \theta))<br>\end{equation}</p><p>$\lambda$ 参数用于平衡两个损失。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MART(Misclassification Aware adveRsarial Training) 是 2020 年提出的最好的对抗防御算法。传统对抗训练算法中 min-max 时不会考虑当前样本是否被正确分类，统一制作对抗样本。而作者抓住了这一点，发现对于 max 制作对抗样本期间没有被网络正确分类的样本，对结果的影响很大。换句话说，&lt;strong&gt;网络连干净样本都不认识，何谈认识它的对抗样本？&lt;/strong&gt; MART 算法的创新点在于区别对待错分类和正确分类的样本。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的常量与指针</title>
    <link href="https://muyuuuu.github.io/2021/06/22/const-pointer/"/>
    <id>https://muyuuuu.github.io/2021/06/22/const-pointer/</id>
    <published>2021-06-22T12:26:47.000Z</published>
    <updated>2021-06-22T20:33:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>和指针联用有佷微妙的地方，之前一直佷晕，现在来继续研究下。诸如以下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>const</code> 是一种处理符号常量的方法，以 <code>const</code> 声明的变量，一般首字母大写，声明之后无法被修改。相比于 <code>define</code>，<code>const</code> 会显式的指定类型。除定义符号外，一般可用于函数声明，表示函数不会修改任何值；用于参数，表示函数不会修改参数；甚至可以用于声明数组的长度。</p><h1 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h1><p>const默认作用于其左边的东西。左边没东西的情况下，作用于其右边的东西。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p><ol><li><code>const int* p</code>，只有右边有东西，修饰的为 <code>int</code>，所以数值不能被修改。在与 <code>*</code> 结合，意思是<code>*p</code>不能被修改，其它的都可以。即不可通过该指针改变其指向的内容，但可改变指针本身所指向的地址。</li><li><code>int const* p</code>，先作用于左侧的 <code>int</code> 为 <code>int const</code>，在叠加上右侧的 <code>*</code>，所以修饰的为 <code>int* p</code>，所以，<code>*p</code>不能被修改，其它的都可以。即不可通过该指针改变其指向的内容，但可改变指针本身所指向的地址。也就是，和上面的是一样的。</li><li><code>int* const p</code>，左边是 <code>*</code>，所以 <code>const</code> 作用于指针，指向一个 <code>int</code> 变量。即不可以修改 <code>p</code>，但可以修改 <code>*p</code>，即不可改变指向的地址。</li><li><code>const int* const p</code>，对于第一个 <code>const</code>，左边没东西，修饰右边的 <code>int</code>，指向的值不能修改；对于第二个 <code>const</code> 修饰 <code>*</code>，指针不能修改。即不可改变指针本身所指向的地址，也不可通过指针改变其指向的内容。同 <code>int const* const p</code>。</li><li><code>int const* const* p</code>，第一个 <code>const</code> 修饰 <code>int</code>，第二个 <code>const</code> 修饰第一个 <code>*</code>，也就是，指向 <code>const int* const p</code> 的指针，最后一个 <code>*</code> 没有被修饰，因此可以指向其它变量。<code>int const* const* const</code> 就不可以了。</li><li>之后再出现此类情况，也可以慢慢分析满天飞的 <code>const</code> 和指针。</li></ol><h1 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h1><p>为了更好的理解上述内容，这里来举一些例子。常见的一般有两种选择：</p><ul><li>常指针指向一个变量，防止修改指针修改变量值</li><li>常指针指向一个常量</li><li>非常指针指向常量（错误）</li></ul><p>先看第一种情况：解引用只是取出指向内存区域的值，因此指向内存区域的值是可以直接修改的，但不能通过指针修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a&#123;<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="comment">// *p 为 const，不能被修改</span></span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    <span class="comment">// *p ++;</span></span><br><span class="line">    <span class="comment">// p 指向的不是常量，因此，可以修改 a</span></span><br><span class="line">    a ++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> b&#123;<span class="number">12</span>&#125;;</span><br><span class="line">    p = &amp;b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第二种情况：不能修改变量，也不能修改常量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a&#123;<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="comment">// *p 为 const，不能被修改，a 也不能被修改</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b&#123;<span class="number">12</span>&#125;;</span><br><span class="line">    p = &amp;b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第三种情况：修改指针来修改常量会显得佷荒谬，因此编译会直接报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a&#123;<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="comment">// error: invalid conversion from 'const int*' to 'int*'</span></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    *p ++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><p>之前说到，常指针可以指向变量，但是涉及二级指针后，情况又会发生逆转。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a&#123;<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>** p1;</span><br><span class="line">    <span class="keyword">int</span>* p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error: invalid conversion from 'int**' to 'const int**'</span></span><br><span class="line">    p1 = &amp;p2;</span><br><span class="line">    *p1 = &amp;a;</span><br><span class="line"></span><br><span class="line">    *p2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述代码通过，那么完全可以通过 <code>p2</code> 指针修改常量。因此我们可以得到以下结论：</p><ul><li>若数据类型本身不是指针，可以将 <code>const</code> 数据或非 <code>const</code> 数据的地址赋给指向 <code>const</code> 的指针，但指针可以修改，指向别的值。因此，<code>const</code> 修饰的数组不能传参给非常量指针。</li><li>如果数据类型是指针，非 <code>const</code> 数据的地址只能赋值给非 <code>const</code> 指针，如二级指针中，<code>p1 = &amp;p2</code> 是错误的。</li></ul><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">https://www.zhihu.com/question/443195492</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;和指针联用有佷微妙的地方，之前一直佷晕，现在来继续研究下。诸如以下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;* p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; p;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 的名称空间</title>
    <link href="https://muyuuuu.github.io/2021/06/20/cpp-namespace/"/>
    <id>https://muyuuuu.github.io/2021/06/20/cpp-namespace/</id>
    <published>2021-06-20T09:43:46.000Z</published>
    <updated>2021-06-21T20:37:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前在学 C++ 的时候，第一个例子大概是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时也没多想，<code>std</code> 这个东西是什么。后来在接触了其它库后，发现也需要 <code>std</code> 的配合使用，如 <code>std::sort()</code>。今日来仔细研究下名称空间这个东西。</p><a id="more"></a><p>先掏出 cplusplus.com 来看看 <code>&lt;iostream&gt;</code> 是什么东西，官方的定义如下：</p><blockquote><p>Header that defines the standard input/output stream objects. After C++11, including <code>&lt;iostream&gt;</code> automatically includes also <code>&lt;ios&gt;</code>, <code>&lt;streambuf&gt;</code>, <code>&lt;istream&gt;</code>, <code>&lt;ostream&gt;</code> and <code>&lt;iosfwd&gt;</code>.</p></blockquote><p>而对于 <code>std</code> 而言，<code>std</code> 是一个名称空间，<code>::</code> 是作用域解析运算符，<code>std::cout</code> 的意思就是使用 <code>std</code> 名称空间中的 <code>cout</code> 标识符，也就是这个对象。而这个对象的定义在 <code>&lt;iostream&gt;</code> 这个标准库文件中，所以要包含这个头文件，才能使用 <code>cout</code> 这个对象。</p><p>除此之外，C++ 标准库中的<strong>函数或对象</strong>都是在名称空间 <code>std</code> 中定义的，所以我们要使用标准函数库中的<strong>函数或对象</strong>都要使用 <code>std</code> 来限定。所以使用 <code>cout</code> 的时候要加上 <code>std::</code> 时，编译器就会明白我们调用的 <code>cout</code> 是名字空间 <code>std</code>中的 <code>cout</code>，而不是其它名称空间中的 <code>cout</code>。</p><ul><li><code>#include</code> 是预处理器编译指令，表示使用预处理器在主编译之前对源文件进行整理。这里并不需要任何指令调用预处理器，编译时自动调用执行。这里的意思就是将 <code>iostream</code> 文件中的内容添加到程序中，即合成为一个新文件。这里的用途就是，在源文件被编译之前，替换或添加文本，这也是典型的一种预处理器操作。</li><li><code>using namespcec std</code> 是编译指令，如果是 <code>#include &lt;xxx.h&gt;</code> 则不需要 <code>using</code> 编译指令，因为老式的头文件没有使用名称空间。新头文件使用了 <code>std</code> 名称空间，标准库的类、函数、变量是 C++ 编译器的标准组件，被放到了 <code>std</code> 空间中。</li></ul><p>但是，尽量不要使用 <code>using namespace std</code>，这句话的意思是告诉编辑器我们将要使用空间 <code>std</code> 中的函数或者对象。或者说，能不用就不用，能在大括号里面用就不要在外面用，尤其是在 <code>.h</code> 等头文件中。幻想一下，你写的 <code>.h</code> 文件被其它人使用，你的名字空间和他人的名字空间不一样，但名字空间下面的函数名一样，就会导致冲突。跟 <code>python</code> 中写 <code>from numpy import *</code> 一个道理。</p><h1 id="自定义名称空间"><a href="#自定义名称空间" class="headerlink" title="自定义名称空间"></a>自定义名称空间</h1><p>名称空间提供了一个声明名称的区域，而可以通过作用域解析运算符 <code>::</code> 访问其中的名称。如下是一种简单的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mylib/show_info.h 文件下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 名称空间</span></span><br><span class="line"><span class="keyword">namespace</span> std1 &#123;</span><br><span class="line">    <span class="comment">// 名称</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cout</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cout</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"second"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp 文件下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mylib/show_info.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="using-声明与编译指令"><a href="#using-声明与编译指令" class="headerlink" title="using 声明与编译指令"></a>using 声明与编译指令</h2><p>有的时候并不希望每次使用名称时都进行限定，所以 <code>C++</code> 提供了两种机制，<code>using</code> 声明使得特定的名称可用，<code>using</code> 编译指令使名称空间中的所有名称可用，两者都可以简化名称空间中名称的使用，也都会增加名称冲突的可能性。</p><p>对于 <code>using</code> 声明而言，将指定的的名称添加到声明区域，使其可用。如下所示的代码：</p><ul><li>在声明的作用域内，不能在声明其它同名变量；</li><li>屏蔽全局同名变量。除用户定义的名称空间外，还存在一个全局名称空间，全局变量在这里面。同 <code>C++</code> 的局部变量会屏蔽全局变量一样，名称空间也是如此，但两个名称空间中的同名变量并不会冲突。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 冲突</span></span><br><span class="line">    <span class="comment">// int a;</span></span><br><span class="line">    <span class="keyword">using</span> test::a;</span><br><span class="line">    <span class="comment">// 冲突</span></span><br><span class="line">    <span class="comment">// int a;</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 12</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>using</code> 编译指令而言，会使所有名称可用，包括可能不会使用的名称。如下所示的代码：</p><ul><li><code>test::a</code> 位于局部名称空间，不会影响全局变量；</li><li>局部同名变量会屏蔽名称空间里的变量和全局变量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局名称空间</span></span><br><span class="line"><span class="comment">// using namespace test;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 编译指令</span></span><br><span class="line">    <span class="comment">// 局部名称空间</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> test;</span><br><span class="line">    <span class="comment">// 不冲突</span></span><br><span class="line">    <span class="keyword">int</span> a&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 全局变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 名称空间的变量</span></span><br><span class="line">    test::a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; test::a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是，当名称空间和声明区域定义了相同的名称：</p><ol><li><code>using</code> 声明导入时，会冲突；</li><li><code>using</code> 编译指令导入时，局部名称会屏蔽名称空间里面的名称，且没有警告。</li></ol><p>因此，使用 <code>using</code> 声明会更加安全，编译指令可能会掩盖一些同名变量。此外，还有一些其它要注意的点：</p><ul><li>名称空间可以嵌套，但最好加上限定，表明这个名称的来源；</li><li>以函数为例，名称空间里面的函数的声明和定义要在同一名称空间内；</li><li>如果函数被重载，那么一个 <code>using</code> 声明将导入所有版本；</li><li><p>对于未命名的名称空间，不能显式使用 <code>using</code>，不能在名称空间之外的文件使用名称空间中的名称。这可以作为<strong>链接性为内部静态变量的替代品</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 名称空间中的 a</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当名称空间很长时，可以简化名称空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MEF = math::element::fire;</span><br><span class="line"><span class="keyword">using</span> MEF::flame;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在学 C++ 的时候，第一个例子大概是：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;hello world&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 或者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;hello world&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当时也没多想，&lt;code&gt;std&lt;/code&gt; 这个东西是什么。后来在接触了其它库后，发现也需要 &lt;code&gt;std&lt;/code&gt; 的配合使用，如 &lt;code&gt;std::sort()&lt;/code&gt;。今日来仔细研究下名称空间这个东西。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>二分搜索的亿点点细节</title>
    <link href="https://muyuuuu.github.io/2021/06/18/binary-search/"/>
    <id>https://muyuuuu.github.io/2021/06/18/binary-search/</id>
    <published>2021-06-18T12:26:53.000Z</published>
    <updated>2021-06-20T11:47:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不能继续开坑了，得整理一下。最近在刷二分法，思路很简单，细节是魔鬼。时而减一时而不用，仿佛在面向玄学编程，所以特意来整理一下。<a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.md" target="_blank" rel="noopener">本文参考</a>。</p><a id="more"></a><p>对于最常见的二分查找框架：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析二分查找的一个技巧是：不要出现 <code>else</code>，而是把所有情况用 <code>else if</code> 写清楚，这样可以清楚地展现所有细节。本文都会使用 <code>else if</code>，旨在讲清楚，读者理解后可自行简化。</p><ol><li>其中 <code>...</code> 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</li><li>另外声明一下，计算 <code>mid</code> 时需要防止溢出，代码中 <code>left + (right - left) / 2</code> 就和 <code>(left + right) / 2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> <strong>太大直接相加导致溢出。</strong></li></ol><h1 id="查找一个数"><a href="#查找一个数" class="headerlink" title="查找一个数"></a>查找一个数</h1><p>这个场景是最简单的，在一个数组中搜索一个数，如果存在，返回其索引，否则返回 -1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6  7  8  9  10</span></span><br><span class="line">    <span class="comment">// 1 3 5 5 8 9 12 23 34 56 84</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">56</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">84</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">23</span>;</span><br><span class="line">    <span class="comment">// 有序是使用二分的前提</span></span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">int</span> a = binarySearch(v, target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为什么 <code>while</code> 循环的条件中是 &lt;=，而不是 &lt;？因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，而不是 <code>nums.length</code>。这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>。我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间，<strong>这个区间其实就是每次进行搜索的区间。</strong></li><li>那 <code>while</code> 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。<code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见这时候区间为空，因为没有数字既大于等于 3 又小于等于 2 。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</li><li>为什么 <code>left = mid + 1</code>，<code>right = mid - 1</code>？我看有的代码是 <code>right = mid</code> 或者 <code>left = mid</code>，或者时而减时而不减，到底怎么回事，怎么判断？答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[left, right]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，下一步应该去搜索哪里呢？之前提到搜索区间是闭区间，所以当然是去搜索 <code>[left, mid-1]</code> 或者 <code>[mid+1, right]</code> ，因为 mid 已经搜索过，应该从搜索区间中去除。之后还有有这方面的细节。</li><li>扩展一些，如果不返回 -1 而是直接返回 <code>left</code>。如果数字在数组中，返回的就是索引；如果不在数组中且以升序为例，返回的就是这个元素插入数组中应该放到哪个位置。</li><li>而对于 <code>while(left &lt; right)</code> 这种情况，也就是搜索区间是 <code>[left, right)</code>，那么终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[right, right]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，这时候区间非空，还有一个数 2，但此时 <code>while</code> 循环终止了。也就是说这区间 <code>[2, 2]</code> 的第一个 2 被漏掉了，索引 <code>2</code> 没有被搜索，如果这时候直接返回 -1 就是错误的。我们已经知道了出错的原因，就打个补丁好了：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left &lt; right ? left : <span class="number">-1</span>;</span><br></pre></td></tr></table></figure></li></ol><h1 id="搜索左侧边界"><a href="#搜索左侧边界" class="headerlink" title="搜索左侧边界"></a>搜索左侧边界</h1><p>给定一个数组，<code>1 2 2 2 3</code>，搜索数字 2 最开始出现的左侧区间，这里就返回索引 1。代码如下，这里写成左闭右开的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.size(); <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == nums.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6  7  8  9  10</span></span><br><span class="line">    <span class="comment">// 1 3 5 5 8 9 12 23 34 56 84</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">56</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">84</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">1000</span>;</span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">int</span> a = binarySearch(v, target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为什么 <code>while</code> 中是 &lt; 而不是 &lt;=? 用相同的方法分析，因为 <code>right = nums.length</code> 而不是 <code>nums.length - 1</code>。因此每次循环的「搜索区间」是 <code>[left, right)</code> 左闭右开。<code>while(left &lt; right)</code> 终止的条件是 <code>left == right</code>，此时搜索区间 <code>[left, left)</code> 为空，所以可以正确终止。</li><li>如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办？对于一个数组 <code>1 2 2 2 3</code>，<code>target</code> 为 2 返回 1，含义是：<code>nums</code> 中小于 2 的元素有 1 个；<code>target = 1</code>，算法会返回 0，<code>nums</code> 中小于 1 的元素有 0 个；<code>target = 8</code>，算法会返回 4，<code>nums</code> 中小于 8 的元素有 4 个。综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 <code>[0, nums.length]</code>，所以我们简单添加两行代码就能在正确的时候 <code>return -1</code>。</li><li>为什么 <code>left = mid + 1，right = mid</code> 和之前的算法不一样？因为我们的「搜索区间」是 <code>[left, right)</code> 左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉 <code>mid</code> 分割成两个区间，即 <code>[left, mid)</code> 或 <code>[mid + 1, right)</code>。</li><li>为什么返回 <code>left</code> 而不是 <code>right</code>？都是一样的，因为 <code>while</code> 终止的条件是 <code>left == right</code>。</li><li>能不能想办法把 <code>right</code> 变成 <code>nums.length - 1</code>，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了。由于 <code>while</code> 的退出条件是 <code>left == right + 1</code>，所以当 <code>target</code> 比 <code>nums</code> 中所有元素都大时，会存在以下情况使得索引越界。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == nums.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6  7  8  9  10</span></span><br><span class="line">    <span class="comment">// 1 3 5 5 8 9 12 23 34 56 84</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">56</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">84</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">1000</span>;</span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">int</span> a = binarySearch(v, target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="寻找右侧边界"><a href="#寻找右侧边界" class="headerlink" title="寻找右侧边界"></a>寻找右侧边界</h1><p>给定一个数组，<code>1 2 2 2 3</code>，搜索数字 2 最开始出现的最右侧区间，这里就返回索引 3。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left<span class="number">-1</span>] == target ? (left<span class="number">-1</span>) : <span class="number">-1</span>; <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>搜索区间」是 <code>[left, right)</code> 左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉 <code>mid</code> 分割成两个区间，即 <code>[left, mid)</code> 或 <code>[mid + 1, right)</code>。</li><li>为什么最后返回 <code>left - 1</code> 而不像左侧边界的函数，返回 <code>left</code> ？而且我觉得这里既然是搜索右侧边界，应该返回 <code>right</code> 才对。首先，<code>while</code> 循环的终止条件是 <code>left == right</code>，所以 <code>left</code> 和 <code>right</code> 是一样的，你非要体现右侧的特点，返回 <code>right - 1</code> 好了。</li><li>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在<strong>等式条件</strong> <code>nums[mid] == target</code> 下的判断：<code>left = mid + 1</code>，因为最后一定是找到了和 <code>target</code> 相等的数字，且是最右侧的。对 <code>left</code> 的更新是 <code>left = mid + 1</code>，就是说 <code>while</code> 循环结束时，<code>nums[left]</code> 一定不等于 <code>target</code> 了，而 <code>nums[left-1]</code> 可能是 <code>target</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.size(); <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left - <span class="number">1</span>] == target ? left - <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6  7  8  9  10</span></span><br><span class="line">    <span class="comment">// 1 3 5 5 8 9 12 23 34 56 84</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">56</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">84</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">34</span>;</span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">int</span> a = binarySearch(v, target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="STL-开车"><a href="#STL-开车" class="headerlink" title="STL 开车"></a>STL 开车</h1><p>对于一些高级语言而言，其实都内置了二分搜索。以 <code>C++</code> 为例，搜索数组 <code>1 2 2 2 3</code> 中有几个 2。第一种方案是搜索 2 出现的左边界，而后搜索出现的右边界。但是也可以通过 <code>lower_bound</code> 和 <code>upper_bound</code> 来解决，因为在某些复杂应用下，二分只是一个小点，没必要花费大多精力在不重要的点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator lower, upper;</span><br><span class="line"></span><br><span class="line">    lower = lower_bound(v.begin(), v.end(), target);</span><br><span class="line">    upper = upper_bound(v.begin(), v.end(), target);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(upper - lower) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不能继续开坑了，得整理一下。最近在刷二分法，思路很简单，细节是魔鬼。时而减一时而不用，仿佛在面向玄学编程，所以特意来整理一下。&lt;a href=&quot;https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文参考&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>对抗攻击篇：一些关于对抗补丁的论文</title>
    <link href="https://muyuuuu.github.io/2021/06/13/adversial-patch/"/>
    <id>https://muyuuuu.github.io/2021/06/13/adversial-patch/</id>
    <published>2021-06-13T06:32:14.000Z</published>
    <updated>2021-06-22T21:28:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在对抗攻击中，有人尝试着去用对抗样本攻击目标检测的网络。但是，检测网络与分类网络不同，检测网络还有检测器，存在 RPN、ROI-Align 以及边界框回归器等。而分类接受的图像来自检测器的输出，并不是原始的输入。所以只在图片上产生细微的扰动很可能不起做作用 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。所以衍生出了一些基于 patch （补丁）的攻击。</p><a id="more"></a><h1 id="Adversial-Patch"><a href="#Adversial-Patch" class="headerlink" title="Adversial Patch"></a>Adversial Patch</h1><p>这篇论文 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 是最开始的，创建一些通用的小 patch，可以放到任何场景下去干扰分类，使得网络忽略真实的物体，而输出诱导的错误分类。传统的对抗攻击，都是在输入上叠加一些微小的扰动，人眼察觉不出来的那种，但需要修改图像中的每一个像素，对于 $1000\times 1000$ 的像素点，需要操作一百万个像素点，在现实世界难以应用。</p><p>而本文中，不在满足这一约束，而是生成一个独立于任何场景（光照、角度）的 patch 放到图片的任何位置，相反，这个 patch 大于只有 $20\times 20$ 的大小，所以这个计算量是可以在现实世界应用的。这个 patch 很容易被网络看到，但仍然可以导致网络错误的输出。当 patch 使用了很大的扰动，传统的防御算法只能防御小扰动的样本，对大扰动的样本鲁棒性反而很差，毕竟数据分布不同。如下所示：</p><p><img data-src="https://z3.ax1x.com/2021/06/13/2IOvY4.png" alt></p><p>所以，这个补丁攻击的仍然是分类网络。</p><h2 id="训练方式"><a href="#训练方式" class="headerlink" title="训练方式"></a>训练方式</h2><p>在全部数据集上进行训练，对 patch 进行各种各样的转换、缩放、旋转，这个 patch 允许被设置为任何形状。对于给定图像 $x$，patch $p$，位置 $l$，变换 $t$，定义一个补丁操作 $A(p,x,l,t)$，将 $t$ 应用到 $p$ 上，在把 $p$ 放到 $x$ 的 $l$ 位置。</p><p>而 patch 是经过训练的，以诱导网络输出错误的标签 $\hat{y}$，这个训练过程为：</p><p>\begin{equation}<br>p = \arg \max_p \mathbb{E}_{x\sim X,t\sim T, l\sim L}[\log P(\hat{y}|A(p,x,l,t))]<br>\end{equation}</p><p>$X$ 是训练数据的分布，$T$ 是 patch 变换的分布，$L$ 是位置。通过这个公式，生成的 patch 会忽略背景，所以生成的 patch 通用性较强。而为了伪装 patch，使得最终的 patch 不太离谱，加入了一个限制 $|p-p_{orig}|_\inf &lt; \epsilon$。</p><h1 id="DPATCH"><a href="#DPATCH" class="headerlink" title="DPATCH"></a>DPATCH</h1><p>这个补丁 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> 就正儿八经的攻击目标检测的网络了。不同于上一个补丁只误导分类器，同时也攻击边界框回归器，以产生错误的定位。其实目标检测是很难攻击的，毕竟有很多 anchor 和候选框，样本不一定能被选中。攻击目标检测的网络时，与传统分类不同的是，需要定位到不同大小的目标及其位置。</p><p>在无目标攻击中，让检测器不能检测到物体的位置，所以最大化真实类别和边界框回归器的损失，这里的类别 $y$ 是背景类。也就是，通过放置补丁，让网络的将真实的目标视为背景。</p><p>\begin{equation}<br>P_u=\arg \max_P \mathbb{E} [L(A(x,s,P);y;B)]<br>\end{equation}</p><p>在有目标攻击中，目标是只能检测到 patch 而忽略其它真正的目标。所以需要最小化 patch 的类别损失和边界损失，类别是自己选择的误导类别。也就是，让网络将补丁视为目标。</p><p>\begin{equation}<br>P_t=\arg \min_P \mathbb{E} [L(A(x,s,P);y_t;B_t)]<br>\end{equation}</p><p>$A(x,s,P)$ 表示将补丁 $P$ 通过变换 $s$ 添加到图像 $x$ 上。在补丁进入网络前，首先先添加一个随机噪音，而后定义 patch 的边界框。训练流程如下：</p><p><img data-src="https://z3.ax1x.com/2021/06/13/2Ijf2j.png" alt></p><ul><li>为了分析不同位置下 DPATCH 的影响，随机对 DPATCH 的位置进行变换，而保持像素点数值不变，在每轮训练时候都随机初始化变换 $s$</li><li>为了分析不同类别下 DPATCH 的影响，将 DAPTCH 的类别都设置为人，随机指定了四个类别</li><li>为了分析不同大小的 DPATCH 的影响，所以做了一些实验，分别分析 20 40 80 大小的 DPATCH 对结果的影响</li></ul><p>实验结果大概证明了，DAPTCH 在可以出现在图片的任何位置，更大的 DAPTCH 攻击性更强。</p><p>DPATCH 起作用的原因：DPATCH 的攻击目标就是目标检测网络，使得 ROI 提取到的区域被 DPATCH 覆盖，所以提取到的 ROI 区域，将会忽略其它目标。如果攻击成功了，许多提取到的 ROI 应该会有 DPATCH 的存在。为此，统计每个区域被提取为 ROI 的次数，也发现那里正好是 DPATCH 出现的地方。故此验证了攻击成功的原因是：DPATCH 欺骗了检测器，使得 ROI 含有 DPATCH，而不是正常目标，如下图所示：</p><p><img data-src="https://z3.ax1x.com/2021/06/13/2IvWTK.png" alt></p><h1 id="物理世界的补丁"><a href="#物理世界的补丁" class="headerlink" title="物理世界的补丁"></a>物理世界的补丁</h1><p>这篇论文 <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> 做了一个演示<a href="https://youtu.be/WXnQjbZ1e7Y" target="_blank" rel="noopener">视频</a>。与之前不同的是，不需要 patch 放到图像上误导分类和检测，而是设计了一个 patch 抑制其它目标的表达。所以可以 patch 到任何地点甚至是远离目标的地点。而且不需要训练位置参数，且不需要修改场景中的目标。</p><p>本文构造一个物理上的 patch，放到图像中，抑制其它目标的表达。寻找与制作 patch 的方式也很简单：</p><p>\begin{equation}<br>\arg \max_{\delta} \mathbb{E}_{(x, y) \sim D, t\sim T} [L(h_\theta(A(\delta, x, t)), y)]<br>\end{equation}</p><p>其中 $\delta$ 是补丁，$D$ 是数据分布，$T$ 是变换分布，$A$ 是将补丁 $\delta$ 经过 $t$ 变换放到 $x$ 上。但是，对 $\delta$ 的最大期望可能会超出预期，所以不够通用。所以像 PGD 一样，让扰动朝着其它目标移动：</p><p>\begin{equation}<br>\delta := \delta - \alpha \nabla_\delta [L(h_\theta(A(\delta, x, t)), \hat{y})]<br>\end{equation}</p><p>但是事实证明这种做法很差。所以尝试最大化与真实目标的损失，不对补丁设置任何的边界框和目标类别，而是直接抑制检测的其它类别：</p><p>\begin{equation}<br>\delta := clip_{[0,1]} (\delta + \alpha \nabla_\delta [L(h_\theta(A(\delta, x, t)), y)])<br>\end{equation}</p><p>这种方法成功的原因和上述的 DPATCH 是一样的，提取到的 ROI 还有 PATCH。作者和 DPATCH 做了对比，分析 DPatch 之所以时好时差，是因为它将 patch 放到了 ground truth box 的周围，patch 最终驻留在一个单一的单元中。这意味着损失由『负责』该单元的 rpn 控制。只要补丁被识别，模型在预测所有其他对象时受到的惩罚就很小，且边界框或类标签上不会受到惩罚。所以在实践中，补丁经常被检测到，但是，<strong>并没有抑制其他目标被检测</strong>。反而言之，一旦 patch 没被检测到，网络还是能识别到目标。</p><p>而在本文的方法中，patch 可以置于任何位置，当 patch 与任何一个 ground truth box 重叠都会造成损失，也就是，当前目标检测失败。当模型不能预测任何 ground truth box 时，损失增加最多。</p><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/abs/1712.02494" target="_blank" rel="noopener">为什么难以攻击目标检测网络</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/abs/1712.09665" target="_blank" rel="noopener">Adversial Patch</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/abs/1806.02299" target="_blank" rel="noopener">DPATCH</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/abs/1906.11897" target="_blank" rel="noopener">物理世界的补丁</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在对抗攻击中，有人尝试着去用对抗样本攻击目标检测的网络。但是，检测网络与分类网络不同，检测网络还有检测器，存在 RPN、ROI-Align 以及边界框回归器等。而分类接受的图像来自检测器的输出，并不是原始的输入。所以只在图片上产生细微的扰动很可能不起做作用 &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。所以衍生出了一些基于 patch （补丁）的攻击。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>面向长尾目标检测的 Seesaw Loss</title>
    <link href="https://muyuuuu.github.io/2021/05/28/seesaw-loss/"/>
    <id>https://muyuuuu.github.io/2021/05/28/seesaw-loss/</id>
    <published>2021-05-28T07:54:02.000Z</published>
    <updated>2021-06-08T23:02:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>论文好像是 2020 年底传到 arxiv <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 的，还比较新。正好最近遇到的问题是类别数量是长尾分布，恰好最近看到 mmdetection 也支持了这个损失函数，索性来看一看这篇论文，算是做个论文笔记吧。不过为了能更容易理解论文的思想，没有按照原论文的内容结构进行整理。</p><a id="more"></a><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>在现实世界中，只有少部分类有充足的数据，大部分类别其实只有小部分数据，这就是类别数量呈现长尾分布。如下图 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 所示：</p><p><img data-src="https://z3.ax1x.com/2021/05/28/2FWClj.jpg" alt></p><p>而头部类实例在长尾数据集中占主导地位，这些实例为尾部类提供了大量的负样本。所以正样本和负样本在尾类上的梯度严重不平衡。说人话的意思是，含有尾部类别的样本本是正样本，头部类别的样本是负样本。由于负样本的数量大于正样本，所以负样本对尾部类别的影响大于正样本对尾部类别的影响，具体为啥可以看公式 $\eqref{why}$。由于交叉熵公式的原因，负样本的梯度在学习过程中起到了决定性影响，导致尾部类别被识别为背景或头部类别。如下图所示：</p><p><img data-src="https://z3.ax1x.com/2021/05/28/2FhmQJ.png" alt></p><ul><li>那些鸟明明是正样本，但目标小，类别少，导致不如右侧常见的负样本的梯度大。负样本梯度指：就是负样本对当前类别的惩罚。</li></ul><p>以传统的交叉熵损失函数为例：</p><p>\begin{equation}<br>L(z) = -\sum_{i=1}^C y_i \log(\sigma_i), \sigma_i = \frac{e^{z_i}}{\sum_{j=1}^Ce^{z_j}}<br>\end{equation}</p><p>$z$ 表示为网络的逻辑预测输出，$\sigma$ 表示网络对每个类别的预测概率。如果当前类别是 $i$，那么对 $z_i$ 和 $z_j$ 的梯度为：</p><p>\begin{equation}\label{why}<br>\frac{\partial L}{\partial z_i} = \sigma_i - 1, \frac{\partial L}{\partial z_j} = \sigma_j<br>\end{equation}</p><p>上述公式中可以看到，第 $i$ 类样本在分类时，也惩罚了类别 $j$，换句话说，类别 $j$ 的输出单元也要受到影响。如果类别 $i$ 是头部类别，类别 $j$ 是尾部类别，那么类别 $j$ 的输出单元、backbone 等网络参数将会在大多数样本中会受到惩罚，于是类别 $j$ 的预测就会受到抑制，导致上图所示的结果。<strong>务必看懂这一步，这也是论文要改进的点。</strong></p><p>现有的一些处理长尾分布的做法是（这部分就是 related works 抄来的，我没看里面的论文）：</p><ul><li>根据不同的类别统计，调整损失来重新计算权重</li><li>重采样技术，保证类别平衡</li><li>在预训练的模型上，用类平衡技术重新训练分类头</li><li>对不同的类别使用不同的分类器去预测</li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h2><ol><li>对于每一个类别，通过缓解（mitigation）因子 $M_{ij}$ 和补偿（compensation）因子 $C_{ij}$ 动态的重新平衡正负样本的梯度</li><li>$M_{ij}$ 在累积的训练过程中，在不同类别之间，减少对尾部类别的惩罚。</li><li>但是只减轻惩罚是不够的，因为其他类别的样本在被误分类为尾类时，尾部类别受到的惩罚仍然较小。说人话的意思是，类别 $j$ 相关的神经元受到的惩罚小，神经网络为了最小化损失，所以不管输入的是什么类，有可能直接输出第 $j$ 类，所以盲目地降低负样本的梯度会增加导致尾类假阳性的风险。所以增加 $C_{ij}$ 增加对<strong>错分类</strong>实例的惩罚，避免假阳性的出现，算是一种补偿机制。</li></ol><p>所以 seesaw loss 有以下优点：</p><ol><li>是动态的，它可以汇总全部训练集的信息，知道哪些是尾类，哪些被错分类，能够更好的调整损失</li><li>是自校准的，因为 $M_{ij}$ 和 $C_{ij}$ 能避免尾部类别被过度惩罚和假阳性</li><li>能更好的处理未知分布的数据集，毕竟在训练期间会统计各个类别的数目，所以能获得更好的正负样本梯度平衡</li></ol><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>文中定义的 seesaw loss 是：</p><p>\begin{equation}<br>L(z) = -\sum_{i=1}^C y_i \log(\hat{\sigma_i}), \hat{\sigma_i} = \frac{e^{z_i}}{\sum_{j\neq i}^CS_{ij}e^{z_j}+e^{z_i}}<br>\end{equation}</p><p>所以对 $z_j$ 的偏导数就是：</p><p>\begin{equation}<br>\frac{\partial L}{\partial z_j} = S_{ij} \frac{e^z_j}{e^z_i} \hat{\sigma_i}, S_{ij} = M_{ij} \cdot C_{ij}<br>\end{equation}</p><p>$S_{ij}$ 表示一种可调节的因子，表示类别为 $i$ 的正样本对类别 $j$ 的惩罚。其中，$M_{ij}$ 表示头部类别 $i$ 降低对尾部类别 $j$ 的惩罚，$C_{ij}$ 表示增加对类别 $j$ 的惩罚，当类别 $i$ 被误分类为 $j$ 时。</p><h3 id="缓和因子"><a href="#缓和因子" class="headerlink" title="缓和因子"></a>缓和因子</h3><p>seesaw loss 在训练期间，会统计类别 $i$ 的数量为 $N_i$，对于正样本，也就是当前网络正在处理的类别 $i$，通过缓解因子调整对其它类别的惩罚，公式如下：</p><p>\begin{equation}<br>M_{ij} =<br>\begin{cases}<br>    1, &amp; N_i \leq N_j \\\\<br>    \biggl(\frac{N_j}{N_i}\biggr)^p, &amp; N_i &gt; N_j<br>\end{cases}<br>\end{equation}</p><p>如上述公式，当类别 $i$ 的数量 $N_i$ 远远大于其它类别时，对其它类别的惩罚力度会降低。$p$ 是控制惩罚程度的超参数。需要注意的是，seesaw loss 会在训练期间统计类别数量，而不是事先统计。这样做有两个好处：</p><ul><li>能适应不可见数据集，如训练数据来自流数据</li><li>每个类别的训练样本能被其它类别的数据适度的影响，更加鲁棒。比如当前每个类只有 5 个数据，就算不上谁是尾部，谁是头部，惩罚力度可以都一样，能更加均匀的初始化和光滑的适应真实世界的数据</li></ul><p><img data-src="https://z3.ax1x.com/2021/05/28/2kVrNR.png" alt></p><h3 id="补偿因子"><a href="#补偿因子" class="headerlink" title="补偿因子"></a>补偿因子</h3><p>这个计算就和上面的公式类似了，假设当前类别是 $i$ 时，被误分类为 $j$，那么缓和因子的计算公式为：</p><p>\begin{equation}<br>C_{ij} =<br>\begin{cases}<br>    1, &amp; \sigma_j \leq \sigma_j \\\\<br>    \biggl(\frac{\sigma_j}{\sigma_i}\biggr)^q, &amp; \sigma_j &gt; \sigma_i<br>\end{cases}<br>\end{equation}</p><p>$q$ 仍然是控制惩罚程度的超参数，被误分类的程度越大，补偿惩罚的力度就越大。</p><p><img data-src="https://z3.ax1x.com/2021/05/28/2keIpt.png" alt></p><h3 id="标准化线性层与输入"><a href="#标准化线性层与输入" class="headerlink" title="标准化线性层与输入"></a>标准化线性层与输入</h3><ul><li>对于头部类别 $i$，与其相关的分类参数 $W_i$ 可能会比较大，抑制了其它类别的表达，所以对分类层进行 $L_2$ 正则化处理</li><li>输入也要做正则化处理，我好奇为啥不是标准化</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>不知道读到现在有没有发现论文的一个明显漏洞。在目标检测领域，从候选框到 ROI Pooling，到处都有背景类的存在，所以背景类会是头部类别，且数量远远大于其它类，对其它类产生抑制。所以，seesaw loss 会减少对<strong>所有</strong>前景类的抑制，但由于采样问题，背景类数量几乎不会低于前景类，所以不会有对前景类的<strong>补偿因子</strong>，这样，可能会将背景识别为前景。</p><p>所以论文的想法是，增加一个前景背景的二分类器，预测目标属于前景的概率 $\sigma_i^{obj}$ 还是背景的概率，背景会被抛弃，前景会被保留。而预测阶段，会保留这个二分类器。最终预测的目标概率就是：</p><p>\begin{equation}<br>\sigma_i = \sigma_i^{obj} \cdot \sigma_i^{class}<br>\end{equation}</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>这篇论文的想法讲真还是不错的。忙猜一下，会有论文说这篇论文的 $p,q$ 是手工设定的不太好，$M_{ij}$ 和 $C_{ij}$ 直接相乘不太好没有道理。然后写篇论文，用神经网络自适应的学习参数 $p,q$ 或 $M_{ij}$，然后说这是改进，性能好了一些。<del>这样的东西我见过太多了，没意思，不过都是为了混一碗饭。</del></p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/abs/2008.10032" target="_blank" rel="noopener">Seesaw Loss for Long-Tailed Instance Segmentation 论文</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://tianchi.aliyun.com/competition/entrance/531888/information" target="_blank" rel="noopener">长尾分布图片来源</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;论文好像是 2020 年底传到 arxiv &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 的，还比较新。正好最近遇到的问题是类别数量是长尾分布，恰好最近看到 mmdetection 也支持了这个损失函数，索性来看一看这篇论文，算是做个论文笔记吧。不过为了能更容易理解论文的思想，没有按照原论文的内容结构进行整理。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="CV" scheme="https://muyuuuu.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>可变形卷积 DCN，从 V1 到 V2</title>
    <link href="https://muyuuuu.github.io/2021/05/26/Deform-CNN/"/>
    <id>https://muyuuuu.github.io/2021/05/26/Deform-CNN/</id>
    <published>2021-05-26T12:42:34.000Z</published>
    <updated>2021-05-27T17:17:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前了解到，可变形卷积 DCN（Deformable Convolutional Networks）是上分常用小技巧，所以把论文找来读了一下，V1 和 V2 两个版本都读了一下，个人感觉以及他人复现的结果显示 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> ，V1写的很好且够用，V2 写的实在是晕头转向。感觉还挺有创意，后期准备复现后，以后可能会用到。</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>传统的 CNN 在建模时，几何变化能力受限，感受野都是规则的相邻矩形。于是，提出了可变形卷积，通过无监督的形式学习额外的偏移参数，加强模型的几何变换能力。也就是说，有了偏移参数，此时的卷积核读取的输入不再是规则的矩阵。且像传统 CNN 一样，支持端到端训练和反向传播，可以通过插拔的形式替换传统模型中的 CNN 。</p><ul><li>偏移参数是在输入的特征图上增加额外的网络分支，自己学出来的，所以这是一种自适应的方式</li><li>在 ROI 时，也可以学习这种偏移参数，自适应的定位到感兴趣区域</li><li>两者都是通过添加额外的网络分支实现的，但计算量不大</li></ul><p>其实这种形式挺重要的，尤其是算法部署到真实世界，是无法提前预知目标和图像的大小的。而如果模型有这种自适应感知目标区域大小和调节感受野的能力则再好不过。如下图所示，DCN 相比 CNN 而言，能更好的感知目标区域。</p><p><img data-src="https://z3.ax1x.com/2021/05/27/2P4Q1J.png" alt></p><h1 id="变形卷积算法"><a href="#变形卷积算法" class="headerlink" title="变形卷积算法"></a>变形卷积算法</h1><p>首先定义区域 $R$ 是输入特征图 $x$ 中的规则矩形，卷积核的权重是 $w$，区域 $R$ 中的元素的含义为横坐标的偏移与纵坐标的偏移量，所以可以通过 $R$ 了解到卷积核的大小和扩张大小。</p><p>\begin{equation}<br>R = \bigl( (-1, 1), (-1, 0), \cdots, (0,1), (1,1) \bigr)<br>\end{equation}</p><p>上面公式中，卷积核的大小就是 3，元素数量是 9，扩张大小为 1。以 $y$ 表示输出特征图，那么 $y$ 在 $p_0$ 位置的取值为 ：</p><p>\begin{equation}<br>y(p_0) = \sum_{p_n \in R} w(p_n) x (p_0 + p_n)<br>\label{traditional}<br>\end{equation}</p><p>$(p_0 + p_n)$ 的意思是偏移到目标像素 $p_n$，原文没有解释，我看了半天才看懂。这也就是传统的卷积。如果我们对 $R$ 中的每一个位置的元素都有一个通过神经网络学习得来的偏移量 $(\Delta p_n | n=1,\cdots,N)$，那么公式 $\eqref{traditional}$ 可以改写为：</p><p>\begin{equation}<br>y(p_0) = \sum_{p_n \in R} w(p_n) x (p_0 + p_n + \Delta p_n)<br>\end{equation}</p><p>此时的卷积可视化如下图中的 b c d 部分，a 是标准的卷积。</p><p><img data-src="https://z3.ax1x.com/2021/05/27/2Py8mD.png" alt></p><p>因为 $p_n + \Delta p_n$ 可能是一个小数，所以需要使用双线性插值来对坐标取整，用 $p$ 来表示 $p_0 + p_n + \Delta p_n$，公式如下：</p><p>\begin{equation}<br>x(p) = \sum_{q} G(q,p)x(q)<br>\end{equation}</p><p>$q$ 是输入特征图中的像素，其实只用到了和 $p$ 相邻的一部分。而 $G$ 是一个二维的双线性插值核函数，可以用两部分表示：</p><p>\begin{equation}<br>G(q,p) = g(q_x,p_x) \cdot g(q_y,p_y)<br>\end{equation}</p><p>其中，$g(a,b) = \max(0, 1- |a-b|)$，所以这里也能看出来，如果 $a,b$ 相差很大，取值会为 0，所以每次计算取 $q$ 时，其实只用到了和 $p$ 相邻的一部分。</p><h1 id="变形卷积训练流程"><a href="#变形卷积训练流程" class="headerlink" title="变形卷积训练流程"></a>变形卷积训练流程</h1><p><img data-src="https://z3.ax1x.com/2021/05/27/2Pg4jP.png" alt></p><p>如上图所示，假设 $R$ 中卷积核的元素数量是 $N$，比如 $3\times 3$ 卷积核的元素数量就是 9。那么就增加一个旁路卷积，这个卷积的通道数就是 $2N$，且卷积前后尺寸不变。这样做的原因是，计算 $x$ 方向和 $y$ 方向共两个方向的偏移量。取前两个通道，就是当前卷积核处理像素点的横坐标偏移和纵坐标偏移。</p><h1 id="变形-ROI-Pooling"><a href="#变形-ROI-Pooling" class="headerlink" title="变形 ROI Pooling"></a>变形 ROI Pooling</h1><p>其实道理也和上面一样了，假设此时在目标检测中将特征图 ROI pool 到 $k\times k$ 的矩阵中，以平均池化为例，输出 $y$ 中第 $(i,j)$ 个元素的取值就是</p><p>\begin{equation}<br>y(i,j)=\sum_{p\in bin(i,j)} x(p + p_0) / n_{ij}<br>\end{equation}</p><p>$bin$ 表示要被池化的区域，$n_{ij}$ 是对应区域中的像素点的数量。而此时，可以学习一个偏移量参数 $\Delta p_{ij}$，新的 ROI Pooling 公式就是</p><p>\begin{equation}<br>y(i,j)=\sum_{p\in bin(i,j)} x(p + p_0 + \Delta p_{ij}) / n_{ij}<br>\end{equation}</p><p>双线性取整部分就和之前的一样了。不过论文中注明了一点，网络学习到的是 $\Delta \hat{p}_{ij}$，如下图所示，使用全连接计算每个像素点的偏移量。</p><p><img data-src="https://z3.ax1x.com/2021/05/27/2PhOOI.png" alt></p><p>而 $\Delta p_{ij} = \gamma \cdot \Delta \hat{p}_{ij} \circ (w,h)$，$\gamma$ 的取值是 0.1，$(w,h)$ 是 ROI Pooling 之前的特征图的宽度和高度，$\circ$ 运算是什么，文中没有声明。</p><h1 id="V2"><a href="#V2" class="headerlink" title="V2"></a>V2</h1><p>DCN V2 看的我属实头晕，不过大体贡献还是能看清的，集中改进了两点：</p><ul><li>采样时，如果采到了背景区域，会对目标分类与检测造成影响，所以要抑制背景区域的贡献</li><li>训练一个教师网络，类似判别器，用于指导检测网络的检测，文中称为特征模仿（feature mimicking），没读懂这个和前文改进的联系，唯一的相似点是摘要中指出的：提高模型捕获特征的能力，但我感觉这里是重点</li></ul><p>以可变形卷积为例，原有 DCN 的输出通道是 $2N$，那么作者将输出通道改为 $2N+1$，最后一个维度用 sigmoid 激活到 (0, 1) ，表示为符号 $\Delta m_k$ ，含义为当前像素点的贡献程度，如果是背景噪音，那么贡献会趋于 0。所以此时可变形卷积的公式为：</p><p>\begin{equation}<br>y(p_0) = \sum_{p_n \in R} w(p_n) x (p_0 + p_n + \Delta p_n) \cdot \Delta m_k<br>\end{equation}</p><p>至于 ROI Pooling 也是一个道理了。</p><h2 id="特征模仿"><a href="#特征模仿" class="headerlink" title="特征模仿"></a>特征模仿</h2><p>而另一个创新点是特征模仿，在主干网络 RPN 后，将得到的题夷旷送到另一个 RCNN 分支，两个分支的输出的相似性做对比作为损失，相似度越高，损失越小，相似度越低，损失越大。相似度是用 $\cos$ 函数计算的。</p><ul><li>测试时，不适用右侧的 RCNN分支</li><li>两个分支的 bacbone 部分共享参数</li><li>三个损失一起反向传播</li></ul><p><img data-src="https://z3.ax1x.com/2021/05/27/2PTMUx.png" alt></p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">https://github.com/open-mmlab/mmdetection/tree/master/configs/dcn</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前了解到，可变形卷积 DCN（Deformable Convolutional Networks）是上分常用小技巧，所以把论文找来读了一下，V1 和 V2 两个版本都读了一下，个人感觉以及他人复现的结果显示 &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; ，V1写的很好且够用，V2 写的实在是晕头转向。感觉还挺有创意，后期准备复现后，以后可能会用到。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="CV" scheme="https://muyuuuu.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>分割篇：Mask R-CNN</title>
    <link href="https://muyuuuu.github.io/2021/05/25/Mask-R-CNN/"/>
    <id>https://muyuuuu.github.io/2021/05/25/Mask-R-CNN/</id>
    <published>2021-05-25T02:15:16.000Z</published>
    <updated>2021-05-25T17:33:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不同于 FCN 的语义分割，Mask R-CNN 是用于实体分割的。借鉴 FCN 的思想，通过在 Faster R-CNN 的用于边界框识别分支上添加了一个并行的用于预测目标掩码的分支 Mask，在实现目标检测的同时，实现实例分割（object instance segmentation），即把每个目标像素分割出来。而 Faster R-CNN 和 FCN 在之前介绍过，所以本文的重点将会放在损失函数的设计和 ROI-Align 上。</p><p>实体分割不同于语义分割的是，不仅要检测出所属类别，还要区分同一类别下的不同实例。</p><p><img data-src="https://z3.ax1x.com/2021/05/25/gxXEss.png" alt></p><a id="more"></a><p>按着前文描述，网络结构如下，蓝色分支是 Faster R-CNN 中用于预测类别和回归框的分支，红色分支是新加入的预测掩码的分支。</p><p><img data-src="https://z3.ax1x.com/2021/05/25/gxOoa6.png" alt></p><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>语义分割问题只需要在语义上对像素点进行区分即可。而实例分割问题不仅需要正确地检测出所有的目标，还需要在单个目标的基础上对每一个实例进行准确的分割。而作者基于 Faster R-CNN 目标检测的框架和 FCN 的语义分割提出了 Mask R-CNN。所以流程就是：</p><ol><li>输入一副图片，将图片输入到特征提取层 backbone，也可以融合 FPN 机制，最终获得对应的 feature map。下图中，左图是 Mask R-CNN 和 Faster R-CNN 结合的方式，右图是 Mask R-CNN 和 FPN 结合的方式。</li><li>对 feature map 中获得多个候选 ROI，候选的 ROI 送入 RPN 网络进行二值分类和 bbox 回归，截止到这一步，Mask R-CNN 和 Faster R-CNN 完全相同</li><li>Mask R-CNN 中，取消 ROI pooling，替换为 ROI-Align</li><li>对这些 ROI 进行分类、box 回归和 MASK 生成</li></ol><p><del>如果看不懂建议重新看 Faster R-CNN 和 FCN</del></p><p><img data-src="https://z3.ax1x.com/2021/05/25/gxvu2F.png" alt></p><h1 id="ROI-Align"><a href="#ROI-Align" class="headerlink" title="ROI-Align"></a>ROI-Align</h1><p>对于传统的 ROI pooling 而言，难免会有精度损失。比如 <code>20X20</code> 的特征图 pool 到 <code>7X7</code>，自然无法整除，就需要对像素点进行取舍，带来精度上的损失。RoI 对应至特征图和 ROI 进行划分这两步取整量化操作会导致 ROI 与抽取出的特征图在空间位置上不匹配。这一问题不会对目标的分类造成大的影响，但会对 mask 预测造成极大的负面影响。如下图所示 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> ，并非均匀划分：</p><p><img data-src="https://z3.ax1x.com/2021/05/25/gzSIZd.gif" alt></p><p>对于 ROI-Align 而言，不在对 ROI 边界进行取整。假设 pool 到 <code>3X3</code> 的格子，那么计算每个格子中心四个点的坐标。对于每个点而言，对每个周围的四个点进行采样，使用双线性插值计算当前点的取值，而后 max pool 获取当前格子里面的值。无论采样点的多少与采样方式，结果都不会很差。如果使用的量化取整，结果就会很差。如下图，作者也只使用了这一张图介绍了 ROI-Align。</p><p><img data-src="https://z3.ax1x.com/2021/05/25/gzptwd.png" alt></p><p>这个过程佷繁琐不易理解，但其实并不难，可以来这篇博客看下动图。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p><p><img data-src="https://z3.ax1x.com/2021/05/25/gziG9I.gif" alt></p><h1 id="Mask-损失"><a href="#Mask-损失" class="headerlink" title="Mask 损失"></a>Mask 损失</h1><p>Mask R-CNN 的分支由三部分组成，其中 $L_{\text{cls}}$ 和 $L_{\text{box}}$ 与 Faster R-CNN 没有本质区别，所以重点是 $ L_{\text{mask}}$，它是平均二分类交叉熵损失。</p><p>\begin{equation}<br>L = L_{\text{cls}} + L_{\text{box}} + L_{\text{mask}}<br>\end{equation}</p><p>假设一共有 $K$ 个类别，则 Mask 分割分支的输出维度是 $K m m$。所以对于 $m\times m$ 中的每个点，都会输出 $K$ 个二值 Mask（每个类别使用 <code>sigmoid</code> 输出）。这里与 FCN 的做法不同，FCN 在每个像素点上应用 softmax 函数，整体采用多任务交叉熵，这样会导致类间竞争（class competition），最终导致分割效果差。其实上文也能看到，分割效果的确很差。</p><p><img data-src="https://z3.ax1x.com/2021/05/25/gzgnb9.png" alt></p><blockquote><p>在 Faster RCNN 做 object detection 的时候，已经把某一块 RoI 识别为汽车，但这个 RoI 内可能存在其他物体的一部分，因此分割的 mask 中，除了要将汽车分割出来外，还要把另外那个物体也分割出来。这就导致这样的情况，在 object detection 的分支中，这块 RoI 整体被识别为汽车，但在 segmentation 的时候，这块 RoI 一部分被识别为汽车，一部分又要当作其他物体。如此一来，这两个分支回传到前面的梯度多少存在冲突，而前面的特征提取网络可是共享的，结果网络在学习的时候就可能出现左右为难的情况。</p></blockquote><p>那么来考虑二分类。To this we apply a per-pixel sigmoid, and define $L_{\text{mask}}$ as the average binary cross-entropy loss. For an RoI associated with ground-truth class $k$, $L_{\text{mask}}$ is only defined on the $k$-th mask (other mask outputs do not contribute to the loss). 也就是，只考虑一种类别，如果 ground truth 中标记了这个 bounding box 中是个人的话，那我们就只针对人的 mask 进行分割，而对这个 bounding box 中其他可能存在的物体一律忽视。如下图所示。这里画图的思想参考了这篇文章 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</p><p><img data-src="https://z3.ax1x.com/2021/05/25/gzRBjS.png" alt></p><p>在测试阶段，通过分类分支预测的类别来选择相应的 Mask 预测。这样，Mask 预测和分类预测就彻底解耦了。</p><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><ol><li><a href="https://pytorch.org/tutorials/intermediate/torchvision_tutorial.html" target="_blank" rel="noopener">torchvision</a> 上有现成的示例。</li><li>等我以后用到语义分割的时候再回来补冲这里的程序，那时候肯定是 open-mmlab 系列的东西了。</li></ol><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://en.wikipedia.org/wiki/File:RoI_pooling_animated.gif" target="_blank" rel="noopener">ROI pooling 动图</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://towardsdatascience.com/understanding-region-of-interest-part-2-roi-align-and-roi-warp-f795196fc193" target="_blank" rel="noopener">ROI Align 动图</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zhuanlan.zhihu.com/p/65321082" target="_blank" rel="noopener">二分类损失代替多分类损失</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不同于 FCN 的语义分割，Mask R-CNN 是用于实体分割的。借鉴 FCN 的思想，通过在 Faster R-CNN 的用于边界框识别分支上添加了一个并行的用于预测目标掩码的分支 Mask，在实现目标检测的同时，实现实例分割（object instance segmentation），即把每个目标像素分割出来。而 Faster R-CNN 和 FCN 在之前介绍过，所以本文的重点将会放在损失函数的设计和 ROI-Align 上。&lt;/p&gt;
&lt;p&gt;实体分割不同于语义分割的是，不仅要检测出所属类别，还要区分同一类别下的不同实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/05/25/gxXEss.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="CV" scheme="https://muyuuuu.github.io/tags/CV/"/>
    
  </entry>
  
</feed>
