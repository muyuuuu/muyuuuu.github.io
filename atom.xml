<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just for Life.</title>
  
  <subtitle>明月更几时</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muyuuuu.github.io/"/>
  <updated>2023-03-03T09:27:12.263Z</updated>
  <id>https://muyuuuu.github.io/</id>
  
  <author>
    <name>兰铃</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个不是很规范的致谢</title>
    <link href="https://muyuuuu.github.io/2023/03/03/thanks-thesis/"/>
    <id>https://muyuuuu.github.io/2023/03/03/thanks-thesis/</id>
    <published>2023-03-03T09:18:27.000Z</published>
    <updated>2023-03-03T09:27:12.263Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写一个正经的致谢吧，作为学生时代的一个小结尾。毕业论文里的致谢太八股了，前一半内容一定要大幅的感谢老师，感谢老师给的机会和培养。后四分之一写实验室同学，在后面写父母。不能感谢自己，最后一段感谢论文评委，过于官方的东西没意思的很。所以写一些不能放到论文里面的致谢。</p><a id="more"></a><p>想来想去一时间不知道从哪里开始谢起，先感谢一下 <a href="https://github.com/note286" target="_blank" rel="noopener">Carol</a> 老师吧，写的 <code>xduts</code> 模板和接口过于强大，让我能愉快的使用 <code>TeX</code> 写硕士毕业论文，不用再花费过多的精力去调整复杂的格式，使用期间也没有遇到任何排版上问题和困难，还耐心的解答了我的各种疑问。<code>Carol</code> 老师原话：毕业论文除内容外的所有东西他都会，比如 pdf 裁边这种很微小但又很细节的东西。</p><p>想起来 2020 年研究生入学的时候，那时候充满了惶恐和焦虑。当时年轻也不知道如何去选择一个好组和一个好老师，听说了老师的各种事迹后焦虑到呼吸困难。入学后直线加深了我的焦虑，时常担忧未来而在夜里无法入眠。感谢我亲爱的 ykc 师兄不知道和我们在夜里交流了多少次，研一很多次，研二很多次，研三很多次，在实验室，在操场，在小饭馆。虽然他也肩负很大的压力，但也尽可能的舒缓我们的情绪，每次和他聊完都感觉身心安定，坚定了读下去的心。也感谢大师兄 wz，帮我们顶住了老师的压力，每次都尽力的和我们讨论问题，帮我们度过一次次的难关，在其他生活琐事和医食住行等方面也给了我们很多帮助。</p><p>在 21 年 11 月的时候，步入了人生的低谷，整日浑浑噩噩沉迷于无所事事。感谢我的师弟 wzb，和我一起开发华为算子中的难点，帮我分担了很大的压力。在今年的 1 月和 2 月帮我跑毕业论文中的部分实验，再次帮我分担压力和焦虑，让我有时间和经历去写毕业论文。真的十分感谢，我当时还在想，毕业后要不要给师弟买个 PS5。</p><p>除此之外，由于进的组人数极少且没有任何形式的合作和交流，我更多的社交也都在互联网上了。感谢一个水群的网友，来自五湖四海但因写代码相识，和你们聊天消耗了我日常 70% 的话语，代码技术聊到人生哲学，甚至偶尔搞搞黄色和八卦，让我感觉没那么孤独。</p><p>十分感谢给予我经济援助的小伙伴们。研一下半年的经济状况过于贫困，也不好意思去找家里要钱，每天都在芹菜、豆芽、粉条、白菜、西葫芦、豆腐和西红柿之间轮换，因为很便宜。连续吃了几个月之后导致我现在看到这些食物依然反胃，迫于无奈选择了靠程序辅导去赚点钱，感谢你们一笔一笔的经济援助和支持，让我有足够的钱去吃肉、买新衣服、回家能坐高铁，让我活的更加体面。你们人都很好，也希望你们在告别短暂的计算机编程之后，能迎来更好的人生。</p><p>尤其感谢期间认识的 tcr 小姐姐，2022 年的 8 9 月份，找工作压力很大期间还生了一次大病，她不断的安慰和鼓励我，每次都发很多很多的话和语音，给我很多建议，希望我坚持下去打败困难，对于我理解不了的内容还打电话特意解释。大恩不言谢，日后必定请吃饭，请最贵的那种。之后感谢 qq，hkx 和 bmh，不嫌弃和我这样的发疯人士聊天，承担了我大多数孤独和压抑的情绪，在我多次发疯后依然不介意尝试去疏导我的情绪和压力。hkx 在听说我读研的遭遇后，二话不说给我买了很多零食，qq 在知道我失眠后给我邮寄了酸枣仁，原来我还不是孤魂野鬼。</p><p>昨晚在写论文摘要的时候，想起来一件事情。18 年打比赛的时候，最后一天的凌晨 4 点累的不知道自己是谁，就去跟老师说，我写不动了，你能帮我写下摘要吗？老师说行。我直接睡了过去，再次醒来就是 8 点了。老师 40 多岁，还是通宵帮我把所有事情都弄好，我永远像个孩子一样。后来每次写论文摘要的时候，都会想起他的样子。我很感谢我的本科老师，他把我带入了新的生活和世界，让我学到了编程和建模，从此走上了不一样的道路。我还记得他说过的话：学以致用。我还记得最感动的一次， 大三的时候我在犹豫要不要去打比赛，他说：如果我要去，他就把最后一个名额留给我，人我随便挑；如果我不去，最后一个名额也不准备带别人了，当时感动了很久。那年全校 100 多个队伍参赛，只有 4 个一等奖，我是其中之一，那年我的获奖证书被放到学校招新的海报中，也一步步的保研成功。</p><p>也许，人生大部分时候都是痛苦的，只有少数的幸福时刻，就像河面上的少许的波光粼粼。但就是这些少许的亮光，能让河流看起来更美，能照亮绝大多数的平庸或难熬时刻，温暖着我们继续走下去。</p><p>甚至还想感谢 XM，给我提供了人生的第一份工作，开了极具诱惑力的薪资，还是我很向往的工作方向。本科学的 A 方向，对 B 方向感兴趣，研究生学的 C 方向，对 E 方向感兴趣，但没有 E 方向的相关知识储备和项目经验，所以找工作准备的 D 方向。最后 XM 提供的工作方向是 E，兜兜转转还是遇到了最喜欢的方向，真的十分满足。其实还有一些宿命论的味道，我第一门学习的编程语言大一开设的 C++ 课程，之后对编程萌发了兴趣转专业去学计算机，未来的工作方向也是 C++，很长一段时间内都要靠它吃饭了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写一个正经的致谢吧，作为学生时代的一个小结尾。毕业论文里的致谢太八股了，前一半内容一定要大幅的感谢老师，感谢老师给的机会和培养。后四分之一写实验室同学，在后面写父母。不能感谢自己，最后一段感谢论文评委，过于官方的东西没意思的很。所以写一些不能放到论文里面的致谢。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Life" scheme="https://muyuuuu.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>2022, 随便写点</title>
    <link href="https://muyuuuu.github.io/2022/12/02/2022/"/>
    <id>https://muyuuuu.github.io/2022/12/02/2022/</id>
    <published>2022-12-02T14:14:21.000Z</published>
    <updated>2022-12-11T09:07:56.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>6年前的12月1号<br>体育课下课后在操场跑了几圈<br>背着当时的初中用过来的破旧书包，去兰园一楼吃了顿鸭扒饭<br>晚上去自习室学高数，分部积分<br>之后每年的12.1都会回忆起那普通的一天，宣告着这一年还有最后一个月<br>今年也不例外 ​​</p><a id="more"></a><p>12岁的时候，觉得动画片这么好看大人怎么不喜欢看呢。总以为20岁以后时间密度和快乐会和童年一样，不断打开的新鲜生活是应接不暇的，每一件事都会历历在目，念念不忘，生活也一定五彩斑斓，总有新领域等待我去玩耍。</p><p>20岁后的这几年才明白，因为各种主客观的壁垒，成年以后的人生在收窄，只能在一个地方永远停留下去，重复的事物越来越多，时间在重复里飞速进行，总觉得根本没做什么一年就过去了。</p><p>人不能同时拥有青春和感受青春，也大概理解了年轻真好的意思，年轻人还有时间去改变一些东西，成年人如果想去改变自己的现状，可以，但会付出很大很大的成本与代价。</p><p>年历仍是在更迭的，但每年都像被水浸泡过一般，界限逐步模糊，无法像幼时那样能一一分得清楚，有期待感。只觉得这几年里都是循环的情绪，堆砌的熟稔，往复的麻木，仿佛依靠惯性在活着。即便偶遇意外的惊喜或猝然的悲恸，事后冷静想想，也好像都是从前早已领教过的二手货。</p><p>今年去西安的时候，下了大雪，我寻思着瑞雪兆丰年；今天完成了找工作的最后一步，寄三方，又下了大雪；两场大雪，也许宣告了青春的结束。</p><p>之前不顺心的时候，总是想着努努力忍一忍，以后去个好地方永远的告别这里，高中是这样，研究生也是这样。</p><p>最近在忙毕设，学校的压迫程度，资本家都自叹不如，期望在毕业之前我的博客还能有所技术产出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;6年前的12月1号&lt;br&gt;体育课下课后在操场跑了几圈&lt;br&gt;背着当时的初中用过来的破旧书包，去兰园一楼吃了顿鸭扒饭&lt;br&gt;晚上去自习室学高数，分部积分&lt;br&gt;之后每年的12.1都会回忆起那普通的一天，宣告着这一年还有最后一个月&lt;br&gt;今年也不例外 ​​&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Life" scheme="https://muyuuuu.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>秋招结束</title>
    <link href="https://muyuuuu.github.io/2022/10/23/fuck-autumn-recruitment/"/>
    <id>https://muyuuuu.github.io/2022/10/23/fuck-autumn-recruitment/</id>
    <published>2022-10-22T16:06:26.000Z</published>
    <updated>2022-10-22T16:30:18.774Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>寒气逼人的惨淡秋招终于 tnnd 的结束了，4月中旬开始投递，10月中旬拿到 offer，耗时6个月。就业形式异常艰难，简历挂，笔试挂，面试挂，感谢信收割机。一种被累垮的感觉。</p><a id="more"></a><p>大家仿佛都是在 3 月份开始了背八股文，我当时觉得没啥意思就顺手参加了个比赛。本人找的算法岗，由于懒惰和各种原因，在第一场面试开始的时候，我都没有背八股，连梯度消失这样的问题偶没有回答上来。拖延到6月下旬才开始背八股，背的时间不长，断断续续的一个月，每次面试前看看笔记就行，剩下的随缘发挥。</p><p>但同组的就不一样了，他们投的 java 开发，从 java 基础，多线程，JVM，框架，分布式，数据库，网络，系统等等等等他们都要背，如果说我要掌握的知识一周就可以背完，他们的知识至少要背十周。找工作的时候，他们是睡在实验室的。</p><p>最艰难的时候是从7月30号开始的，我清楚的记得那天能投10家公司，除了快手通知我面试外，其余全挂，可惜快手也是一面就挂。在8月的某天下午和晚上连开四场笔试，极限操作，头晕脑胀，手在颤抖，从8月到9月，持续一个月不间断的面试和笔试。这辈子也不想在回忆这种头晕的感觉。</p><p>来形容一下某头部大厂的面试，开局两个 hard 级别的 leetcode 题，我写上来了。结果以为后面会很顺畅，结果呢，面试全程就三个字，嗯，啊，好，面试结束。后来才知道他想用代码题来劝退我，早知道我就不写了。在形容一下某硬件大厂的面试：你了解过XX吗，我说没有；你用过XX吗，我说不好意思只听说过。面试直接结束，全程不到5分钟，至于简历里写了什么，你是做什么的一概不问。</p><p>京东，网易和腾讯的题目都是令人劝退的难度。如果说数学不会还能写个解，编程不会甚至不能写个空格。我还清楚的记得今年的网易，京东和百度都在围绕 <code>red</code> 这个字符串出题，红色意味着警告，可能告诉我们今年形式很严峻吧。蚂蚁笔试干脆交了白卷，后续的笔试也没有参加，不是看不上蚂蚁，是我真的累了；字节笔试一个不会，瞪着屏幕发呆两小时的感觉很难受。7月投了多少公司，8月就收了多少感谢信。</p><p>我在17年因为喜欢代码转专业到了计算机。但是秋招的很长一段时间内患上了代码 PTSD，一看到代码题目就头晕，想睡，本人十分厌恶刷题，找不到丝毫写代码的乐趣，也没有学习的乐趣，一股为了学习而学习的中学味，令人呕吐。以至于后来面试的时候，明明很简单的题，我的下意识反应都是我不会，很简单的题我会想的很复杂。比如求最长回文子串，明明是一个很简单的暴力模拟题，我看到最这个字就往动态规划那边去想，结果写出来的程序又臭又长，我自己都看不下去，写到一半干脆说了不会。</p><p>就像准备了很久的高考，上了考场发现自己害怕，不会，也不敢动笔。百度是这样，快手是这样，滴滴也是这样；我是这样，同组得这样，舍友也是这样，大家都被拖的很累。经济形势不好，今年的就业形势到处是槽点。百度和快手的面试官态度是最好的，夸一下。</p><p>今年最大的意外就是：本科学的A方向，研究生是B方向，准备的C方向，最后的工作是D方向。至于我能拿offer跟我实力没有半毛钱关系，计算机卷的起飞，我被挤到了芯片，医疗，金融，VR等各个方向，没有一个和计算机相关。面试凭实力？错，全凭运气，有的厂的笔试很简单大二学生都会，面试也能聊得来；有的令人想直接关了屏幕再你妈的见。如果可以，我还是想回到大学的校园里，好好补补基础课。面到最后发现还是大学课程的基本功，可惜大学的黄金时光被我荒废。</p><p>感谢各位大哥的帮助，尤其是田学姐数次救我狗命于水火之中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;寒气逼人的惨淡秋招终于 tnnd 的结束了，4月中旬开始投递，10月中旬拿到 offer，耗时6个月。就业形式异常艰难，简历挂，笔试挂，面试挂，感谢信收割机。一种被累垮的感觉。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Life" scheme="https://muyuuuu.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>从 0 开始的 TorchScript</title>
    <link href="https://muyuuuu.github.io/2022/10/03/torch-jit-1/"/>
    <id>https://muyuuuu.github.io/2022/10/03/torch-jit-1/</id>
    <published>2022-10-02T16:04:09.000Z</published>
    <updated>2022-10-02T16:08:35.887Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上一次正儿八经写博客是今年 2 月，5 月做了个比赛总结，其余的博客竟然都是刷题和算法，实属无聊。艰难的日子已经过去，准备学点模型部署相关的东西以及参与一个实际的开源项目，争取数据、算法和工程全链路打通。众所周知，对于一个不是很常用的东西，学完就忘，如 <code>spark, Go</code> 等学过的但很少用的东西，已经被我抛到九霄云外了。所以，这次学完模型的 <code>trace</code> 之后，尝试部署一些能实际运行的软件。</p><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><code>TorchScript</code> 是 <code>PyTorch</code> 的 <code>JIT</code> 实现。<code>JIT</code> 全程是 Just In Time Compilation，也就是即使编译。在深度学习中 <code>JIT</code> 的思想更是随处可见，最明显的例子就是 <code>Keras</code> 框架的 model.compile 创建的静态图。</p><ul><li>静态图需要先构建再运行，优势是在运行前可以对图结构进行优化，比如常数折叠、算子融合等，可以获得更快的前向运算速度。缺点也很明显，就是只有在计算图运行起来之后，才能看到变量的值，像 <code>TensorFlow1.x</code> 中的 <code>session.run</code> 那样。</li><li>动态图是一边运行一边构建，优势是可以在搭建网络的时候看见变量的值，便于检查。缺点是前向运算不好优化，因为根本不知道下一步运算要算什么。动态图模型通过牺牲一些高级特性来换取易用性。</li></ul><p>那么那到底 <code>JIT</code> 有哪些特性，使得 <code>torch</code> 这样的动态图框架也要走 <code>JIT</code> 这条路呢？或者说在什么情况下不得不用到 <code>JIT</code> 呢？下面主要通过介绍 <code>TorchScript</code> 来分析 <code>JIT</code> 到底带来了哪些好处。</p><p><code>JIT</code> 是 <code>Python</code> 和 <code>C++</code> 的桥梁，我们可以使用 <code>Python</code> 训练模型，然后通过 <code>JIT</code> 将模型转为语言无关的模块，从而让 <code>C++</code> 可以非常方便得调用，从此「使用 <code>Python</code> 训练模型，使用 <code>C++</code> 将模型部署到生产环境」对 <code>PyTorch</code> 来说成为了一件很容易的事。而因为使用了 <code>C++</code>，我们现在几乎可以把 <code>PyTorch</code> 模型部署到任意平台和设备上：树莓派、iOS、Android 等等。不然每次都要通过 <code>python</code> 调用模型，性能会大打折扣。</p><p>既然是为部署生产所提供的特性，那免不了在性能上面做了极大的优化，如果推断的场景对性能要求高，则可以考虑将模型（<code>torch.nn.Module</code>）转换为 <code>TorchScript Module</code>，再进行推断。有两种方式可以转换：</p><ol><li>使用 <code>TorchScript Module</code> 的更简单的办法是使用 <code>Tracing</code>，<code>Tracing</code> 可以直接将 <code>PyTorch</code> 模型（<code>torch.nn.Module</code>）转换成 <code>TorchScript Module</code>。「 <code>trace</code> 」顾名思义，就是需要提供一个「输入」来让模型 <code>forward</code> 一遍，以通过该输入的流转路径，获得图的结构。这种方式对于 <code>forward</code> 逻辑简单的模型来说非常实用，但如果 <code>forward</code> 里面本身夹杂了很多流程控制语句，就会存在问题，因为同一个输入不可能遍历到所有的逻辑分枝。<strong>而没有被经过的分支就不会被 <code>trace</code> 。</strong></li><li>可以直接使用 <code>TorchScript Language</code> 来定义一个 <code>PyTorch JIT Module</code>，然后用 <code>torch.jit.script</code> 来将他转换成 <code>TorchScript Module</code> 并保存成文件。而 <code>TorchScript Language</code> 本身也是 <code>Python</code> 代码，所以可以直接写在 <code>Python</code> 文件中。对于 <code>TensorFlow</code> 我们知道不能直接使用 <code>Python</code> 中的 <code>if</code> 等语句来做条件控制，而是需要用 <code>tf.cond</code>，但对于 <code>TorchScript</code> 我们依然能够直接使用 <code>if</code> 和 <code>for</code> 等条件控制语句，所以即使是在静态图上，<code>PyTorch</code> 依然秉承了「易用」的特性。</li></ol><h1 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h1><h2 id="trace-方法"><a href="#trace-方法" class="headerlink" title="trace 方法"></a>trace 方法</h2><p>首先定义一个简单的模型：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDecisionGate</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># 分支判断</span></span><br><span class="line">        <span class="keyword">if</span> x.sum() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyCell, self).__init__()</span><br><span class="line">        self.dg = MyDecisionGate()</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, h)</span>:</span></span><br><span class="line">        y = torch.tanh(self.dg(self.linear(x)) + h)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">my_cell = MyCell()</span><br><span class="line">print(my_cell)</span><br><span class="line">x, h = torch.rand(<span class="number">1</span>, <span class="number">4</span>), torch.rand(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">print(my_cell(x, h))</span><br></pre></td></tr></table></figure><p>我们可以绑定输入对模型进行 <code>trace</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDecisionGate</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x.sum() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyCell, self).__init__()</span><br><span class="line">        self.dg = MyDecisionGate()</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, h)</span>:</span></span><br><span class="line">        y = torch.tanh(self.dg(self.linear(x)) + h)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">my_cell = MyCell()</span><br><span class="line">x, h = torch.rand(<span class="number">1</span>, <span class="number">4</span>), torch.rand(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">trace_model = torch.jit.trace(my_cell, (x, h))</span><br><span class="line">print(trace_model(x, h))</span><br><span class="line">print(trace_model.code)</span><br><span class="line"><span class="comment"># def forward(self,</span></span><br><span class="line"><span class="comment">#     x: Tensor,</span></span><br><span class="line"><span class="comment">#     h: Tensor) -&gt; Tensor:</span></span><br><span class="line"><span class="comment">#   dg = self.dg</span></span><br><span class="line"><span class="comment">#   linear = self.linear</span></span><br><span class="line"><span class="comment">#   _0 = torch.add((dg).forward((linear).forward(x, ), ), h)</span></span><br><span class="line"><span class="comment">#   return torch.tanh(_0)</span></span><br></pre></td></tr></table></figure><p>可以看到没有出现 <code>if-else</code> 的分支， <code>trace</code> 做的是：运行代码，记录出现的运算，构建 <code>ScriptModule</code>，但是控制流就丢失了。然后流程丢失并不是好事，在 <code>trace</code> 只会对一个输入进行处理的情况下，对不同的输入得到的结果是不一样的，因为输入只会满足一个分支，因此 <code>trace</code> 的程序也只包含一个分支。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDecisionGate</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x.sum() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line">my_cell = MyDecisionGate()</span><br><span class="line">x = torch.tensor([<span class="number">-0.1</span>, <span class="number">0.05</span>]) <span class="comment"># 这两个 x trace 到的代码是不一样的</span></span><br><span class="line"><span class="comment"># x = torch.tensor([0.1, -0.05])</span></span><br><span class="line">trace_model = torch.jit.trace(my_cell, (x))</span><br><span class="line">print(trace_model(x))</span><br><span class="line">print(trace_model.code)</span><br></pre></td></tr></table></figure><p>因此，我们认为这样的 <code>trace</code> 没有泛化能力。而这种现象普遍发生在动态控制流中，即：具体执行哪个算子取决于输入的数据。</p><ul><li><code>if x[0] == 4: x += 1</code> 是动态控制流</li><li><code>model: nn.Sequential = ... [m(x) for x in model]</code> 不是</li><li><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">  backbone: nn.Module</span><br><span class="line">  head: Optiona[nn.Module]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    x = self.backbone(x)</span><br><span class="line">    <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        x = self.head(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></li></ul><p>不是</p><p>在之后的文章中，会介绍如何使 <code>trace</code> 具备泛化能力。</p><h2 id="script-方法"><a href="#script-方法" class="headerlink" title="script 方法"></a>script 方法</h2><p><code>script</code> 方法直接分析 <code>python</code> 代码进行转换：使用他们提供的 <code>script</code> 编译器，将 <code>python</code> 的代码进行语法分析，并重新解释为 <code>TorchScript</code>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDecisionGate</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x.sum() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dg)</span>:</span></span><br><span class="line">        super(MyCell, self).__init__()</span><br><span class="line">        self.dg = dg</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, h)</span>:</span></span><br><span class="line">        new_h = torch.tanh(self.dg(self.linear(x)) + h)</span><br><span class="line">        <span class="keyword">return</span> new_h, new_h</span><br><span class="line"></span><br><span class="line">scripted_gate = torch.jit.script(MyDecisionGate())</span><br><span class="line">print(scripted_gate.code) <span class="comment"># 含有流程控制</span></span><br><span class="line">my_cell = MyCell(scripted_gate)</span><br><span class="line">traced_cell = torch.jit.script(my_cell)</span><br><span class="line">print(traced_cell.code)</span><br></pre></td></tr></table></figure><ol><li><code>TorchScript</code> 代码可以被它自己的解释器（一个受限的 <code>Python</code> 解释器）调用。这个解释器不需要获得全局解释锁GIL，这样很多请求可以同时处理。</li><li>这个格式可以让我们保存模型到硬盘上，在另一个环境中加载，例如服务器，也可以使用非 <code>python</code> 的语言。</li><li><code>TorchScript</code> 提供的表示可以做编译器优化，做到更有效地执行。</li><li><code>TorchScript</code> 可以与其他后端/设备运行时进行对接，他们只需要处理整个项目，无需关心细节运算。</li></ol><h1 id="Trace-和-Script-谁更好？"><a href="#Trace-和-Script-谁更好？" class="headerlink" title="Trace 和 Script 谁更好？"></a>Trace 和 Script 谁更好？</h1><p>通过上文我们可以了解到：</p><ul><li><p><code>trace</code> 只记录走过的 <code>tensor</code> 和对 <code>tensor</code> 的操作，不会记录任何控制流信息，如 <code>if</code> 条件句和循环。因为没有记录控制流的另外的路，也没办法对其进行优化。好处是 <code>trace</code> 深度嵌入 <code>python</code> 语言，复用了所有 <code>python</code> 的语法，在计算流中记录数据流。</p></li><li><p><code>script</code> 会去理解所有的 <code>code</code>，真正像一个编译器一样去进行词法分析语法分析句法分析，形成 <code>AST</code> 树，最后再将 <code>AST</code> 树线性化。<code>script</code> 相当于一个嵌入在 <code>Python/Pytorch</code> 的 <code>DSL</code>，其语法只是 <code>Pytorch</code> 语法的子集，这意味着存在一些 <code>op</code> 和语法 <code>script</code> 不支持，这样在编译的时候就会遇到问题。此外，<code>script</code> 的编译优化方式更像是 <code>CPU</code> 上的传统编译优化，重点对于图进行硬件无关优化，并对 <code>if</code>、<code>loop</code> 进行优化。</p></li></ul><p>在大模型的部署上 <code>trace</code> 更好，因为可以有效的优化复杂的计算图，如下所示：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x1, x2, x3)</span>:</span></span><br><span class="line">    z = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    xs = [x1, x2, x3]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> z: x1 += xs[k]</span><br><span class="line">    <span class="keyword">return</span> x1</span><br><span class="line">model = A()</span><br><span class="line">print(torch.jit.script(model).code)</span><br><span class="line"><span class="comment"># def forward(self, x1: Tensor, x2: Tensor, x3: Tensor) -&gt; Tensor:</span></span><br><span class="line"><span class="comment">#   z = [0, 1, 2]</span></span><br><span class="line"><span class="comment">#   xs = [x1, x2, x3]</span></span><br><span class="line"><span class="comment">#   x10 = x1</span></span><br><span class="line"><span class="comment">#   for _0 in range(torch.len(z)):</span></span><br><span class="line"><span class="comment">#     k = z[_0]</span></span><br><span class="line"><span class="comment">#     x10 = torch.add_(x10, xs[k])</span></span><br><span class="line"><span class="comment">#   return x10</span></span><br><span class="line">print(torch.jit.trace(model, [torch.tensor(<span class="number">1</span>)] * <span class="number">3</span>).code)</span><br><span class="line"><span class="comment"># def forward(self, x1: Tensor, x2: Tensor, x3: Tensor) -&gt; Tensor:</span></span><br><span class="line"><span class="comment">#   x10 = torch.add_(x1, x1)</span></span><br><span class="line"><span class="comment">#   x11 = torch.add_(x10, x2)</span></span><br><span class="line"><span class="comment">#   return torch.add_(x11, x3)</span></span><br></pre></td></tr></table></figure><p>因为 <code>script</code> 试图忠实地表示 <code>Python</code> 代码，所以即使其中一些是不必要的。例如：并不能对 <code>Python</code> 代码中的某些循环或数据结构进行优化。如上例，所以它实际上有变通方法，或者循环可能会在以后的优化过程中得到优化。但关键是：这个编译器并不总是足够聪明。对于复杂的模型， <code>script</code> 可能会生成一个具有不必要复杂性且难以优化的计算图。</p><p><code>tracing</code> 有许多优点，事实上，在 <code>Facebook/Meta</code> 部署的分割和检测模型中，<code>tracing</code> 是默认的选择，仅当必要的时候使用 <code>scripting</code>。因为 <code>trace</code> 不会破坏代码质量，可以结合 <code>script</code> 来避免一些限制。</p><p><code>python</code> 是一个很大很动态的语言，编译器最多只能支持其语法功能和内置函数的子集，同理，<code>script</code> 也不例外。这个编译器支持 <code>Python</code> 的哪个子集？一个粗略的答案是：编译器对最基本的语法有很好的支持，但对任何更复杂的东西（类、内置函数、动态类型等）的支持度很低或者不支持。但并没有明确的答案：即使是编译器的开发者，通常也需要运行代码，看看能不能编译去判断是否支持。</p><p>所以不完整的 <code>Python</code> 编译器限制了用户编写代码的方式。尽管没有明确的约束列表，但可以从经验中看出它们对大型项目的影响：<code>script</code> 的问题会影响代码质量。很多项目只停留在了代码能 <code>script</code> 成功这一层面，使用基础语法，没有自定义类型，没有继承，没有内置函数，没有 <code>lambda</code> 等等的高级特性。因为这些高级的功能编译器并不支持或者部分支持，就会导致在某些情况下成功，但在其他情况下失败。而且由于没有明确的规范哪些是被支持的，因此用户无法推理或解决故障。因此，最终用户会仅仅停留在代码成功搬移，而不考虑可维护性和性能问题，会导致开发者因为害怕报错而停止进一步的探索高级特性。</p><p>如此下去，代码质量可能会严重恶化：垃圾代码开始积累，因为优良的代码有时无法编译。此外，由于编译器的语法限制，无法轻松进行抽象以清理垃圾代码。该项目的可维护状况逐渐走下坡路。如果认为 <code>script</code> 似乎适用于我的项目，基于过去在一些支持 <code>script</code> 的项目中的经验，我可能会出于以下原因建议不要这样做：</p><ul><li>编译成功可能比你想象的更脆弱（除非将自己限制在基本语法上）：你的代码现在可能恰好可以编译，但是有一天你会在模型中添加一些更改，并发现编译失败；</li><li>基本语法是不够的：即使目前你的项目似乎不需要更复杂的抽象和继承，但如果预计项目会增长，未来将需要更多的语言特性。</li></ul><p>以多任务检测器为例：</p><ul><li>可能有 10 个输入，因此最好使用一些结构/类。</li><li>检测器有许多架构选择，这使得继承很有用。</li><li>大型、不断增长的项目肯定需要不断发展的抽象来保持可维护性。</li></ul><p>因此，这个问题的现状是：<code>script</code> 迫使你编写垃圾的代码，因此我们仅在必要时使用它。</p><h1 id="Trace-细节"><a href="#Trace-细节" class="headerlink" title="Trace 细节"></a>Trace 细节</h1><p><code>trace</code> 让模型的 <code>trace</code> 更清楚，对代码质量有很少的影响。</p><p>如果模型不是以 <code>Pytorch</code> 格式表示的计算图，则 <code>script</code> 和 <code>trace</code> 都不起作用。例如，如果模型具有 <code>DataParallel</code> 子模块，或者如果模型将张量转换为 <code>numpy</code> 数组并调用 <code>OpenCV</code> 函数等，则必须对其进行重构。除了这个明显的限制之外，对 <code>trace</code> 只有两个额外的要求：</p><ul><li><p>输入/输出格式是 <code>Tensor</code> 类型时才能被 <code>trace</code>。但是，这里的格式约束不适用于子模块：子模块可以使用任何输入/输出格式：类、<code>kwargs</code> 以及 <code>Python</code> 支持的任何内容。格式要求仅适用于最外层的模型，因此很容易解决。如果模型使用更丰富的格式，只需围绕它创建一个简单的包装器，它可以与 <code>Tuple[Tensor]</code> 相互转换。</p></li><li><p><code>shape</code>。<code>tensor.size(0)</code> 是 <code>eager</code> 模式下的整数，但它是 <code>tracing mode</code> 下的 <code>tensor</code>。这个差异在 <code>trace</code> 时是必要的，<code>shape</code> 的计算可以被捕获为计算图中的算子。由于不同的返回类型，如果返回的一部分是 <code>shape</code> 是整数则无法 <code>trace</code> ，这通常可以简单的解决。此外，一个有用的函数是 <code>torch.jit.is_tracing</code>，它检查代码是否在 <code>trace</code> 模式下执行。</p></li></ul><p>我们来看个例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = torch.rand(<span class="number">1</span>), torch.rand(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> torch.arange(x.shape[<span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> torch.arange(len(x))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># See if the two traces generalize from a to b:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.jit.trace(f1, a)(b)</span><br><span class="line">tensor([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.jit.trace(f2, a)(b)</span><br><span class="line">tensor([<span class="number">0</span>])  <span class="comment"># WRONG!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Why f2 does not generalize? Let's compare their code:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(torch.jit.trace(f1, a).code, torch.jit.trace(f2, a).code)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(x: Tensor)</span> -&gt; Tensor:</span></span><br><span class="line">  _0 = ops.prim.NumToTensor(torch.size(x, <span class="number">0</span>))</span><br><span class="line">  _1 = torch.arange(annotate(number, _0), dtype=<span class="literal">None</span>, layout=<span class="number">0</span>, device=torch.device(<span class="string">"cpu"</span>), pin_memory=<span class="literal">False</span>)</span><br><span class="line">  <span class="keyword">return</span> _1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(x: Tensor)</span> -&gt; Tensor:</span></span><br><span class="line">  _0 = torch.arange(<span class="number">1</span>, dtype=<span class="literal">None</span>, layout=<span class="number">0</span>, device=torch.device(<span class="string">"cpu"</span>), pin_memory=<span class="literal">False</span>)</span><br><span class="line">  <span class="keyword">return</span> _0</span><br></pre></td></tr></table></figure><p>在 <code>trace f2</code> 函数时，<code>lex(x)</code> 是一个定值而非 <code>tensor</code>，这样在传入其他长度的数据时就回报错。除了 <code>len()</code>，这个问题也可能出现在：</p><ul><li><code>.item()</code> 将张量转换为 <code>int/float</code>。</li><li>将 <code>Torch</code> 类型转换为 <code>numpy/python</code> 原语的任何其他代码。</li></ul><p><code>tensor.size()</code> 在 <code>trace</code> 期间返回 <code>Tensor</code>，以便在图中捕获形状计算。用户应避免意外将张量形状转换为常量。使用 <code>tensor.size(0)</code> 而不是 <code>len(tensor)</code>，因为后者是一个 <code>int</code>。这个函数对于将大小转换为张量很有用，在 <code>trace</code> 和 <code>eager</code> 模式下都可以使用。对于自定义类，实现 <code>.size()</code> 方法或使用 <code>.__len__()</code> 而不是 <code>len()</code>，不要通过 <code>int()</code> 转换大小，因为它们会捕获常量。</p><p>这就是 <code>trace</code> 所需要的一切。最重要的是，模型实现中允许使用任何 <code>Python</code> 语法，因为 <code>trace</code> 根本不关心语法。</p><h2 id="Trace-的泛化问题"><a href="#Trace-的泛化问题" class="headerlink" title="Trace 的泛化问题"></a>Trace 的泛化问题</h2><h3 id="Trace-和-Script-混合"><a href="#Trace-和-Script-混合" class="headerlink" title="Trace 和 Script 混合"></a>Trace 和 Script 混合</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>  <span class="keyword">return</span> torch.sqrt(x) <span class="keyword">if</span> x.sum() &gt; <span class="number">0</span> <span class="keyword">else</span> torch.square(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = torch.jit.trace(f, torch.tensor(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(m.code)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x: Tensor)</span> -&gt; Tensor:</span></span><br><span class="line">  <span class="keyword">return</span> torch.sqrt(x)</span><br></pre></td></tr></table></figure><p>注意这种代码在 <code>trace</code> 时不会报错，只有 <code>warning</code> 的输出，因此我们要特别关注。<code>trace</code> 和 <code>script</code> 都有各自的问题，最好的方法是混合使用他们。避免影响代码质量，主要的部分进行 <code>trace</code>，必要时进行 <code>script</code>。如果有一个 <code>module</code> 里面有很多选择，但是我们不希望在 <code>TorchScript</code> 里出现，那么应该使用 <code>tracing</code> 而不是 <code>scripting</code>，这个时候，<code>trace</code> 将内联 <code>script</code> 模块的代码。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDecisionGate</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x.sum() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCell</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dg)</span>:</span></span><br><span class="line">        super(MyCell, self).__init__()</span><br><span class="line">        self.dg = dg</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, h)</span>:</span></span><br><span class="line">        new_h = torch.tanh(self.dg(self.linear(x)) + h)</span><br><span class="line">        <span class="keyword">return</span> new_h, new_h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRNNLoop</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, scripted_gate, x, h)</span>:</span></span><br><span class="line">        super(MyRNNLoop, self).__init__()</span><br><span class="line">        <span class="comment"># 对控制流进行 trace</span></span><br><span class="line">        self.cell = torch.jit.trace(MyCell(scripted_gate), (x, h))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, xs)</span>:</span></span><br><span class="line">        h, y = torch.zeros(<span class="number">3</span>, <span class="number">4</span>), torch.zeros(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(xs.size(<span class="number">0</span>)):</span><br><span class="line">            y, h = self.cell(xs[i], h)</span><br><span class="line">        <span class="keyword">return</span> y, h</span><br><span class="line"></span><br><span class="line">x, h = torch.rand(<span class="number">2</span>, <span class="number">4</span>), torch.rand(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">scripted_gate = torch.jit.script(MyDecisionGate())</span><br><span class="line">rnn_loop = torch.jit.script(MyRNNLoop(scripted_gate, x, h))</span><br><span class="line">print(rnn_loop.code)</span><br><span class="line">print(rnn_loop.cell.code)</span><br></pre></td></tr></table></figure><p>我们简化一下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.submodule = torch.jit.script(model.submodule)</span><br><span class="line">torch.jit.trace(model, inputs)</span><br></pre></td></tr></table></figure><p>对于不能正确 <code>trace</code> 的子模块，可以进行 <code>script</code> 处理。但是并不推荐，更建议使用 <code>@script_if_tracing</code>，因为这样修改 <code>script</code> 仅限于子模块的内部，而不影响模块的接口。使用 <code>@script_if_tracing</code> 装饰器，在 <code>torch.jit.trace</code> 时，<code>@script_if_tracing</code> 装饰器可以通过 <code>script</code> 编译。通常，这只需要对前向逻辑进行少量重构，以分离需要编译的部分（具有控制流的部分）：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, ...)</span>:</span></span><br><span class="line">  <span class="comment"># ... some forward logic</span></span><br><span class="line"><span class="meta">  @torch.jit.script_if_tracing</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_inner_impl</span><span class="params">(x, y, z, flag: bool)</span>:</span></span><br><span class="line">      <span class="comment"># use control flow, etc.</span></span><br><span class="line">      <span class="keyword">return</span> ...</span><br><span class="line">  output = _inner_impl(x, y, z, flag)</span><br><span class="line">  <span class="comment"># ... other forward logic</span></span><br></pre></td></tr></table></figure><p>只 <code>script</code> 需要的部分，代码质量相对于全部 <code>script</code> 被破坏的很少，被 <code>@script_if_tracing</code> 装饰的函数必须是不包含 <code>tensor</code> 模块运算的纯函数。因此，有时需要进行更多重构：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Before:</span></span><br><span class="line"><span class="keyword">if</span> x.numel() &gt; <span class="number">0</span>:  <span class="comment"># This branch cannot be compiled by @script_if_tracing because it refers to `self.layers`</span></span><br><span class="line">  x = preprocess(x)</span><br><span class="line">  output = self.layers(x)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  output = torch.zeros(...)  <span class="comment"># Create empty outputs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># After:</span></span><br><span class="line"><span class="keyword">if</span> x.numel() &gt; <span class="number">0</span>:  <span class="comment"># This branch can now be compiled by @script_if_tracing</span></span><br><span class="line">  x = preprocess(x)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  x = torch.zeros(...)   <span class="comment"># Create empty inputs</span></span><br><span class="line"><span class="comment"># Needs to make sure self.layers accept empty inputs.</span></span><br><span class="line"><span class="comment"># If necessary, add such condition branch into self.layers as well.</span></span><br><span class="line">output = self.layers(x)</span><br></pre></td></tr></table></figure><p>同样的，我们可以在 <code>script</code> 中嵌套 <code>trace</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.submodule = torch.jit.trace(model.submodule, submodule_inputs)</span><br><span class="line">torch.jit.script(model)</span><br></pre></td></tr></table></figure><p>这里的子模块是 <code>trace</code>，但是实际中并不常用，因为会影响子模块的推理（当且仅当子模块的输入和输出都是 <code>tensor</code> 时才适用），这是很大的限制。但是 <code>trace</code> 作为子模块的时候也有很试用的场景：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="comment"># Dispatch to different submodules based on a dynamic, data-dependent condition:</span></span><br><span class="line">    <span class="keyword">return</span> self.submodule1(x) <span class="keyword">if</span> x.sum() &gt; <span class="number">0</span> <span class="keyword">else</span> self.submodule2(x)</span><br></pre></td></tr></table></figure><p><code>@script_if_tracing</code> 不能处理这样的控制流，因为它只支持纯函数。如果子模块很复杂不能被 <code>script</code>，使用 <code>trace</code>  <code>trace</code> 子模块是很好的选择，这里就是 <code>self.submodule2</code> 和 <code>self.submodule1</code>，类 <code>A</code> 还是要 <code>script</code> 的。</p><h3 id="Script-优势"><a href="#Script-优势" class="headerlink" title="Script 优势"></a>Script 优势</h3><p>事实上，对于大多数视觉模型，动态控制流仅在少数易于编写 <code>script</code> 的子模块中需要。<code>script</code> 相对于 <code>trace</code>，有两个有点：</p><ul><li>一个数据有很多属性的控制流，<code>trace</code> 无法处理</li><li><code>trace</code> 只支持 <code>forward</code> 方法，<code>script</code> 支持更多的方法</li></ul><p>实际上，上述两个功能都在做同样的事情：它们允许以不同的方式使用导出的模型，即根据调用者的请求执行不同的运算符序列。下面是一个这样的特性很有用的示例场景：如果 <code>Detector</code> 是 <code>script</code> 化，调用者可以改变它的 <code>do_keypoint</code> 属性来控制它的行为，或者如果需要直接调用 <code>predict_keypoint</code> 方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Detector</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">  do_keypoint: bool</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, img)</span>:</span></span><br><span class="line">      box = self.predict_boxes(img)</span><br><span class="line">      <span class="keyword">if</span> self.do_keypoint:</span><br><span class="line">          kpts = self.predict_keypoint(img, box)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">predict_boxes</span><span class="params">(self, img)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">predict_keypoint</span><span class="params">(self, img, box)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这种要求并不常见。但是如果需要，如何在 <code>trace</code> 中实现这一点？我有一个不是很优雅的解决方案：<code>Tracing</code> 只能捕获一个序列的算子，所以自然的方式是对模型进行两次 <code>Tracing</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">det1 = torch.jit.trace(Detector(do_keypoint=<span class="literal">True</span>), inputs)</span><br><span class="line">det2 = torch.jit.trace(Detector(do_keypoint=<span class="literal">False</span>), inputs)</span><br></pre></td></tr></table></figure><p>然后我们可以为它们的模型设置别名（以不重复存储），并将两个 <code>trace</code> 合并到一个模块中以编写 <code>script</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">det2.submodule.weight = det1.submodule.weight</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span><span class="params">(nn.ModuleList)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, img, do_keypoint: bool)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> do_keypoint:</span><br><span class="line">        <span class="keyword">return</span> self[<span class="number">0</span>](img)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self[<span class="number">1</span>](img)</span><br><span class="line">exported = torch.jit.script(Wrapper([det1, det2]))</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>还可以使用单元测试来判断 <code>trace</code> 是否成功：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> allclose(torch.jit.trace(model, input1)(input2), model(input2))</span><br></pre></td></tr></table></figure><h3 id="程序优化"><a href="#程序优化" class="headerlink" title="程序优化"></a>程序优化</h3><p>此外，还可以通过<a href="https://github.com/pytorch/pytorch/issues/56998" target="_blank" rel="noopener">优化</a>程序，避免掉不必要的特殊情况：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x.numel() &gt; <span class="number">0</span>:</span><br><span class="line">  output = self.layers(x)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  output = torch.zeros((<span class="number">0</span>, C, H, W))  <span class="comment"># Create empty outputs</span></span><br></pre></td></tr></table></figure><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p>此外还需要注意设备问题，在 <code>trace</code> 期间会记录使用的设备，而 <code>trace</code> 不会对不同的设备进行泛化，但是部署时都会有固定的设备，这个问题不用担心。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>  <span class="keyword">return</span> torch.arange(x.shape[<span class="number">0</span>], device=x.device)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = torch.jit.trace(f, torch.tensor([<span class="number">3</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(m.code)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x: Tensor)</span> -&gt; Tensor:</span></span><br><span class="line">  _0 = ops.prim.NumToTensor(torch.size(x, <span class="number">0</span>))</span><br><span class="line">  _1 = torch.arange(annotate(number, _0), dtype=<span class="literal">None</span>, layout=<span class="number">0</span>, device=torch.device(<span class="string">"cpu"</span>), pin_memory=<span class="literal">False</span>)</span><br><span class="line">  <span class="keyword">return</span> _1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m(torch.tensor([<span class="number">3</span>]).cuda()).device</span><br><span class="line">device(type=<span class="string">'cpu'</span>)  <span class="comment"># WRONG!</span></span><br></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><code>trace</code> 有明显的局限性：本文大部分时间都在讨论 <code>trace</code> 的局限性以及如何解决它们。我实际上认为这是 <code>trace</code> 的优点：它有明确的限制和解决方案，所以你可以推断它是否有效。相反， <code>script</code> 更像是一个黑匣子：在尝试之前没有人知道它是否有效。</p><p><code>trace</code> 具有较小的代码破坏范围： <code>trace</code> 和 <code>script</code> 都会影响代码的编写方式，但 <code>trace</code> 的代码破坏范围要小得多，并且造成的损害要小得多：</p><ul><li>它限制了输入/输出格式，但仅限于最外层的模块。</li><li>在 <code>trace</code> 中混合 <code>script</code>，但可以只更改受影响模块的内部实现，而不是它们的接口。</li></ul><p>另一方面， <code>script</code> 对以下方面有影响：</p><ul><li>涉及的每个模块和子模块的接口，接口需要高级语法特性，针对接口编程时，千万别在接口设计上妥协。</li><li>这也可能最终影响训练，因为接口通常在训练和推理之间共享。</li></ul><p>这也是为什么 <code>script</code> 会对代码质量造成很大损害的原因。<code>Detectron2</code> 支持 <code>script</code>，但不推荐其他大型项目以可 <code>script</code> 且不丢失抽象为目标，因为这实在有点难度，除非它们也能像阿里巴巴那样得到 <code>PyTorch</code> 团队的支持。</p><p><code>PyTorch</code> 深受用户喜爱，最重要的是编写 <code>Python</code> 控制流。但是 <code>Python</code> 的其他语法也很重要。如果能够编写 <code>Python</code> 控制流（ 使用 <code>script</code> ）意味着失去其他优秀的语法，我宁愿放弃编写 <code>Python</code> 控制流的能力。事实上，如果 <code>PyTorch</code> 对 <code>Python</code> 控制流不那么执着，并且像这样（类似于 <code>tf.cond</code> 的 <code>API</code>）为我提供了诸如 <code>torch.cond</code> 之类的符号控制流：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> torch.cond(x.sum() &gt; <span class="number">0</span>, <span class="keyword">lambda</span>: torch.sqrt(x), <span class="keyword">lambda</span>: torch.square(x))</span><br></pre></td></tr></table></figure><p>然后 <code>f</code> 可以正确 <code>trace</code>，不再需要担心 <code>script</code>。</p><h1 id="保存和加载模型"><a href="#保存和加载模型" class="headerlink" title="保存和加载模型"></a>保存和加载模型</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">traced.save(<span class="string">'wrapped_rnn.pt'</span>)</span><br><span class="line"></span><br><span class="line">loaded = torch.jit.load(<span class="string">'wrapped_rnn.pt'</span>)</span><br><span class="line"></span><br><span class="line">print(loaded)</span><br><span class="line">print(loaded.code)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>基本概念，<a href="https://zhuanlan.zhihu.com/p/370455320" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/370455320</a></li><li>两者的优势，<a href="https://zhuanlan.zhihu.com/p/410507557" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/410507557</a></li><li>trace vs script，<a href="https://ppwwyyxx.com/blog/2022/TorchScript-Tracing-vs-Scripting/" target="_blank" rel="noopener">https://ppwwyyxx.com/blog/2022/TorchScript-Tracing-vs-Scripting/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一次正儿八经写博客是今年 2 月，5 月做了个比赛总结，其余的博客竟然都是刷题和算法，实属无聊。艰难的日子已经过去，准备学点模型部署相关的东西以及参与一个实际的开源项目，争取数据、算法和工程全链路打通。众所周知，对于一个不是很常用的东西，学完就忘，如 &lt;code&gt;spark, Go&lt;/code&gt; 等学过的但很少用的东西，已经被我抛到九霄云外了。所以，这次学完模型的 &lt;code&gt;trace&lt;/code&gt; 之后，尝试部署一些能实际运行的软件。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Pytorch" scheme="https://muyuuuu.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：双指针</title>
    <link href="https://muyuuuu.github.io/2022/08/06/double-pointer/"/>
    <id>https://muyuuuu.github.io/2022/08/06/double-pointer/</id>
    <published>2022-08-06T15:26:44.000Z</published>
    <updated>2022-08-06T16:20:49.366Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这几天接连遇到了一些双指针的问题，但是说实话，并没有从这些题中看到一种通用的东西，也就不是能很好的做一个总结，但不得不说双指针是一个很神奇的东西，所以做一道记一道吧。</p><a id="more"></a><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><p>快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如fast每次增长两个，slow每次增长一个。</p><p>常用于链表问题，如：slow开始移动，由于移动速度是 fast 的一半，那么 fast 移动到链表的末尾时，slow 就位于链表的中央，可以用这这种方法求链表的中点。</p><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a>26. 删除有序数组中的重复项</h2><p>给你一个升序排列的数组 <code>nums</code>，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。元素的相对顺序应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组 <code>nums</code> 的第一部分。更规范地说，如果在删除重复项之后有 <code>k</code> 个元素，那么 <code>nums</code> 的前 <code>k</code> 个元素应该保存最终结果。将最终结果保存到 <code>nums</code> 的前 <code>k</code> 个位置后返回 <code>k</code> 。</p><p>不要使用额外的空间，你必须在原地修改输入数组 并在使用 $O(1)$ 额外空间的条件下完成。</p><p>这个题乍一看还真不会，于是果断看了题解：</p><ul><li>fast 和 slow 初始为 1，因为就算数组内全是重复元素，那么 1 也可以表示其中不重复的数量</li><li>如果 fast 和 fast-1 对应的元素相等，表示有重复元素，此时 fast++，继续搜索后面的元素</li><li>如果 fast 和 fast-1 不相等，表示没有重复元素，且，不重复的元素是 <code>nums[fast]</code>，此时我们让 <code>nums[slow]=nums[fast]</code>，slow 和 fast 同时向后移动即可</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">1</span>, fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[fast<span class="number">-1</span>]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-II-022-链表中环的入口节点"><a href="#剑指-Offer-II-022-链表中环的入口节点" class="headerlink" title="剑指 Offer II 022. 链表中环的入口节点"></a>剑指 Offer II 022. 链表中环的入口节点</h2><p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 next 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p><img data-src="https://s1.ax1x.com/2022/08/06/vubX6J.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>首先明确一点，使用哈希存储地址肯定可以做出来，但这里是为了熟悉双指针。</p><p><img data-src="https://s1.ax1x.com/2022/08/06/vubz01.png" alt></p><ul><li>假设 fast 指针和 slow 指针在紫色节点处相交</li><li>对于 fast 指针，走过的距离为 $a+n(b+c) + b$，$n$ 为任意整数</li><li>对于 slow 指针，走过的距离为 $a+m(b+c) + b$，$m$ 为任意整数</li></ul><p>由于 fast 移动的距离是 slow 的二倍，因此：</p><p>\brgin{equation}<br>a+n(b+c)+b = 2 [a+m(b+c) + b] \\<br>\Rightarrow a = (n-2m)(b+c) - b<br>\end{equation}</p><p>也就是说，$a$ 的长度等于整数倍的环的长度减去 $b$ 的长度。得到这个等式后，我们让一个指针从 <code>head</code> 出发，<code>slow</code> 指针从相交处出发，两者相交时，就是环的入口节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h1><p>对撞数组适用于有序数组、利用数组两侧求最值、只用数组内的两个元素等问题，应该第一时间想到用对撞指针解题。</p><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。</p><p><img data-src="https://s1.ax1x.com/2022/08/06/vubRSg.jpg" alt></p><ul><li>双指针，左指针位于左侧，右指针位于右侧，求一次能存储的最大水量</li><li>如果左边低，为了能求存储的最大水量，就需要将左指针向右移动，同理，如果右边低，就需要将右指针向左移动</li><li>每次移动的时候求极值就可以了</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> t1 = height[l];</span><br><span class="line">            <span class="keyword">int</span> t2 = height[r];</span><br><span class="line">            res = max(res, min(t1, t2) * (r - l));</span><br><span class="line">            <span class="keyword">if</span> (t1 &lt; t2) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="881-救生艇"><a href="#881-救生艇" class="headerlink" title="881. 救生艇"></a>881. 救生艇</h2><p>给定数组 <code>people</code> 。<code>people[i]</code> 表示第 <code>i</code> 个人的体重，船的数量不限，每艘船可以承载的最大重量为 <code>limit</code>。每艘船最多可同时载两人，但条件是这些人的重量之和最多为 <code>limit</code>。返回承载所有人所需的最小船数。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [3,2,2,1], limit = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：3 艘船分别载 (1, 2), (2) 和 (3)</span><br></pre></td></tr></table></figure><p>我们假设一种极端情况，数组排序后是 <code>[1, 2, ..., n-2, n-1]</code>，而船能容纳的极限是 <code>n</code>。那么，最佳分配就是让 <code>1</code> 和 <code>n-1</code> 在一起，<code>2</code> 和 <code>n-2</code> 在一起。此时只用两条船。虽然 <code>1</code> 可以和 <code>2</code> 在一起，那么要承载 <code>n-2</code> 和 <code>n-1</code>，就需要 3 条船。</p><p>基于贪心的思想，我们应该尽可能的把轻的和重的分配到一起，来减少船的使用数量，首先对数组排序：</p><ul><li>设立双指针，<code>l=0, r=n-1</code></li><li>因为船只能坐两个人，因此，如果 <code>nums[l] + nums[n-1] &lt;= limit</code>，就让这两个人坐一起，此时 <code>l++</code></li><li>而无论如何，都需要 <code>r--</code>，因为数组末尾的必须上一个人，而数组左侧的人选择性上或不上 </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;people, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sort(people.begin(), people.end());</span><br><span class="line">        <span class="keyword">int</span> light = <span class="number">0</span>, heavy = people.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (light &lt;= heavy) &#123;</span><br><span class="line">            <span class="keyword">if</span> (people[light] + people[heavy] &lt;= limit) &#123;</span><br><span class="line">                ++light;</span><br><span class="line">            &#125; </span><br><span class="line">            --heavy;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="红白球"><a href="#红白球" class="headerlink" title="红白球"></a>红白球</h2><p>给定一个长度为 $n$ 的字符串，其中，<code>W</code> 表示白色的球，<code>R</code> 表示红色的球，如果把红色的球放到一起，请问最少移动多少次？示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;WRRWRW&quot;</span><br><span class="line">输出：1</span><br><span class="line">输入：s = &quot;WWRWWWRWR&quot;</span><br><span class="line">输出：4，&quot;WWRWWWRWR&quot; -&gt; &quot;WWWRWWRWR&quot; -&gt; &quot;WWWWRWRWR&quot; -&gt; &quot;WWWWWRRWR&quot; -&gt; &quot;WWWWWWRRRW&quot;</span><br></pre></td></tr></table></figure><p>一个很经典的双指针题目，注：2022年微软秋招笔试题原题。这个题解有点长，日后完善。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> red_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'R'</span>) red_count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.size() - <span class="number">1</span>, result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left] == <span class="string">'R'</span> &amp;&amp; s[right] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                red_count -= <span class="number">2</span>;</span><br><span class="line">                result = right - left - <span class="number">1</span> - red_count;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[left] != <span class="string">'R'</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天接连遇到了一些双指针的问题，但是说实话，并没有从这些题中看到一种通用的东西，也就不是能很好的做一个总结，但不得不说双指针是一个很神奇的东西，所以做一道记一道吧。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>由内存分配引发的回忆</title>
    <link href="https://muyuuuu.github.io/2022/07/11/memory-allocation/"/>
    <id>https://muyuuuu.github.io/2022/07/11/memory-allocation/</id>
    <published>2022-07-11T08:52:39.000Z</published>
    <updated>2022-08-06T16:30:48.819Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>闲来无事，在面经上看到了一个问题：在物理机只有 1G 内存的情况下，能否 <code>malloc</code> 出 4G 大小的数组。奇怪的是，这个问题在网上搜不到特别好的解答，于是突发奇想试着解答一下。</p><a id="more"></a><h1 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h1><p>先直接给出结论，<code>malloc</code> 的内存位于堆区，顺便简单了解下 C/C++ 的内存分布。对于 C/C++ 语言，程序内存分布如下：</p><ul><li>栈区(stack)：由编译器自动分配释放，存储函数的参数值，局部变量值等，其操作方法类似于数据结构中的栈</li><li>堆区(heap)：一般由程序员申请和释放，与数据结构中的堆没有任何关系，分配方式类似于链表</li><li>全局/静态区(static)：全局变量和静态变量是存储在一起的，在程序编译时分配</li><li>文字常量区：存储常量字符串</li><li>程序代码区：存储函数体(类的成员函数、全局函数)的二进制代码</li></ul><p>重点是其中的栈区和堆区：</p><ul><li><p>栈区：程序自动向操作系统申请分配以及回收，速度快，使用方便，但是程序员无法控制。如果分配的内存超过了栈区的最大空间，会抛出栈溢出错误。const 局部变量也存储在栈区，栈区向地址减小的方向增长。系统为变量在栈上申请内存后，CPU 需要不断地判断变量是否已结束使用的生命周期，如果生命周期结束，系统就会释放为这个变量申请的栈内存，这样一来随着在栈上申请的变量增多，会对 CPU 造成额外的消耗。</p></li><li><p>堆区：程序员向操作系统申请一段内存，当系统收到程序的申请时，会遍历一个记录空内存结点的链表，找到第一个空间大于或等于所申请空间的堆结点，将该空闲结点从链表中删除，并将该结点的空间分配给程序，如果链表中空闲结点的空间大于申请空间的大小，系统会自动将对于的部分放入空闲链表中，故容易造成内存的碎片化，分配速度较慢，地址不连续。且堆区的内存由程序员申请，也必须由程序员负责管理和释放，否则会导致内存泄漏，堆的增长方向与内存地址的增长方向相同，因此在堆区上申请空间理论上是没有大小限制的，但是受安装内存条的大小和系统以及其他程序的占用，不是无限大的。不像栈上的变量那样，需要消耗 CPU 资源判断变量的生命周期，所以不会对 CPU 造成额外的消耗，这也是程序员申请堆上内存的优点。</p></li></ul><p>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生内存泄露。碎片问题：对于堆来讲，频繁的 <code>malloc/free</code> 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。</p><h1 id="1G-内存-4G-数组"><a href="#1G-内存-4G-数组" class="headerlink" title="1G 内存 4G 数组"></a>1G 内存 4G 数组</h1><p>在了解 <code>malloc</code> 分配到的堆区大小取决于内存剩余的空闲空间后，再来研究能不能分配出大于空闲空间的数据。先给出结论，在虚拟内存足够大的情况下，1G 大小的内存可以开辟出 4G 的数组。虚拟内存是一个假象的内存空间，在程序运行过程中虚拟内存空间中需要被访问的部分会被映射到物理内存空间中。虚拟内空间大只能表示程序运行过程中可访问的空间比较大，不代表物理内存空间占用也大。</p><p><code>malloc</code> 可以申请到超出机器物理内存的大小，为什么说是一部分呢，因为可申请的内存不仅和已占用的内存相关，还和机器的 <code>swap space</code> （虚拟内存）相关，事实上在你给你机器装 Linux 系统的时候应该碰到过，那就是磁盘分区的时候会有一个 <code>swap</code>设定，只需要知道它是一种挂载在物理硬盘上，用来存放一些不太频繁使用的内存，是一种低速的物理内存的扩展。</p><p>当物理内存不够用时，原先一些物理内存中不常访问的内容会被转移到这里以让出空间给其它进程。所以 <code>swap</code> 空间也可以被 <code>malloc</code> 申请到。<code>malloc</code> 这个时候申请了内存，但没有完全申请，这就涉及到一个叫做 <code>Lazy Allocation</code> 的东东，当你使用 <code>malloc</code> 时，系统并没有真正从物理内存中分配，而是等到进程要操作时才提供 <code>allocation</code>。</p><p>因此，正是因为虚拟内存的存在，通过虚拟内存可以让程序可以拥有超过系统物理内存大小的可用内存空间。</p><h2 id="虚拟内存扩展"><a href="#虚拟内存扩展" class="headerlink" title="虚拟内存扩展"></a>虚拟内存扩展</h2><p>这是我研究生第一节课老师讲述的内容（顿时我就觉得那老师才是真正的计算机学者）：虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉。使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区，<strong>不同进程使用的虚拟地址彼此隔离</strong>。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存，如果各个进程之间没有独立的地址空间，一个进程由于执行错误指令或是恶意代码都可以直接修改其它进程的数据，甚至修改内核地址空间的数据，这是操作系统所不愿看到的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闲来无事，在面经上看到了一个问题：在物理机只有 1G 内存的情况下，能否 &lt;code&gt;malloc&lt;/code&gt; 出 4G 大小的数组。奇怪的是，这个问题在网上搜不到特别好的解答，于是突发奇想试着解答一下。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="OS" scheme="https://muyuuuu.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：链表反转问题</title>
    <link href="https://muyuuuu.github.io/2022/06/24/link/"/>
    <id>https://muyuuuu.github.io/2022/06/24/link/</id>
    <published>2022-06-24T13:44:00.000Z</published>
    <updated>2022-06-24T14:35:18.445Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文集中写链表的反转问题，因为其他的链表相交、链表数量等问题比较简单，即使没啥算法经验也能写个差不多，而链表反转也算一种经典的递归问题。这个文章的文字描述太乱了，有时间回来补图。</p><a id="more"></a><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。反转链表有两种实现方式，一种是迭代式实现，一种是通过递归实现。先来看通过迭代实现：迭代的反转需要使用三个指针，<code>pre</code>，<code>cur</code> 和 <code>nxt</code>，核心思想就是 <code>cur</code> 不断的向后移动过程中，让 <code>cur</code> 指向 <code>pre</code>。而这一过程分为四步：</p><ol><li><code>nxt = nxt-&gt;next</code>，先让 <code>nxt</code> 向后移动，因为 <code>cur</code> 指向 <code>pre</code> 之后，需要通过 <code>nxt</code> 找到下一个节点</li><li><code>cur-&gt;next = pre</code>，实现指针的反转，让 <code>cur</code> 指向上一个指针</li><li><code>pre = cur</code>，为下一次反转做准备，<code>pre</code> 就是在反转中要被指向的节点</li><li><code>cur = nxt</code>，<code>cur</code> 指向下一个节点，为下一次反转做准备</li></ol><p>通过以上四点，我们可以在推出一些细节：</p><ol><li><code>pre</code> 的初始值应该是 <code>null</code>，因为任何一个链表的末尾节点应该是空节点，而第一次反转时 <code>cur</code> 指向了 <code>pre</code>，因此 <code>pre</code> 也就是链表的末尾，因此 <code>pre</code> 初始为空</li><li><code>cur</code> 的初始值就是 <code>head</code> 节点，<code>nxt</code> 的初始值也是 <code>head</code> 节点，因为这样才能让 <code>nxt = nxt-&gt;next</code> 和 <code>cur-&gt;next = pre</code> 有意义</li><li>如果 <code>nxt</code> 指向 <code>null</code>，说明此时链表反转完毕，而 <code>cur</code> 指向的就是 <code>nxt</code>，因此最后要返回 <code>pre</code> 指针</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode() = <span class="keyword">default</span>;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val&#123;x&#125; &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">      ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">      ListNode* cur = head;</span><br><span class="line">      ListNode* nxt = head;</span><br><span class="line">      <span class="keyword">while</span> (nxt != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        nxt = nxt-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至于递归方法就简单了很多：</p><ol><li>如果这个节点是原链表的尾部节点，那么直接将其返回，而且每一层递归函数的返回值都是它。而尾部节点的判断方式就是 <code>head-&gt;next == null</code>。因此先写出部分程序：如下的程序中，任何一个递归函数返回的都是链表的尾部节点。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* last = reverseList(head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>在找到尾部节点后，将其余节点依次反转即可。而且一定是在找到尾部节点后反转，如果在找到尾部节点之前就反转，链表就无法向下递归。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模板</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* last = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head; <span class="comment">// 后面的节点指向自己</span></span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 自己的下一个节点是 nullptr</span></span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h2><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回反转后的链表 。</p><p><img data-src="https://s1.ax1x.com/2022/06/24/jFNxsS.jpg" alt></p><p>我决定以后用递归了，如果用迭代去写，涉及的变量和程序都比较繁琐。基于上面的递归反转：和反转全部链表不同，部分反转链表，需要在反转后，将链表的尾部指向原链表不反转部分的下一个元素。之前指向的是 <code>nullptr</code>，那么这里就需要指向原链表不反转部分的第一个元素。并返回反转链表后的第一个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* node, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// right=1 的时候，下一个元素就是不需要反转的链表的第一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">1</span>) &#123;</span><br><span class="line">            p = node-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* last = reverse(node-&gt;next, right - <span class="number">1</span>);</span><br><span class="line">        node-&gt;next-&gt;next = node;</span><br><span class="line">        <span class="comment">// 之前指向 nullptr，现在指向 p</span></span><br><span class="line">        node-&gt;next = p;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是链表的头部</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 反转前 k 个链表</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> reverse(head, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归，head-&gt;next 移动一次，left 和 right 都递减</span></span><br><span class="line">        <span class="comment">// head-&gt;next 指向链表的第一个元素，无论反转或不反转，也是递归的精髓</span></span><br><span class="line">        head-&gt;next = reverseBetween(head-&gt;next, left<span class="number">-1</span>, right<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。<code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><img data-src="https://s1.ax1x.com/2022/06/24/jFU4Wq.jpg" alt></p><p>和上一题一样，反转后的链表末尾元素需要指向不需要反转的链表的第一个元素。第一题，反转链表的末尾元素指向 <code>nullptr</code>，所以需要和 <code>nullptr</code> 判断关系，这里同理，只是不是 <code>nullptr</code> 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* p1, ListNode* p2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指向谁，就和谁判断，第一题的 nullptr 也是如此</span></span><br><span class="line">        <span class="keyword">if</span> (p1 == p2 || p1-&gt;next == p2) &#123;</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* last = reverse(p1-&gt;next, p2);</span><br><span class="line">        p1-&gt;next-&gt;next = p1;</span><br><span class="line">        p1-&gt;next = p2;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是反转链表的头</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        ListNode* p2 = head;</span><br><span class="line">        <span class="comment">// 如果不够反转，就不用反转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p2 == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一次链表反转，的第一个元素一定是最后链表的头，因此要返回</span></span><br><span class="line">        ListNode* last = reverse(p1, p2);</span><br><span class="line">        <span class="comment">// 头指针变成局部链表的尾指针，串起整个链表</span></span><br><span class="line">        head-&gt;next = reverseKGroup(p2, k);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文集中写链表的反转问题，因为其他的链表相交、链表数量等问题比较简单，即使没啥算法经验也能写个差不多，而链表反转也算一种经典的递归问题。这个文章的文字描述太乱了，有时间回来补图。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：优先遍历</title>
    <link href="https://muyuuuu.github.io/2022/05/30/dfs-bfs/"/>
    <id>https://muyuuuu.github.io/2022/05/30/dfs-bfs/</id>
    <published>2022-05-30T13:42:03.000Z</published>
    <updated>2022-06-24T14:36:44.546Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要收录深度优先遍历和宽度优先遍历，深度优先遍历一般可以与回溯、递归、树等方法联用，达到优雅遍历的效果，而宽度优先搜索可以用到最短路问题的求解中。</p><ul><li>为什么不用 <code>bfs</code> 去遍历？第一是因为 <code>bfs</code> 写起来麻烦，不如 <code>dfs</code> 直观。第二是在某些查找到满足情况即可退出的应用而言，<code>bfs</code> 需要一层一层的去检查，效率很低。</li><li>为什么不用 <code>dfs</code> 去求最短路？如上所示，<code>bfs</code> 可以一层一层的检查，相对 <code>dfs</code> 更容易查到最短路。</li></ul><a id="more"></a><h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><h2 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h2><h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a>130. 被围绕的区域</h3><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><p><img data-src="https://s1.ax1x.com/2022/05/30/X3SX8I.jpg" alt></p><ol><li>那么如何填充内部的 <code>O</code> 呢？这里就要用到 <code>dfs</code>，首先遍历 <code>board</code>，如果遇到了 <code>O</code>，那个和这个 <code>O</code> 相邻的 <code>O</code> 也要被填充，此时就要使用 <code>dfs</code> 来查找相邻的 <code>O</code></li><li>由于只填充被 <code>X</code> 包围的 <code>O</code>，因此，边界上的 <code>O</code> 不能被填充。那么我们预先把和边界相连的 <code>O</code> 都填充为其他符号，在处理完 <code>board</code> 内部的 <code>O</code> 的时候，在把其他符号替换为 <code>O</code> 即可。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        n = board.size();</span><br><span class="line">        m = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 替换边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(i, <span class="number">0</span>, board, <span class="string">'+'</span>);</span><br><span class="line">            dfs(i, m<span class="number">-1</span>, board, <span class="string">'+'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(<span class="number">0</span>, i, board, <span class="string">'+'</span>);</span><br><span class="line">            dfs(n<span class="number">-1</span>, i, board, <span class="string">'+'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 填充内部的 O</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    dfs(i, j, board, <span class="string">'X'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换回来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'+'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs 查找相连的 O</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">char</span> pad)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= n || c &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[r][c] == <span class="string">'O'</span>) &#123;</span><br><span class="line">            board[r][c] = pad;</span><br><span class="line">            dfs(r + <span class="number">1</span>, c, board, pad);</span><br><span class="line">            dfs(r - <span class="number">1</span>, c, board, pad);</span><br><span class="line">            dfs(r, c + <span class="number">1</span>, board, pad);</span><br><span class="line">            dfs(r, c - <span class="number">1</span>, board, pad);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h1><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h2><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。</p><p><img data-src="https://s1.ax1x.com/2022/06/24/jFdQv6.jpg" alt></p><p>求二叉树或者多叉树中根节点到叶子节点的最短路径，一般都是 <code>bfs</code> 遍历算法。给出 <code>bfs</code> 的模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>.push(root);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">queue</span>.size()) &#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">queue</span>.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = <span class="built_in">queue</span>.top();</span><br><span class="line">        <span class="built_in">queue</span>.pop();</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != null)</span><br><span class="line">            <span class="built_in">queue</span>.push(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != null)</span><br><span class="line">            <span class="built_in">queue</span>.push(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在进入 <code>bfs</code> 之前先处理一些极端的特殊情况，比如根节点为空，根节点就是目标节点等</li><li>在处理完特殊情况后，之后就是 <code>bfs</code> 遍历，如果遍历期间的节点满足目标情况，返回结果即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line">        <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.front();</span><br><span class="line">                q.pop_front();</span><br><span class="line">                <span class="comment">// 找到了叶子节点，直接返回深度</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.push_back(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.push_back(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="752-打开转盘锁"><a href="#752-打开转盘锁" class="headerlink" title="752. 打开转盘锁"></a>752. 打开转盘锁</h2><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有 10 个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。</span><br><span class="line">注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，</span><br><span class="line">因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</span><br></pre></td></tr></table></figure><ul><li>寻找最短路径时，同样需要使用 <code>bfs</code> 算法。我们把这个问题看成一个多叉树问题，如果 <code>00</code> 是根节点，那么叶子节点就是 <code>01, 10, 09, 90</code>，同理，也能得到 <code>0000</code> 为根节点时对应的叶子节点</li><li>同样，先处理极端情况，如根节点被死锁，以及根节点就是目标的特殊情况</li><li>之后，以 <code>0000</code> 为根节点开始 <code>bfs</code> 算法，我们手写两个函数，分别为 <code>_up</code> 和 <code>_down</code> 来对 <code>0000</code> 的每一位进行转动进而得到子节点，如果子节点满足要求，返回此时的深度即可</li><li>与二叉树不同的是，二叉树使用 <code>root-&gt;left, root-&gt;right</code> 能保证不会遍历重复节点，而对于此问题，很有可能从 <code>0000</code> 查找到 <code>5555</code>，又从 <code>5555</code> 查找回 <code>0000</code>，因为只要一直转动下去，<code>0000</code> 也是 <code>5555</code> 的子节点。因此，在遍历期间需要设置一个 <code>map</code>，将遍历过的节点添加进去，保证不会重复遍历一个节点，不走回头路。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> _up(<span class="built_in">string</span> node, <span class="keyword">int</span> idx) &#123;</span><br><span class="line">        <span class="built_in">string</span> s = node;</span><br><span class="line">        <span class="keyword">if</span> (s[idx] == <span class="string">'9'</span>)</span><br><span class="line">            s[idx] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s[idx] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> _down(<span class="built_in">string</span> node, <span class="keyword">int</span> idx) &#123;</span><br><span class="line">        <span class="built_in">string</span> s = node;</span><br><span class="line">        <span class="keyword">if</span> (s[idx] == <span class="string">'0'</span>)</span><br><span class="line">            s[idx] = <span class="string">'9'</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s[idx] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; deadends, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        q.push_back(<span class="string">"0000"</span>);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : deadends)</span><br><span class="line">            m[i] = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (m[<span class="string">"0000"</span>] == <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="string">"0000"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.front();</span><br><span class="line">                q.pop_front();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="built_in">string</span> s1 = _up(node, i);</span><br><span class="line">                    <span class="keyword">if</span> (s1 == target)</span><br><span class="line">                        <span class="keyword">return</span> cnt;</span><br><span class="line">                    <span class="keyword">if</span> (m[s1] != <span class="number">10</span>) &#123;</span><br><span class="line">                        m[s1] = <span class="number">10</span>;</span><br><span class="line">                        q.push_back(s1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">string</span> s2 = _down(node, i);</span><br><span class="line">                    <span class="keyword">if</span> (s2 == target)</span><br><span class="line">                        <span class="keyword">return</span> cnt;</span><br><span class="line">                    <span class="keyword">if</span> (m[s2] != <span class="number">10</span>) &#123;</span><br><span class="line">                        m[s2] = <span class="number">10</span>;</span><br><span class="line">                        q.push_back(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要收录深度优先遍历和宽度优先遍历，深度优先遍历一般可以与回溯、递归、树等方法联用，达到优雅遍历的效果，而宽度优先搜索可以用到最短路问题的求解中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么不用 &lt;code&gt;bfs&lt;/code&gt; 去遍历？第一是因为 &lt;code&gt;bfs&lt;/code&gt; 写起来麻烦，不如 &lt;code&gt;dfs&lt;/code&gt; 直观。第二是在某些查找到满足情况即可退出的应用而言，&lt;code&gt;bfs&lt;/code&gt; 需要一层一层的去检查，效率很低。&lt;/li&gt;
&lt;li&gt;为什么不用 &lt;code&gt;dfs&lt;/code&gt; 去求最短路？如上所示，&lt;code&gt;bfs&lt;/code&gt; 可以一层一层的检查，相对 &lt;code&gt;dfs&lt;/code&gt; 更容易查到最短路。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：回溯</title>
    <link href="https://muyuuuu.github.io/2022/05/28/backtrack/"/>
    <id>https://muyuuuu.github.io/2022/05/28/backtrack/</id>
    <published>2022-05-28T06:30:27.000Z</published>
    <updated>2022-06-24T14:45:41.644Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>回溯算法是一种暴力枚举的算法。但是，枚举是一个技术活，枚举过程如何保证不重复、剪纸、不遗漏和优先处理可能的结果，这并不简单。</p><p>回溯应该是算法系列中除动态规划外最难的一个，需要很好的明确回溯入口，退出条件，两者保证回溯的不遗漏。而下一步如何回溯，以及如何退出当前状态要保证回溯的不重复。也许有些抽象，我们来看具体例子。</p><a id="more"></a><h1 id="什么是回溯"><a href="#什么是回溯" class="headerlink" title="什么是回溯"></a>什么是回溯</h1><p>如果简单的说回溯，那么如下函数就可以解释清楚：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : arr) &#123;</span><br><span class="line">    backtrack(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n)</span><br><span class="line">        退出条件</span><br><span class="line">    <span class="comment">// 回溯入口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> j : arr[i]) &#123;</span><br><span class="line">        <span class="built_in">vector</span>.push_back(j);</span><br><span class="line">        <span class="comment">// 下一步而回溯</span></span><br><span class="line">        backtrack(j);</span><br><span class="line">        <span class="comment">// 退出当前的状态，往回走</span></span><br><span class="line">        <span class="comment">// 因此叫做回溯</span></span><br><span class="line">        <span class="built_in">vector</span>.pop_back()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图路径"><a href="#图路径" class="headerlink" title="图路径"></a>图路径</h1><h2 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797. 所有可能的路径"></a>797. 所有可能的路径</h2><p>给你一个有 <code>n</code> 个节点的 有向无环图 <code>DAG</code>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出，不要求按特定顺序。<code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p><p><img data-src="https://s1.ax1x.com/2022/05/28/Xul4OA.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure><p>如果说从 0 开始，而 0 又指向 1 和 2，那么只能按照这样的顺序找下去，因为题目并没有说要求最短路径。如果遍历的是 0，1，3，那么在找完这条路径后，需要回退，找到 0，1，2 这条路径。也就是，这算是一道回溯类题目。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">allPathsSourceTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        tmp.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n = graph.size();</span><br><span class="line">        <span class="comment">// 回溯入口</span></span><br><span class="line">        dfs(<span class="number">0</span>, n, graph);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 退出条件</span></span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 回溯入口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i : graph[idx]) &#123;</span><br><span class="line">                tmp.push_back(i);</span><br><span class="line">                dfs(i, n, graph);</span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h1><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><p>给定一个不含重复数字的数组 <code>nums</code>，返回其所有可能的全排列 。你可以按任意顺序返回答案。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p>和上一题大体相同，我们来分析一下不同点在哪里。</p><ul><li>全排列问题，由于会出现 <code>[3,2,1]</code> 这样的情况，因此回溯的入口每次都是 <code>0</code>，而不能是上次回溯的终点，因为 <code>3</code> 后面没有任何东西</li><li>其次，由于每次入口都是 <code>0</code>，而且每个元素只能出现一次，因此我们需要使用一个 <code>map</code>，根据索引记录该元素是否使用，只有没有使用时才能回溯</li><li>回溯的退出条件为子序列长度等于 <code>nums</code> 的长度</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        backtrack(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.size() == nums.size()) &#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    tmp.push_back(nums[i]);</span><br><span class="line">                    m[i] = <span class="number">1</span>;</span><br><span class="line">                    backtrack(i, nums);</span><br><span class="line">                    m[i] = <span class="number">0</span>;</span><br><span class="line">                    tmp.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h2><p>给定一个可包含重复数字的序列 <code>nums</code> ，按任意顺序返回所有不重复的全排列。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><p>根据前面提到的求解回溯问题的框架，我们可以注意到这个题有两个细节：</p><ul><li>由于 <code>2</code> 可以出现在 <code>1</code> 的前面，因此每次回溯的起点都是 <code>0</code>。而为了避免添加重复元素，我们需要使用一个 <code>map</code>，记录哪些元素被添加过，从过跳过已经被添加的元素</li><li>由于会有重复元素，根据我对回溯问题的了解，我建议先对 <code>nums</code> 进行排序，而后先将结果添加到集合内，最后将结果放入 <code>vector</code> 内</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        backtrack(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : res)</span><br><span class="line">            r.push_back(i);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.size() == nums.size()) &#123;</span><br><span class="line">            res.insert(tmp);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 回溯入口始终为 0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">                <span class="comment">// 如果没有被添加</span></span><br><span class="line">                <span class="keyword">if</span> (m[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    tmp.push_back(nums[i]);</span><br><span class="line">                    m[i] = <span class="number">1</span>;</span><br><span class="line">                    backtrack(<span class="number">0</span>, nums);</span><br><span class="line">                    m[i] = <span class="number">0</span>;</span><br><span class="line">                    tmp.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h1><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><p>给你一个无重复元素的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的所有不同组合 ，并以列表形式返回。你可以按任意顺序返回这些组合。</p><p><code>candidates</code> 中的同一个数字可以无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p>需要注意的是，如果回溯的入口是 <code>0</code>，那么可以得到 <code>2+2+3=7</code> 的结果，在后续的回溯中，如果入口是 <code>1</code>，而 <code>3</code> 在之前以及的结果中已经使用过了。因此和上一题不一样的是，下一次回溯的入口是上一次回溯的出口，由于一个数值允许多次使用，因此入口和出口的值是可以相等的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        backtrack(<span class="number">0</span>, candidates, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _sum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : tmp)</span><br><span class="line">            s += i;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_sum(tmp) == target) &#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// idx 是回溯的入口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; candidates.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((candidates[i] &lt;= target) &amp;&amp; (_sum(tmp) + candidates[i] &lt;= target)) &#123;</span><br><span class="line">                    tmp.push_back(candidates[i]);</span><br><span class="line">                    <span class="comment">// i 是回溯的出口，也就是下一次回溯的入口</span></span><br><span class="line">                    backtrack(i, candidates, target);</span><br><span class="line">                    tmp.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a>40. 组合总和 II</h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的每个数字在每个组合中只能使用一次。注意：解集不能包含重复的组合。示例 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>既然每个数字只能使用一次，根据上一题我们能知道：下一次回溯的入口和上一次回溯的出口不能相同</li><li>此外，这个题的重点是：<strong>可能存在相同数字，因此，我们需要在回溯的过程中进行剪枝</strong>。剪枝发生在：同一层数值相同的结点第 2、3 … 个结点，因为数值相同的第 1 个结点已经搜索出了包含了这个数值的全部结果，同一层的其它结点，候选数的个数更少，搜索出的结果一定不会比第 1 个结点更多，并且是第 1 个结点的子集。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp_sum = <span class="number">0</span>;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        backtrack(<span class="number">0</span>, tmp_sum, candidates, target);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; r1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : res) &#123;</span><br><span class="line">            r1.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span>&amp; tmp_sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp_sum == target) &#123;</span><br><span class="line">            res.insert(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; candidates.size(); i++) &#123;</span><br><span class="line">                <span class="comment">// 剪枝，i &gt; idx 保证第一个结果计算完了</span></span><br><span class="line">                <span class="comment">// candidates[i] == candidates[i-1] 去除相同的子情况</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; idx &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (tmp_sum + candidates[i] &lt;= target) &#123;</span><br><span class="line">                    tmp.push_back(candidates[i]);</span><br><span class="line">                    tmp_sum += candidates[i];</span><br><span class="line">                    backtrack(i + <span class="number">1</span>, tmp_sum, candidates, target);</span><br><span class="line">                    tmp_sum -= candidates[i];</span><br><span class="line">                    tmp.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h2><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。你可以按任何顺序返回答案。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>由于出现 <code>[1,2]</code> 后就不会在出现 <code>[2,1]</code>，因此每次回溯的入口是上次回溯的出口 +1</li><li>回溯的退出条件是 <code>tmp.size()==k</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        backtrack(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.size() == k) &#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt;= n; i++) &#123;</span><br><span class="line">                tmp.push_back(i);</span><br><span class="line">                <span class="comment">// 下一次回溯的入口，是本次回溯出口 +1</span></span><br><span class="line">                backtrack(i + <span class="number">1</span>, n, k);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a>216. 组合总和 III</h2><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字 1 到 9</li><li>每个数字最多使用一次 </li><li>返回所有可能的有效组合的列表。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</li></ul><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><ul><li>由于每个数字只能使用一次，因此每次回溯的入口是上次回溯的出口 +1</li><li>回溯退出的条件有两个，一个是和满足，一个是数量满足</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmpSum = <span class="number">0</span>;</span><br><span class="line">        backtrack(<span class="number">1</span>, k, n, tmpSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span>&amp; tmpSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmpSum == n &amp;&amp; tmp.size() == k) &#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmpSum + i &lt;= n) &#123;</span><br><span class="line">                    tmp.push_back(i);</span><br><span class="line">                    tmpSum += i;</span><br><span class="line">                    backtrack(i + <span class="number">1</span>, k, n, tmpSum);</span><br><span class="line">                    tmpSum -= i;</span><br><span class="line">                    tmp.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h1><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h2><p>给你一个整数数组 <code>nums</code>，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。你可以按任意顺序返回解集。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p>我们发现回溯期间的任何结果都会被返回，即使是一个空集，因此：回溯不在设置退出条件，但此时需要保证回溯的入口条件正确。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        backtrack(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            tmp.push_back(nums[i]);</span><br><span class="line">            backtrack(i + <span class="number">1</span>, nums);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h2><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。返回的解集中，子集可以按任意顺序排列。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure><p>前文已经提到过，如果有重复元素，对于重复元素，先排序，在将结果存储到集合中，最后转化为 <code>vector</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        backtrack(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : res) &#123;</span><br><span class="line">            r.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        res.insert(tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            tmp.push_back(nums[i]);</span><br><span class="line">            backtrack(i + <span class="number">1</span>, nums);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="回溯实战"><a href="#回溯实战" class="headerlink" title="回溯实战"></a>回溯实战</h1><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p>这个和之前的回溯还不太一样，之前的回溯是选择填入一个数字，或者说每次回溯只能选择一个数字，而一般是可以按照顺序选择数字的。但是这个题不同的是，当前的字符取决于前面的字符，如果前面的字符是 <code>(</code>，那么后面的字符可能是 <code>(</code> 或者 <code>)</code>，如果前面的字符是 <code>)</code>，后面的字符可能是 <code>(</code> 或 <code>)</code>，具体是哪一个还需要判断前面的次数，这样程序的逻辑会很复杂。</p><p>也就是说，这种情况，不能用 <code>for</code> 循环遍历 <code>()</code> 来回溯。既然如此，只能在回溯中进行遍历。</p><ul><li>如果此时任何一个括号的使用次数大于 <code>n</code>，退出</li><li>回溯期间，无论如何左括号的使用次数一定大于右括号，因此当右括号的使用次数大于左括号时，退出</li><li>之后就是没有循环的回溯，回溯有两部分，分别是添加 <code>(</code> 和 <code>)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> s&#123;<span class="string">""</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        backtrack(n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; <span class="number">0</span> || r &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; l)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 所有括号被添加</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 追加左括号</span></span><br><span class="line">        s += <span class="string">"("</span>;</span><br><span class="line">        backtrack(l - <span class="number">1</span>, r);</span><br><span class="line">        s.pop_back();</span><br><span class="line">        <span class="comment">// 追加右括号</span></span><br><span class="line">        s += <span class="string">")"</span>;</span><br><span class="line">        backtrack(l, r - <span class="number">1</span>);</span><br><span class="line">        s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="回溯游戏"><a href="#回溯游戏" class="headerlink" title="回溯游戏"></a>回溯游戏</h1><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。数独的解法需遵循如下规则：</p><ul><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</li><li>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</li></ul><p><img data-src="https://s1.ax1x.com/2022/06/24/jFda8I.png" alt></p><ul><li>对于这个回溯问题，我们发现遍历时有三种状态：行、列和数字，也就是说，不同于之前的数组遍历，选择一个数字就行。这个题在遍历期间，需要处理三种状态。</li><li>一般情况是，回溯本身就能处理一些状态的遍历，此时需要保证本次回溯的入口是上次回溯的出口 +1。</li><li>对于本题目，回溯本身处理行和列的遍历，每次回溯时列自增，当列等于 9 时行自增。而在回溯中，使用训练遍历数字，由于上一个回溯选择数字和本次回溯选择的数字有先后关系，因此数字的循环始终为 <code>1,...,9</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, board);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isvalid</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (board[row][i] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (board[(row/<span class="number">3</span>)*<span class="number">3</span> + i/<span class="number">3</span>][(col/<span class="number">3</span>)*<span class="number">3</span> + i%<span class="number">3</span>] == c)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row &gt; <span class="number">9</span> || col &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (col == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(row + <span class="number">1</span>, <span class="number">0</span>, board);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[row][col] != <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(row, col + <span class="number">1</span>, board);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'1'</span>; c &lt;= <span class="string">'9'</span>; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isvalid(c, row, col, board)) &#123;</span><br><span class="line">                board[row][col] = c;</span><br><span class="line">                <span class="keyword">if</span> (dfs(row, col + <span class="number">1</span>, board))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a>51. N 皇后</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<code>n</code> 皇后问题 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <code>n</code> 皇后问题的解决方案。每一种解法包含一个不同的 <code>n</code> 皇后问题 的棋子放置方案，该方案中 <code>Q</code> 和 <code>.</code> 分别代表了皇后和空位。</p><p>和数独不一样的是，这个题的遍历状态只有行和列，因为棋子的状态只有 <code>Q</code>，回溯前放 <code>Q</code>，回溯后回退为 <code>.</code> 即可。</p><p>既然如此，按照常规的想法，就用循环遍历列，当这一列满足要求时，就进入下一行，开始填充下一行的棋子，想到这里，回溯的程序也就可以写出来了。</p><p>也就是说对于回溯问题，至少要让回溯中的循环控制一个状态的遍历，而回溯本身则控制其他状态的遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        tmp.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                s += <span class="string">'.'</span>;</span><br><span class="line">            tmp[i] = s;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(<span class="number">0</span>, tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[row][i] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i][col] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; ((i &gt;= <span class="number">0</span>) &amp;&amp; (j &gt;= <span class="number">0</span>)); i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; ((i &gt;= <span class="number">0</span>) &amp;&amp; (j &lt; tmp.size())); i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (row == tmp.size()) &#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid(row, i, tmp)) &#123;</span><br><span class="line">                tmp[row][i] = <span class="string">'Q'</span>;</span><br><span class="line">                backtrack(row + <span class="number">1</span>, tmp);</span><br><span class="line">                tmp[row][i] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回溯算法是一种暴力枚举的算法。但是，枚举是一个技术活，枚举过程如何保证不重复、剪纸、不遗漏和优先处理可能的结果，这并不简单。&lt;/p&gt;
&lt;p&gt;回溯应该是算法系列中除动态规划外最难的一个，需要很好的明确回溯入口，退出条件，两者保证回溯的不遗漏。而下一步如何回溯，以及如何退出当前状态要保证回溯的不重复。也许有些抽象，我们来看具体例子。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：数学运算与位运算</title>
    <link href="https://muyuuuu.github.io/2022/05/27/math-and-bit/"/>
    <id>https://muyuuuu.github.io/2022/05/27/math-and-bit/</id>
    <published>2022-05-27T13:41:03.000Z</published>
    <updated>2022-07-06T15:53:59.983Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前从未意识到位运算的强大威力，认为与或非只存在大一 C 语言的考试或单片机的设计中，直到今天才发现我错了。做一个常用的位运算和数学运算的整理。</p><a id="more"></a><h1 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h1><p>与运算我们都知道，1 与 1 为 1，其他的与运算结果都是 0。那这有什么用呢？如果一个数用二进制表示，不断的进行 <code>n = n &amp; (n-1)</code> 运算，可以知道这个数的二进制有多少个 1。</p><h2 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a>191. 位1的个数</h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。</span><br></pre></td></tr></table></figure><p>这个题就是上面说的与运算的经典例子，直接写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n = n &amp; (n<span class="number">-1</span>);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="231-2-的幂"><a href="#231-2-的幂" class="headerlink" title="231. 2 的幂"></a>231. 2 的幂</h2><p>给你一个整数 <code>n</code>，请你判断该整数是否是 <code>2</code> 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。如果存在一个整数 <code>x</code> 使得 $n == 2^x$ ，则认为 <code>n</code> 是 <code>2</code> 的幂次方。</p><p>不要急，我们脑部一下 2 的幂那些数，比如 4，8，16 有什么显著特点，答案是他们的二进制只有一个 1，那么就很简单了。利用上一题的结论，直接判断输入的数字二进制中是否有一个 1 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = n &amp; (n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> a == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h1><p>如果不出意外的话，这个运算只会在考试前一周牢牢记住，考试完彻底忘记。今天来补充一下，异或运算是指：当两数相同时，输出为 <code>false</code>，不同时，输出为 <code>true</code>。异或具有以下性质：</p><ol><li>交换率：$p \circ q = q \circ p$</li><li>结合率：$p \circ (a \circ b) = p \circ a \circ b$</li><li>恒等率：$p \circ 0 = p$</li><li>归零率：$p \circ p = 0$</li><li>自反率：$p \circ q \circ q = 0$</li></ol><p>其实自反率就是交换率的延伸，而用的最多的也是自反，用于判断数组中只出现一次的元素。只需要异或数组内的全部元素，由于其他元素均重复出现。因此结果只保留只出现一次的元素。</p><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>注意，初始化为 0，因为任何数异或 0 都是它自己。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a>268. 丢失的数字</h2><p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure><p>因为数字的范围是 <code>[0,n]</code> 且丢失了其中一个，那么我们直接异或 <code>[0,...,n]</code>，再去异或输入的数组，结果就是缺失的数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="阶乘问题"><a href="#阶乘问题" class="headerlink" title="阶乘问题"></a>阶乘问题</h1><p>阶乘或数学运算等问题只需要记住一点，不用真的去算，因为结果一定会越界。</p><h2 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a>172. 阶乘后的零</h2><p>给定一个整数 <code>n</code> ，返回 <code>n!</code> 结果中尾随零的数量。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：0</span><br><span class="line">解释：3! = 6 ，不含尾随 0</span><br></pre></td></tr></table></figure><p>我们首先来分析，阶乘的时候只有出现 5 或 5 的倍数时，阶乘才能出现 0。因此，如果阶乘的数字小于 5，可以直接返回 0。而 19 这样的数字能提供 5，10，15 一共 3 个 5，因此末尾 0 的数量就是 3。</p><p>此外，对于 25，125 等 5 的幂次方，25，50，75，100 能提供两个 5。也就是说，针对这种情况需要额外的处理，处理完 5 后要处理 25，然后 125，直到遇到 0 结束。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            res += n / <span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="793-阶乘函数后-K-个零"><a href="#793-阶乘函数后-K-个零" class="headerlink" title="793. 阶乘函数后 K 个零"></a>793. 阶乘函数后 K 个零</h2><p><code>f(x)</code> 是 <code>x!</code> 末尾是 <code>0</code> 的数量。例如，<code>f(3) = 0</code> ，因为 <code>3! = 6</code> 的末尾没有 <code>0</code> ；而 <code>f(11) = 2</code> ，因为  <code>11!= 39916800</code> 末端有 <code>2</code> 个 <code>0</code> 。给定 <code>k</code>，找出返回能满足 <code>f(x) = k</code> 的非负整数 <code>x</code> 的数量。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 0</span><br><span class="line">输出：5</span><br><span class="line">解释：0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。</span><br></pre></td></tr></table></figure><p>分析题意：</p><ol><li>如果末尾没有 0，那么一定是 0，1，2，3，4 这 5 个数</li><li>如果末尾有 0，利用 172 题的结论，二分查找即可。如果满足给定的 0 的个数，那么一定是 5 个数，因为，6 个数的情况下，一定会多出一个 0。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 0 的数量</span></span><br><span class="line">    <span class="function">lng <span class="title">find_</span><span class="params">(lng mid)</span> </span>&#123;</span><br><span class="line">        lng n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (mid) &#123;</span><br><span class="line">            n += mid / <span class="number">5</span>;</span><br><span class="line">            mid /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">preimageSizeFZF</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        lng l = <span class="number">0</span>, r = lNG_MAX;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            lng mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">auto</span> a = find_(mid);</span><br><span class="line">            <span class="keyword">if</span> (a == k)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; k) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; k) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h1><h2 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h2><p>给定整数 <code>n</code> ，返回 所有小于非负整数 <code>n</code> 的质数的数量 。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure><p>高效的计数素数。我理解的高效是，如果之前计算过，那么后续就不用计算了。如 2 是素数，那么 4，6，8，10 则都不是素数，如果遍历到 7，那么 14，21 也不是素数。</p><p>按照想法写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">arr</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 素数常见处理，平方小于 n 即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]) &#123;</span><br><span class="line">                <span class="comment">// 这个数的倍数都是素数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i) &#123;</span><br><span class="line">                    arr[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 剩下的都是素数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i])</span><br><span class="line">                res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="超级幂运算"><a href="#超级幂运算" class="headerlink" title="超级幂运算"></a>超级幂运算</h1><h2 id="372-超级次方"><a href="#372-超级次方" class="headerlink" title="372. 超级次方"></a>372. 超级次方</h2><p>你的任务是计算 $a^b$ 对 <code>1337</code> 取模，<code>a</code> 是一个正整数，<code>b</code> 是一个非常大的正整数且会以数组形式给出。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2, b = [3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure><p>如果要计算 $4^{1337}$ 次方，直接暴力计算是愚蠢的行为。我们对问题进行分解：$4^{1337} = 4^7 \times 4^{(133)10}$，分治这不就来了。</p><p>如果说，之前需要运算 1337 次，那么分治后，只需要运算 7 + 3 + 3 + 1 + 10 + 10 + 10 次，显著降低运算次数，算是一种空间换时间吧。</p><p>在补充一条数学运算：<code>(a * b) % c = (a % c) * (b % c) % c</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _pow(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> s1 = a;</span><br><span class="line">        <span class="keyword">int</span> s2 = a;</span><br><span class="line">        s2 %= mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            s2 *= (s1 % mod);</span><br><span class="line">            s2 %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> e = b.back();</span><br><span class="line">        b.pop_back();</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">int</span> a1 = _pow(a, e);</span><br><span class="line">        <span class="keyword">int</span> a2 = _pow(superPow(a, b), <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> (a1 % mod) * (a2 % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <code>a，b，c</code> ，使得 <code>a + b + c = 0</code> ？请你找出所有和为 <code>0</code> 且不重复的三元组。注意：答案中不可以包含重复的三元组。示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure><p>在此之前，先来看两数之和。在数组中找到两个数，两数之和为 0。此时我们对数组进行排序，并使用两个指针，左指针从左向右移动，右指针从右向左移动，求两者之和，如果和大于 0，说明右指针指向的数据太大，需要将右指针左移，反之将左指针右移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">twoSumTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// nums 数组必须有序</span></span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[l] + nums[hi];</span><br><span class="line">        <span class="keyword">int</span> left = nums[l], right = nums[hi];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push_back(&#123;left, right&#125;);</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是呢，对于 <code>[-3, -3, 1, 2, 3]</code> 这样的数组而言，第一个 <code>-3</code> 计算过之后，第二个 <code>-3</code> 就没必要计算了。因此，可以在数值相等的情况下省略一些情况，前提是数组必须有序。写出以下优化的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">twoSumTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// nums 数组必须有序</span></span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[l] + nums[r];</span><br><span class="line">        <span class="keyword">int</span> left = nums[l], right = nums[r];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == left) l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == right) r--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push_back(&#123;left, right&#125;);</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == left) l++;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == right) r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们可以写出三数之和：</p><ul><li>遍历数组，得到第一个数 <code>first</code>，因为数组是有序的，如果 <code>first&gt;0</code> 的情况就可以跳过</li><li>那么另外两个数必须在 <code>first</code> 之后，且另外两数之和需要等于 <code>-first</code>，此时套用上面的两数之和的程序即可</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; n; first++) &#123;</span><br><span class="line">            <span class="comment">// 如果第一个 first 算过了，后面相等的值都可以忽略</span></span><br><span class="line">            <span class="keyword">if</span> (nums[first] &gt; <span class="number">0</span> || (first &gt; <span class="number">0</span> &amp;&amp; nums[first<span class="number">-1</span>] == nums[first])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[first];</span><br><span class="line">            <span class="comment">// third 是双指针中的右指针</span></span><br><span class="line">            <span class="keyword">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> second = first + <span class="number">1</span>; second &lt; n; second++) &#123;</span><br><span class="line">                <span class="comment">// 忽略算过的值</span></span><br><span class="line">                <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second<span class="number">-1</span>] == nums[second]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (third &gt; second &amp;&amp; nums[third] + nums[second] &gt; target) &#123;</span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不能有相同的值</span></span><br><span class="line">                <span class="keyword">if</span> (third == second) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 保留结果</span></span><br><span class="line">                <span class="keyword">if</span> (nums[third] + nums[second] == target) &#123;</span><br><span class="line">                    res.push_back(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前从未意识到位运算的强大威力，认为与或非只存在大一 C 语言的考试或单片机的设计中，直到今天才发现我错了。做一个常用的位运算和数学运算的整理。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：滑动窗口</title>
    <link href="https://muyuuuu.github.io/2022/05/24/slide-window/"/>
    <id>https://muyuuuu.github.io/2022/05/24/slide-window/</id>
    <published>2022-05-24T13:21:21.000Z</published>
    <updated>2022-05-24T14:04:57.473Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>听到滑动窗口这个词，让我想起了计算机网络中的 TCP 传输和拥塞控制，可惜时隔多年还给老师了，那老师讲课还很不错。我的大部分本科老师都有着很多年的工作经验，并不像部分硕博留校那种只擅长验证玩具理论和咬文嚼字，而从未到实际环境中实习过一次。所以他们讲课十分形象具体，结合理论和实际环境告诉你这是个什么东西。</p><p>说远了，回到正题。滑动窗口一般用于求接子串中满足某种情况的最值，可以简单的划分为三类：</p><ol><li>给一个字符串，求满足条件的最长子串</li><li>给两个字符串，求其中一个字符串是否能覆盖另一个字符串</li><li>给定一个数组和窗口大小，窗口没滑动一次，求一次最值</li></ol><a id="more"></a><h1 id="满足条件的最长子串"><a href="#满足条件的最长子串" class="headerlink" title="满足条件的最长子串"></a>满足条件的最长子串</h1><p>这个是最简单的一个，也是后面其他滑动窗口的模板。既然是滑动窗口，就必然有一个窗口和滑动的步骤。为了实现窗口，我们定义两个指针，左指针和右指针。随着右指针的移动，窗口逐渐变大，也就是窗口扩张。如果破坏了和满足了题目要求，那么左指针移动，称为窗口收缩，根据题目条件判断窗口收缩的程度，然后当前窗口就是一个满足题意的结果。</p><p>随着左右指针的先后移动，会以此查找子串中所有满足情况的子串，我们保留其中的最值即可。说了这么多，来看一个例题，不然太抽象了。</p><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>我们来分析一下，条件就是不含重复子串，结果就是保留最短的子串长度。既然如此，大概思想就是：</p><ol><li>右指针移动扩张窗口</li><li>当窗口内有重复元素时，收缩窗口，直到没有重复元素</li><li>记录窗口的大小，也就是没有重复字符的子串长度</li><li>重复这个流程，直到求出最长的子串</li></ol><p>我们写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, n = s.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 右侧指针滑动</span></span><br><span class="line">            <span class="keyword">char</span> c = s[r];</span><br><span class="line">            r++;</span><br><span class="line">            m1[c] ++;</span><br><span class="line">            <span class="comment">// 不满足重复条件，因此要收缩，直到满足条件</span></span><br><span class="line">            <span class="keyword">while</span> (m1[c] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> d = s[l];</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">if</span> (m1[d] &gt;= <span class="number">2</span>)</span><br><span class="line">                    m1[d] --;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (m1[d] == <span class="number">1</span>)</span><br><span class="line">                    m1.erase(d);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 窗口收缩后，此时满足不重复条件</span></span><br><span class="line">            <span class="comment">// 记录结果</span></span><br><span class="line">            ans = max(ans, r - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == <span class="number">0</span> ? n : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="子串包含问题"><a href="#子串包含问题" class="headerlink" title="子串包含问题"></a>子串包含问题</h1><h2 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a>567. 字符串的排列</h2><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code>。换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 子串。如 <code>adc</code> 是 <code>kajihscda</code> 的子串。</p><p>同样，窗口滑动的时候，把条件判断更改为是否能覆盖 <code>s1</code> 即可：</p><ol><li>右指针移动扩张窗口</li><li>如果能覆盖 <code>s1</code>，收缩窗口，直到不能覆盖 <code>s1</code></li><li>记录窗口的大小，也就是 <code>s2</code> 中的窗口大小</li><li>判断这个窗口是否为 <code>s1</code> 的排列组合</li></ol><p>甚至可以看到，这个和最开始的「无重复字符的最长子串」如出一辙，我们写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s2.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s1)</span><br><span class="line">            m1[i]++;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s2[r];</span><br><span class="line">            m2[c] ++;</span><br><span class="line">            <span class="comment">// 判断是否覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (m1.count(c) &amp;&amp; m1[c] == m2[c]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 覆盖了，满足题中条件，开始收缩</span></span><br><span class="line">            <span class="keyword">while</span> (valid == m1.size()) &#123;</span><br><span class="line">                res = r - l + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">char</span> d = s2[l];</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">if</span> (m1.count(d) &amp;&amp; m1[d] == m2[d]) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                m2[d] --;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="comment">// 收缩结束，判断这个窗口是否满足结果</span></span><br><span class="line">            <span class="keyword">if</span> (res == s1.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h2><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure><p>和上一题一模一样，写出程序保存所有结果即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), valid = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : p)</span><br><span class="line">            m1[i]++;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[r];</span><br><span class="line">            m2[c]++;</span><br><span class="line">            <span class="keyword">if</span> (m1.count(c) &amp;&amp; m1[c] == m2[c]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (valid == m1.size()) &#123;</span><br><span class="line">                <span class="keyword">char</span> d = s[l];</span><br><span class="line">                ans = r - l + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (m1.count(d) &amp;&amp; m1[d] == m2[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                m2[d]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans == p.size()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res.empty())</span><br><span class="line">                    res.push_back(l - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (res.back() != l - <span class="number">1</span>)</span><br><span class="line">                    res.push_back(l - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p>仿佛不知道说啥，就把上一题的异位词，改成每次保留最短的子串就好了。如出一辙：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt; t.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_l = <span class="number">0</span>, min_r = <span class="number">0</span>, res = INT_MAX;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : t)</span><br><span class="line">            m1[i]++;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[r];</span><br><span class="line">            m2[c]++;</span><br><span class="line">            <span class="keyword">if</span> (m1.count(c) &amp;&amp; m1[c] == m2[c]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (valid == m1.size()) &#123;</span><br><span class="line">                <span class="keyword">char</span> d = s[l];</span><br><span class="line">                <span class="comment">// 每次都保留最短的</span></span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; res) &#123;</span><br><span class="line">                    res = r - l + <span class="number">1</span>;</span><br><span class="line">                    min_l = l;</span><br><span class="line">                    min_r = r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (m1.count(d) &amp;&amp; m1[d] == m2[d]) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                m2[d]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == <span class="number">0</span> ? <span class="string">""</span> : s.substr(min_l, min_r - min_l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="窗口滑动时求最值"><a href="#窗口滑动时求最值" class="headerlink" title="窗口滑动时求最值"></a>窗口滑动时求最值</h1><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值 。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p>说实话，这是我见过最好的一个数据结构设计类题目。如果每次滑动都遍历求解最大值，是最简单的方法，也是超时的做法，此时就要发挥算法的魅力了：</p><ol><li>我实现一个数据结构，这个数据结构能很快的返回最大值，不需要用户操作什么。虽然很容易想到使用优先级队列，但是优先级队列是不行的，因为优先级队列会破坏元素进入的先后关系，我们不能破坏这一点</li><li>那我们自己定义一个队列，让队首元素是最大值即可，而且队列中的元素降序排列。既然有了队列，那么每次滑动求最大值就容易了，返回队首即可</li><li>且在滑动过程中，如果被滑出去的元素恰好是最大值，那就删除队列中的最大值。由于队列中的元素降序排列，因此下一个队首元素也一定是下一个窗口的最大值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myque</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> max_num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    myque() &#123;&#125;;</span><br><span class="line">    myque(<span class="keyword">int</span> s) : size&#123;s&#125; &#123;&#125;;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 自定义队列，保证队列降序</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (q.size() &amp;&amp; num &gt; q.back()) &#123;</span><br><span class="line">            q.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        q.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果滑出去的是最大值，那么就滑走</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == q.front())</span><br><span class="line">            q.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队首即最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">myque <span class="title">q</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="comment">// 先填充满窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            q.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始滑动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            q.push(nums[i]);</span><br><span class="line">            res.push_back(q.getMax());</span><br><span class="line">            q.pop(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="乱入"><a href="#乱入" class="headerlink" title="乱入"></a>乱入</h1><p>开头提到讲课的老师，我还是很怀念我大学工程能力很强的老师。</p><ul><li>能力低下的老师讲课：我许多年前多么多么厉害，要参加比赛和科研，别人多么不行，你们多么差劲，两个小时的课说一个半小时没用的，这种老师基本硕博留校，上学期间写玩具代码或让别人写，但一定擅长咬文嚼字发文章，也不懂课程内容，只是被分配到了这里。就像我这个博客一样，内容不怎么样，但废话很多。</li><li>一般老师讲课：念 PPT，讲一些例题。</li><li>比较好的老师讲课：不念 PPT，把课本内容翻译成人话讲出来。</li><li>不错的老师讲课，讲完理念，告诉你实际生产环境该如何处理。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听到滑动窗口这个词，让我想起了计算机网络中的 TCP 传输和拥塞控制，可惜时隔多年还给老师了，那老师讲课还很不错。我的大部分本科老师都有着很多年的工作经验，并不像部分硕博留校那种只擅长验证玩具理论和咬文嚼字，而从未到实际环境中实习过一次。所以他们讲课十分形象具体，结合理论和实际环境告诉你这是个什么东西。&lt;/p&gt;
&lt;p&gt;说远了，回到正题。滑动窗口一般用于求接子串中满足某种情况的最值，可以简单的划分为三类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给一个字符串，求满足条件的最长子串&lt;/li&gt;
&lt;li&gt;给两个字符串，求其中一个字符串是否能覆盖另一个字符串&lt;/li&gt;
&lt;li&gt;给定一个数组和窗口大小，窗口没滑动一次，求一次最值&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的类型转换</title>
    <link href="https://muyuuuu.github.io/2022/05/22/cpp-type-cast/"/>
    <id>https://muyuuuu.github.io/2022/05/22/cpp-type-cast/</id>
    <published>2022-05-22T14:16:02.000Z</published>
    <updated>2022-05-24T15:18:44.866Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今晚翻了一下 <code>todo list</code>，发现这个条目堆积在未完成列表的末尾，于是来学习一下 <code>C++</code> 中的四种类型转化方式，而 <code>C++</code> 的复习也告一段落。我知道我还差得很远，等某天 <code>C++</code> 功底足够深厚，来写一下 <code>C++</code> 的内存模型。</p><a id="more"></a><h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h1><p><code>static_cast</code> 是一个 <code>c++</code> 运算符，功能是把一个表达式转换为某种类型，依赖编译时得到的类型信息，没有运行时类型检查来保证转换的安全性，用于非多态类型的转换。所以为了安全起见，通常用于转换数值数据类型，如 <code>int</code> 到 <code>double</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">double</span> result = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a) /  b;</span><br></pre></td></tr></table></figure><p>如果涉及到类层次的类型转换，父到子不安全（向下转换），子到父安全（向上转换，也是隐式转换）。由于不检查转换的安全性，因此向下转换为子类类型时，可能有基类不存在的成员变量和函数，会导致未定义行为，直接报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    child a;</span><br><span class="line">    base b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> c = <span class="keyword">static_cast</span>&lt;base&gt;(a); <span class="comment">// fine</span></span><br><span class="line">    <span class="keyword">auto</span> d = <span class="keyword">static_cast</span>&lt;child&gt;(b); <span class="comment">// fail</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1><p><code>const_cast</code> 能给变量添加 <code>const</code> 特性或移除变量的 <code>const</code> 特性，其他的任何转换不能移除 <code>const</code> 修饰。因为可以直接将非 <code>const</code> 变量赋值给 <code>const</code> 变量，因此 <code>const_cast</code> 增加 <code>const</code> 修饰很少用到。此外，如果修饰的引用或指针指向的是 <code>const</code> 修饰的变量，将指针和引用修改为 <code>non-const</code> 会导致未定义行为；相反，如果修饰的变量不是 <code>const</code>，那么转换是安全的。</p><p>至于未定义行为是否能编译通过，取决于使用的编译器，不能一概而论。是 UB 不过这样写的话编译器不会报错， 然后一般来说会产生指向一个局部变量的指针， 所以也不会 <code>Segmentation fault</code> 。</p><p>但是如果是字符串常量， 那实现上会存放在 rodata， 运行时加载到了一个只读的页， 如果 <code>const_cast</code> 掉 <code>const</code> 然后写入那么就会 <code>Segmentation fault</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// <span class="doctag">NOTE:</span> non-const object </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* pA = &amp;a; <span class="comment">// non-const to const</span></span><br><span class="line">*pA = <span class="number">10</span>; <span class="comment">// compiler error, pA is a pointer to const int  </span></span><br><span class="line"><span class="keyword">int</span>* pX = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(pA); <span class="comment">// cast away constness </span></span><br><span class="line">*pX = <span class="number">10</span> <span class="comment">// fine and a is now 10 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// <span class="doctag">NOTE:</span> const object </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* pA = &amp;a; </span><br><span class="line"><span class="keyword">int</span>* pX = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(pA); <span class="comment">// cast away constness  </span></span><br><span class="line">*pX = <span class="number">10</span> <span class="comment">// Free ticket to a long journey of UNDEFINED BEHAVIOR</span></span><br></pre></td></tr></table></figure><p>此外，<code>const_cast</code> 不能修改到其他的数据类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="literal">nullptr</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ptr = <span class="string">"Hello"</span>; </span><br><span class="line">a = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(ptr); <span class="comment">// Fail </span></span><br><span class="line">a = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(ptr); <span class="comment">// Fail, reinterpret_cast can't cast away const qualifiers </span></span><br><span class="line">a = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr)); <span class="comment">// Fine, as long as you know why you are doing it</span></span><br></pre></td></tr></table></figure><h1 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h1><p>这个是最危险的转换，如果使用这个转换，相当于告诉了编译器，我知道我在做什么。假如从 <code>A</code> 类型转换为 <code>B</code> 类型，那么就是基于 bit 模式，用 <code>B</code> 类型重新解释 <code>A</code> 类型之前指向的地址，由于是重新解释地址，因此这个转换不会编译为任何 CPU 指令。滥用 <code>reinterpret_cast</code> 运算符可能很容易带来风险，除非所需转换本身是低级别的，比如 int 到 double，否则建议使用其他强制转换运算符之一。</p><p>这个转换允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全），也允许将任何整数类型转换为任何指针类型以及反向转换。这些转换中唯一正确的是 <code>reinterpret_cast</code> 将变量转换为原类型, 会得到相同的值，但是如果中间变量所占内存小的话就不一定了。听着就危险，此外，<code>reinterpret_cast</code> 运算符不能丢掉 <code>const</code> 修饰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;  </span><br><span class="line">A *a = <span class="keyword">new</span> A&#123;&#125;;  </span><br><span class="line">B *b = <span class="keyword">reinterpret_cast</span>&lt;B*&gt;(a);  <span class="comment">// Fine </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* message = <span class="string">"hello"</span>;  </span><br><span class="line"><span class="keyword">int</span>* data = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(message);  <span class="comment">// can't remove const</span></span><br></pre></td></tr></table></figure><h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><p>这个和 <code>RTTI</code> 还有些关系，所以多说一些吧。这个转换应用于用于多态类型的转换，如果被转换的类型不具备多态性，那么向上转换可以在编译时期分析继承关系，确定类型，而且向下转换会直接报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> &#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; &#125;; </span><br><span class="line"> </span><br><span class="line">Base a, *ptr_a; </span><br><span class="line">Derived b, *ptr_b; </span><br><span class="line"> </span><br><span class="line">ptr_a = <span class="keyword">dynamic_cast</span>&lt;Base *&gt;(&amp;b);  <span class="comment">// Fine </span></span><br><span class="line">ptr_b = <span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(&amp;a);  <span class="comment">// Fail</span></span><br></pre></td></tr></table></figure><p>假设此时基类具备了多态性，那么这个转换能够去检验具有继承关系的父子类型的指针、引用的转换是否安全。那么可以将一个指针类型或引用转换为其他多态类型，也可以用来向下转换。由于只适用于指针或引用，那么只能进行运行时类型检查，<code>dynamic_cast</code> 将寻找所需的对象并在可能的情况下返回它，对不明确的指针的转换将失败（返回 <code>nullptr</code>），但不引发异常。来看个例子：</p><p>第二个转换失败，因为子类不具有多态性，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125; &#125;; <span class="comment">// polymorphic class </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; <span class="keyword">int</span> a; &#125;; <span class="comment">// so is this </span></span><br><span class="line"></span><br><span class="line">Base *ptr_a = <span class="keyword">new</span> Derived&#123;&#125;; </span><br><span class="line">Base *ptr_b = <span class="keyword">new</span> Base&#123;&#125;; </span><br><span class="line"> </span><br><span class="line">Derived *ptr_c = <span class="literal">nullptr</span>; </span><br><span class="line">Derived *ptr_d = <span class="literal">nullptr</span>; </span><br><span class="line"> </span><br><span class="line">ptr_c = <span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(ptr_a);  <span class="comment">// Fine, 指向的和转换的一致</span></span><br><span class="line">ptr_d = <span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(ptr_b);  <span class="comment">// ptr_d will be NULL, 指向的和转换的不一致</span></span><br></pre></td></tr></table></figure><p><code>dynamic_cast</code> 在转换之前，就要确定基类究竟指向的是什么类型的对象。由于基类可能指向任何的自身类型对象、子类类型对象。所以，编译期基类指针是无法确定其指向的对象类型的，只能等到运行时。</p><h2 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h2><p>除 <code>dynamic_cast</code> 外，也能通过 <code>typeid</code> 运算符使用运行时堕胎，获得变量的类型。此时，需要重点注意的是，<code>typeid</code> 可以在编译期将获得变量的类型，也可以在运行期获得变量的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(a).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于无法在编译时期确认的类型，只能等到运行时期。如下所示的程序：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A: base &#123;virtual void show() override&#125;</span><br><span class="line">class B: base &#123;virtual void show() override&#125;</span><br></pre></td></tr></table></figure><p>但是重点是要把方法声明为虚方法:</p><ul><li>如果一个方法不是虚方法，那么将根据引用类型或指针类型选择执行的方法，静态联编</li><li>如果一个方法是虚方法，将根据指针或引用指向对象的类型选择执行的方法，动态联编</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今晚翻了一下 &lt;code&gt;todo list&lt;/code&gt;，发现这个条目堆积在未完成列表的末尾，于是来学习一下 &lt;code&gt;C++&lt;/code&gt; 中的四种类型转化方式，而 &lt;code&gt;C++&lt;/code&gt; 的复习也告一段落。我知道我还差得很远，等某天 &lt;code&gt;C++&lt;/code&gt; 功底足够深厚，来写一下 &lt;code&gt;C++&lt;/code&gt; 的内存模型。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：数组类题目</title>
    <link href="https://muyuuuu.github.io/2022/05/22/array-series/"/>
    <id>https://muyuuuu.github.io/2022/05/22/array-series/</id>
    <published>2022-05-22T10:48:27.000Z</published>
    <updated>2022-08-06T16:14:50.327Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前没有很留意，没想到大一学过的数组也能有很多精彩的算法题。本文收录了数组类算法常见的：前缀和、差分数组、常数时间查找和删除数组元素和数组去重问题。</p><ul><li>前缀和数组：用于频繁求解给定区间内，数组元素的和</li><li>差分数组：用于频繁更改给定区间内数组元素的取值，最后得到数组</li></ul><p>前面两个侧重频繁修改数组，常规模拟算法必然超时。而至于常数时间内查找和删除数组元素，数组元素去重已经是固定要求的题目了，文末直接给出题解。</p><a id="more"></a><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>前缀和就是输入数组的累计和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">presum[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    presum[i] = presum[i<span class="number">-1</span>] + sum[i];</span><br></pre></td></tr></table></figure><p>因此， <code>presum[r] - presum[l-1]</code> 就是数组在区间 <code>[l,r]</code> 内的和。</p><p>前缀和算法一般用于求解以下问题：需要频繁的调用某个方法，这个方法需要求出数组在给定区间中元素的和。如果每次查询都要遍历数组求和，会超时的很严重，因此需要使用前缀和来解决。但是众所周知算法不可能这么简单，一边看题一边看前缀和的细节。</p><h2 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a>303. 区域和检索 - 数组不可变</h2><p>给定一个整数数组 <code>nums</code>，处理以下类型的多个查询: 计算索引 <code>left</code> 和 <code>right</code> （包含 <code>left</code> 和 <code>right</code>）之间的 <code>nums</code> 元素的和 ，其中 <code>left &lt;= right</code>。实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 中索引 <code>left</code> 和 <code>right</code> 之间的元素的总和 ，包含 <code>left</code> 和 <code>right</code> 两点（也就是 <code>nums[left] + nums[left + 1] + ... + nums[right]</code> ) 。示例 1：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, -1, -3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);</span><br><span class="line">numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)</span><br><span class="line">numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) </span><br><span class="line">numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</span><br></pre></td></tr></table></figure><p>这个是典型的求解区间数组和的题目，如果每次都暴力计算会超时。因此我们使用前缀和数组来解决问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; presum;</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        presum.resize(nums.size());</span><br><span class="line">        presum.assign(nums.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 构建前缀和</span></span><br><span class="line">        presum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            presum[i] = presum[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> presum[right];</span><br><span class="line">        <span class="keyword">return</span> presum[right] - presum[left - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般不建议这么写，因为 <code>left-1</code> 很容易越界，涉及到二维数组十分不好处理。因此，推荐的写法是，<strong>前缀和数组比输入数组大一个维度</strong>。此时，只需要让 <code>right+1</code> 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; presum;</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        presum.resize(nums.size() + <span class="number">1</span>);</span><br><span class="line">        presum.assign(nums.size() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 前缀和数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); i++) &#123;</span><br><span class="line">            presum[i] = presum[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> presum[right + <span class="number">1</span>] - presum[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二维区域和检索-矩阵不可变"><a href="#二维区域和检索-矩阵不可变" class="headerlink" title="二维区域和检索 - 矩阵不可变"></a>二维区域和检索 - 矩阵不可变</h2><p>给定一个二维矩阵 <code>matrix</code>，以下类型的多个请求：计算其子矩形范围内元素的总和，该子矩阵的 左上角为 <code>(row1, col1)</code> ，右下角为 <code>(row2, col2)</code> 。实现 <code>NumMatrix</code> 类：</p><ul><li><code>NumMatrix(int[][] matrix)</code> 给定整数矩阵 <code>matrix</code> 进行初始化</li><li><code>int sumRegion(int row1, int col1, int row2, int col2)</code> 返回左上角 <code>(row1, col1)</code> 、右下角 <code>(row2, col2)</code> 所描述的子矩阵的元素总和。</li></ul><p>对于二维数组，方法还是和一维数组一样，我们求某个坐标对应的前缀和就可以了。但是迫切建议前缀和数组大一个维度，不然边界情况真的很难处理。和一维数组一样，构建数组的前缀和数组，在求解指定区间的数组和时，也是两个边界相减就行，但是有一点点细节要处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; presum;</span><br><span class="line">    NumMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        presum.resize(m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            presum[i].assign(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        presum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 构建二维前缀和数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                presum[i][j] = matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] + presum[i<span class="number">-1</span>][j] + presum[i][j<span class="number">-1</span>] - presum[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间相减，但是要注意 presum[row1][col1] 减了两次</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> presum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - presum[row1][col2+<span class="number">1</span>] - presum[row2+<span class="number">1</span>][col1] + presum[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1124-表现良好的最长时间段"><a href="#1124-表现良好的最长时间段" class="headerlink" title="1124. 表现良好的最长时间段"></a>1124. 表现良好的最长时间段</h2><p>这个是和<a href="https://muyuuuu.github.io/2022/05/20/monotonic-stack/">单调栈</a>的梦幻联动，掌握了这个题，前缀和学的就可以了。</p><p>给你一份工作时间表 <code>hours</code>，上面记录着某一位员工每天的工作小时数。我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格大于「不劳累的天数」。请你返回「表现良好时间段」的最大长度。示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：hours = [9,9,6,0,6,6,9]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长的表现良好时间段是 [9,9,6]。</span><br></pre></td></tr></table></figure><p>一开始的时候毫无头绪，甚至暴力模拟也没有什么太好的思路，直到看了题解。</p><ol><li>因为工作时长以 8 小时为划分，不管是 10 小时还是 13 小时，本质是一样的，7 小时和 8 小时的本质也是一样的。因此，我们新建一个数组 <code>score</code>，大于 8 为 1，否则为 -1。</li><li>根据 <code>score</code> 构建前缀和数组，前缀和数组元素的值越大，表示近期的工作表现越良好。换一种说法，如果 <code>score</code> 数组呈现了上升的趋势，那么说明今天在好好工作。</li><li>因此，我们只需要求前缀和数组中的最大上升跨度，就是劳累天数严格大于不劳累天数，结果即为表现良好的时间段。最大跨度请参考<a href="http://localhost:4000/2022/05/20/monotonic-stack/" target="_blank" rel="noopener">单调栈</a>那篇文章的最后一题。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestWPI</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; hours)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = hours.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">presum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">socre</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            socre[i] = hours[i] &gt; <span class="number">8</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            presum[i] = presum[i<span class="number">-1</span>] + socre[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单调递减栈</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.empty() || presum[stk.top()] &gt; presum[i]) &#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大上升跨度</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stk.size() &amp;&amp; presum[stk.top()] &lt; presum[i]) &#123;</span><br><span class="line">                ans = max(ans, i - stk.top());</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h1><p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减，然后问你修改后的数组是多少。差分数组的构造方式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">diff[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    diff[i] = arr[i] - arr[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果让数组区间 <code>[l, r]</code> 内的元素增加 3，只需要让 <code>diff[l]+3</code>, <code>diff[r]-3</code> 即可 （自己画图理解下）。而通过 <code>diff</code> 也能得到原始的数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    arr[i] = arr[i<span class="number">-1</span>] + diff[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1109-航班预订统计"><a href="#1109-航班预订统计" class="headerlink" title="1109. 航班预订统计"></a>1109. 航班预订统计</h2><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p><p>有一份航班预订表 <code>bookings</code> ，表中第 i 条预订记录 <code>bookings[i] = [first[i], last[i], seats[i]]</code> 意味着在从 <code>first[i]</code> 到 <code>last[i]</code> （包含 <code>first[i]</code> 和 <code>last[i]</code> ）的每个航班上预订了 <code>seats[i]</code> 个座位。请你返回一个长度为 n 的数组 <code>answer</code>，里面的元素是每个航班预定的座位总数。示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2   3   4   5</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       20  20</span><br><span class="line">预订记录 3 ：       25  25  25  25</span><br><span class="line">总座位数：      10  55  45  25  25</span><br><span class="line">因此，answer = [10,55,45,25,25]</span><br></pre></td></tr></table></figure><p>典型的差分数组应用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : bookings) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = i[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> e = i[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> v = i[<span class="number">2</span>];</span><br><span class="line">            diff[s] += v;</span><br><span class="line">            <span class="comment">// 防止越界</span></span><br><span class="line">            <span class="keyword">if</span> (e + <span class="number">1</span> &lt;= n - <span class="number">1</span>)</span><br><span class="line">                diff[e + <span class="number">1</span>] -= v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] = res[i<span class="number">-1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="拼车"><a href="#拼车" class="headerlink" title="拼车"></a>拼车</h2><p>车上最初有 <code>capacity</code> 个空座位。车只能向一个方向行驶（也就是说，不允许掉头或改变方向。给定整数 <code>capacity</code> 和一个数组 <code>trips</code> ,  <code>trip[i] = [numPassengers[i], from[i], to[i]]</code> 表示第 i 次旅行有 <code>numPassengers[i]</code> 乘客，接他们和放他们的位置分别是 <code>from[i]</code> 和 <code>to[i]</code> 。这些位置是从汽车的初始位置向东的公里数。当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：trips = [[2,1,5],[3,3,7]], capacity = 4</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>这里需要注意的是，比如客户 A 在 5 下车，而客户 B 在 5 上车，此时是能顺利交接的。因此，下车的时候，<code>diff[r]-n</code> 即可，不需要占用 <code>r</code> 处的容量。可以理解为，在地点 4 ，车上就没有客户了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(<span class="number">1005</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : trips) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> s = i[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> e = i[<span class="number">2</span>];</span><br><span class="line">            diff[s] += v;</span><br><span class="line">            diff[e] -= v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1005</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 细节判断</span></span><br><span class="line">        <span class="keyword">if</span> (res[<span class="number">0</span>] &gt; capacity)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1005</span>; i++) &#123;</span><br><span class="line">            res[i] = res[i<span class="number">-1</span>] + diff[i];</span><br><span class="line">            <span class="keyword">if</span> (res[i] &gt; capacity)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><p>给你一个字符串 s，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bcabc&quot;</span><br><span class="line">输出：&quot;abc&quot;</span><br></pre></td></tr></table></figure><p>严格来说，这算一个模拟题，只要思路足够清晰，是可以写出代码的：</p><ol><li>每个字符只出现一次，因此在遍历字符串时，如果当前字符已经被添加到结果中时，需要跳过当前字符，避免重复；</li><li>如果当前字符没有在结果中，添加当前字符时需要一些处理来满足字典序。如果这个字符比上一个字符的字典序小，且上一个字符后面还会出现，我们就需要弹出上一个字符，添加当前字符。</li></ol><p>如果要实现以上两点，就需要使用哈希和栈。<code>need</code> 哈希表用于记录每个字符出现的次数，每添加一次，取值就递减，可以判断这个字符之后还会不会出现，以及出现的次数。<code>isin</code> 哈希表判断当前字符是否已经添加。<code>res</code> 栈用来存储结果，因为栈可以方便的弹出末尾元素来使字典序更小。程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need;</span><br><span class="line">        <span class="comment">// 记录次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.size(); i++) &#123;</span><br><span class="line">            need[s[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; res;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">isin</span><span class="params">(<span class="number">26</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">            <span class="comment">// 之后出现的次数递减</span></span><br><span class="line">            need[i]--;</span><br><span class="line">            <span class="comment">// 不在结果中</span></span><br><span class="line">            <span class="keyword">if</span> (isin[i - <span class="string">'a'</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="comment">// 可以弹栈的情况</span></span><br><span class="line">                <span class="keyword">while</span> (res.size() &amp;&amp; need[res.top()] &gt; <span class="number">0</span> &amp;&amp; res.top() &gt; i) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> a = res.top();</span><br><span class="line">                    res.pop();</span><br><span class="line">                    <span class="comment">// 弹栈后不在结果中</span></span><br><span class="line">                    isin[a - <span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res.push(i);</span><br><span class="line">                isin[i - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans&#123;<span class="string">""</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (res.size()) &#123;</span><br><span class="line">            ans += res.top();</span><br><span class="line">            res.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="O-1-时间查找和删除元素"><a href="#O-1-时间查找和删除元素" class="headerlink" title="$O(1)$ 时间查找和删除元素"></a>$O(1)$ 时间查找和删除元素</h1><p>刚开始看到题的时候给我整不会了，众所周知数组内查找元素的时间复杂度为 $O(n)$，有序数组内查找元素的时间复杂度为 $O(\log n)$，怎么可能做到 $O(1)$。</p><p>但看到题目是这种类的时间，频繁的调用方法插入和删除，那么 $O(1)$ 时间的查找和删除也有了可能。只需要在插入的时候通过哈希记录数值的索引，那么能很轻松的查找到数值是否在数组中，以及它的索引。</p><p>而要实现 $O(1)$ 的删除元素，我们知道 C++ 的 STL 支持 $O(1)$ 删除的只有 <code>pop_back()</code>  这样的方法。因此，当需要删除某一个值时，我们把这个数值和数组末尾的数值进行交换，而后 <code>pop_back()</code> 即可。</p><p>实现 <code>RandomizedSet</code> 类：</p><ol><li><code>RandomizedSet()</code> 初始化 <code>RandomizedSet</code> 对象</li><li><code>bool insert(int val)</code> 当元素 <code>val</code> 不存在时，向集合中插入该项，并返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>bool remove(int val)</code> 当元素 <code>val</code> 存在时，从集合中移除该项，并返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>int getRandom()</code> 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。<br>你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">输出</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">RandomizedSet randomizedSet = new RandomizedSet();</span><br><span class="line">randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span><br><span class="line">randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。</span><br><span class="line">randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。</span><br><span class="line">randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span><br><span class="line">randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。</span><br><span class="line">randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">    RandomizedSet() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入时记录索引</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m1.count(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push_back(val);</span><br><span class="line">        m1[val] = arr.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m1.count(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val_idx = m1[val];</span><br><span class="line">        <span class="keyword">int</span> back_val = arr.back();</span><br><span class="line">        <span class="keyword">int</span> back_idx = m1[back_val];</span><br><span class="line">        <span class="comment">// 和末尾元素交换</span></span><br><span class="line">        arr[val_idx] = back_val;</span><br><span class="line">        m1[back_val] = val_idx;</span><br><span class="line">        m1.erase(val);</span><br><span class="line">        arr.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机选择</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = rand() % arr.size();</span><br><span class="line">        <span class="keyword">return</span> arr[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="寻找数组重复和缺失元素"><a href="#寻找数组重复和缺失元素" class="headerlink" title="寻找数组重复和缺失元素"></a>寻找数组重复和缺失元素</h1><p>直接来看题目吧。</p><h2 id="645-错误的集合"><a href="#645-错误的集合" class="headerlink" title="645. 错误的集合"></a>645. 错误的集合</h2><p>集合 <code>s</code> 包含从 <code>1</code> 到 <code>n</code> 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合丢失了一个数字并且有一个数字重复。给定一个数组 <code>nums</code> 代表了集合 <code>S</code> 发生错误后的结果。请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,2,4]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><p>对于如上的示例，正常的数组应该是 <code>[1,2,3,4]</code>，因此，重复的是 2，缺失的是 3。其实这个题挺简单的，没啥可说的，<del>面试碰到这个题可以内心狂喜了</del>。即使不看题解，绝大多数人也知道怎么去做。再不济输入数组排序，然后依次遍历，总能查到重复的和缺失的。</p><p>但是排序的时间复杂度可能有点高，我们优化一下这个复杂度。创建一个哈希数组：</p><ol><li>首先遍历原数组得到数值，以数值为索引，反哈希数组中的值设置为 <code>true</code></li><li>这样，在下一次遇到 <code>true</code> 时，就能得到重复元素</li><li>遍历哈希数组，如果元素为 <code>false</code>，说明索引对应的值为缺失值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findErrorNums</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); i++) &#123;</span><br><span class="line">            arr[i<span class="number">-1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i<span class="number">-1</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">                arr[i<span class="number">-1</span>] = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">-1</span>) &#123;</span><br><span class="line">                b = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h1><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img data-src="https://s1.ax1x.com/2022/08/07/vuquAP.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</span><br></pre></td></tr></table></figure><p>注：华为2022提前批类似题目。柱子能接多少雨水，完全取决于左侧的最高高度和右侧的最高高度，我们可以得到每个柱子的左侧最高和右侧最高，那么所能存储的雨水就是：左侧最高的和右侧最高的中的最小值，减去当前柱子的高度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l_max</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">r_max</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        l_max[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        r_max[n<span class="number">-1</span>] = height.back();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            l_max[i] = max(l_max[i<span class="number">-1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            r_max[i] = max(r_max[i+<span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans += min(l_max[i], r_max[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前没有很留意，没想到大一学过的数组也能有很多精彩的算法题。本文收录了数组类算法常见的：前缀和、差分数组、常数时间查找和删除数组元素和数组去重问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前缀和数组：用于频繁求解给定区间内，数组元素的和&lt;/li&gt;
&lt;li&gt;差分数组：用于频繁更改给定区间内数组元素的取值，最后得到数组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面两个侧重频繁修改数组，常规模拟算法必然超时。而至于常数时间内查找和删除数组元素，数组元素去重已经是固定要求的题目了，文末直接给出题解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：单调栈</title>
    <link href="https://muyuuuu.github.io/2022/05/20/monotonic-stack/"/>
    <id>https://muyuuuu.github.io/2022/05/20/monotonic-stack/</id>
    <published>2022-05-20T14:26:12.000Z</published>
    <updated>2022-05-28T06:25:08.604Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>栈有着广泛的应用，比如逆波兰表达式，表达式求值，迷宫问题求解，程序调用等，不过这些问题今天都不涉及哈哈哈哈。关于程序执行期间，各个函数的相互调用使用的调用栈，可以<a href="https://muyuuuu.github.io/2019/09/22/stack/">参考这里</a>。</p><p>单调栈属于栈的具体应用，而非栈这种数据结构的简单使用。此类问题一般用于求解以下场景：<strong>序列中某个元素的下一个最大元素，元素间的最大跨度，维持某一状态持续的最长时间等</strong>。以序列 <code>[2,1,3,4]</code> 为例，1 的下一个最大元素就是 3，而不是 4；最大上升的跨度为从 2 到 4，跨越了 2 个数。对于这种问题都可以用单调栈求解。</p><a id="more"></a><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>也许在上数据结构这门课的时候，经常遇到一个问题，一个栈压入一个序列，随缘pop，判断哪个是合理的pop，哪个是不合理的pop，之前都是脑内演算。很巧的今天我在刷题期间也遇到了，记录一下如何用代码判断pop序列是否合理。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a stack which can keep $M$ numbers at most. Push $N$ numbers in the order of 1, 2, 3, …, $N$ and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. </p><p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): $M$ (the maximum capacity of the stack), $N$ (the length of push sequence), and $K$ (the number of pop sequences to be checked). Then $K$ lines follow, each contains a pop sequence of $N$ numbers. All the numbers in a line are separated by a space.</p><p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p><h2 id="示例输入"><a href="#示例输入" class="headerlink" title="示例输入"></a>示例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 7 5</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">3 2 1 7 5 6 4</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">5 6 4 3 7 2 1</span><br><span class="line">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure><h2 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a>示例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p>众所周知，栈是先进先出的一种数据结构，进栈为push，出栈为pop。题目的大概意思就是给定栈的最大空间，压入的序列和待检查的pop序列，因为栈是随缘pop的，判断哪个pop序列是正确的，哪个pop序列是错误的。</p><h2 id="脑内演算"><a href="#脑内演算" class="headerlink" title="脑内演算"></a>脑内演算</h2><ul><li>对于序列 1, 2, 3, 4, 5, 6, 7， 很容易得到栈是如何工作的，即压入一个元素立刻弹出即可。push 1，pop 1，push 2，pop 2，一直到push 7，pop 7。</li><li>对于序列 5, 6, 4, 3, 7, 2, 1，也可以得到栈的工作顺序为：push 1, 2, 3, 4, 5，而后pop 5，而后push 6 pop 6，pop 4，pop 3，push 7 pop 7，pop 2，pop 1。</li><li>对于序列 3, 2, 1, 7, 5, 6, 4，如果pop 7后，后面的顺序必然是 6，5，4而不可能是5，6，4。因此这个序列是错误的。</li><li>对于序列 7, 6, 5, 4, 3, 2, 1，在栈空间为5的情况下，不可能第一次就pop 7，因此这个序列是错误的。</li></ul><h2 id="一般化"><a href="#一般化" class="headerlink" title="一般化"></a>一般化</h2><p>在脑内演算后，也很容易发现题的难点在于不确定性的pop，可能在第一次pop，也可能在第三次pop，且每次pop几个元素也是不确定的。</p><p>我们实现知道了元素的进栈顺序，是1，2，3，4，…，$N$这样的顺序序列，所以，如果想办法<strong>按着它给出的序列模拟压栈和弹栈</strong>，如果能模拟出来，说明序列正确，模拟不出来说明序列错误。</p><ul><li><p>第一步，创建一个序列，读取题目示例输入的序列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br></pre></td></tr></table></figure></li><li><p>第二步，创建一个栈，并按元素的输入顺序组织元素进栈，开始按读取序列元素的顺序进行压栈和弹栈。</p></li><li><p>对输入序列设立标志位，并初始化标志位为1。当刚进栈的元素和输入序列标志位的元素相等时，说明此时元素要弹栈，则执行弹栈操作，且标志位自增向后移动；若不相等，则继续组织进栈，直到进栈元素和输入序列中标志位的元素相等。若一直不相等，则表明此序列错误。因此核心算法程序如下：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1002</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>, pos = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(i);</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; m) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() == arr[pos])</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                pos += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == n + <span class="number">1</span>) flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="/2022/05/20/monotonic-stack/1.png" alt></p><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>同样以 <code>[2,1,3,4]</code> 为例，假设此时我们有一个容器，输入一个数，容器顶部的元素是下一个最大的数。对于 1 而言，后面的最大元素是 3，因此可以得到一个结论：3 比 1 先进入容器，更通用一些：<strong>如果判断下一个最大元素，序列就要倒序进入容器，如果判断上一个最大元素，序列就要顺序进入容器</strong>。</p><p>由于 1 比 2 先进入容器，但 2 的下一个最大元素是 3 而不是 1，那么就需要在容器中进行一些操作来删除 1。即 1 比 2 早进入容器，却要先从容器种出来，那么有什么容器是后入先出的呢？当然是栈。这也就是单调栈的由来。我们总结一下：</p><ul><li>如果是求下一个最大元素，就需要倒序遍历序列，否则正序遍历；</li><li>判断输入的元素和栈顶元素的关系，如果是求最大元素，那么就需要弹出栈顶所有的小元素；</li></ul><p>不过还有一些小细节，这个就来看具体的题目了。</p><h1 id="下一个最大-小元素"><a href="#下一个最大-小元素" class="headerlink" title="下一个最大/小元素"></a>下一个最大/小元素</h1><h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a>496. 下一个更大元素 I</h2><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的下一个更大元素 。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出：[-1,3,-1]</span><br><span class="line">解释：nums1 中每个值的下一个更大元素如下所述：</span><br><span class="line">- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</span><br><span class="line">- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。</span><br><span class="line">- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</span><br></pre></td></tr></table></figure><p>根据前面的结论，写出程序并分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">10005</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 求下一个最大元素，因此要倒序进入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums2.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 弹出栈顶的小元素</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; nums2[i] &gt;= stk.top()) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈为空，说明没有比当前元素更大的，只能 -1</span></span><br><span class="line">            <span class="comment">// 否则栈顶比输入大</span></span><br><span class="line">            res[nums2[i]] = stk.empty() ? <span class="number">-1</span> : stk.top();</span><br><span class="line">            <span class="comment">// 并把当前元素放入栈中，用去后面序列元素的判断</span></span><br><span class="line">            stk.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums1) &#123;</span><br><span class="line">            ans.push_back(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指在第 <code>i</code> 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure><p>和上一题不一样的是，这个题不在求下一个最大温度了，而是下一个最大温度的<strong>索引</strong>。因此压入栈中的是索引而不是温度，索引之间的差，就是相差的天数。在判断输入元素和栈顶元素的大小关系时，根据索引访问温度即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = temperatures.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 倒序输入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 抛弃掉温度低的，索引访问温度</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; temperatures[i] &gt;= temperatures[stk.top()]) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果今天温度不是最高的，那么索引的差距就是间隔的天数</span></span><br><span class="line">            res[i] = stk.empty() ? <span class="number">0</span> : stk.top() - i;</span><br><span class="line">            <span class="comment">// 把今天放进去</span></span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a>901. 股票价格跨度</h2><p>编写一个 <code>StockSpanner</code> 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。例如，如果未来7天股票的价格是 <code>[100, 80, 60, 70, 60, 75, 85]</code>，那么股票跨度将是 <code>[1, 1, 1, 2, 1, 4, 6]</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]</span><br><span class="line">输出：[null,1,1,1,2,1,4,6]</span><br><span class="line">解释：</span><br><span class="line">首先，初始化 S = StockSpanner()，然后：</span><br><span class="line">S.next(100) 被调用并返回 1，</span><br><span class="line">S.next(80) 被调用并返回 1，</span><br><span class="line">S.next(60) 被调用并返回 1，</span><br><span class="line">S.next(70) 被调用并返回 2，</span><br><span class="line">S.next(60) 被调用并返回 1，</span><br><span class="line">S.next(75) 被调用并返回 4，</span><br><span class="line">S.next(85) 被调用并返回 6。</span><br><span class="line"></span><br><span class="line">注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格</span><br><span class="line">(包括今天的价格 75) 小于或等于今天的价格。</span><br></pre></td></tr></table></figure><p>这个题问的是：序列中小于等于当前元素，因此需要正序输入，确切来说，只能正序输入。此外，<code>next()</code> 方法会不断的调用，如果每次调用都通过输入来重新构建栈，就会超时。因此，我们把单调栈的核心算法封装进 <code>next()</code> 方法即可，且由于求的是时间跨度，因此压入栈中的是索引。个人认为，能独立把这个题写出来，单调栈就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    StockSpanner() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 序列元素</span></span><br><span class="line">        arr.push_back(price);</span><br><span class="line">        <span class="keyword">int</span> res = build(price);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="comment">// 保留大栈顶，如 100 60 80 则保留为 100 80</span></span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; price &gt;= arr[stk.top()]) &#123;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一天，一定为 1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 否则，如果栈空了，说明前几天都比今天低，就返回天数。否则就求时间跨度</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a = stk.empty() ? n + <span class="number">1</span> : n - stk.top();</span><br><span class="line">        <span class="comment">// 把今天压入，这里先 +1 或先压入都可以，细节自行处理</span></span><br><span class="line">        stk.push(n);</span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockSpanner* obj = new StockSpanner();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="最大跨度问题"><a href="#最大跨度问题" class="headerlink" title="最大跨度问题"></a>最大跨度问题</h1><p>除了可以求解下一个最大元素外，单调栈还能求满足某一条件的<strong>最大跨度</strong>。</p><h2 id="962-最大宽度坡"><a href="#962-最大宽度坡" class="headerlink" title="962. 最大宽度坡"></a>962. 最大宽度坡</h2><p>给定一个整数数组 A，坡是元组 <code>(i, j)</code>，其中 <code>i &lt; j</code> 且 <code>A[i] &lt;= A[j]</code>。这样的坡的宽度为 <code>j - i</code>。找出 A 中的坡的最大宽度，如果不存在，返回 0 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[6,0,8,2,1,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.</span><br></pre></td></tr></table></figure><p>是不是觉得毫无头绪，我刚开始也是这么想的，后来直到看了一个不错的<a href="https://leetcode.cn/problems/maximum-width-ramp/solution/c-962-zui-da-kuan-du-po-ti-jie-dan-diao-5ztod/" target="_blank" rel="noopener">题解</a>。暴力破解能得到答案，但显然会超时，单调栈是如何应用到求最大跨度问题中呢？</p><p>首先来一点点的分析，由于要求解最大跨度，因此存储的肯定为索引。在者，对于 <code>[9,8,1,0,1,9,4,0,4,1]</code> 而言的最大跨度，我们希望在左边找很小的值，在右边找比左边大的值。并且有两个 0，显然第一个 0 能贡献的跨度更大。因此，基于以上两点，我们可以使用栈来存储单调递减序列的而索引，即：<code>[9,8,1,0]</code>，对应的索引是 <code>[0,1,2,3]</code>。如此，满足了找左侧很小值的目标，也满足了不考虑后面的 0。</p><p>之后，我们只要倒序遍历序列，依次和栈顶元素比较大小，如果大于，那么记录跨度并弹栈。随着弹栈的进行，索引会越来越小，也求到了更大的跨度。具体理解一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：[9,8,1,0,1,9,4,0,4,1]</span><br><span class="line">单调递减元素:[9,8,1,0], 对应下标:[0,1,2,3], 严格单调递减栈s:[0,1,2,3]</span><br><span class="line">j=9, nums[j]=1 &gt; nums[s.top()]=nums[3]=0, pos=s.top()=3, pop出3, res=max(res, j-pos)=(0, 9-3)=6</span><br><span class="line">     nums[j]=1 = nums[s.top()]=nums[2]=1, pos=s.top()=2, pop出2, res=max(res, j-pos)=(6, 9-2)=7</span><br><span class="line">     nums[j]=1 &lt; nums[s.top()]=nums[1]=8, 遍历下一个j</span><br><span class="line">j=8, nums[j]=4 &lt; nums[s.top()]=nums[1]=8, 遍历下一个j</span><br><span class="line">     ... </span><br><span class="line">     ...</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure><p>不难写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxWidthRamp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.empty() || nums[stk.top()] &gt; nums[i]) &#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stk.size() &amp;&amp; nums[j] &gt;= nums[stk.top()]) &#123;</span><br><span class="line">                res = max(res, j - stk.top());</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="维持某一状态最长的持续时间"><a href="#维持某一状态最长的持续时间" class="headerlink" title="维持某一状态最长的持续时间"></a>维持某一状态最长的持续时间</h1><p>这个题需要用到一些其他知识，因此和前缀和数组整理到一起了，可以观看下一篇博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;栈有着广泛的应用，比如逆波兰表达式，表达式求值，迷宫问题求解，程序调用等，不过这些问题今天都不涉及哈哈哈哈。关于程序执行期间，各个函数的相互调用使用的调用栈，可以&lt;a href=&quot;https://muyuuuu.github.io/2019/09/22/stack/&quot;&gt;参考这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;单调栈属于栈的具体应用，而非栈这种数据结构的简单使用。此类问题一般用于求解以下场景：&lt;strong&gt;序列中某个元素的下一个最大元素，元素间的最大跨度，维持某一状态持续的最长时间等&lt;/strong&gt;。以序列 &lt;code&gt;[2,1,3,4]&lt;/code&gt; 为例，1 的下一个最大元素就是 3，而不是 4；最大上升的跨度为从 2 到 4，跨越了 2 个数。对于这种问题都可以用单调栈求解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：动态规划</title>
    <link href="https://muyuuuu.github.io/2022/05/16/dp-series/"/>
    <id>https://muyuuuu.github.io/2022/05/16/dp-series/</id>
    <published>2022-05-16T15:51:06.000Z</published>
    <updated>2022-07-11T08:50:32.054Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>动态规划作为算法中较难的部分，还是下定决心慢慢整理。人生建议：遇到太难的动态规划，建议直接放弃。动态规划解题也有技巧，一般而言题目的问题都是：移动最少的次数到达终点。此时我们只需要：</p><ol><li>设置 <code>dp</code> 数组，数组大小一般和输入相同，但细节需要微操。<code>dp[i]</code> 的含义是，到达 <code>i</code> 的最少次数</li><li>对 <code>dp</code> 数组进行初始化，即开始动态规划时，起始所需的次数，一般为 0，不过也有特殊情况</li><li><code>dp</code> 的转移，如何从上一状态计算当前状态</li></ol><p>掌握这三点，一般难度的动态规划是可以做出来的。</p><a id="more"></a><h1 id="一维状态转移"><a href="#一维状态转移" class="headerlink" title="一维状态转移"></a>一维状态转移</h1><h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h2><p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><p>一维的状态转移是较为简单的动态规划。直接动态规划三步走，我们设 <code>dp[i]</code> 表示到达数组第 <code>i</code> 个位置需要的最少次数。第 <code>i</code> 个位置最小次数这个状态 <code>dp[i]</code>，有两种方式得到，要么本身最小，要么由上一个状态 +1 的来，即：<code>dp[i] = min(dp[i], dp[i-1] +1)</code>。</p><p>因此，我们的初始值要为 <code>INT_MAX</code>，因为如果用 0 初始化，<code>dp[i]</code> 始终为 0。我们写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 从 i 开始，能跳到的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums[i]; j++) &#123;</span><br><span class="line">                <span class="comment">// 这些位置的状态</span></span><br><span class="line">                <span class="keyword">if</span> (i + j &lt; n) &#123;</span><br><span class="line">                    dp[i + j] = min(dp[i + j], dp[i] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过这一题，顺便补充一点：动态规划中，$O(n^2)$ 时间复杂度的程序比较常见，不必担心超时。</p><h1 id="多维动态规划"><a href="#多维动态规划" class="headerlink" title="多维动态规划"></a>多维动态规划</h1><p>股票买卖问题是简单的多维动态规划问题，一维动态规划是：<code>dp[i]</code> 表示第 <code>i</code> 步的最优结果，多维动态规划 <code>dp[i][j]</code> 是指第 <code>i</code> 步的第 <code>j</code> 个选择下的最优结果。也就是，多维动态规划会有多种选择情况，注意这里的选择不是状态转移时的选择。而对于股票买卖问题有两种选择，买入或卖出。从简到难来学习下股票买卖问题：</p><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121 买卖股票的最佳时机"></a>121 买卖股票的最佳时机</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p>动态规划三部曲：</p><ul><li><code>dp[i]</code>的含义：我们设 <code>dp[i][0]</code> 表示不持有股票的最大利润，<code>dp[i][1]</code> 表示持有股票时获得的最大利润</li><li>初始化：根据如上的定义，<code>dp[0][0]</code> 表示在最开始没有买入，因此利润为0；<code>dp[0][1]</code> 表示最开始就买入，此时利润为 <code>-prices[0]</code></li><li>状态转移：<code>dp[i][0]</code> 有两种状态来源，要么保持不持有的状态，要么从上一个持有状态卖出。<code>dp[i][1]</code> 同理，要么保持上一个持有状态，要么从不持有股票变成持有股票。</li></ul><p>而最大收益是，在最后时刻卖出了股票。如上所述，我们写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h2><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。返回你能获得的最大利润 。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。</span><br><span class="line">     总利润为 4 + 3 = 7 。</span><br></pre></td></tr></table></figure><p>和上一题不一样的是，这个题可以多次买卖股票，那么动态规划的三部曲哪里不一样了呢？<code>dp[i]</code> 的定义和初始化肯定不会变，那么唯一不同的就是状态转移。</p><ul><li>对于不持有股票，要么继续不持有，要么此刻卖出</li><li>对于持有股票，要么继续不持有，要么买入。但是这里的买入和上一题的是不一样的，上一题的买入是 <code>-prices[i]</code>，也就是本金为 0 的情况下买入；而这个题允许多次买卖，因此买入的时候应该是 <code>dp[i-1][0]-prices[i]</code>，本金为 <code>dp[i-1][0]</code>，也就是买入的股票全部卖出时的收益。</li></ul><p>如上所述，简单的修改程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// 有了本金</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a>714. 买卖股票的最佳时机含手续费</h2><p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] = 1</span><br><span class="line">在此处卖出 prices[3] = 8</span><br><span class="line">在此处买入 prices[4] = 4</span><br><span class="line">在此处卖出 prices[5] = 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</span><br></pre></td></tr></table></figure><p>如上，能推断出是状态转移发生的变化。而且是卖出即不持有股票时需要减去手续费，同理，直接写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 卖出的手续费</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a>309. 最佳买卖股票时机含冷冻期</h2><p>给定一个整数数组 <code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格。​设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li><li>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><p>这次的限制是有冻结时限，对应到转移方程，就是在买入的时候，应该用前天的不持有股票的状态作为本金，不能用昨天的。也就是，买入的 <code>dp[i-1][0] - prices[i]</code> 改为 <code>dp[i-2][0] - prices[i]</code>，处理一下越界的情况即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 越界，要么保留上一个持有股票的状态，要么这一时刻买入</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a>123. 买卖股票的最佳时机 III</h2><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><br></pre></td></tr></table></figure><p>这个题和前面不同的是，开始限制了交易次数。也就是说，我们需要在增加一个状态，来表示第 <code>k</code> 次交易所能获得的最大利润。还是动态规划三部曲：</p><ol><li><code>dp[i][k][0]</code> 表示在第 i 天，交易了 k 次，不持有股票的最大收益；<code>dp[i][k][1]</code> 表示在第 i 天，交易了 k 次，持有股票的最大收益</li><li>对于初始化，<code>dp[0][j][0]</code> 表示在最开始，无论几次交易都不持有股票，收益为 0；<code>dp[0][j][1]</code> 表示在最开始，不管进行了几次交易，手上持有股票，那么收益为 <code>-prices[0]</code>，因为只能买入第一天的股票。</li><li>在状态转移时，如果是不持有股票，那么最大收益可能是继续不持有，或者上一持有状态卖出；而持有股票，如果是最开始交易，那么保留上一时刻的买入状态或重新买入，或者此刻买入。如果不是首次交易，买入的时候，用之间的收益减去买入价格，就是此刻的收益。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                <span class="comment">// base case</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[<span class="number">0</span>][j][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 第 j 次交易不持有，要么继续不持有，要么卖出</span></span><br><span class="line">                    <span class="comment">// 持有到卖出是一次交易，因此 j 不用变</span></span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                    <span class="comment">// 持有时，要么保留持有状态，要么在上一次的交易上继续买入</span></span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                        dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], -prices[i]);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a>188. 买卖股票的最佳时机 IV</h2><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 2, prices = [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span><br></pre></td></tr></table></figure><p>和上一题一样了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], -prices[i]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i][j<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="打家劫舍问题"><a href="#打家劫舍问题" class="headerlink" title="打家劫舍问题"></a>打家劫舍问题</h1><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><ul><li>这个是单状态的状态转移，当前状态有两种选择，要么偷当前屋子，要么偷上上个屋子，进行转移即可</li><li>因此初始化状态就是 <code>dp[0]=nums[0], dp[1]=max(dp[0], nums[1])</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>] + nums[i], dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a>213. 打家劫舍 II</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><ul><li>和上一题一样，既然是首尾相连的村庄，也就是首尾不能同时抢</li><li>既然如此，我们划分数组，第一个数组是 <code>nums[0,,,n-1]</code>，第二个数组是 <code>nums[1,,,n]</code>，计算这两个数组的最大值，选择其中最大的即可</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxRob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; t1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = t1.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = t1[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max(t1[<span class="number">0</span>], t1[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>] + t1[i], dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t1&#123;nums.begin(), nums.end() - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t2&#123;nums.begin() + <span class="number">1</span>, nums.end()&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(maxRob(t1), maxRob(t2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a>337. 打家劫舍 III</h2><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code>。除了 <code>root</code> 之外，每栋房子有且只有一个「父」房子与之相连。一番侦察之后，聪明的小偷意识到这个地方的所有房屋的排列类似于一棵二叉树。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。给定二叉树的 <code>root</code> 。返回在不触动警报的情况下 ，小偷能够盗取的最高金额 。</p><p><img data-src="https://s1.ax1x.com/2022/06/12/X2yQG4.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,2,3,null,3,null,1]</span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</span><br></pre></td></tr></table></figure><p>这个某种程度上算是二叉树的后续遍历问题。</p><ul><li>对于某个节点，当前的最大抢劫收益是：要么抢当前节点，此时就不能抢孩子节点；要么抢孩子节点；要么不抢孩子节点，也不抢当抢节点</li><li>我们可以看到，节点的状态取决于孩子节点，这样，我们能得到两个信息，第一个信息是需要给每个孩子节点返回状态，状态就是：当前节点的最大抢劫收益，第二个信息是需要先有孩子节点的状态，才能确定当前节点的状态，因此需要后续遍历</li><li>定义一个状态，表示抢或不抢所带来的最大收益，如果遍历期间越界，那么收益就是 0，按照前面说的三种状态进行转移即可</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">node <span class="title">maxrob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> a = maxrob(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> b = maxrob(root-&gt;right);</span><br><span class="line">        <span class="comment">// 抢当前节点</span></span><br><span class="line">        <span class="keyword">int</span> s = root-&gt;val + a.n + b.n;</span><br><span class="line">        <span class="comment">// 叶子节点的抢或不抢选最大值</span></span><br><span class="line">        <span class="keyword">int</span> n = max(a.s, a.n) + max(b.s, b.n);</span><br><span class="line">        <span class="comment">// 三种状态选最大值</span></span><br><span class="line">        <span class="keyword">return</span> &#123;s, n&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> a = maxrob(root);</span><br><span class="line">        <span class="comment">// 抢或不抢选最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(a.s, a.n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h1><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a>300. 最长递增子序列</h2><p>给你一个整数数组 <code>nums</code>，找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p>子序列与子串不同，子序列的元素之间可以不连续，子串的元素之间必须连续。在了解基本问题后，我们进行动态规划：</p><ul><li>设 <code>dp[i]</code> 表示第 <code>i</code> 个位置处的最长递增子序列长度。且递增子序列，取决于两个字符的大小关系</li><li>因此要计算 <code>dp[i]</code>，就必须要知道 <code>i-1</code> 处的最大长度，以及 <code>nums[i-1]</code> 和 <code>nums[i]</code> 的大小关系</li><li>因此我们需要 $O(n^2)$ 的算法，<code>j</code> 指针指向的位置小于 <code>i</code> 指针，判断 <code>nums[j]</code> 和 <code>nums[i]</code> 的大小关系，并得到 <code>dp[i]</code> 的值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                    dp[i] = max(dp[i], <span class="number">1</span>+dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">-12</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : dp) &#123;</span><br><span class="line">            maxn = max(i, maxn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a>354. 俄罗斯套娃信封问题</h2><p>给你一个二维整数数组 <code>envelopes</code>，其中 <code>envelopes[i] = [wi, hi]</code>，表示第 <code>i</code> 个信封的宽度和高度。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。请计算最多能有多少个信封能组成一组俄罗斯套娃信封（即可以把一个信封放到另一个信封里面）。注意：不允许旋转信封。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]</span><br><span class="line">输出：3</span><br><span class="line">解释：最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</span><br></pre></td></tr></table></figure><p>这个问题很有趣，也算是一种最长递增子序列问题。只不过需要预先的排序处理：</p><ul><li>首先按照宽度进行升序排列</li><li>对于宽度相同的信封，按照高度进行降序排列</li><li>针对高度，求得的最长递增子序列，就是能套娃的最大数量。因为宽度已经默认升序，而高度的最长递增子序列也是升序，即信封的最大数量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] != b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">        sort(envelopes.begin(), envelopes.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> n = envelopes.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : dp) &#123;</span><br><span class="line">            maxn = max(maxn, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p>动态规划三部曲：</p><ul><li>设 <code>dp[i]</code> 表示数组的第 <code>i</code> 个位置处，最大的子数组和</li><li>初始化：<code>dp[0]=nums[0]</code></li><li>状态转移：<code>dp[i]</code> 要么来自上一个子数组，要么是当前数组元素重新开始，<code>dp[i]=max(dp[i-1]+nums[i], nums[i])</code></li></ul><p>但是有一个细节需要注意，在遍历 <code>dp</code> 求最大值的时候，如果我们此时不知道最小值是多少，就用 <code>dp[0]</code> 作为最小值，不然的话容易计算错误。比如数组是 <code>[-3,-4,-5]</code>，我们用 <code>-1</code> 作为最小值去选择最大值是错误的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>] + nums[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">int</span> maxn = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : dp) &#123;</span><br><span class="line">            maxn = max(maxn, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回 0。一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，<code>ace</code> 是 <code>abcde</code> 的子序列，但 <code>aec</code> 不是 <code>abcde</code> 的子序列。两个字符串的公共子序列是这两个字符串所共同拥有的子序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p>对于这种基于两个输入求解一个输出，通常要涉及二维的动态规划：</p><ul><li><code>dp[i][j]</code> 表示 <code>text1[0,...,i]</code> 和 <code>text2[0,...,j]</code> 的最长公共子串的长度</li><li>那么进行初始化，最开始的时候，默认不存在最长公共子串，因此 <code>dp</code> 数组的取值都是 0。<code>dp[0][j]</code> 表示 <code>text1[0]</code> 和 <code>text2</code> 的最长公共子串的长度，因此只要 <code>text1[0]==text2[j]</code>，那么 <code>dp[0][j,...,n]</code> 这些取值都为 1。同理可以得到 <code>dp[i][0]</code> 的值</li><li>开始状态转移，这里需要注意的是，无论 <code>text1[i]</code> 是否与 <code>text2[j]</code> 相等，都需要计算 <code>dp[i][j]</code>，假如 <code>asdf</code> 和 <code>asdg</code>，在 <code>f,g</code> 处，最长的公共子串仍然是 3。</li><li>而 <code>dp[i][j]</code> 的状态有 3 种选择，<code>text1[i]==text[j]</code>，此时 <code>dp[i][j]=dp[i-1][j-1]+1</code>；否则就在 <code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code> 这两者之间选择一个最大值即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.size(), n = text2.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[<span class="number">0</span>] == text2[i]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                    dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text2[<span class="number">0</span>] == text1[i]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; m; j++)</span><br><span class="line">                    dp[j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 注意</span></span><br><span class="line">                <span class="keyword">int</span> a = text1[i] == text2[j] ? dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span> : dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">int</span> b = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                dp[i][j] = max(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数。你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)</span><br><span class="line">rorse -&gt; rose (删除 &apos;r&apos;)</span><br><span class="line">rose -&gt; ros (删除 &apos;e&apos;)</span><br></pre></td></tr></table></figure><p>当时看到这个题目的时候，我是晕晕的不知如何解决，直到看了答案，还是动态规划三步走吧：</p><ul><li>前面我们知道，对于这种求两种字符串的状态，需要设置 <code>dp[i][j]</code>，表示从 <code>word1[i]</code> 到 <code>word2[j]</code> 的最小编辑距离</li><li>初始化：再明确 <code>dp[i][j]</code> 的定义后，需要进行简单的初始化。如下所示，当 <code>word1[0] == word2[i]</code> 时，我们只需要保留相同的元素，插入其他元素即可，此时可以少修改一个。否则，修改的次数就是 <code>word2</code> 的长度，分别是替换与插入。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (word1[<span class="number">0</span>] == word2[i]) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>状态转移。如果 <code>word1[i]==word2[j]</code>，说明此时不用进行任何操作，那么 <code>dp[i][j]</code> 所代表的次数就和 <code>dp[i-1][j-1]</code> 相同。如果 <code>word1[i] != word2[j]</code>，就说明此时要么进行插入，要么进行删除，要么进行替换，在三者中选择一个最小的代价。这里我们需要注意的是：对于任何 <code>dp[i][j]</code>，都是以 <code>dp[i-1][j-1]</code> 为基础出发的。</li></ul><p><code>dp[i][j-1]</code> 为 <code>word1</code> 的前 <code>i</code> 个字符和 <code>word2</code> 的前 <code>j - 1</code> 个字符编辑距离的子问题。即在 <code>dp[i-1][j-1]</code> 的基础上 <code>i</code> 增加了，表示我们需要在 <code>word1</code> 的末尾添加了一个相同的字符，那么 <code>dp[i][j]</code> 最小可以为 <code>dp[i][j-1] + 1</code>；</p><p><code>dp[i-1][j]</code> 为 <code>word1</code> 的前 <code>i - 1</code> 个字符和 <code>word2</code> 的前 <code>j</code> 个字符编辑距离的子问题。即在 <code>dp[i-1][j-1]</code> 的基础上 <code>j</code> 增加了，表示我们删除 <code>word1</code> 末尾的字符，那么 <code>dp[i][j]</code> 最小可以为 <code>dp[i-1][j] + 1</code>；</p><p><code>dp[i-1][j-1]</code> 为 <code>word1</code> 前 <code>i - 1</code> 个字符和 <code>word2</code> 的前 <code>j - 1</code> 个字符编辑距离的子问题。即对于 <code>word2</code> 的第 <code>j</code> 个字符，我们修改 <code>word1</code> 的第 <code>i</code> 个字符使它们相同，那么 <code>dp[i][j]</code> 最小可以为 <code>dp[i-1][j-1] + 1</code>。特别地，如果 <code>word1</code> 的第 <code>i</code> 个字符和 <code>word2</code> 的第 <code>j</code> 个字符原本就相同，那么我们实际上不需要进行修改操作。在这种情况下，<code>dp[i][j]</code> 最小可以为 <code>dp[i-1][j-1]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[<span class="number">0</span>] == word2[i]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = i;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                    dp[<span class="number">0</span>][i] = i;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[<span class="number">0</span>][i] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i] == word2[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = i;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                    dp[i][<span class="number">0</span>] = i;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i] == word2[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> a = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>, dp[i][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">int</span> b = min(a, dp[i<span class="number">-1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                    dp[i][j] = min(a, b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h2><p>给你一个只包含正整数的非空数组 <code>nums</code>。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure><p>假设数组的总和是 <code>2sum</code>，那么一半就是 <code>sum</code>。这是一个背包问题，意思是现在有 <code>nums</code> 个物品，每个物品的重量是 <code>nums[i]</code>，能不能将 <code>nums</code> 中的若干个物品装入一个背包，使背包内物品的重量为 <code>sum</code>。由于 <code>nums[i]</code> 只能使用一次，因此这是一个 <code>0-1</code> 背包问题。</p><ul><li>我们设 <code>dp[i][j]</code> 表示使用前 <code>i</code> 个物品，装入质量为 <code>j</code> 的背包能否装下。这也是一般背包问题的 <code>dp</code> 数组创建方法。因此最后我们只需要判断 <code>dp[n-1][sum]</code> 即可。</li><li>初始化：背包可以选择不装入任何物体，因此 <code>dp[0,...,n][0]</code> 的取值为 1，表示有 1 中方法使得背包中物体的重量是 0，即什么都不装。</li><li>状态转移：对于物品 <code>nums[i]</code>，如果当前背包所允许的重量小于 <code>nums[i]</code>，就说明当前物体不能放进来，因此 <code>dp[i][j]</code> 就等于 <code>dp[i-1][j]</code>，表示当前能装下的重量等于：同等背包的大小下，少装一个物体的状态，继承之前的结果。</li><li>否则，<code>dp[i][j]</code> 就等于 <code>dp[i-1][j]</code> 和 <code>dp[i-1][j - nums[i]]</code> 的最大值，选择一个最大值表示装或者不装，前者表示不装当前物体，后者表示装当前物体，既然要装当前物体，就需要腾出一些空间来，而腾出的空间是 <code>j-nums[i]</code>。在这个限制下，也就是能保证装入新物体的前提下，腾出来的空间最少，这样可以装的物体最多。</li></ul><p>还有一些细节需要注意，因为背包问题需要访问到 <code>sum</code>，因此创建 <code>dp</code> 数组时需要 <code>sum</code> 个元素，也就是需要 <code>+1</code>。至于为什么都是 <code>dp[i-1]</code>，因为装 <code>nums[i]</code> 之前，<code>nums[i]</code> 还没进入背包，因此只能使用装了前 <code>i-1</code> 个物品的背包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(sum + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="comment">// 不装物品，方案为 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">                <span class="comment">// 装不下，就选择不装</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 装得下，选择装和不装的最大状态</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j - nums[i<span class="number">-1</span>]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a>518. 零钱兑换 II</h2><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。假设每一种面额的硬币有无限个。示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = <span class="number">5</span>, coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line"><span class="number">5</span>=<span class="number">5</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span>+<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="number">5</span>=<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>当一个物品不被限制次数选择时，就说明这是一个完全背包问题。对于 <code>0-1</code> 背包问题，取值是两者取最大，表示只能选择一个；对于完全背包问题，取值是两者之和，表示两种选择我都要。剩下的和 <code>0-1</code> 背包完全一致了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(amount + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; coins[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 我全都选</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j - coins[i<span class="number">-1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来说两个细节吧。</p><ul><li>状态转移的时候，<code>i</code> 和 <code>j</code> 都是从 1 开始的。对于 <code>i</code> 遍历的所有物品，0 表示没有物品，因此没必要进行转移，状态就是初始设置的 0。对于 <code>j</code> 遍历的所有背包，0 同样表示不选择物品，初始化状态已经预设且始终为 1。</li><li>对于选最大值的情景，<code>0-1</code> 背包问题的转移方程：<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j - nums[i-1]]);</code>，完全背包问题的转移方程：<code>dp[i][j] = max(dp[i-1][j], dp[i][j - nums[i-1]]);</code>。区别在于：<code>dp[i-1][j - nums[i-1]]</code> 和 <code>dp[i][j - nums[i-1]]</code>。可以这么理解，对于 <code>0-1</code> 背包问题，一个物品只能选一次，因此在选第 <code>i</code> 个物品时，上一个选择的物品只能是第 <code>i-1</code> 个；对于完全背包问题，一个物品可以选很多次，因此在选择第 <code>i</code> 个物品时，上一个选择的物品仍然能是第 <code>i</code> 个。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划作为算法中较难的部分，还是下定决心慢慢整理。人生建议：遇到太难的动态规划，建议直接放弃。动态规划解题也有技巧，一般而言题目的问题都是：移动最少的次数到达终点。此时我们只需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置 &lt;code&gt;dp&lt;/code&gt; 数组，数组大小一般和输入相同，但细节需要微操。&lt;code&gt;dp[i]&lt;/code&gt; 的含义是，到达 &lt;code&gt;i&lt;/code&gt; 的最少次数&lt;/li&gt;
&lt;li&gt;对 &lt;code&gt;dp&lt;/code&gt; 数组进行初始化，即开始动态规划时，起始所需的次数，一般为 0，不过也有特殊情况&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp&lt;/code&gt; 的转移，如何从上一状态计算当前状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;掌握这三点，一般难度的动态规划是可以做出来的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：区间问题</title>
    <link href="https://muyuuuu.github.io/2022/05/12/interval-algo/"/>
    <id>https://muyuuuu.github.io/2022/05/12/interval-algo/</id>
    <published>2022-05-12T15:45:46.000Z</published>
    <updated>2022-05-20T14:41:59.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>算法继续整理系列之区间问题。这类问题可以总结或者变化为：给定多个区间，求满足覆盖范围的最小相交区间的数量。一般而言都是：题目给定一个乱序的区间。我们需要对区间进行排序调整和统计结果，来满足题目条件。<strong>其中变化的部分只有如何处理相交区间</strong>，因此整理一个通用的算法模板。</p><a id="more"></a><h1 id="区间固定"><a href="#区间固定" class="headerlink" title="区间固定"></a>区间固定</h1><h2 id="986-固定区间的交集"><a href="#986-固定区间的交集" class="headerlink" title="986. 固定区间的交集"></a>986. 固定区间的交集</h2><p>先看一道简单的题目，这个题目中我们不需要对区间进行排序调整，因此相对简单一些。</p><p><img data-src="/2022/05/12/interval-algo/interval1.png" alt></p><p>这个题目很简单，我们只需要按照顺序遍历区间，处理相交部分：</p><ol><li>判断两个区间是否相交，如果不相交，右侧区间靠前的那一组，索引向后移动</li><li>如果相交，取出交集，右侧区间靠前的那一组，索引向后移动</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">intervalIntersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; firstList, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; secondList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; firstList.size() &amp;&amp; j &lt; secondList.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> l1 = firstList[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r1 = firstList[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> l2 = secondList[j][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r2 = secondList[j][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 没有交集</span></span><br><span class="line">            <span class="keyword">if</span> (l1 &gt; r2 || r1 &lt; l2) &#123;</span><br><span class="line">                <span class="comment">// r2 比较小，为了尽快和 l1 相交，需要向后移动</span></span><br><span class="line">                <span class="keyword">if</span> (l1 &gt; r2) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> a = max(l1, l2);</span><br><span class="line">            <span class="keyword">int</span> b = min(r1, r2);</span><br><span class="line">            <span class="comment">// 交集</span></span><br><span class="line">            res.push_back(&#123;a, b&#125;);</span><br><span class="line">            <span class="keyword">if</span> (r2 &gt; r1) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="区间可变"><a href="#区间可变" class="headerlink" title="区间可变"></a>区间可变</h1><p>代表题目：1288 删除覆盖区间，56 合并区间，452 射箭引爆气球，1024 视频拼接 和 435 无重叠区间。</p><h2 id="1288-删除覆盖区间"><a href="#1288-删除覆盖区间" class="headerlink" title="1288. 删除覆盖区间"></a>1288. 删除覆盖区间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[3,6],[2,8]]</span><br><span class="line">输出：2</span><br><span class="line">解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。</span><br></pre></td></tr></table></figure><p>题目意思比较明确，删除大区间覆盖的小区间，那么如何统计被覆盖的区间呢？我们看来看图：</p><p><img data-src="/2022/05/12/interval-algo/cover.png" alt></p><p>如果想统计一个区间覆盖更多的区间，乱序状态下用暴力算法肯定是可以破解的，大不了一个一个统计。但是如果我们对区间排序一下，按照左侧区间升序或者右侧区间降序，问题会简单很多：</p><p><img data-src="/2022/05/12/interval-algo/sort.png" alt></p><p>以按照左侧区间排序为例，排序结果如图 (c) 中所示的三种情况：</p><ul><li>如果是<strong>覆盖的相交情况</strong>，统计数量</li><li>如果<strong>相交的情况</strong>，表示上面区间没有能力覆盖下面的区间了，不再考虑上面的区间，开始往下移动</li><li>如果没有重叠也就是不相交，同样表示上面区间没有能力覆盖下面的区间了，不再考虑上面的区间</li></ul><p>图(a)是按照左侧的区间升序，我们只需要顺序遍历区间，依次判断上面的区间的右侧值是否能覆盖下面的区间的右侧值即可，因为左侧区间已经排好序了，是肯定能覆盖的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> r = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 相交时的处理</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt;= intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有覆盖，向后移动</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.size() - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同理，图(b)是我们按照右侧区间降序排列，此时统计上一个左侧区间能覆盖下一个左侧区间的数量即可，因为右侧区间肯定能覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] == b[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> l = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l = intervals[i][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.size() - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p>至此，leetcode 的第 56 题区间合并也可以轻松写出程序。思路和覆盖是一样的：</p><ul><li>如果上一个区间覆盖了下一个区间，那么合并区间，<strong>也就是相交区间的处理</strong></li><li>如果上一个区间没有覆盖下一个区间，那么从头开始</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> r = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 相交处理，合并</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                l = min(l, intervals[i][<span class="number">0</span>]);</span><br><span class="line">                r = max(r, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不能覆盖，先把之前的结果添加进来</span></span><br><span class="line">                <span class="comment">// 并重新更新区间</span></span><br><span class="line">                res.push_back(&#123;l, r&#125;);</span><br><span class="line">                l = intervals[i][<span class="number">0</span>];</span><br><span class="line">                r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一组没有被添加进来</span></span><br><span class="line">        res.push_back(&#123;l, r&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">10</span>,<span class="number">16</span>],[<span class="number">2</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">12</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：气球可以用<span class="number">2</span>支箭来爆破:</span><br><span class="line">-在x = <span class="number">6</span>处射出箭，击破气球[<span class="number">2</span>,<span class="number">8</span>]和[<span class="number">1</span>,<span class="number">6</span>]。</span><br><span class="line">-在x = <span class="number">11</span>处发射箭，击破气球[<span class="number">10</span>,<span class="number">16</span>]和[<span class="number">7</span>,<span class="number">12</span>]。</span><br></pre></td></tr></table></figure><p>只需要对区间排序，每次<strong>统计相交区间</strong>的交集，直到交集没有重叠时，射箭数量需要加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        sort(points.begin(), points.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> l = points[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> r = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; points[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                l = points[i][<span class="number">0</span>];</span><br><span class="line">                r = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 相交处理，有相交区间，缩小相交区间</span></span><br><span class="line">                l = max(l, points[i][<span class="number">0</span>]);</span><br><span class="line">                r = min(r, points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h2><p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 移除 [<span class="number">1</span>,<span class="number">3</span>] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p>注意，这个题目和之前的题目不太相同，具体体现在<strong>相交时的处理</strong>，而相交分为覆盖和非覆盖：</p><ol><li>如果上一个区间覆盖了下面的区间，说明上面的区间太大了。由于我们要删除最少数量的区间，因此首先考虑删除覆盖更广的区间</li><li>如果上一个区间和下一个区间相交，此时不能像之前的合并、相交一样，直接移动到下一个区间或处抛弃上面的区间。因为区间在排序后，如果上一个区间和第二个区间相交，上一个区间和第三个区间不相交，此时我们要删除第二个区间，而不是上一个和第三个区间。因此，相交时我们应该保留上一个区间。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> r = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 覆盖，往下移动</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt;= intervals[i][<span class="number">0</span>] &amp;&amp; r &gt;= intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">                l = intervals[i][<span class="number">0</span>];</span><br><span class="line">                r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r &gt; intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// 相交，不移动，保留上一个区间</span></span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不相交，往后移动，看看后面有多少相交的要处理</span></span><br><span class="line">                r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a>1024. 视频拼接</h2><p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 time 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, time]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">选中 [0,2], [8,10], [1,9] 这三个片段。</span><br><span class="line">然后，按下面的方案重制比赛片段：</span><br><span class="line">将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。</span><br><span class="line">现在手上的片段为 [0,2] + [2,8] + [8,10]，而这些覆盖了整场比赛 [0, 10]。</span><br></pre></td></tr></table></figure><p>从题面上我们能看出来：在多个片段相交的基础上，我们尽可能选择时间长的片段，这样才能使用的碎片最少。同样，重点就在于：<strong>相交时，我们要选择最长的片段</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; clips, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        sort(clips.begin(), clips.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, i = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从起点开始</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; clips.size() &amp;&amp; clips[i][<span class="number">0</span>] &lt;= l) &#123;</span><br><span class="line">            <span class="comment">// 碎片部分和起点相交，选择片段最长的</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; clips.size() &amp;&amp; clips[i][<span class="number">0</span>] &lt;= l) &#123;</span><br><span class="line">                r = max(clips[i][<span class="number">1</span>], r);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= time)</span><br><span class="line">                <span class="keyword">return</span> cnt;</span><br><span class="line">            <span class="comment">// 最长的片段，是下个片段的起点</span></span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>更像是把 labuladong 上区间的题目整理到了一起，写出自己风格的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法继续整理系列之区间问题。这类问题可以总结或者变化为：给定多个区间，求满足覆盖范围的最小相交区间的数量。一般而言都是：题目给定一个乱序的区间。我们需要对区间进行排序调整和统计结果，来满足题目条件。&lt;strong&gt;其中变化的部分只有如何处理相交区间&lt;/strong&gt;，因此整理一个通用的算法模板。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的 this 和 Python 中的 self</title>
    <link href="https://muyuuuu.github.io/2022/05/12/Cpp-this-and-python-self/"/>
    <id>https://muyuuuu.github.io/2022/05/12/Cpp-this-and-python-self/</id>
    <published>2022-05-12T15:10:54.000Z</published>
    <updated>2022-05-16T15:30:41.823Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前一直好奇 <code>C++</code> 中的 <code>this</code> 和 <code>python</code> 中的 <code>self</code> 到底是什么关系，为什么 <code>C++</code> 要显式的写出来，<code>python</code> 则不需要。顺便深入了解一下 <code>this</code>。</p><a id="more"></a><h2 id="self"><a href="#self" class="headerlink" title="self"></a>self</h2><p><code>python</code> 当对象调用类中的函数的时候，系统会自动把当前对象传入函数，且参数就是第一个 <code>self</code>，不过可以用其他 <code>token</code> 代替 <code>self</code>。因此在定义的时候，需要声明 <code>self</code> 这个参数，调用时，却不需要手动传入对象。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x 接收 12 这个参数</span></span><br><span class="line">A.test(<span class="number">12</span>)</span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># x 接收 a 这个对象</span></span><br><span class="line">a.test()</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(mine, x)</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mine 接收 1，x 接收 12</span></span><br><span class="line">A.test(<span class="number">1</span>, <span class="number">12</span>)</span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># mine 接收 a，x 接收 12</span></span><br><span class="line">a.test(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>对于 <code>C++</code> 而言，每个对象都要操作自己内部的数据，如何知道哪里的数据是自己的内部数据，而不会发生调用对象 <code>A</code>，而修改了对象 <code>B</code> 的数据呢？答案是 <code>this</code> 指针。</p><p><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针，被隐含地声明为: <code>ClassName \*const this</code>，也就是地址不能改变，这意味着不能给 <code>this</code> 指针赋值；在类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）。对象被创建以后才会给 <code>this</code> 赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，且 <code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址。</p><p>当对象调用类中的非静态函数时，自动向它传递一个隐含的 <code>this</code> 指针参数，该参数是一个指向这个成员函数所在的对象的指针，在函数体内作为局部变量，且每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</p><p>总结一下的话就是：</p><ul><li><code>this</code> 是关键字而 <code>self</code> 不是。</li><li><code>C++</code> 类内的函数默认都是给对象调用的，而 <code>python</code> 不是。</li><li><code>python</code> 中的 <code>self</code> 还可以用于声明和创建变量，而 <code>C++</code> 在类中声明和创建则不需要。</li><li>定义、传参和调用中，<code>this</code> 参数始终隐藏，而 <code>self</code> 不是。</li><li>两者有相同点，在类的函数内部可以显式的使用它，来调用类内的变量和函数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直好奇 &lt;code&gt;C++&lt;/code&gt; 中的 &lt;code&gt;this&lt;/code&gt; 和 &lt;code&gt;python&lt;/code&gt; 中的 &lt;code&gt;self&lt;/code&gt; 到底是什么关系，为什么 &lt;code&gt;C++&lt;/code&gt; 要显式的写出来，&lt;code&gt;python&lt;/code&gt; 则不需要。顺便深入了解一下 &lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
      <category term="Python" scheme="https://muyuuuu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的 static</title>
    <link href="https://muyuuuu.github.io/2022/05/12/cpp-static/"/>
    <id>https://muyuuuu.github.io/2022/05/12/cpp-static/</id>
    <published>2022-05-12T13:54:28.000Z</published>
    <updated>2022-05-12T15:53:43.800Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前对 <code>static</code> 的理解仅限于：在类中声明这种类型的变量，可以通过这个变量知道这个类被创建了多少个对象。但是前些日子刷 <code>leetcode</code> 的时候，发现类中自定义的 <code>cmp</code> 函数如果不是 <code>static</code> 类型，就无法被类内的 <code>sort</code> 函数识别。所以今天来一探究竟。</p><a id="more"></a><h1 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h1><p>其实 C 语言中也有 <code>static</code> 这个关键字，在全局区分配内存，或者说可以理解为全局变量，来回顾一下：</p><ol><li>在全局区分配内存，自动初始化为 0，注：全局区就是静态区</li><li>在声明的整个文件是可见的</li><li>不会因子函数的退出而被释放空间，即子函数被执行完成初始化后，之后的调用不会再初始化，但作用域是局部的</li><li>修饰普通函数，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li></ol><p>全局变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    sub_func();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> test;</span><br><span class="line">    test += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无法访问 test</span></span><br><span class="line">    sub_func(); <span class="comment">// 1</span></span><br><span class="line">    sub_func(); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="static-成员变量"><a href="#static-成员变量" class="headerlink" title="static 成员变量"></a>static 成员变量</h2><ol><li>这个类的所有对象都可以访问静态成员变量，一个对象修改，其他对象也会改变。说高级一些，不随对象创建而分配内存，不随对象销毁而释放内存</li><li>存储在全局区</li><li>必须类外初始化</li><li>可以通过类名访问</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">    A()&#123;</span><br><span class="line">        A::num += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 类名访问</span></span><br><span class="line">        A::num += a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类声明的外部初始化</span></span><br><span class="line"><span class="keyword">int</span> A::num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; A::num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">    b.increase(<span class="number">18</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; A::num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><ol><li>静态成员函数仅可以访问静态成员、函数；不能访问非静态成员、函数</li><li>非静态成员函数可以任意访问静态成员、函数</li><li>不需要 <code>this</code> 指针的额外操作</li><li>可以通过类名访问</li></ol><p>来看一个 <code>static</code> 的成员函数，顺便解答本文开始的疑问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">auto</span> <span class="title">get_num</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 错误，不能访问非 static 变量</span></span><br><span class="line">        <span class="comment">// 毕竟全局区不能访问堆栈区</span></span><br><span class="line">        <span class="comment">// return a + A::num;</span></span><br><span class="line">        <span class="keyword">return</span> A::num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不加 static</span></span><br><span class="line">    <span class="comment">// 错误：对非静态成员函数‘bool A::cmp(int&amp;, int&amp;)’的使用无效</span></span><br><span class="line">    <span class="comment">// 因为 sort 这个函数是全局的，找不到类内的 cmp</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(arr.begin(), arr.end(), cmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类声明的外部初始化</span></span><br><span class="line"><span class="keyword">int</span> A::num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    a.sort(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : arr) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title=":: 扩展"></a><code>::</code> 扩展</h2><p>上面写了很多 <code>::</code>，江湖人称范围解析运算符，顺手总结一下：</p><ol><li><code>::variable</code>，全局作用域符，作用域是全局空间，如 <code>::isspace</code></li><li><code>class::variable</code>，某个类的作用域范围</li><li><code>namespace::variable</code>，某个<a href="https://muyuuuu.github.io/2021/06/20/cpp-namespace/">命名空间</a>的作用域范围。重点是，<code>static</code> 声明的链接性为内部静态变量的东西，可以使用未命名的 <code>namespace</code> 代替。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前对 &lt;code&gt;static&lt;/code&gt; 的理解仅限于：在类中声明这种类型的变量，可以通过这个变量知道这个类被创建了多少个对象。但是前些日子刷 &lt;code&gt;leetcode&lt;/code&gt; 的时候，发现类中自定义的 &lt;code&gt;cmp&lt;/code&gt; 函数如果不是 &lt;code&gt;static&lt;/code&gt; 类型，就无法被类内的 &lt;code&gt;sort&lt;/code&gt; 函数识别。所以今天来一探究竟。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>从 python 中的垃圾回收回顾下内存碎片化</title>
    <link href="https://muyuuuu.github.io/2022/05/03/python-gc/"/>
    <id>https://muyuuuu.github.io/2022/05/03/python-gc/</id>
    <published>2022-05-03T15:46:01.000Z</published>
    <updated>2022-05-06T15:18:54.117Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不出意外的话，这应该是 <code>python</code> 复习的最后一部分了，之前写 <code>python</code> 的时候，一般是在实践中积累一些常见的用法而后系统的学习，比如生成器装饰器、高级数据结构、各种工具库乃至 <code>__init__.py</code> 等细节。但 <code>python</code> 帮开发者自动进行了垃圾回收，所以一直没涉足这个领域，今天来了解一下 <code>python</code> 中垃圾回收的三种机制：引用计数、标记清除和分代回收。</p><a id="more"></a><h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><p>引用计数是 <code>python</code> 中默认使用的垃圾回收方法，思想也比较简单，每个对象有一个字段来记录对象被引用的次数，如果对象引用次数是 0，那么这个对象就会被回收并释放空间。优势是想法简单容易实现，能够处理对象创建、引用、传参、被存储至容器等引用计数增加的场景，以及 <code>del</code> 显式删除、对象别名被赋予新对象、离开作用域、容器被销毁等计数器减少的场景。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This Obj Address: &#123;&#125;"</span>.format(id(self)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obj_ref_count</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">"Obj Ref Count: &#123;&#125;"</span>.format(sys.getrefcount(obj)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># create</span></span><br><span class="line">a = Demo()</span><br><span class="line">print(sys.getrefcount(a)) <span class="comment"># output 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create</span></span><br><span class="line">a = Demo()</span><br><span class="line">obj_ref_count(a) <span class="comment"># output 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ref</span></span><br><span class="line">b = a</span><br><span class="line">obj_ref_count(a) <span class="comment"># output 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># change ref</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">obj_ref_count(a) <span class="comment"># output 4</span></span><br></pre></td></tr></table></figure><p>这里的引用次数为 4 是因为创建、函数调用堆栈帧、参数、<code>sys</code> 调用累积得到的，小缺点就是需要开辟额外的空间来维护<del>这仿佛是废话</del>，主要的缺点是不能处理循环引用问题。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> _ctypes</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.child = <span class="literal">None</span></span><br><span class="line">        print(<span class="string">"This Obj Address: &#123;&#125;"</span>.format(id(self)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obj_ref_count</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">"Obj Ref Count: &#123;&#125;"</span>.format(sys.getrefcount(obj)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Loop &#123;&#125;"</span>.format(i + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    a = Demo()</span><br><span class="line">    b = Demo()</span><br><span class="line"></span><br><span class="line">    obj_ref_count(a)</span><br><span class="line">    obj_ref_count(b)</span><br><span class="line"></span><br><span class="line">    a.child = b</span><br><span class="line">    b.child = a</span><br><span class="line"></span><br><span class="line">    obj_ref_count(a)</span><br><span class="line">    obj_ref_count(b)</span><br><span class="line"></span><br><span class="line">    a_addr = id(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> a</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 引用次数为 5，没回收，内存泄漏</span></span><br><span class="line">    a = _ctypes.PyObj_FromPtr(int(a_addr))</span><br><span class="line">    obj_ref_count(a)</span><br></pre></td></tr></table></figure><p>上述的程序存在循环引用问题，如果去掉循环引用的部分，我们会发现每个循环创建对象的地址都是一样的，说明之前的对象经过 <code>del</code> 之后会被回收。而如果增加循环引用的语句，每个循环都会创建新的对象，也就是垃圾没有被回收。</p><h1 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h1><p>标记清除顾名思义，首先给所有的活动对象打上标记，然后清除没有被标记的非活动对象。所以问题转移为：如何判断对象是活动的？</p><p><code>python</code> 中的对象通过引用连接在一起构成一个有向图，对象是图中的节点，引用关系就是有向边。从根对象出发，沿着有向边遍历对象，如果能到达这个节点，那么这个节点就是活动对象，否则就是非活动对象。如下图所示。</p><p><img data-src="https://s1.ax1x.com/2022/05/06/OKT1UK.gif" alt></p><p>这个方法主要来解决前文提到的循环引用问题，也可以扩展到 <code>list</code>、<code>dict</code> 和 <code>tuple</code> 等容器对象，因为数值、字符串等字面常量不会被循环引用。</p><p>虽然能清除循环引用的对象，但是需要扫描整个堆内存，这可能只有一小部分非活动对象。而且当这个算法启动去清除垃圾时，程序会挂起运行，因为这两者显然不能同时执行。</p><h2 id="标记清除与操作系统"><a href="#标记清除与操作系统" class="headerlink" title="标记清除与操作系统"></a>标记清除与操作系统</h2><p>标记清除容易导致内存碎片化。非活动对象可能位于内存的不同位置，当执行这个算法后，这些对象被释放，就导致了内存的不同位置空缺出现外碎片问题，但没有大单位的可用内存。而内存碎片化也是操作系统中的常见问题，导致内存利用率不高。</p><p><img data-src="https://s1.ax1x.com/2022/05/06/OK7kqI.jpg" alt></p><p>既然说到了内存碎片问题，就来回顾一下大三学过的操作系统，一般解决方法有连续分配方案和离散分配方案，对于连续分配方案：</p><ul><li>固定分区，内存划分为固定大小的分区，会面临内碎片问题</li><li>动态分区，包括分区匹配和分区释放，分区匹配一般有最先匹配算法（找到合适分区立刻划分，不容易保留大分区）、最佳适应算法（找到大小最合适的分区，容易形成外碎片）和最差适应算法（避免外碎片，分配最大的分区，不容易保留大分区），分区释放阶段将两个空闲分区合并为一个空闲分区。</li></ul><p>连续分配中内存碎片是不可避免的，为了解决这个问题，一般会进行<strong>紧缩</strong>：将小的内存碎片调整位置，组合成大的可用空间去装载新的进程。因为紧缩会移动内存改变进程的地址，因此这种带有额外开销的操作一般会在特定时期进行，如释放分区后或者新的进程不被满足时。</p><p>离散分配方案，允许进程所在的物理地址空间非连续：</p><ul><li>页式管理，将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，也把内存空间分成与页面相同大小的若干个存储块，称为页框，也同样为它们加以编号。在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的页框中。这种方式消减外部碎片，由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称为页内碎片。虽然仍然有内碎片，但控制了内碎片的大小范围。优势是程序不必连续存放，所需的空间可以动态改变。但是程序需要一次性放入内存；几个子函数位于同一页面时，不利于程序和数据的共享和动态链接。</li><li>段式管理，为了解决共享数据和动态链接的问题，将程序的地址空间按内容或函数关系划分为若干段，每个段是逻辑上完整的程序或数据。将不同的段装入内存的不同位置，就可以支持逻辑共享了。所以通常段长不固定，决定于用户所编写的程序，所以这部分内存可以进行动态分区的管理。</li><li>段页式系统的基本原理是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页。</li></ul><h1 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h1><p><code>python</code> 根据对象的存活时间划分为三个的集合：年轻、中年和老年，新创建的对象位于年轻代，当年轻代的数量到达上限就会触发回收机制，不会被回收的对象会放在中年代中，依次类推，因此老年代是存活最久的对象。</p><p>清除过程是基于前文提到的标记清除算法实现的，这也是上文没写代码举例的原因，也能解释引用计数中，标记清除算法为什么没有清除循环引用的对象。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> _ctypes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obj_ref_count</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">"Obj Ref Count: &#123;&#125;"</span>.format(sys.getrefcount(obj)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.child = <span class="literal">None</span></span><br><span class="line">        print(<span class="string">"This Obj Address: &#123;&#125;"</span>.format(id(self)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gc.enable()</span><br><span class="line"><span class="keyword">assert</span> gc.isenabled() <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    a = Demo()</span><br><span class="line">    b = Demo()</span><br><span class="line"></span><br><span class="line">    a.child = b</span><br><span class="line">    b.child = a</span><br><span class="line"></span><br><span class="line">    a_addr = id(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> a</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2 表示检查 1 2 3 代的对象</span></span><br><span class="line">    <span class="comment"># 回收，并返回不活动对象的数目</span></span><br><span class="line">    print(gc.collect(<span class="number">2</span>)) <span class="comment"># output 4</span></span><br><span class="line">    <span class="comment"># 每代已经回收的数目</span></span><br><span class="line">    print(gc.get_count())</span><br><span class="line"></span><br><span class="line">    tmp = _ctypes.PyObj_FromPtr(int(a_addr))</span><br><span class="line">    obj_ref_count(tmp)</span><br></pre></td></tr></table></figure><p>最后的输出为 4，表示被清除了。<strong>强行使用被删除对象的地址很危险</strong>，不建议这么写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">This Obj Address: 1968923570128</span><br><span class="line">This Obj Address: 1968923570032</span><br><span class="line">4</span><br><span class="line">(1, 0, 0)</span><br><span class="line">Obj Ref Count: 4</span><br><span class="line">This Obj Address: 1968923570128</span><br><span class="line">This Obj Address: 1968923570032</span><br><span class="line">0</span><br><span class="line">(1, 0, 0)</span><br><span class="line">Obj Ref Count: 4</span><br><span class="line">This Obj Address: 1968923569840</span><br><span class="line">This Obj Address: 1968923567488</span><br><span class="line">4</span><br><span class="line">(1, 0, 0)</span><br><span class="line">Obj Ref Count: 4</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.geeksforgeeks.org/mark-and-sweep-garbage-collection-algorithm/" target="_blank" rel="noopener">mark &amp; sweep</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不出意外的话，这应该是 &lt;code&gt;python&lt;/code&gt; 复习的最后一部分了，之前写 &lt;code&gt;python&lt;/code&gt; 的时候，一般是在实践中积累一些常见的用法而后系统的学习，比如生成器装饰器、高级数据结构、各种工具库乃至 &lt;code&gt;__init__.py&lt;/code&gt; 等细节。但 &lt;code&gt;python&lt;/code&gt; 帮开发者自动进行了垃圾回收，所以一直没涉足这个领域，今天来了解一下 &lt;code&gt;python&lt;/code&gt; 中垃圾回收的三种机制：引用计数、标记清除和分代回收。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="https://muyuuuu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>轻量的神经网络</title>
    <link href="https://muyuuuu.github.io/2022/04/30/light-net/"/>
    <id>https://muyuuuu.github.io/2022/04/30/light-net/</id>
    <published>2022-04-30T12:43:59.000Z</published>
    <updated>2022-05-11T14:47:09.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很久之前我觉得移动端应用几百兆的模型不切实际，在不考虑蒸馏、量化等压缩方法下，发现了 MobileNet 设计的很神奇，大小只有几 MB，可以说是一股清流了。就整理发布了一下，然后今天发现找不到了，神奇。（于是顺手和 ShuffleNet 一并整理到轻量化的神经网络中）</p><a id="more"></a><h1 id="MobileNet-V1"><a href="#MobileNet-V1" class="headerlink" title="MobileNet-V1"></a>MobileNet-V1</h1><p>基本上可以说这个版本是后面几个版本的出发点。先来看一下创新点：提出 depthwise separable conv 和 pointwise conv 来降低网络的计算次数。还是直接画图吧：</p><p><img data-src="https://s1.ax1x.com/2022/04/30/OpcCxU.png" alt></p><p>对于传统卷积而言，输入一个三通道的图片，如果想要输出五通道，那么就需要 5 个 $3\times 3 \times 3$ 的卷积核。一般一些，假设传统卷积处理图像的大小是 $D_F\times D_F$，有 $M$ 个通道，卷积核的大小是 $D_K$，输出的通道数数 $N$，那么计算量就是 $D_K \cdot D_K \cdot M \cdot N \cdot D_F \cdot D_F$。</p><p>在得到相同大小输出的情况下，使用 DW 卷积和 PW 卷积来简化一下这个计算过程：</p><p><img data-src="https://s1.ax1x.com/2022/04/30/OpcFr4.png" alt></p><p>如果换成深度可分离卷积和逐点卷积，可以看到达到同样的输出，参数量从 $27\times 5$ 减少到了 $27+15$，而且计算量为 $D_K \cdot D_K \cdot M \cdot D_F \cdot D_F + M \cdot N \cdot D_F \cdot D_F$。两者的比值是 $1/N+1/D_K^2$。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileNetV1</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ch_in, n_classes)</span>:</span></span><br><span class="line">        super(MobileNetV1, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">conv_bn</span><span class="params">(inp, oup, stride)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">                nn.Conv2d(inp, oup, <span class="number">3</span>, stride, <span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">                nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">conv_dw</span><span class="params">(inp, oup, stride)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">                <span class="comment"># dw</span></span><br><span class="line">                <span class="comment"># 输入通道和输出通道相等，groups 表示每个卷积核只处理一个通道</span></span><br><span class="line">                nn.Conv2d(inp, inp, <span class="number">3</span>, stride, <span class="number">1</span>, groups=inp, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(inp),</span><br><span class="line">                nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line"></span><br><span class="line">                <span class="comment"># pw</span></span><br><span class="line">                <span class="comment"># 卷积核大小为 1X1</span></span><br><span class="line">                nn.Conv2d(inp, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">                nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            conv_bn(ch_in, <span class="number">32</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">32</span>, <span class="number">64</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">128</span>, <span class="number">128</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">256</span>, <span class="number">256</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">1024</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">1024</span>, <span class="number">1024</span>, <span class="number">1</span>),</span><br><span class="line">            nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">        self.fc = nn.Linear(<span class="number">1024</span>, n_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.model(x)</span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">1024</span>)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h1 id="MobileNet-V2"><a href="#MobileNet-V2" class="headerlink" title="MobileNet-V2"></a>MobileNet-V2</h1><p>V1 的思想可以概括为：首先利用 3×3 的深度可分离卷积提取特征，然后利用 1×1 的卷积来扩张通道。但是有人在实际使用的时候，发现训完之后发现 dw 卷积核有不少是空的。</p><p>作者认为这是 ReLU 激活函数导致的。于是做了一个实验，就是对一个 n 维空间中的一个东西乘以矩阵 $T$，而后做 ReLU 运算，然后利用 $T$ 的逆矩阵恢复，对比 ReLU 之后的结果与 Input 的结果相差有多大。作者发现：低维度做 ReLU 运算，很容易造成信息的丢失。而在高维度进行 ReLU 运算的话，信息的丢失则会很少。</p><p>由于卷积本身没有改变通道的能力，来的是多少通道输出就是多少通道。上面又得出低维通道不好的结论，因此使用 PW 卷积升维再降维，这也就形成了 Inverted Residuals 这种结构，因为传统的残差结构和本文相反，传统的是先降维在升维。</p><p>这样高维的仍然使用 ReLU 激活函数，低维的换成线性激活函数。因为有先升维在降维的结构，因此使用了残差连接来提升性能。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvertedResidual</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inp, oup, stride, expand_ratio)</span>:</span></span><br><span class="line">        super(InvertedResidual, self).__init__()</span><br><span class="line">        self.stride = stride</span><br><span class="line">        <span class="keyword">assert</span> stride <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        hidden_dim = int(inp * expand_ratio)</span><br><span class="line">        self.use_res_connect = self.stride == <span class="number">1</span> <span class="keyword">and</span> inp == oup</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> expand_ratio == <span class="number">1</span>:</span><br><span class="line">            self.conv = nn.Sequential(</span><br><span class="line">                <span class="comment"># dw</span></span><br><span class="line">                nn.Conv2d(hidden_dim, hidden_dim, <span class="number">3</span>, stride, <span class="number">1</span>, groups=hidden_dim, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                nn.ReLU6(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># pw-linear</span></span><br><span class="line">                nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv = nn.Sequential(</span><br><span class="line">                <span class="comment"># pw 升维</span></span><br><span class="line">                nn.Conv2d(inp, hidden_dim, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                nn.ReLU6(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># dw 深度可分离卷积</span></span><br><span class="line">                nn.Conv2d(hidden_dim, hidden_dim, <span class="number">3</span>, stride, <span class="number">1</span>, groups=hidden_dim, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                nn.ReLU6(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># pw-linear 激活</span></span><br><span class="line">                nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.use_res_connect:</span><br><span class="line">            <span class="keyword">return</span> x + self.conv(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.conv(x)</span><br></pre></td></tr></table></figure><h1 id="MobileNet-V3"><a href="#MobileNet-V3" class="headerlink" title="MobileNet-V3"></a>MobileNet-V3</h1><p>主要做了两点创新，一个是在 MobileNet V2 残差分支加入了 SE（Squeeze-and-Excitation） 注意力机制的模块，一个是更新了激活函数。SE 注意力就是通过池化得到每个通道的值，并输入到全连接层学习到每个通道的权重，对每个通道的数值进行更新。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SELayer</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, channel, reduction=<span class="number">4</span>)</span>:</span></span><br><span class="line">        super(SELayer, self).__init__()</span><br><span class="line">        self.avg_pool = nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 输入维度和输出维度相同</span></span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(channel, _make_divisible(channel // reduction, <span class="number">8</span>)),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(_make_divisible(channel // reduction, <span class="number">8</span>), channel),</span><br><span class="line">            h_sigmoid()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        b, c, _, _ = x.size()</span><br><span class="line">        y = self.avg_pool(x).view(b, c)</span><br><span class="line">        y = self.fc(y).view(b, c, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># y 是每个通道的权重</span></span><br><span class="line">        <span class="keyword">return</span> x * y</span><br></pre></td></tr></table></figure><p>在重新设计激活函数方面，使用 h-swish 激活函数代替了 swish 激活函数，因为更容易计算。对于 swish 激活函数：</p><p>\begin{equation}<br>    \begin{aligned}<br>        \text{swish} x &amp;= x \cdot \sigma(x) \\<br>        \sigma(x) &amp;= \frac{1}{1+e^{-x}}<br>    \end{aligned}<br>\end{equation}</p><p>这个反向传播和激活的计算过程略显复杂，对量化不够友好。于是使用较为接近的 h-swish 激活函数代替：</p><p>\begin{equation}<br>    \begin{aligned}<br>        \text{h-sigmoid} &amp;= \frac{\text{ReLU6}(x+3)}{6} \\<br>        \text{h-swish} &amp;= x \cdot \text{h-sigmoid}<br>    \end{aligned}<br>\end{equation}</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">h_sigmoid</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inplace=True)</span>:</span></span><br><span class="line">        super(h_sigmoid, self).__init__()</span><br><span class="line">        self.relu = nn.ReLU6(inplace=inplace)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.relu(x + <span class="number">3</span>) / <span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">h_swish</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inplace=True)</span>:</span></span><br><span class="line">        super(h_swish, self).__init__()</span><br><span class="line">        self.sigmoid = h_sigmoid(inplace=inplace)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x * self.sigmoid(x)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvertedResidual</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inp, hidden_dim, oup, kernel_size, stride, use_se, use_hs)</span>:</span></span><br><span class="line">        super(InvertedResidual, self).__init__()</span><br><span class="line">        <span class="keyword">assert</span> stride <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        self.identity = stride == <span class="number">1</span> <span class="keyword">and</span> inp == oup</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> inp == hidden_dim:</span><br><span class="line">            self.conv = nn.Sequential(</span><br><span class="line">                <span class="comment"># dw</span></span><br><span class="line">                nn.Conv2d(hidden_dim, hidden_dim, kernel_size, stride, (kernel_size - <span class="number">1</span>) // <span class="number">2</span>, groups=hidden_dim, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                h_swish() <span class="keyword">if</span> use_hs <span class="keyword">else</span> nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># Squeeze-and-Excite</span></span><br><span class="line">                SELayer(hidden_dim) <span class="keyword">if</span> use_se <span class="keyword">else</span> nn.Identity(),</span><br><span class="line">                <span class="comment"># pw-linear</span></span><br><span class="line">                nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv = nn.Sequential(</span><br><span class="line">                <span class="comment"># pw 升维</span></span><br><span class="line">                nn.Conv2d(inp, hidden_dim, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                h_swish() <span class="keyword">if</span> use_hs <span class="keyword">else</span> nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># dw 提取特征</span></span><br><span class="line">                nn.Conv2d(hidden_dim, hidden_dim, kernel_size, stride, (kernel_size - <span class="number">1</span>) // <span class="number">2</span>, groups=hidden_dim, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                <span class="comment"># Squeeze-and-Excite</span></span><br><span class="line">                SELayer(hidden_dim) <span class="keyword">if</span> use_se <span class="keyword">else</span> nn.Identity(),</span><br><span class="line">                h_swish() <span class="keyword">if</span> use_hs <span class="keyword">else</span> nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># pw-linear 先行激活，降维</span></span><br><span class="line">                nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.identity:</span><br><span class="line">            <span class="keyword">return</span> x + self.conv(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.conv(x)</span><br></pre></td></tr></table></figure><h1 id="ShuffleNet-V1"><a href="#ShuffleNet-V1" class="headerlink" title="ShuffleNet-V1"></a>ShuffleNet-V1</h1><p>group 卷积能有效的减少卷积参数。假设输入图像的大小为 $c_1\times H \times W$，卷积核大小为 $c_1 \times h \times w$，想要得到 $c_2 \times H \times W$ 的输出目标，那么需要的卷积层参数量就是：$c_2 \times c_1 \times h \times w$。</p><p>如果使用 group 卷积，将通道分成 $g$ 组，那么每个输入就是 $c_1/g \times H \times W$，对应的卷积核大小为 $c_1/g \times h \times w$，为了得到同样大小的输出，一组卷积的输出大小就是 $c_2/g \times H \times W$，将 $g$ 组卷积核的输出拼接到一起得到同等大小的输出 $c_2 \times H \times W$，此时的参数量为 $c_2 \times c_1 / g\times h \times w$。</p><p><img data-src="https://s1.ax1x.com/2022/05/02/OFVjDH.jpg" alt></p><ul><li>图 a 中，对于 group 卷积而言，channel 特征只在组内传递</li><li>图 b 中，对 channel 进行打乱，特征在多个 channel 中传递</li></ul><p>综上，使用 group 卷积替换传统卷积，并在 group 卷积后使用 channel shuffle 操作。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">channel_shuffle</span><span class="params">(x, groups)</span>:</span></span><br><span class="line">    batchsize, num_channels, height, width = x.data.size()</span><br><span class="line"></span><br><span class="line">    channels_per_group = num_channels // groups</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># reshape</span></span><br><span class="line">    x = x.view(batchsize, groups, </span><br><span class="line">        channels_per_group, height, width)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通道那个矩阵发生了转置</span></span><br><span class="line">    <span class="comment"># - contiguous() required if transpose() is used before view()</span></span><br><span class="line">    x = torch.transpose(x, <span class="number">1</span>, <span class="number">2</span>).contiguous()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># flatten</span></span><br><span class="line">    x = x.view(batchsize, <span class="number">-1</span>, height, width)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h1 id="ShuffleNet-V2"><a href="#ShuffleNet-V2" class="headerlink" title="ShuffleNet-V2"></a>ShuffleNet-V2</h1><p>在众多影响模型推理速度的因素中，理论计算量只是一部分，额外的还有内存访问（memory access cost, MAC）、平台架构和并行等级；而 数据 IO、逐元素运算也会占用时间。因此作者给出了设计轻量网络的四条准则和实验验证：</p><p>\begin{equation}<br>    \begin{aligned}<br>        \text{MAC} &amp;= hw(c_1+c_2)+c_1c_2 \\<br>        { } &amp; \geq 2hw\sqrt{c_1c_2}+c_1c_2\\<br>        { } &amp; \geq 2\sqrt{hwB} + \frac{B}{hw}\\<br>        B &amp;= hwc_1c_2 (\text{FLOPs})<br>    \end{aligned}<br>\end{equation}</p><ol><li>如上的 MAC 计算中，可以发现当 $c_1=c_2$ 的时候取等号。也就是当卷积的输入和输出 channel 相等时，内存访问代价最低，因此尽可能使通道不变</li></ol><p>\begin{equation}<br>    \begin{aligned}<br>        \text{Group-MAC} &amp;= hw(c_1+c_2)+c_1c_2/g \\<br>        { } &amp;=hwc_1 + \frac{Bg}{c_1} + \frac{B}{hw}\\<br>        B &amp;= hwc_1c_2/g (\text{FLOPs})<br>    \end{aligned}<br>\end{equation}</p><ol><li>在 Group-MAC 计算中，因为其他是定植，那么大小取决于 $g$，因此分组卷积分的越多时，内存访问代价会增大</li><li>网络的碎片化程度越高（分支越多的意思），速度越慢。对于 GPU 的并行计算不友好，而且涉及不同分支的同步问题</li><li>逐元素相加也会带来不可忽视的开销，如 relu，残差的 add 运算</li></ol><p><img data-src="https://s1.ax1x.com/2022/05/02/OFVXKe.jpg" alt></p><p>图左侧的 a（stride=1） 和 b（stride=2） 是 ShuffleNetV1 的结构，右侧的 c（stride=1） 和 d（stride=2） 是 ShuffleNetV2 的结构。</p><p>图 c 中，为了减少碎片化，在 c 中取消了左侧分支没有运算，右侧分支满足第一个准则，而最开始的 channel split 到最后的 concat，再次满足第一个准则，不选择 add 操作满足第 4 个准则。只对右侧的分支进行 relu 激活，并取消最终输出的 relu，满足第 4 个准则。而 concat，channel shuffle 和下一层输入的 channel split 可以合并为一个逐元素操作，不得不说太细了。</p><p>然后 ShuffleNetV2+ 在借鉴 MobileNetV3 的想法，也使用了 h-swish 激活函数和 SE 注意力机制，结果上超过了 MobileNetV3，这一部分可以在旷视的 github 上找到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久之前我觉得移动端应用几百兆的模型不切实际，在不考虑蒸馏、量化等压缩方法下，发现了 MobileNet 设计的很神奇，大小只有几 MB，可以说是一股清流了。就整理发布了一下，然后今天发现找不到了，神奇。（于是顺手和 ShuffleNet 一并整理到轻量化的神经网络中）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
</feed>
