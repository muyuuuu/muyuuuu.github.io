<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just for Life.</title>
  
  <subtitle>明月更几时</subtitle>
  <link href="https://muyuuuu.github.io/atom.xml" rel="self"/>
  
  <link href="https://muyuuuu.github.io/"/>
  <updated>2024-02-03T07:13:43.367Z</updated>
  <id>https://muyuuuu.github.io/</id>
  
  <author>
    <name>兰铃</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C 语言中的黑魔法：宏</title>
    <link href="https://muyuuuu.github.io/2024/02/03/define-macro/"/>
    <id>https://muyuuuu.github.io/2024/02/03/define-macro/</id>
    <published>2024-02-02T17:36:01.000Z</published>
    <updated>2024-02-03T07:13:43.367Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前对 <code>C</code> 语言中宏定义的认知十分简单，包括但不限于停留在以下浅薄的层面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> add(a, b) a + b</span></span><br></pre></td></tr></table></figure><p>上述代码完全是大学课本中的用法。但当我看到实际项目中宏的用法后完全是一头雾水，<del>所以自己也要写出那种高逼格让别人看不太懂的代码</del>。宏远远比我想象的要强大，所以本文为每个宏技巧都配备了一个实用场景。</p><ul><li>字符串化操作符，实现一个简单的自动化测试样例</li><li>字符串连接，实现一个具备计时功能的宏</li><li>X 宏，实现根据输入执行不同的函数</li><li>特殊宏 <code>__VA_ARGS__</code>，实现一个简单的日志函数</li></ul><span id="more"></span><h1 id="字符串化操作符"><a href="#字符串化操作符" class="headerlink" title="字符串化操作符"></a>字符串化操作符</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> str(a) #a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">str</span>(FUNC);   <span class="comment">// 输出 FUNC</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述宏 <code>str</code> 通过单井号的形式实现了字符串化操作符，将传入的参数字符串化。</p><h2 id="简单测试框架"><a href="#简单测试框架" class="headerlink" title="简单测试框架"></a>简单测试框架</h2><p>C 语言有一些预定义的宏，比如 <code>__LINE__</code> 表示当前行号，<code>__FILE__</code> 表示当前的文件名，基于这一基础，我们实现一个简单的测试程序。在测试程序时，打印测试用例、文件名、行号、以及是否通过测试。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(format) printf(format)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TO_STR__(x) #x <span class="string">&quot;:&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TO_REAL__(x) __TO_STR__(x)</span></span><br><span class="line"><span class="comment">// 文件:行号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FILE_LINE__ __FILE__ <span class="string">&quot;:&quot;</span> __TO_REAL__(__LINE__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_VAL(val) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        LOG_INFO(__FILE_LINE__ <span class="string">&quot;:calling &quot;</span> #val <span class="string">&quot;\n&quot;</span>); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (0 == (val)) &#123; \</span></span><br><span class="line"><span class="meta">            LOG_INFO(__FILE_LINE__ <span class="string">&quot;:error \n&quot;</span>); \</span></span><br><span class="line"><span class="meta">            goto fail; \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> &#123; \</span></span><br><span class="line"><span class="meta">            LOG_INFO(__FILE_LINE__ <span class="string">&quot;:passed \n&quot;</span>); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n_total = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> n_passed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CHECK_VAL</span>(<span class="number">1</span> == <span class="built_in">test_func</span>());</span><br><span class="line">    n_passed ++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CHECK_VAL</span>(<span class="number">2</span> == <span class="built_in">test_func</span>());</span><br><span class="line">    n_passed ++;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;################ summary ###################\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;passed: %d\n&quot;</span>, n_passed);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total: %d\n&quot;</span>, n_total);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>#val</code> 会打印测试样例</li><li><code>__FILE_LINE__</code> 会打印当前的文件名和行号</li></ul><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">demo.cpp:30::calling 1 == test_func()</span><br><span class="line">demo.cpp:30::passed </span><br><span class="line">demo.cpp:33::calling 2 == test_func()</span><br><span class="line">demo.cpp:33::error </span><br><span class="line">################ summary ###################</span><br><span class="line">passed: 1</span><br><span class="line">total: 2</span><br></pre></td></tr></table></figure><h2 id="为什么用-do-while-0-？"><a href="#为什么用-do-while-0-？" class="headerlink" title="为什么用 do-while(0) ？"></a>为什么用 do-while(0) ？</h2><p><code>do-while(0)</code> 的用法还是比较常见的，多用于在一个宏定义中出现多条语句的情境中。那我们来分析一下为什么要这么用：</p><p>如果我们这样定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SS \</span></span><br><span class="line"><span class="meta">    stmt1; \</span></span><br><span class="line"><span class="meta">    stmt2;</span></span><br></pre></td></tr></table></figure><p>在以下的使用场景中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cond)</span><br><span class="line">    SS;</span><br><span class="line">    stmt3;</span><br></pre></td></tr></table></figure><p>宏展开后，会变成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cond)</span><br><span class="line">    stmt1;</span><br><span class="line">    stmt2;</span><br><span class="line">    ;</span><br><span class="line">    stmt3;</span><br></pre></td></tr></table></figure><p>所以不管 <code>cond</code> 是真是假，<code>stmt2</code> 语句都会执行。而我们自己的意图肯定是，只有 <code>cond</code> 为真的时候，<code>stmt1</code> 和 <code>stmt2</code> 才会执行。造成上述结果的原因是调用者希望宏中的多条语句是绑定在一起执行的，那我们给宏加上花括号试一试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SS &#123; \</span></span><br><span class="line"><span class="meta">    stmt1; \</span></span><br><span class="line"><span class="meta">    stmt2; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>但是在下面这种情况下，还是会存在一些错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cond)</span><br><span class="line">    SS;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    stmt3;</span><br></pre></td></tr></table></figure><p>这样宏展开的结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cond) &#123; </span><br><span class="line">    stmt1; </span><br><span class="line">    stmt2; </span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    stmt3;</span><br></pre></td></tr></table></figure><p>直接导致编译错误，而出错的原因是 <code>else</code> 前面多一个分号。当然也可以在使用 <code>SS</code> 的地方后面不加分号，但是在 C 语言中通常我们习惯性的会在语句后面加一个分号。鉴于上面的这些原因，就有人想出了 <code>do-while(0)</code> 式的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SS \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        stmt1; \</span></span><br><span class="line"><span class="meta">        stmt2; \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br></pre></td></tr></table></figure><h1 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> define_val(tag)  \</span></span><br><span class="line"><span class="meta">    int a_##tag = 77</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">define_val</span>(MAX);</span><br><span class="line">    std::cout &lt;&lt; a_MAX;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的意思是，将 <code>a_</code> 和传入的 <code>tag</code> 连接在一起，形成一个新的字符串使用。上述代码中完全没有直接出现 <code>a_MAX</code> 这个字符串，但我们依然可以使用。</p><p>这样做的一点点好处是：比如现在有 100 个模块分散在项目的各个角落，需要给模块计时。那么每次都定义起始时间、结束时间，并且计算执行时间。这些操作都是重复的，为了精简重复的操作，我们可以使用这个宏技巧来实现。如下所示的代码，我们把宏放到头文件，所以用户只需要两行代码就可以快速的完成计时功能。</p><h2 id="测试函数执行时间的宏"><a href="#测试函数执行时间的宏" class="headerlink" title="测试函数执行时间的宏"></a>测试函数执行时间的宏</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Time</span> &#123;</span><br><span class="line">    <span class="type">double</span> time;</span><br><span class="line">&#125; Time;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetTime</span><span class="params">(Time* T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    T-&gt;time = (tv.tv_sec * <span class="number">1000.0</span>) + (tv.tv_usec / <span class="number">1000.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_START(tag) \</span></span><br><span class="line"><span class="meta">    Time tag##_start, tag##_end; \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        GetTime(&amp;(tag##_start)); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_END(tag) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        GetTime(&amp;(tag##_end)); \</span></span><br><span class="line"><span class="meta">        printf(#tag <span class="string">&quot; cost %.2f \n&quot;</span>, tag##_end.time - tag##_start.time); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="built_in">TIME_START</span>(loop_func_20);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="built_in">TIME_END</span>(loop_func_20);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loop_func_20 cost 202.44ms </span><br></pre></td></tr></table></figure><h1 id="特殊宏"><a href="#特殊宏" class="headerlink" title="特殊宏"></a>特殊宏</h1><p><code>__VA_ARGS__</code> 是一个预处理器宏，用于表示可变参数列表。它通常用于定义可变参数的宏，例如 <code>printf</code> 函数。在宏定义中，<code>__VA_ARGS__</code> 表示可变参数列表的部分，可以在宏展开时将其替换为实际的参数列表。官方定义较为玄幻，直接看代码吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(format, ...) printf(format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;===== info =====\n&quot;</span>);   <span class="comment">// 0 参数</span></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;data is %d\n&quot;</span>, <span class="number">2</span>);      <span class="comment">// 1 个参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个简单的打日志函数"><a href="#一个简单的打日志函数" class="headerlink" title="一个简单的打日志函数"></a>一个简单的打日志函数</h2><p>给上述代码加一些辅助信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(tag, format, ...) \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;[%s] [%s %s %d] &quot;</span> format, tag, __FILE__, __FUNCTION__, __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;BASE&quot;</span>, <span class="string">&quot;Nothing\n&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;BASE&quot;</span>, <span class="string">&quot; ? info diff &gt;= %d : %.4f %d\n&quot;</span>, <span class="number">2</span>, <span class="number">0.1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LOG</span>(<span class="string">&quot;BASE&quot;</span>, <span class="string">&quot;Nothing&quot;</span>);</span><br></pre></td></tr></table></figure><p>宏展开为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%s] [%s %s %d] &quot;</span> <span class="string">&quot;Nothing&quot;</span>, <span class="string">&quot;Base&quot;</span>, <span class="string">&quot;demo.cpp&quot;</span>, <span class="string">&quot;main&quot;</span>, <span class="number">7</span>);  </span><br></pre></td></tr></table></figure><p>注意，<code>Nothing</code> 这个信息是在 <code>format</code> 中，因此第一个 <code>%s</code> 先输出 <code>tag</code>，所以最终输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[BASE] [test.cpp main 8] Nothing</span><br></pre></td></tr></table></figure><p>同理，第二个宏展开后的输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[BASE] [test.cpp main 7]  ? info diff &gt;= 2 : 0.1000 2</span><br></pre></td></tr></table></figure><h1 id="X-宏的使用"><a href="#X-宏的使用" class="headerlink" title="X 宏的使用"></a>X 宏的使用</h1><p>根据指令执行不同的函数，待整理……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACROS_TABLE                    \</span></span><br><span class="line"><span class="meta">    X_MACROS(CMD_LED_ON,  led_on)       \</span></span><br><span class="line"><span class="meta">    X_MACROS(CMD_LED_OFF, led_off)      \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment">/*定义命令列表*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> X_MACROS(a, b) a,</span></span><br><span class="line">    MACROS_TABLE</span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> X_MACROS</span></span><br><span class="line">    CMD_MAX</span><br><span class="line">&#125;cmd_e;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义字符串列表用作Log打印*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cmd_str[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> X_MACROS(a, b) #a,</span></span><br><span class="line">    MACROS_TABLE</span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> X_MACROS</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">led_on</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s \r\n&quot;</span>, (<span class="type">char</span> *)p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">led_off</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s \r\n&quot;</span>, (<span class="type">char</span> *)p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> func func_table[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> X_MACROS(a, b) b,</span></span><br><span class="line">    MACROS_TABLE</span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> X_MACROS</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cmd_handle</span><span class="params">(cmd_e cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cmd &lt; CMD_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        func_table[cmd]((<span class="type">void</span>*)cmd_str[cmd]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cmd_handle</span>(CMD_LED_ON);</span><br><span class="line">    <span class="built_in">cmd_handle</span>(CMD_LED_OFF);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/521073931">X-宏的用法</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前对 &lt;code&gt;C&lt;/code&gt; 语言中宏定义的认知十分简单，包括但不限于停留在以下浅薄的层面：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; PI 3.14&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; add(a, b) a + b&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码完全是大学课本中的用法。但当我看到实际项目中宏的用法后完全是一头雾水，&lt;del&gt;所以自己也要写出那种高逼格让别人看不太懂的代码&lt;/del&gt;。宏远远比我想象的要强大，所以本文为每个宏技巧都配备了一个实用场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串化操作符，实现一个简单的自动化测试样例&lt;/li&gt;
&lt;li&gt;字符串连接，实现一个具备计时功能的宏&lt;/li&gt;
&lt;li&gt;X 宏，实现根据输入执行不同的函数&lt;/li&gt;
&lt;li&gt;特殊宏 &lt;code&gt;__VA_ARGS__&lt;/code&gt;，实现一个简单的日志函数&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="C" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>一次不太愉快的软件开发</title>
    <link href="https://muyuuuu.github.io/2024/02/03/an-unpleasant-experience-dev/"/>
    <id>https://muyuuuu.github.io/2024/02/03/an-unpleasant-experience-dev/</id>
    <published>2024-02-02T17:19:02.000Z</published>
    <updated>2024-02-02T17:30:21.315Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>整体的开发感受是：缺乏一个合理的、完整的软件开发流程或规范。</p><span id="more"></span><ul><li><p>合理是指：大多需求都是由领导拍脑门、飞书、现场沟通传达。尤其在面临这种前路未知、需求多变的任务时，由于背景知识的缺乏， 沟通会更加吃力。最大的缺点是难以记录，不利于软件的维护、更新等。需要加什么功能，改什么功能，为什么这么做，无从查起。</p></li><li><p>完整是指：什么时候开会和立项，什么时候讨论，怎么样算完成，软件如何发布，如何维护，这些东西没有任何规范。一个软件的生命周期，从需求分析到维护，这些都没有。整体感受和学生时代的大作业没啥区别。</p></li><li><p>沟通效率很低。</p><ul><li>逐字、逐标点符号对文档十分没有必要，应该关注大纲。需要知道目标是什么，有哪些场景即可</li><li>以为刷新一下就实现的东西，说快速让我实现一下。但需要很复杂的数据传输与解析，脑子幻想的东西实现起来也许很费力</li><li>一开始不要讨论代码，浪费时间。一开始的讨论都是基于颅内 <code>debug</code>，到后面会发现之前讨论的代码很可能无法实现，或者说并不是最优的实现方式。代码写到那里，自然而然的会发现更好、更便捷的实现方法，回过头来发现前期的讨论除了浪费时间和耽误进度外，没有任何价值。</li></ul></li></ul><ul><li><p>应用场景，用户需求没有任何调研。</p><ul><li>未调研用户的需求，并没有得到他们的反馈。只是在满足领导想象出来的需求。假设有 50 人用软件，领导说你软件写的不行，不符合他的要求，一直提需求导致软件迟迟没有发布，项目一直 <code>delay</code>，自己很着急，老板很失望。我想写小而美的软件，后面慢慢添加功能；领导希望一次性支持全部功能，这仿佛真的很难实现。比如今天 AI 组又提了一个新需求，超出了我们最开始的规划，真的很难一次性实现全部需求。</li><li>其实呢，也许你的软件 20 人用着是满意的，20 人用着是觉得凑合的，9人觉得还需要改进，只有领导觉得这里不行，应该这样显示；那里不行，应该加个隐藏按钮。但也许 30 人觉得那个隐藏按钮多此一举，10个人觉得千万不要加隐藏按钮，只满足一个人的需求是没有意义的。换句话说，领导该把控大的方向，而不是纠结是否添加一个隐藏按钮。</li></ul></li></ul><ul><li><p>临时添加功能过于繁琐。</p><ul><li>想临时看一下峰值内存、想临时加一下 <code>unknown</code> 函数调用、想取消 <code>unknown</code> 的函数调用、想随便生成一个表看看界面什么样子。这些至少还是能应付的，改几行代码去应付即可，只不过累一些。而这些繁琐的临时需求，会发现写完之后不在需要，只会一点一点的消耗耐心，浪费宝贵的积极性。</li><li>后续再安排新任务时，会下意识的质疑任务的合理性，以及是否有必要去实现，产生一点排斥心理。</li></ul></li></ul><ul><li><p>需求不明确</p><ul><li>当软件过于庞大，输入、功能、需求、应用场景其中之一发生严重变化时，这绝对不是改几行代码能搞定的。只有两条路可走：继续维护屎山代码，或者重写代码。</li><li>所以一开始，最好讨论清楚目标是什么，功能是什么，支持的用户范围，最重要的是：做到什么程度就到此为止，哪些功能不需要实现，哪些用户不需要支持。等一切都清晰后，再开始去写代码。一开始被领导叫去写代码，还被要求实现很多的功能。后面和老板讨论后发现一些功能不用实现，一些功能需要改。<strong>看着手里的屎山代码，我选择了重写。</strong></li><li>如果功能发生大的变化，一定是前期的目标出了问题。作为领导，应该只要求大的方向，而不该关注和过分追求细节：比如按钮在哪个位置，信息如何提示给用户，文件命名等。比如文件名是日期+版本号，还是版本号+日期。小细节前期讨论会很浪费精力，后期修改又会更浪费时间、消耗耐心、浪费经历，十分没有必要。</li></ul></li></ul><p><del>如果某天我当了领导</del>，我大概率会说：先调研，有无现有的高性能实现方案，是写异步函数还是同步函数。然后写技术方案，和我沟通后我确定做的方向与内容，细节你们决定。</p><h1 id="如何维护？"><a href="#如何维护？" class="headerlink" title="如何维护？"></a>如何维护？</h1><ul><li>需要修复一些紧急的 <code>bug</code>，立刻发布</li><li>大家提了一些共性的需求，库会周期性发布，一次性多实现几个功能</li><li>个别需求不考虑实现</li></ul><p>提问和发布暂定使用 <code>gitlab</code>，将软件管理起来。第一次管理软件的维护和发布，处于探索阶段，还需要学习。功能实现或紧急 <code>bug</code> 修复后，关闭对应的 <code>issue</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;整体的开发感受是：缺乏一个合理的、完整的软件开发流程或规范。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Design" scheme="https://muyuuuu.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>前后端全栈开发：0 基础搭建 UI 界面和提供数据服务</title>
    <link href="https://muyuuuu.github.io/2024/01/03/full-stack-amis-tornado/"/>
    <id>https://muyuuuu.github.io/2024/01/03/full-stack-amis-tornado/</id>
    <published>2024-01-03T14:12:54.000Z</published>
    <updated>2024-01-03T14:37:19.483Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写在前面。希望你不会有快速搭建 UI 界面为他人服务这种迫切的需求。虽然这是我的博客，但是我并不希望你搜到他。对于完全未知的领域，快速搭建、快速学习、不会就去学、不会就查、速成，通过这种方式写出来的代码一定是不好的，心累的，事倍功半的，也一定存在多多少少的 <code>bug</code> 和无法实现的逻辑。</p><p>但也有一个好消息，如果你完全不会前端后端，只会 <code>Python</code>，看了本文也能搭建完成的前后端服务，但距离入门的全栈工程师还差很远。</p><span id="more"></span><h1 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h1><p>在开发初期，我真的以为是弄一些简单的图表就结束，所以没放在心上。但是越往后项目越大，我的 <code>js</code> 和 <code>html</code> 水平实在驾驭不了，工作时也不会给我足够的时间让我从头学这些东西。每天晚上都在给之前的同学打电话询问：这种交互逻辑该怎么实现。在她帮我写了整体架构后，我便在架构上修修改改，查 <code>api</code>，整体是能满足需求的。</p><p>但是后续，项目又变大了，要求这个，要求那个，要求各种各样的 <code>UI</code> 界面和交互。0 前端基础的我实在应付不了，麻烦同学也不是长久之计，于是开始使用 <code>amis</code> 搭建前端界面。</p><h2 id="选择低代码框架-amis"><a href="#选择低代码框架-amis" class="headerlink" title="选择低代码框架 amis"></a>选择低代码框架 amis</h2><p>以上内容摘自百度 <code>amis</code> 的官方文档：</p><ul><li>在经历了十几年的发展后，前端开发变得越来越复杂，门槛也越来越高，要使用当下流行的 <code>UI</code> 组件库，必须懂 <code>npm</code>、<code>webpack</code>、<code>react/vue</code>，必须熟悉 <code>ES6</code> 语法，最好还了解状态管理，比如 <code>Redux</code>，如果没接触过函数式编程，入门都很费劲。而入门之后会发现它还有巨大的生态，相关的库有 2347 个，很多功能相似，挑选成本高。然而前端技术的发展不会停滞，等学完这些后可能会发现大家都用 <code>Hooks</code> 了、某个打包工具取代 <code>Webpack</code> 了……</li><li>用 <code>amis</code> 只需要几百行 <code>JSON</code> 配置，不需要了解 <code>React/Vue</code>、<code>Webpack</code>，甚至不需要了解 <code>JavaScript</code>，即便没学过 <code>amis</code> 也能猜到大部分配置的作用，只需要简单配置就能完成所有页面开发。</li><li>可以借助 <code>amis</code> 的<a href="https://aisuda.github.io/amis-editor-demo/#/hello-world">可视化编辑器</a>，快速完成页面的开发。对于大部分常用页面，应该使用最简单的方法来实现，甚至不需要学习前端框架和工具。</li><li><code>amis</code> 在百度内部得到了广泛使用，在 6 年多的时间里创建了 5 万页面，从内容审核到机器管理，从数据分析到模型训练，<code>amis</code> 满足了各种各样的页面需求。</li></ul><p><img data-src="https://s11.ax1x.com/2024/01/03/pivmv8A.jpg" alt></p><h2 id="下载-amis-并使用"><a href="#下载-amis-并使用" class="headerlink" title="下载 amis 并使用"></a>下载 amis 并使用</h2><p>下载<a href="https://github.com/baidu/amis/releases">链接</a>中的 <code>sdk.tar.gz</code>，解压放到本地文件夹。目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sdk/</span><br><span class="line">index.html</span><br></pre></td></tr></table></figure><p><code>index.html</code> 中的内容，重点是 14，15，33 行中的 <code>sdk</code> 路径，需要正确的指定。<code>index.html</code> 中的内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>amis demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=Edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./sdk/sdk.css&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./sdk/helper.css&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 从 1.1.0 开始 sdk.css 将不支持 IE 11，如果要支持 IE11 请引用这个 css，并把前面那个删了 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;sdk-ie11.css&quot; /&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 不过 amis 开发团队几乎没测试过 IE 11 下的效果，所以可能有细节功能用不了，如果发现请报 issue --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">html</span>,</span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">body</span>,</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.app-wrapper</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span> <span class="attr">class</span>=<span class="string">&quot;app-wrapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./sdk/sdk.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> amis = <span class="title function_">amisRequire</span>(<span class="string">&#x27;amis/embed&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 通过替换下面这个配置来生成不同页面</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> amisJSON = &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">type</span>: <span class="string">&#x27;page&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">title</span>: <span class="string">&#x27;表单页面&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">body</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&#x27;form&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">mode</span>: <span class="string">&#x27;horizontal&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">api</span>: <span class="string">&#x27;/saveForm&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">controls</span>: [</span></span><br><span class="line"><span class="language-javascript">              &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">label</span>: <span class="string">&#x27;Name&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: <span class="string">&#x27;text&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span></span></span><br><span class="line"><span class="language-javascript">              &#125;,</span></span><br><span class="line"><span class="language-javascript">              &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">label</span>: <span class="string">&#x27;Email&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: <span class="string">&#x27;email&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>: <span class="string">&#x27;email&#x27;</span></span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">            ]</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> amisScoped = amis.<span class="title function_">embed</span>(<span class="string">&#x27;#root&#x27;</span>, amisJSON);</span></span><br><span class="line"><span class="language-javascript">      &#125;)();</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用浏览器打开 <code>index.html</code>，就能看到一个简单的页面。当然，也可以打开百度提供的<a href="https://aisuda.github.io/amis-editor-demo/#/hello-world">前端编辑器</a>，以拖拉拽的形式完成前端界面的开发即可，类似 <code>qtdesigner</code> 或者 <code>C#</code> 开发 <code>.NET FrameWork</code> 的操作。</p><p>友情提示：和任何 <code>UI</code> 开发一样，建议为每个组件提供 <code>flex</code> 布局或者容器，后期容易调整样式，开发出来的 <code>UI</code> 界面也更好看。开发完成之后，点击这个按钮获取 <code>json</code> 文件：</p><p>待补充图片</p><p>然后拷贝到 <code>index.html</code> 中的 <code>let amisJSON =</code> 字段，就完成了 <code>UI</code> 界面的开发。注意：这里只是完成了 <code>UI</code> 界面开发，并没有和后台的数据相关联，并没有捕捉用户的动作，完成交互和响应需要单独写代码。需要在下图的位置添加事件：</p><p>待补充图片</p><p>如果你有幸搞过 <code>Qt</code> 或者 <code>.NET FrameWork</code> 的开发，那么一定对这个东西不陌生。熟练使用事件可以让界面的响应更加流畅。下面开始介绍事件的使用，并和后端相关联。</p><h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>说实话，入职 3 个月培训结束后，一直在被安排干前后端开发的活，为他人提供一些网站服务。然而实际是我是一个算法工程师，每天到工位都感觉自己像个傻逼。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写在前面。希望你不会有快速搭建 UI 界面为他人服务这种迫切的需求。虽然这是我的博客，但是我并不希望你搜到他。对于完全未知的领域，快速搭建、快速学习、不会就去学、不会就查、速成，通过这种方式写出来的代码一定是不好的，心累的，事倍功半的，也一定存在多多少少的 &lt;code&gt;bug&lt;/code&gt; 和无法实现的逻辑。&lt;/p&gt;
&lt;p&gt;但也有一个好消息，如果你完全不会前端后端，只会 &lt;code&gt;Python&lt;/code&gt;，看了本文也能搭建完成的前后端服务，但距离入门的全栈工程师还差很远。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://muyuuuu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在 python 操作大文件时节省内存</title>
    <link href="https://muyuuuu.github.io/2023/12/26/python-memory-optimization/"/>
    <id>https://muyuuuu.github.io/2023/12/26/python-memory-optimization/</id>
    <published>2023-12-26T15:09:44.000Z</published>
    <updated>2023-12-28T15:55:03.637Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>没想到有一天写 <code>python</code> 的时候也会想着如何去节省内存。平时写 <code>python</code> 的时候根本不会关注这些，变量什么的直接创建和使用就完了，也不用考虑内存的释放，反正有垃圾回收机制。只不过这次数据量过大，<code>debug</code> 的时候发现内存一直在申请，导致系统彻底的卡死。</p><p>可能也是从事算法的优化工作养成了职业病，每次写代码的时候都会想，这些代码消耗的时间怎么样，占用的空间怎么样，数据结构是否可以继续优化，这些逻辑有没有更优雅的写法。</p><p>注：本文程序中使用 <code>psutil</code> 库来监测进程使用的内存大小，需要 <code>pip install psutil</code>一下。</p><span id="more"></span><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>需要解析一个很大的日志文件，日志文件中含有一些无用的信息，像下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有用信息1</span><br><span class="line">无用信息1</span><br><span class="line">有用信息2</span><br><span class="line">有用信息3</span><br><span class="line">无用信息2</span><br><span class="line">...</span><br><span class="line">有用信息N</span><br></pre></td></tr></table></figure><p>解析文件的时候，需要从文件中解析并提取出有用的信息，存入一个对象中，完成后续的处理。<br>但是呢，对于某些特殊的任务和需求，发现文件只解析一次是不行的，也就是需要对文件进行二次解析。</p><p>所以为了避免重复的解析文件，在第一次文件解析完毕后，直接把有用的核心信息序列化出去，这样二次解析的话就不用重新读取源文件在解析，直接读取序列化后的核心数据就好了。</p><h1 id="序列化导出"><a href="#序列化导出" class="headerlink" title="序列化导出"></a>序列化导出</h1><p>最开始的方案是使用一个 <code>list</code> 持续追加解析得到的核心数据，文件解析完毕后把这个很大的 <code>list</code> 序列化出去。监测到进程占用的内存大小为：700MB。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">    data.append(<span class="built_in">str</span>(random.randint(<span class="number">10000</span>, <span class="number">109070987</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.pkl&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pickle.dump(data, f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前 Python 进程占用的内存</span></span><br><span class="line">memory_info = process.memory_info()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印占用的内存大小，rss 单位为字节</span></span><br><span class="line"><span class="built_in">print</span>(memory_info.rss / <span class="number">1024</span> / <span class="number">1024</span>, <span class="string">&quot;MB&quot;</span>)</span><br></pre></td></tr></table></figure><p>而如果使用序列化追加的方式，仅用 15MB，耗时增加 2s，毕竟每次序列化的时候都需要打开文件并在末尾追加内容：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.pkl&quot;</span>, <span class="string">&quot;ab&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        pickle.dump(<span class="built_in">str</span>(random.randint(<span class="number">10000</span>, <span class="number">109070987</span>)), f)</span><br></pre></td></tr></table></figure><p>这里可以设置一个 <code>buffer</code> 进行优化，<code>buffer</code> 达到一定大小后在统一序列化出去。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SeriesModel</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._buf = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">series</span>(<span class="params">self, stack, finish=<span class="literal">False</span></span>):</span><br><span class="line">        self._buf.append(stack)</span><br><span class="line">        <span class="keyword">if</span> <span class="number">100</span> &lt; <span class="built_in">len</span>(self._buf) <span class="keyword">or</span> finish <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(config.SERIES_PATH, <span class="string">&quot;ab&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> self._buf:</span><br><span class="line">                    pickle.dump(item, f)</span><br><span class="line">                self._buf = []</span><br></pre></td></tr></table></figure><h1 id="序列化读入"><a href="#序列化读入" class="headerlink" title="序列化读入"></a>序列化读入</h1><p>在二次解析的时候，需要把序列化的数据 <code>load</code> 进来。如果加载序列化的文件并且直接处理数据，同样需要使用 700MB 的内存。这种一次性创建所有元素的行为是没有必要的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.pkl&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = pickle.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        i += <span class="string">&quot; &quot;</span></span><br></pre></td></tr></table></figure><p>可以使用惰性计算来解决这一问题，只有在真正需要这个变量的时候才去创建，而不是一开始就创建所有的变量。考虑到生成器表达式的局限性，我们直接使用 <code>yield</code> 关键字创建一个生成器函数。</p><p><code>yield</code> 语句类似 <code>return</code> 会返回一个值，但它会记住这个返回的位置，下次迭代的时候就从这个位置继续执行，返回下一个元素。这样就消耗内存 15MB。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = pickle.load(f)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment"># data 是生成器</span></span><br><span class="line">data = read(<span class="string">&quot;data.pkl&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    i += <span class="string">&quot; &quot;</span></span><br></pre></td></tr></table></figure><h1 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h1><p>任何一个生成器都会定义一个名为 <code>__next__</code> 的方法，这个方法要在最后一个元素之后需抛出 <code>StopIteration</code> 异常。<code>next()</code> 函数的本质就是调用对象的 <code>__next__()</code>。这个方法要么返回迭代的下一项，要么引起结束迭代的异常 <code>StopIteration</code>，下面的示例揭示了生成器的本质。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FibGenerator</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.__n = n</span><br><span class="line"></span><br><span class="line">        self.__s0 = <span class="number">0</span></span><br><span class="line">        self.__s1 = <span class="number">1</span></span><br><span class="line">        self.__count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):  <span class="comment"># 用于内建函数 next()</span></span><br><span class="line">        <span class="keyword">if</span> self.__count &lt; self.__n:</span><br><span class="line">            ret = self.__s0</span><br><span class="line">            self.__s0, self.__s1 = self.__s1, (self.__s0 + self.__s1)</span><br><span class="line">            self.__count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):  <span class="comment"># 用于 for 循环语句</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">fg = FibGenerator(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(fg))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(fg, Iterable))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fg:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.FibGenerator&#x27;</span>&gt;</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>示例中如果没有定义 <code>__iter__()</code> 方法则只能使用 <code>next()</code> 函数进行迭代，当它定义后，就可以使用 <code>for</code> 和 <code>in</code> 语句访问了，同时定义了这两种方法的对象称为迭代器。生成器表达式和生成器函数产生生成器时，会自动生成名为 <code>__iter__</code> 和 <code>__next__</code> 的方法，所以生成器也是一种迭代器。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://pythonhowto.readthedocs.io/zh-cn/latest/iterator.html">https://pythonhowto.readthedocs.io/zh-cn/latest/iterator.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;没想到有一天写 &lt;code&gt;python&lt;/code&gt; 的时候也会想着如何去节省内存。平时写 &lt;code&gt;python&lt;/code&gt; 的时候根本不会关注这些，变量什么的直接创建和使用就完了，也不用考虑内存的释放，反正有垃圾回收机制。只不过这次数据量过大，&lt;code&gt;debug&lt;/code&gt; 的时候发现内存一直在申请，导致系统彻底的卡死。&lt;/p&gt;
&lt;p&gt;可能也是从事算法的优化工作养成了职业病，每次写代码的时候都会想，这些代码消耗的时间怎么样，占用的空间怎么样，数据结构是否可以继续优化，这些逻辑有没有更优雅的写法。&lt;/p&gt;
&lt;p&gt;注：本文程序中使用 &lt;code&gt;psutil&lt;/code&gt; 库来监测进程使用的内存大小，需要 &lt;code&gt;pip install psutil&lt;/code&gt;一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://muyuuuu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>如何写出更好的程序二：尽可能减少代码的修改</title>
    <link href="https://muyuuuu.github.io/2023/11/17/minimize-code-modification/"/>
    <id>https://muyuuuu.github.io/2023/11/17/minimize-code-modification/</id>
    <published>2023-11-17T15:50:00.000Z</published>
    <updated>2023-12-28T15:56:09.489Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>职场新人兼新手程序员斗胆开了新坑「如何写出更好的程序」，所见所得都是来自实际写代码时自己的思考，且已脱敏。这一系列不包含任何复杂的技术，也不包含任何难懂的代码。只是将核心问题暴露出来，针对这些场景，如何写出可维护性更高、更简洁优雅的代码。</p><p>目前仅包括 <code>python</code> 装饰器的使用，等某天遇到其他技术也可以减少代码的修改时，会追加到本文。</p><span id="more"></span><h1 id="使用-Python-装饰器"><a href="#使用-Python-装饰器" class="headerlink" title="使用 Python 装饰器"></a>使用 Python 装饰器</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一开始写代码的时候，都在想着要尽可能的支持全部功能，要获取各种信息并反馈给用户。于是我写了一大堆代码，创建了各种类、各种数据结构，以及实现了各种方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func1</span>(): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>(): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func3</span>(): ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func4</span>(): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func5</span>(): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func6</span>(): ...</span><br></pre></td></tr></table></figure><p>为了高效的获取信息，一些数据可以复用，一些逻辑可以跳过，这样写出来的代码也会错综复杂：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    a = A()</span><br><span class="line">    a.func1()</span><br><span class="line">    b = B()</span><br><span class="line"></span><br><span class="line">    val = some_func()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> val &lt; <span class="number">100</span>:</span><br><span class="line">        a.func3()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        b.func4()</span><br></pre></td></tr></table></figure><p>某天忽然遇到一个新需求：需要增加一个轻量版的代码，只得到 3 个核心信息就好了，其他信息直接忽略掉。这时我回首我的代码发现：为了得到各种信息，之前的代码十分庞大，有很多类，也有很多方法，复杂的逻辑修改起来并不是件很容易的事。</p><ul><li>为了实现轻量版的代码，重写代码肯定是不值得的，毕竟一些代码逻辑和数据结构可以复用。重写代码势必会导致代码文件增加，冗余代码增多。</li><li>如果复用代码，会发现这个类可以不用创建，这个逻辑可以跳过，一些类的成员方法可以不用执行。</li></ul><h2 id="坏代码"><a href="#坏代码" class="headerlink" title="坏代码"></a>坏代码</h2><p>如果在代码中手动添加 <code>lite</code> 这一轻量化参数，遇到不需要执行的代码就根据 <code>lite</code> 写 <code>if else</code> 分支给代码加岔路口，代码结构会十分繁杂。比如有 <code>lite</code> 选项时，我们需要创建 <code>A</code> 这个类，根据临时结果判断是否需要执行 <code>b.func4()</code>，那么上述代码修改为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    lite = <span class="literal">True</span></span><br><span class="line">    a = A()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> lite:</span><br><span class="line">        a.func1()</span><br><span class="line">    b = B()</span><br><span class="line">        </span><br><span class="line">    val = some_func()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> val &lt; <span class="number">100</span> <span class="keyword">and</span> lite:</span><br><span class="line">        a.func3()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        b.func4()</span><br></pre></td></tr></table></figure><p>对于 1000 多行更加复杂的代码，手动添加 <code>lite</code> 分支并修改逻辑，这是很累的工作，写出来的代码也不好看，通用性也随之变差。</p><h2 id="装饰器优化"><a href="#装饰器优化" class="headerlink" title="装饰器优化"></a>装饰器优化</h2><p>此时我们可以使用装饰器来完成这一工作，如果不知道装饰器是什么东西可以参考我之前的<a href="https://muyuuuu.github.io/2020/01/07/python-wrapper/">文章</a>。在装饰器中首先传入 <code>self</code> 参数，如果检测到类的 <code>lite</code> 属性为 <code>true</code>，直接跳过这一函数不执行。此时我们只需要打开需要改动的类，增加 <code>lite</code> 属性。</p><p>如果确定这个方法可以不执行，给方法增加装饰器即可。而对于 <code>main</code> 函数中的代码，是不需要任何修改的，也不需要增加大量的 <code>if else</code> 分支，减少代码结构的修改和破坏。逻辑处理部分的代码如下所示，相比坏代码部分精简了很多，且 <code>a.func1</code> 和 <code>a.func3</code> 都是不会执行的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">use_lite</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_lite:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> func(self, *args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, lite=<span class="literal">False</span></span>):</span><br><span class="line">        self.lite = <span class="literal">True</span></span><br><span class="line"><span class="meta">    @use_lite</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func1</span>(): ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    a = A(<span class="literal">True</span>)</span><br><span class="line">    a.func1()</span><br><span class="line">    b = B()</span><br><span class="line">        </span><br><span class="line">    val = some_func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> val &lt; <span class="number">100</span>:</span><br><span class="line">        a.func3()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        b.func4()</span><br></pre></td></tr></table></figure><p>补充：<code>@use_lite(self.lite)</code> 是会报错的，因为装饰器是外部方法，并不是类的成员，也就无法捕捉类对象。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;职场新人兼新手程序员斗胆开了新坑「如何写出更好的程序」，所见所得都是来自实际写代码时自己的思考，且已脱敏。这一系列不包含任何复杂的技术，也不包含任何难懂的代码。只是将核心问题暴露出来，针对这些场景，如何写出可维护性更高、更简洁优雅的代码。&lt;/p&gt;
&lt;p&gt;目前仅包括 &lt;code&gt;python&lt;/code&gt; 装饰器的使用，等某天遇到其他技术也可以减少代码的修改时，会追加到本文。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Design" scheme="https://muyuuuu.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>如何写出更好的程序一：用好配置文件和减少硬编码</title>
    <link href="https://muyuuuu.github.io/2023/10/18/data-config-and-decrease-hard-coding/"/>
    <id>https://muyuuuu.github.io/2023/10/18/data-config-and-decrease-hard-coding/</id>
    <published>2023-10-18T15:15:26.000Z</published>
    <updated>2023-12-29T11:01:32.908Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>职场新人兼新手程序员斗胆开了新坑「如何写出更好的程序」，所见所得都是来自实际写代码时自己的思考，且已脱敏。这一系列不包含任何复杂的技术，也不包含任何难懂的代码。只是将核心问题暴露出来，针对这些场景，如何写出可维护性更高、更简洁优雅的代码。</p><p>以 <code>python</code> 为例，本文的主要内容包括：如何使用配置文件，以及如何减少代码中的硬编码，引申到了代码的组织架构和可维护性上。</p><span id="more"></span><h1 id="如何使用好配置文件"><a href="#如何使用好配置文件" class="headerlink" title="如何使用好配置文件"></a>如何使用好配置文件</h1><h2 id="针对一个代码文件使用配置文件的情况"><a href="#针对一个代码文件使用配置文件的情况" class="headerlink" title="针对一个代码文件使用配置文件的情况"></a>针对一个代码文件使用配置文件的情况</h2><p>假设只有在 <code>main.py</code> 中需要读取配置文件，将配置文件的部分变量以传参的形式交给其他函数使用，这是最简单的场景。举个简单的例子，如果是生产环境，那么 <code>env=debug</code>；如果是开发环境，那么 <code>env=release</code>，当然这是从配置文件里读取得到的。考虑复杂一些的情况，如果是用户 DIY 使用，可能需要的变量并不在配置文件中。</p><p>对于这一场景，建议将配置文件写到 <code>config.py</code> 中，并且用一个类进行封装，变量就是类的成员。当需要根据生产或开发环境执行不同的代码时，只需要在类内进行判断即可。当用户需要增加其他变量时，由用户继承这一个类并添加自己的变量和方法就好。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.env1 = ...</span><br><span class="line">        self.env2 = ...</span><br><span class="line">        self.__setup()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setup</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.env1 == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">            func1()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            func3()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.env2 == <span class="string">&quot;2&quot;</span>:</span><br><span class="line">            func2()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            func4()</span><br></pre></td></tr></table></figure><h2 id="针对多个文件使用配置文件的情况"><a href="#针对多个文件使用配置文件的情况" class="headerlink" title="针对多个文件使用配置文件的情况"></a>针对多个文件使用配置文件的情况</h2><p>如果此时有几十个代码文件都需要读取配置文件，获取其中的变量并执行对应的代码，总不能每个文件都创建一个类对象并初始化吧。你说参数传递？如果函数的传参很困难又该怎么办呢？具体而言，当开发后端的时候，<code>main.py</code> 读取配置文件并得到了 <code>env=debug</code>，此时打开了网页，点击一些按钮完成一些交互，则 <code>web</code> 端会通过 <code>js</code> 发起了一个 <code>post</code> 请求，告诉你需要执行某些代码，这个请求被 <code>handler.py</code> 拦截到。</p><p>此时存在一个问题：<code>handler.py</code> 中的 <code>get</code> 方法拦截到 <code>web</code> 端请求，并不是 <code>main.py</code> 直接将请求发送到 <code>handler.py</code>。所以此时不能直接传递参数，<code>handler.py</code> 也并不知道 <code>env=debug</code>，所以可能不知道执行哪些代码。再去重新实例化一个类？几十个代码文件都去实例化同一个类，未免浪费空间。</p><p>简单的参数可以加到 <code>post</code> 请求的 <code>url</code> 里，但是当参数高达十几个时，传参和接收参数这会很麻烦。何况配置文件就在那里，<code>handler.py</code> 直接获取会方便很多。这个时候建议将配置文件写到 <code>config.py</code> 中，但不是以类的形式，而是直接写入变量并赋值，如 <code>ENV=&quot;DEBUG&quot;</code>。当任何文件需要读取这一变量时，直接 <code>import config; config.ENV</code> 便可获取。有点类似 <code>C</code> 语言中的 <code>#define</code>。</p><h2 id="yaml-或者-json？"><a href="#yaml-或者-json？" class="headerlink" title="yaml 或者 json？"></a>yaml 或者 json？</h2><p>还有一些通过读取 <code>yaml</code>，<code>json</code> 等配置文件来生成变量的，但是这会不可避免的增加代码中的硬编码，而且只能获取变量。根据变量去判断执行哪些方法需要单独实现，所以没有考虑使用。具体而言：</p><ul><li><p>对于情景一中的代码，用类实现配置文件的话可以直接调用类内的 <code>__setup()</code> 方法。如果是 <code>yaml</code> 文件，从文件加载到 <code>env1, env2</code> 后，需要单独去写情景一例子中的 <code>__setup()</code> 方法，不如封装到类内方便。</p></li><li><p>对于情景二，如果几十个代码文件都去执行 <code>import yaml; yaml.load()</code> 来获取配置文件中的变量，这又会造成大量的文件 <code>IO</code>，没有意义。这也是我不考虑使用 <code>yaml,json</code> 作为配置文件的原因。</p></li></ul><h1 id="减少代码的硬编码"><a href="#减少代码的硬编码" class="headerlink" title="减少代码的硬编码"></a>减少代码的硬编码</h1><p>在有了配置文件后，可以有效减少代码中的硬编码，增强代码的可维护性。比如创建了一个字典：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">&quot;name&quot;</span>]     = ...</span><br><span class="line">data[<span class="string">&quot;value&quot;</span>]    = ...</span><br><span class="line">data[<span class="string">&quot;children&quot;</span>] = ...</span><br></pre></td></tr></table></figure><p>但是此时后台的接口忽然发生了变化，<code>children</code> 这个名字忽然改成了 <code>subfunc</code>，后台解析只认 <code>data[&quot;subfunc&quot;]</code> 这个字段，上面的写法需要去所有代码文件里一个个的搜索 <code>&quot;children&quot;</code> 并替换为 <code>&quot;subfunc&quot;</code>，显然是很累又不得不干的活。这个时候可以使用配置文件：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config.py</span><br><span class="line">CHILDREN = <span class="string">&quot;children&quot;</span></span><br><span class="line"></span><br><span class="line">main.py</span><br><span class="line"><span class="keyword">import</span> config</span><br><span class="line">data[config.CHILDREN] = ...</span><br></pre></td></tr></table></figure><p>如果再遇到 <code>children</code> 名字改成了 <code>subfunc</code>，只需要在 <code>config.py</code> 里修改 <code>CHILDREN</code> 的取值就可以了，只需要修改一次，比上面的实现优雅一些。</p><h2 id="重灾区：函数返回值"><a href="#重灾区：函数返回值" class="headerlink" title="重灾区：函数返回值"></a>重灾区：函数返回值</h2><p>另一个硬编码重灾区是函数的返回值，众所周知 <code>python</code> 函数是可以有多个返回值的，对于暂时不需要的返回值可以用下划线忽略掉。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">return</span> name, info, value, key, address, flag, context</span><br><span class="line"></span><br><span class="line">name, info, value, key, address, _, context = func()</span><br></pre></td></tr></table></figure><p>其实上面获取函数返回值的形式更像列表的切片：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">return</span> name, info, value, key, address, flag, context</span><br><span class="line"></span><br><span class="line">return_val = func()</span><br><span class="line">name = return_val[<span class="number">0</span>]</span><br><span class="line">info = return_val[<span class="number">1</span>]</span><br><span class="line">value = return_val[<span class="number">2</span>]</span><br><span class="line">key = return_val[<span class="number">3</span>]</span><br><span class="line">address = return_val[<span class="number">4</span>]</span><br><span class="line">context = return_val[<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>可以看到，如果要调用 <code>func</code> 函数，就必须牢记返回值的顺序，当代码文件很多时并不友好，也不优雅。当需要增加或减少返回值的数量时，切片访问函数返回值的形式也很难处理。比如当不需要返回 <code>name</code> 字段时，或者需要增加一个 <code>param</code> 参数，下标都需要修改。增加返回值时， 别说把这个返回值放到所有函数返回值的最后，这只是为了代码能运行起来做的妥协，没意思。以上情况对于调用 <code>func</code> 的函数而言都需要一个个手动修改，简直是一场灾难。</p><p>这个时候建议使用类对象或者字典，道理是一样的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: name,</span><br><span class="line">        <span class="string">&quot;info&quot;</span>: info</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样，就在也不需要记住返回值的顺序，也不必担心函数增加或减少返回值，甚至不用关注返回值的顺序。都可以直接通过字典的 <code>key</code> 访问。你说 <code>&quot;name&quot;, &quot;info&quot;</code> 这样的硬编码不好？可以用前面讲述的配置文件避免掉它呀。</p><p><code>C</code> 这种语言并不支持函数返回多个变量，需要返回多个变量时都是使用结构体来完成，这种想法值得借鉴。对于 <code>python</code> 语言，字典也好，类对象也罢（对象的话就是通过成员访问），取决于具体的适用场景，但是都可以避免通过切片这样的硬编码方式去获取函数的返回值。</p><h2 id="使用类规范函数返回值"><a href="#使用类规范函数返回值" class="headerlink" title="使用类规范函数返回值"></a>使用类规范函数返回值</h2><p>对于一个函数，接受原生的数据 <code>raw_data</code> 完成解析，并返回各种信息数据：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">raw_data</span>):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> info1, info2, info3, info4, info5, info6</span><br></pre></td></tr></table></figure><p>但是其他函数使用返回值时，info1到info6这些信息并不是全部都需要使用。有时候仅仅需要使用 <code>info1</code> 和 <code>info4</code>，很烂的写法有两种：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> </span><br><span class="line">info1, _, _, info4, _, _ = func(raw_data)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line">data = func(raw_data)</span><br><span class="line">info1 = data[<span class="number">0</span>]</span><br><span class="line">info4 = data[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>上述写法，当 <code>func</code> 函数发生变化，如：增加其他返回值、删除无用的返回值时，对于代码维护而言都是一场灾难。千万不要假设需求不会变化，也不要假设针对接口编程时接口始终不变，永远不知道会面临什么新的鬼需求和变动。就算是针对接口编程，每个函数的返回值是什么，返回值的顺序都需要记住，是一种很累的事情。</p><p>除了上文讲述的使用字典或者类之外，还有一种其他方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__idx = &#123;</span><br><span class="line">            <span class="string">&quot;info1&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;info2&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;info3&quot;</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">&quot;info4&quot;</span> : <span class="number">3</span>,</span><br><span class="line">            <span class="string">&quot;info5&quot;</span> : <span class="number">4</span>,</span><br><span class="line">            <span class="string">&quot;info6&quot;</span> : <span class="number">5</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_item</span>(<span class="params">self, data, args</span>):</span><br><span class="line">        return_val = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">            return_val.append(data[self.__idx[i]])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(return_val) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> return_val[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> return_val</span><br><span class="line"></span><br><span class="line">info = Info()</span><br><span class="line">info1, info2 = info.get_item(func(raw_data), [<span class="string">&quot;info1&quot;</span>, <span class="string">&quot;info2&quot;</span>])</span><br></pre></td></tr></table></figure><p>只需要创建一个对象，在 <code>get_item</code> 这个函数的参数中指定自己想要获取的参数和顺序即可。即使函数 <code>func</code> 的返回值发生了顺序、数量等方面的变化，也只需要修改一下 <code>__idx</code> 成员即可。</p><p>仿佛不如字典简单？确切来说，这种方法有自己的适用场景：当 <code>A</code> 函数获取 <code>info.get_item</code> 信息后需要进行 <code>postA</code> 的后处理，当 <code>B</code> 函数获取 <code>info.get_item</code> 信息后需要进行 <code>postB</code> 的后处理。这样，就可以把 <code>postA</code> 和 <code>postB</code> 放入到 <code>class Info</code> 中，将分散到各地的相同逻辑的代码整合到一起。至于 <code>&quot;info1&quot;</code> 和 <code>&quot;info2&quot;</code> 这种硬编码，也可以用前面讲的东西规避掉。</p><p>需要注意的是，这种实现是比较耗时的。如果这个方法到处被调用，会增加程序的执行时间。耗时这一点是通过 <code>py-spy + speedscope</code> 这两个工具发现的，推荐一下这两个工具，用来观察 <code>python</code> 代码中的性能瓶颈。</p><h1 id="关于代码的组织架构"><a href="#关于代码的组织架构" class="headerlink" title="关于代码的组织架构"></a>关于代码的组织架构</h1><p>文件、文件夹都要做好各司其职，不要怕麻烦，写好 <code>__init__.py</code>，不要把很多文件胡乱的扔到单个文件夹里随意的调用，甚至没有文件夹。时间长了或者当别人用的时候，真的很乱。这次任务我实现了经典的 <code>MVC</code> 模式。</p><ul><li><code>model</code> 就是数据解析，存储和维护一些数据结构，如果想要的数据不能直接获取，也可以在 <code>model</code> 里增加一些获取数据的接口。建议将 <code>model</code> 封装为一个类，在一个方法里读取文件，解析得到数据结构，并放到类成员中，方便接口调用获取数据，也避免重复读文件和数据传来传去带来的拷贝开销。交由一个对象去维护数据，由对象的接口去操作数据。而不是将数据读取放到全局变量，任由各个代码、各个函数随意操作。</li><li><code>view</code> 是数据的展示，以什么形式和结构展示给用户，显示界面、写出文件或命令行输出等形式；</li><li><code>control</code> 是交互的控制，用于捕捉用户请求，按照请求访问 <code>model</code> 的接口并获得想要的数据，再调用 <code>view</code> 接口反馈给用户。</li></ul><p>当需要获取很多种类型的数据时，开发重点在 <code>model</code> 部分，因为 <code>control</code> 只是调用获取数据的接口，<code>view</code> 只是展示数据。当需要 <code>A</code> 类型的数据时，<code>control</code> 调用 <code>model</code> 的 <code>getA()</code> 方法即可，当需要 <code>B</code> 类型的数据时，调用 <code>model</code> 的 <code>getB()</code> 方法。</p><p>重点就是这两个方法去如何实现，如何设计高效的数据结构去维护数据，来减少数据的拷贝和优化获取数据的效率。总不能 <code>getA()</code> 的时候重新读文件，<code>getB()</code> 的时候再去读文件，对吧。这就需要在 <code>model</code> 部分下工夫，比如这次就用到了数据结构中经典的 <code>dfs</code>+树的后根法快速解析了数据。<del>leetcode 没白刷了属于是</del></p><h1 id="关于代码维护"><a href="#关于代码维护" class="headerlink" title="关于代码维护"></a>关于代码维护</h1><p>额外的，在开发 <code>model</code> 时也有其他的收获：写代码尽可能将各个模块独立封装，写出高内聚，低耦合的传说级代码。虽然当函数很多时会很看着有些乱，怎么到处是函数？但是也有重要的优点：代码和数据重用方便。比如要增加一个新功能，只需要写一点函数，其他函数也许已经实现了，我们直接调用就好，而且不易出错。</p><p>如果写一个大函数完成一个功能 <code>A</code>，在写另外一个大函数完成功能 <code>B</code>，这两个大函数操作的变量会有重叠，也会有一些重复的逻辑。当其中的逻辑过于复杂时，难免出错。十分建议将功能剥离开来。</p><p>这种低耦合+配置文件的形式也可以灵活的解决一些暂时不确定的场景。领导告诉你说：暂时有 <code>A，B，C，D，E</code> 这五种类型，需要分类处理，后面可能会有改动。你兴冲冲的把这些类型作为字典的 <code>key</code> 完成了分类处理。</p><p>某天领导又说，把 <code>A，B，C</code> 归类为类型 1，把 <code>D，E</code> 归类为类型 2，根据不同的类型创建不同的文件夹，但是后面可能还会变动。不到半小时，又收到通知说把 <code>D</code> 归为类型 1，<code>A</code> 的名字改为 <code>Afunc</code>，删除类型 2，并增加 <code>F，G，H</code> 为类型 3。既要修改类型，又要映射关系，去大段的代码函数里修改这些内容真的很累的，也很容易出错。这个时候可以在配置文件里写一个映射函数，每次修改这个小函数并调用就可以了。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">map</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> [<span class="string">&quot;Afunc&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> name <span class="keyword">in</span> [<span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>， <span class="string">&quot;H&quot;</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结，<strong>不要假设需求是不变的，这样写出来的代码很烂；需求发生改变时，代码修改难度也很大。</strong></p><ul><li>它就应该是这样，不存在其他情况；</li><li>这种情况不会出现，就先不考虑了；</li></ul><p>程序员最好杜绝以上想法，不然写代码一时爽，改代码火葬场。场景会发生变化，需求永远是在变化。异常情况做好处理，减少代码的硬编码，降低代码功能的耦合度，针对接口编程，学过的设计模式也都可以用起来。避免需求发生变化时大量的修改代码，尽可能通过增加新接口和新函数来适应新的需求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;职场新人兼新手程序员斗胆开了新坑「如何写出更好的程序」，所见所得都是来自实际写代码时自己的思考，且已脱敏。这一系列不包含任何复杂的技术，也不包含任何难懂的代码。只是将核心问题暴露出来，针对这些场景，如何写出可维护性更高、更简洁优雅的代码。&lt;/p&gt;
&lt;p&gt;以 &lt;code&gt;python&lt;/code&gt; 为例，本文的主要内容包括：如何使用配置文件，以及如何减少代码中的硬编码，引申到了代码的组织架构和可维护性上。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Design" scheme="https://muyuuuu.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>git 实操记录</title>
    <link href="https://muyuuuu.github.io/2023/09/13/git-use-1/"/>
    <id>https://muyuuuu.github.io/2023/09/13/git-use-1/</id>
    <published>2023-09-13T15:16:44.000Z</published>
    <updated>2023-11-13T15:51:09.774Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2023.7.10 入职距今已经两个月零 3 天了，培训课程十分紧张也没来得及做一些技术的思考和整理。<del>主要是下班回家后只想躺着玩手机，周末持续性出去撒欢。</del> 但只学习不思考和整理是程序员的忌讳。培训课程结束后，会对这两个月的培训时间进行思考，同时对未来该怎么更好的工作也进行一个思考，甚至包括如何更好的休息锻炼来保持充沛的精力。</p><p>回到正文，<code>git</code> 是程序员写框架和交流代码时的必要工具，而<strong>过于贫瘠的实操经验导致我真的不会这玩意</strong>。尤其是多人协作 <code>pull, merge</code> 或者 <code>reset</code> 时，时常把代码搞的乱七八糟。所以在这里记录 <code>git</code> 的踩坑记录。</p><span id="more"></span><h1 id="git-开发流程"><a href="#git-开发流程" class="headerlink" title="git 开发流程"></a>git 开发流程</h1><p>首先克隆仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@xxx.git</span><br></pre></td></tr></table></figure><p>创建本地分支，并对应远程分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -a         // 查看分支</span><br><span class="line">git checkout -b local_branch remote_branch // 切换分支并对应远程分支</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取新分支"><a href="#获取新分支" class="headerlink" title="获取新分支"></a>获取新分支</h2><p><code>clone</code> 仓库的 1 天后，有新分支提交到了远程仓库，所以本地没有这个分支。为了查看新分支的代码，需要更新分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote update origin -p</span><br></pre></td></tr></table></figure><h1 id="暂存修改"><a href="#暂存修改" class="headerlink" title="暂存修改"></a>暂存修改</h1><p>在新分支开发代码时，遇到紧急任务需要切换到其他分支修复漏洞。但是新分支的代码才写了一点点还没有 <code>commit</code>，如果直接 <code>git checkout</code> 会报错，因为新分支的修改没有被存下来或提交。此时可以暂存修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash                  // 暂存当前未提交的更改</span><br><span class="line">git checkout &lt;branch_name&gt; // 切换到另一个分支</span><br></pre></td></tr></table></figure><p>当你完成其他工作并切换回原分支时，可以使用以下命令还原暂存的更改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>不建议以下的操作，因为这会直接放弃当前分支的修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -f &lt;branch_name&gt; // 切换到另一个分支并丢弃未提交的更改</span><br></pre></td></tr></table></figure><h1 id="git-开发时，A-分支的代码泄漏到了-B-分支-？"><a href="#git-开发时，A-分支的代码泄漏到了-B-分支-？" class="headerlink" title="git 开发时，A 分支的代码泄漏到了 B 分支 ？"></a><code>git</code> 开发时，A 分支的代码泄漏到了 B 分支 ？</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>当时想实现 <code>master</code> 分支只有 <code>README.md, .gitignore, 3rdparty</code> 等公共文件。</p><ul><li>对于任务一，新建 <code>dev1</code> 分支，并在 <code>dev1</code> 文件夹里面写代码</li><li>对于任务二，新建 <code>dev2</code> 分支，并在 <code>dev2</code> 文件夹里面写代码</li></ul><p>这样 <code>dev1</code> 和 <code>dev2</code> 分支的代码位于不同文件夹，互不干扰。最后全部合并到 <code>master</code> 分支的时候，也不会产生冲突。</p><h2 id="错误操作"><a href="#错误操作" class="headerlink" title="错误操作"></a>错误操作</h2><p>在实现期间出现了一个漏洞，当完成 <code>dev1</code> 任务的代码后，直接在 <code>dev1</code> 分支下 <code>git checkout -b dev2</code>，这样就会发生：<code>dev2</code> 分支下有 <code>dev1</code> 的代码，不是很优雅。</p><p>当时培训课程的进度比较紧张，也没有刻意去关注这个问题。只是在 <code>dev2</code> 分支下手动删除了 <code>dev1</code> 文件夹的代码，这样在 <code>git status</code> 的时候会看到很多 <code>delete</code> 信息，且会随着 <code>dev2</code> 分支的提交而提交到 <code>gitlab</code> 中，<code>merge</code> 时会看到很多无用的删除文件信息。</p><h2 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a>正确做法</h2><p>随着课程的陆续学习，框架规模越来越大，代码文件也越来越复杂。由于自己的 <code>git</code> 实操很少，担心 <code>git</code> 误操作后导致分支或文件过于混乱。又回过头来重新看这一问题，在本地进行一些简单的实验后发现了正确做法。</p><p>在完成 <code>dev1</code> 分支的代码并提交后，应该 <code>git checkout master</code>，在 <code>master</code> 分支下新建 <code>dev2</code> 分支，这样才能实现 <code>dev2</code> 分支不含 <code>dev1</code> 的代码，保证提交代码时的信息足够干净。</p><h1 id="临时代码推送"><a href="#临时代码推送" class="headerlink" title="临时代码推送"></a>临时代码推送</h1><p>临时创建了一个文件夹复现了某个问题，需要把这份代码提交到某个仓库。在 <code>git init</code> 之后增加远程仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@xxx:xxx.git</span><br></pre></td></tr></table></figure><p>因为是临时新建的仓库，所以目前处于 <code>master</code> 分支。执行下面命令，将本地的 <code>master</code> 分支推送到远程的 <code>test</code> 分支（远程没有的话会自动创建）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master:test     // 不加 master: 会报错，因为本地没有 test 分支</span><br></pre></td></tr></table></figure><h1 id="修改错别字，不值得重新-commit"><a href="#修改错别字，不值得重新-commit" class="headerlink" title="修改错别字，不值得重新 commit"></a>修改错别字，不值得重新 commit</h1><p>首先修改小错误，然后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commmit --amend</span><br></pre></td></tr></table></figure><p>如果此时直接 <code>push</code> 会报错，因为 <code>git status</code> 显示并没有新的内容。如果是提交到自己的分支，在不影响他人的开发的情况下可以直接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master:test -f</span><br></pre></td></tr></table></figure><p>这样仓库上只显示一次 <code>commit</code> 记录。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2023.7.10 入职距今已经两个月零 3 天了，培训课程十分紧张也没来得及做一些技术的思考和整理。&lt;del&gt;主要是下班回家后只想躺着玩手机，周末持续性出去撒欢。&lt;/del&gt; 但只学习不思考和整理是程序员的忌讳。培训课程结束后，会对这两个月的培训时间进行思考，同时对未来该怎么更好的工作也进行一个思考，甚至包括如何更好的休息锻炼来保持充沛的精力。&lt;/p&gt;
&lt;p&gt;回到正文，&lt;code&gt;git&lt;/code&gt; 是程序员写框架和交流代码时的必要工具，而&lt;strong&gt;过于贫瘠的实操经验导致我真的不会这玩意&lt;/strong&gt;。尤其是多人协作 &lt;code&gt;pull, merge&lt;/code&gt; 或者 &lt;code&gt;reset&lt;/code&gt; 时，时常把代码搞的乱七八糟。所以在这里记录 &lt;code&gt;git&lt;/code&gt; 的踩坑记录。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Git" scheme="https://muyuuuu.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>优雅的解决 hexo 推送 index.html 内容为空的奇奇怪怪</title>
    <link href="https://muyuuuu.github.io/2023/07/04/hexo-index-null/"/>
    <id>https://muyuuuu.github.io/2023/07/04/hexo-index-null/</id>
    <published>2023-07-04T10:52:48.000Z</published>
    <updated>2023-07-05T09:05:13.461Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>某天闲来无聊的时候，恍惚的发现我竟然还有个博客？主要是太忙了。 <del>其实是自己过于懈怠没学新东西，休息了半年多也没缓过来</del>。尝试推送了一下，也许是某次滚动更新 Linux 的时候升级了 <code>Node.js</code> ，结果 <code>Node.js</code> 版本过高和 <code>hexo</code> 版本不匹配。这就导致博客推送后， github 仓库中全部的 <code>html</code> 文件内容为空。网上绝大多数博客都是写的降级 <code>Node.js</code>，但这总不是办法，所以不如升级 <code>hexo</code> 来解决问题。</p><span id="more"></span><p>也许在大学的时候遇到过：代码或者软件无法跑通的情况，去问学长或者老师的时候他们就会说，你用的版本太新了，新版本不好用，换成旧版本和我一样就没问题了。总会有人因为可以方便的向老师或者学长提问而屈服于选择旧软件。但从软件开发和维护的角度而言，软件在不断的更新，旧版本无人维护或功能不全。事物在不断的发展，古人都知道不要刻舟求剑，为何抱着老旧软件不放而不选择新软件呢？对于个人使用而言，咬咬牙解决一些 bug 或者版本冲突，问题也就解决了。扯远了，一共两种解决方案，分别是 <code>Node.js</code> 降级或者 <code>hexo</code> 升级，本文推荐后者。</p><h1 id="hexo-与-Node-js-的版本对应关系"><a href="#hexo-与-Node-js-的版本对应关系" class="headerlink" title="hexo 与 Node.js 的版本对应关系"></a>hexo 与 Node.js 的版本对应关系</h1><p>打开 <code>hexo</code> 的<a href="https://hexo.io/zh-cn/docs/index.html">官方文档</a>可以看到 <code>hexo</code> 与 <code>Node.js</code> 的版本对应关系：</p><div class="table-container"><table><thead><tr><th><code>hexo</code> 版本</th><th>最低版本 (<code>Node.js</code> 版本)</th><th>最高版本 (<code>Node.js</code> 版本)</th></tr></thead><tbody><tr><td>6.2+</td><td>12.13.0</td><td>latest</td></tr><tr><td>6.0+</td><td>12.13.0</td><td>18.5.0</td></tr><tr><td>5.0+</td><td>10.13.0</td><td>12.0.0</td></tr><tr><td>4.1 - 4.2</td><td>8.10</td><td>10.0.0</td></tr><tr><td>4.0</td><td>8.6</td><td>8.10.0</td></tr><tr><td>3.3 - 3.9</td><td>6.9</td><td>8.0.0</td></tr><tr><td>3.2 - 3.3</td><td>0.12</td><td>未知</td></tr><tr><td>3.0 - 3.1</td><td>0.10 或 iojs</td><td>未知</td></tr><tr><td>0.0.1 - 2.8</td><td>0.10</td><td>未知</td></tr></tbody></table></div><p>由于我的博客是在 20 年初迁移到新电脑的，<code>hexo</code> 是 3.9.0 的旧版本，而 <code>Node.js</code> 被更新到 20.3.1，也就是版本不匹配，导致博客一波被清空，各种 <code>html</code> 文件没有任何内容。</p><h1 id="Plan1：Node-js-降级"><a href="#Plan1：Node-js-降级" class="headerlink" title="Plan1：Node.js 降级"></a>Plan1：Node.js 降级</h1><p>打开浏览器搜索，这个就是绝大多数的解决方案。这里建议使用 <code>nvm</code> 管理 <code>Node.js</code> 的版本，之后对 <code>nvm</code> 换源，并安装各个版本的 <code>Node.js</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Ss nvm  // 安装</span><br><span class="line">export NVM_Node.js_ORG_MIRROR=https://npm.taobao.org/mirrors/node/  // 换源</span><br><span class="line">nvm install 12.0.0 // 选择适配 3.9.0 的 nodejs 版本</span><br></pre></td></tr></table></figure><p>通过上述命令，如果没有遇到其他奇怪的 bug 的话，<code>Node.js</code> 12.0 版本就被安装成功了。由于 <code>hexo</code> 默认使用系统安装的 <code>Node.js</code>，而不是 <code>nvm</code> 安装的 <code>Node.js</code>。所以在每次更新博客时需要调用 <code>nvm</code> 切换 <code>Node.js</code> 版本进行推送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm use 12.0.0 // 切换版本</span><br><span class="line">hexo g --d     // 推送博客</span><br></pre></td></tr></table></figure><p>而且由于 <code>hexo</code> 默认使用系统安装的 <code>Node.js</code>，这个版本的 <code>Node.js</code> 不被 <code>nvm</code> 所管理，所以每次推送必须使用 <code>use</code> 命令来切换版本，这个就很繁琐，不够优雅。下述命令是无法起作用的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm alias default 12.0.0</span><br></pre></td></tr></table></figure><p>此时虽然能推送博客，但由于 <code>hexo</code> 版本过低，在推送时仍然会提示有异常信息：<code>ERROR Plugin load failed: hexo-cli</code>，反正就看着很不爽。</p><p><img data-src="https://user-images.githubusercontent.com/43681138/250651466-27494e36-ce61-41e4-b668-ed1f9cd2d7b5.png" alt></p><p>此外，我使用了 <code>fish</code> 终端，这个终端安装和使用 <code>nvm</code> 有些许的费劲，这里给个<a href="https://eshlox.net/2019/01/27/how-to-use-nvm-with-fish-shell/">教程</a>，防止未来某天我自己忘掉。</p><h1 id="Plan2：hexo-升级"><a href="#Plan2：hexo-升级" class="headerlink" title="Plan2：hexo 升级"></a>Plan2：hexo 升级</h1><p>如上所述，软件升级是不可避免的，每次推送博客需要使用 <code>nvm</code> 去切换版本也过于繁琐。那不如直接升级 <code>hexo</code> 一劳永逸？</p><p>我当时是卸载了全部的 <code>npm，Node.js hexo</code> 重新安装。备注：<code>nvm</code> 是 <code>Node.js</code> 的版本管理工具，<code>npm</code> 是 <code>Node.js</code> 下面的库安装工具，类似 python 的 <code>pip</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-cli          // 卸载 hexo</span><br><span class="line">sudo pacman -Rsc -n nodejs      // 卸载 nodejs</span><br><span class="line">sudo pacman -Sy nodejs          // 重新安装 nodejs</span><br><span class="line">sudo pacman -Sy npm             // 重新安装 npm</span><br></pre></td></tr></table></figure><p>之后，给 <code>npm</code> 换源，并安装 <code>hexo</code> 即可，备注：如果安装无响应或无权限，给下面的命令加个 <code>sudo</code> 即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org // 换源</span><br><span class="line">npm install -g hexo-cli // 安装 hexo</span><br></pre></td></tr></table></figure><p>但是呢我发现，安装后的 <code>hexo</code> 依然是 3.9.0 的旧版本，所以我选择给 <code>hexo</code> 升级，同样，下面的命令如果无法执行时，就加个 <code>sudo</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean -f     //清除缓存</span><br><span class="line">// 进入 Hexo 根目录，执行如下命令</span><br><span class="line">npm install -g npm-check       // 检查之前安装的插件，都有哪些是可以升级的 </span><br><span class="line">npm install -g npm-upgrade     // 升级系统中的插件</span><br><span class="line">npm-check</span><br><span class="line">npm-upgrade</span><br><span class="line"></span><br><span class="line">npm update     // 更新 Hexo 及所有插件</span><br></pre></td></tr></table></figure><p>这样，就升级了 <code>hexo</code>，本文升级到了 6.3.0，正好适配最新的 <code>Node.js</code>，推送博客没有任何问题。</p><p>由于我的博客主题配置文件好多年没有更新，而最新的 <code>hexo</code> 和博客的 <code>_config.yaml</code>还有一个冲突：<code>external_link</code> 报错，只需要打开博客配置文件 <code>_config.yaml</code>，找到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">external_link: true # Open external links in new tab</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">external_link:</span><br><span class="line">  enable: true # Open external links in new tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: &#x27;&#x27;</span><br></pre></td></tr></table></figure><p>至此，<code>hexo</code> 推送博客时没有任何报错，清清爽爽。</p><h1 id="一些彩蛋"><a href="#一些彩蛋" class="headerlink" title="一些彩蛋"></a>一些彩蛋</h1><p>当时本人对于如何解决这个问题也是一头雾水，胡乱的查阅各种文档，走了很多弯路，试了很多错，在无数次卸载重装后解决了问题。期间一个手滑把 <code>node_modules</code> 给删除了，后面重新安装了数学渲染的库，但 <code>equation</code> 和 <code>aligned</code> 这种环境依然无法被正确渲染，处于乱码的状态，按照<a href="https://mercer5.github.io/2021/10/31/hexo%E6%B8%B2%E6%9F%93%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">这一文章</a>可以正确修复行间公式无法渲染的漏洞。</p><p>该上班了，学到新知识后也许博客可以勤快的更新起来？哦对还有，查阅文档时看到的一个乐子：</p><p><img data-src="https://s1.ax1x.com/2023/07/04/pCs78OO.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://guoguocai.github.io/2022/06/05/%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7-Hexo-%E7%89%88%E6%9C%AC/">npm 升级 hexo</a></li><li><a href="https://boriskp.github.io/upgrade-hexo-to-v5-1-1/">hexo版本更新报错： “external_link”</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;某天闲来无聊的时候，恍惚的发现我竟然还有个博客？主要是太忙了。 &lt;del&gt;其实是自己过于懈怠没学新东西，休息了半年多也没缓过来&lt;/del&gt;。尝试推送了一下，也许是某次滚动更新 Linux 的时候升级了 &lt;code&gt;Node.js&lt;/code&gt; ，结果 &lt;code&gt;Node.js&lt;/code&gt; 版本过高和 &lt;code&gt;hexo&lt;/code&gt; 版本不匹配。这就导致博客推送后， github 仓库中全部的 &lt;code&gt;html&lt;/code&gt; 文件内容为空。网上绝大多数博客都是写的降级 &lt;code&gt;Node.js&lt;/code&gt;，但这总不是办法，所以不如升级 &lt;code&gt;hexo&lt;/code&gt; 来解决问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blog" scheme="https://muyuuuu.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>一个不是很规范的致谢</title>
    <link href="https://muyuuuu.github.io/2023/03/03/thanks-thesis/"/>
    <id>https://muyuuuu.github.io/2023/03/03/thanks-thesis/</id>
    <published>2023-03-03T09:18:27.000Z</published>
    <updated>2023-11-13T16:01:55.211Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写一个正经的致谢吧，作为学生时代的一个小结尾。毕业论文里的致谢太八股了，前一半内容一定要大幅的感谢老师，感谢老师给的机会和培养。后四分之一写实验室同学，在后面写父母。不能感谢自己，最后一段感谢论文评委，过于官方的东西没意思的很。所以写一些不能放到论文里面的致谢。</p><span id="more"></span><p>想来想去一时间不知道从哪里开始谢起，先感谢一下 <a href="https://github.com/note286">Carol</a> 老师吧，写的 <code>xduts</code> 模板和接口过于强大，让我能愉快的使用 <code>TeX</code> 写硕士毕业论文，不用再花费过多的精力去调整复杂的格式，使用期间也没有遇到任何排版上问题和困难，还耐心的解答了我的各种疑问。<code>Carol</code> 老师原话：毕业论文除内容外的所有东西他都会，比如 pdf 裁边这种很微小但又很细节的东西。在邻近毕业的时候，我没有在微信上走任何形式去感谢任何人，唯独卡老师是个例外。当时说：希望毕业后在工作中还能遇到你这样的人，这大概是我能想到的最高赞扬了。当时还说等我工作赚钱了一定去打赏 <code>xduts</code>。在某天忽然想起来时，陆陆续续打赏了 800 大洋，就当赞助用爱发电的开源项目了。</p><p>想起来 2020 年研究生入学的时候，那时候充满了惶恐和焦虑。当时年轻也不知道如何去选择一个好组和一个好老师，听说了老师的各种事迹后焦虑到呼吸困难。入学后直线加深了我的焦虑，时常担忧未来而在夜里无法入眠。感谢我亲爱的 ykc 师兄不知道和我们在夜里交流了多少次，研一很多次，研二很多次，研三很多次，在实验室，在操场，在小饭馆。虽然他也肩负很大的压力，但也尽可能的舒缓我们的情绪，每次和他聊完都感觉身心安定，坚定了读下去的心。也感谢大师兄 wz，帮我们顶住了老师的压力，每次都尽力的和我们讨论问题，帮我们度过一次次的难关，在其他生活琐事和医食住行等方面也给了我们很多帮助。</p><p>在 21 年 11 月的时候，步入了人生的低谷，整日浑浑噩噩沉迷于无所事事。感谢我的师弟 wzb，和我一起开发华为算子中的难点，帮我分担了很大的压力。在今年的 1 月和 2 月帮我跑毕业论文中的部分实验，再次帮我分担压力和焦虑，让我有时间和经历去写毕业论文。真的十分感谢，我当时还在想，毕业后要不要给师弟买个 PS5。</p><p>除此之外，由于进的组人数极少且没有任何形式的合作和交流，我更多的社交也都在互联网上了。感谢一个水群的网友，来自五湖四海但因写代码相识，和你们聊天消耗了我日常 70% 的话语，代码技术聊到人生哲学，甚至偶尔搞搞黄色和八卦，让我感觉没那么孤独。</p><p>十分感谢给予我经济援助的小伙伴们。研一下半年的经济状况过于贫困，也不好意思去找家里要钱，每天都在芹菜、豆芽、粉条、白菜、西葫芦、豆腐和西红柿之间轮换，因为很便宜。连续吃了几个月之后导致我现在看到这些食物依然反胃，迫于无奈选择了靠程序辅导去赚点钱，感谢你们一笔一笔的经济援助和支持，让我有足够的钱去吃肉、买新衣服、回家能坐高铁，让我活的更加体面。你们人都很好，也希望你们在告别短暂的计算机编程之后，能迎来更好的人生。</p><p>尤其感谢期间认识的 tcr 小姐姐，2022 年的 8 9 月份，找工作压力很大期间还生了一次大病，她不断的安慰和鼓励我，每次都发很多很多的话和语音，给我很多建议，希望我坚持下去打败困难，对于我理解不了的内容还打电话特意解释。大恩不言谢，日后必定请吃饭，请最贵的那种。之后感谢 qq，hkx 和 bmh，不嫌弃和我这样的发疯人士聊天，承担了我大多数孤独和压抑的情绪，在我多次发疯后依然不介意尝试去疏导我的情绪和压力。hkx 在听说我读研的遭遇后，二话不说给我买了很多零食，qq 在知道我失眠后给我邮寄了酸枣仁，原来我还不是孤魂野鬼。</p><p>昨晚在写论文摘要的时候，想起来一件事情。18 年打比赛的时候，最后一天的凌晨 4 点累的不知道自己是谁，就去跟老师说，我写不动了，你能帮我写下摘要吗？老师说行。我直接睡了过去，再次醒来就是 8 点了。老师 40 多岁，还是通宵帮我把所有事情都弄好，我永远像个孩子一样。后来每次写论文摘要的时候，都会想起他的样子。我很感谢我的本科老师，他把我带入了新的生活和世界，让我学到了编程和建模，从此走上了不一样的道路。我还记得他说过的话：学以致用。我还记得最感动的一次， 大三的时候我在犹豫要不要去打比赛，他说：如果我要去，他就把最后一个名额留给我，人我随便挑；如果我不去，最后一个名额也不准备带别人了，当时感动了很久。那年全校 100 多个队伍参赛，只有 4 个一等奖，我是其中之一，那年我的获奖证书被放到学校招新的海报中，也一步步的保研成功。</p><p>也许，人生大部分时候都是痛苦的，只有少数的幸福时刻，就像河面上的少许的波光粼粼。但就是这些少许的亮光，能让河流看起来更美，能照亮绝大多数的平庸或难熬时刻，温暖着我们继续走下去。</p><p>甚至还想感谢 XM，给我提供了人生的第一份工作，开了极具诱惑力的薪资，还是我很向往的工作方向。本科学的 A 方向，对 B 方向感兴趣，研究生学的 C 方向，对 E 方向感兴趣，但没有 E 方向的相关知识储备和项目经验，所以找工作准备的 D 方向。最后 XM 提供的工作方向是 E，兜兜转转还是遇到了最喜欢的方向，真的十分满足。其实还有一些宿命论的味道，我第一门学习的编程语言大一开设的 C++ 课程，之后对编程萌发了兴趣转专业去学计算机，未来的工作方向也是 C++，很长一段时间内都要靠它吃饭了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写一个正经的致谢吧，作为学生时代的一个小结尾。毕业论文里的致谢太八股了，前一半内容一定要大幅的感谢老师，感谢老师给的机会和培养。后四分之一写实验室同学，在后面写父母。不能感谢自己，最后一段感谢论文评委，过于官方的东西没意思的很。所以写一些不能放到论文里面的致谢。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Life" scheme="https://muyuuuu.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>2022, 随便写点</title>
    <link href="https://muyuuuu.github.io/2022/12/02/2022/"/>
    <id>https://muyuuuu.github.io/2022/12/02/2022/</id>
    <published>2022-12-02T14:14:21.000Z</published>
    <updated>2022-12-11T09:07:56.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>6年前的12月1号<br>体育课下课后在操场跑了几圈<br>背着当时的初中用过来的破旧书包，去兰园一楼吃了顿鸭扒饭<br>晚上去自习室学高数，分部积分<br>之后每年的12.1都会回忆起那普通的一天，宣告着这一年还有最后一个月<br>今年也不例外 ​​</p><span id="more"></span><p>12岁的时候，觉得动画片这么好看大人怎么不喜欢看呢。总以为20岁以后时间密度和快乐会和童年一样，不断打开的新鲜生活是应接不暇的，每一件事都会历历在目，念念不忘，生活也一定五彩斑斓，总有新领域等待我去玩耍。</p><p>20岁后的这几年才明白，因为各种主客观的壁垒，成年以后的人生在收窄，只能在一个地方永远停留下去，重复的事物越来越多，时间在重复里飞速进行，总觉得根本没做什么一年就过去了。</p><p>人不能同时拥有青春和感受青春，也大概理解了年轻真好的意思，年轻人还有时间去改变一些东西，成年人如果想去改变自己的现状，可以，但会付出很大很大的成本与代价。</p><p>年历仍是在更迭的，但每年都像被水浸泡过一般，界限逐步模糊，无法像幼时那样能一一分得清楚，有期待感。只觉得这几年里都是循环的情绪，堆砌的熟稔，往复的麻木，仿佛依靠惯性在活着。即便偶遇意外的惊喜或猝然的悲恸，事后冷静想想，也好像都是从前早已领教过的二手货。</p><p>今年去西安的时候，下了大雪，我寻思着瑞雪兆丰年；今天完成了找工作的最后一步，寄三方，又下了大雪；两场大雪，也许宣告了青春的结束。</p><p>之前不顺心的时候，总是想着努努力忍一忍，以后去个好地方永远的告别这里，高中是这样，研究生也是这样。</p><p>最近在忙毕设，学校的压迫程度，资本家都自叹不如，期望在毕业之前我的博客还能有所技术产出。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;6年前的12月1号&lt;br&gt;体育课下课后在操场跑了几圈&lt;br&gt;背着当时的初中用过来的破旧书包，去兰园一楼吃了顿鸭扒饭&lt;br&gt;晚上去自习室学高数，分部积分&lt;br&gt;之后每年的12.1都会回忆起那普通的一天，宣告着这一年还有最后一个月&lt;br&gt;今年也不例外 ​​&lt;/p&gt;</summary>
    
    
    
    
    <category term="Life" scheme="https://muyuuuu.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>秋招结束</title>
    <link href="https://muyuuuu.github.io/2022/10/23/fuck-autumn-recruitment/"/>
    <id>https://muyuuuu.github.io/2022/10/23/fuck-autumn-recruitment/</id>
    <published>2022-10-22T16:06:26.000Z</published>
    <updated>2022-10-22T16:30:18.774Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>寒气逼人的惨淡秋招终于 tnnd 的结束了，4月中旬开始投递，10月中旬拿到 offer，耗时6个月。就业形式异常艰难，简历挂，笔试挂，面试挂，感谢信收割机。一种被累垮的感觉。</p><span id="more"></span><p>大家仿佛都是在 3 月份开始了背八股文，我当时觉得没啥意思就顺手参加了个比赛。本人找的算法岗，由于懒惰和各种原因，在第一场面试开始的时候，我都没有背八股，连梯度消失这样的问题偶没有回答上来。拖延到6月下旬才开始背八股，背的时间不长，断断续续的一个月，每次面试前看看笔记就行，剩下的随缘发挥。</p><p>但同组的就不一样了，他们投的 java 开发，从 java 基础，多线程，JVM，框架，分布式，数据库，网络，系统等等等等他们都要背，如果说我要掌握的知识一周就可以背完，他们的知识至少要背十周。找工作的时候，他们是睡在实验室的。</p><p>最艰难的时候是从7月30号开始的，我清楚的记得那天能投10家公司，除了快手通知我面试外，其余全挂，可惜快手也是一面就挂。在8月的某天下午和晚上连开四场笔试，极限操作，头晕脑胀，手在颤抖，从8月到9月，持续一个月不间断的面试和笔试。这辈子也不想在回忆这种头晕的感觉。</p><p>来形容一下某头部大厂的面试，开局两个 hard 级别的 leetcode 题，我写上来了。结果以为后面会很顺畅，结果呢，面试全程就三个字，嗯，啊，好，面试结束。后来才知道他想用代码题来劝退我，早知道我就不写了。在形容一下某硬件大厂的面试：你了解过XX吗，我说没有；你用过XX吗，我说不好意思只听说过。面试直接结束，全程不到5分钟，至于简历里写了什么，你是做什么的一概不问。</p><p>京东，网易和腾讯的题目都是令人劝退的难度。如果说数学不会还能写个解，编程不会甚至不能写个空格。我还清楚的记得今年的网易，京东和百度都在围绕 <code>red</code> 这个字符串出题，红色意味着警告，可能告诉我们今年形式很严峻吧。蚂蚁笔试干脆交了白卷，后续的笔试也没有参加，不是看不上蚂蚁，是我真的累了；字节笔试一个不会，瞪着屏幕发呆两小时的感觉很难受。7月投了多少公司，8月就收了多少感谢信。</p><p>我在17年因为喜欢代码转专业到了计算机。但是秋招的很长一段时间内患上了代码 PTSD，一看到代码题目就头晕，想睡，本人十分厌恶刷题，找不到丝毫写代码的乐趣，也没有学习的乐趣，一股为了学习而学习的中学味，令人呕吐。以至于后来面试的时候，明明很简单的题，我的下意识反应都是我不会，很简单的题我会想的很复杂。比如求最长回文子串，明明是一个很简单的暴力模拟题，我看到最这个字就往动态规划那边去想，结果写出来的程序又臭又长，我自己都看不下去，写到一半干脆说了不会。</p><p>就像准备了很久的高考，上了考场发现自己害怕，不会，也不敢动笔。百度是这样，快手是这样，滴滴也是这样；我是这样，同组得这样，舍友也是这样，大家都被拖的很累。经济形势不好，今年的就业形势到处是槽点。百度和快手的面试官态度是最好的，夸一下。</p><p>今年最大的意外就是：本科学的A方向，研究生是B方向，准备的C方向，最后的工作是D方向。至于我能拿offer跟我实力没有半毛钱关系，计算机卷的起飞，我被挤到了芯片，医疗，金融，VR等各个方向，没有一个和计算机相关。面试凭实力？错，全凭运气，有的厂的笔试很简单大二学生都会，面试也能聊得来；有的令人想直接关了屏幕再你妈的见。如果可以，我还是想回到大学的校园里，好好补补基础课。面到最后发现还是大学课程的基本功，可惜大学的黄金时光被我荒废。</p><p>感谢各位大哥的帮助，尤其是田学姐数次救我狗命于水火之中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;寒气逼人的惨淡秋招终于 tnnd 的结束了，4月中旬开始投递，10月中旬拿到 offer，耗时6个月。就业形式异常艰难，简历挂，笔试挂，面试挂，感谢信收割机。一种被累垮的感觉。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Life" scheme="https://muyuuuu.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>从 0 开始的 TorchScript</title>
    <link href="https://muyuuuu.github.io/2022/10/03/torch-jit-1/"/>
    <id>https://muyuuuu.github.io/2022/10/03/torch-jit-1/</id>
    <published>2022-10-02T16:04:09.000Z</published>
    <updated>2022-10-02T16:08:35.887Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上一次正儿八经写博客是今年 2 月，5 月做了个比赛总结，其余的博客竟然都是刷题和算法，实属无聊。艰难的日子已经过去，准备学点模型部署相关的东西以及参与一个实际的开源项目，争取数据、算法和工程全链路打通。众所周知，对于一个不是很常用的东西，学完就忘，如 <code>spark, Go</code> 等学过的但很少用的东西，已经被我抛到九霄云外了。所以，这次学完模型的 <code>trace</code> 之后，尝试部署一些能实际运行的软件。</p><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><code>TorchScript</code> 是 <code>PyTorch</code> 的 <code>JIT</code> 实现。<code>JIT</code> 全程是 Just In Time Compilation，也就是即使编译。在深度学习中 <code>JIT</code> 的思想更是随处可见，最明显的例子就是 <code>Keras</code> 框架的 model.compile 创建的静态图。</p><ul><li>静态图需要先构建再运行，优势是在运行前可以对图结构进行优化，比如常数折叠、算子融合等，可以获得更快的前向运算速度。缺点也很明显，就是只有在计算图运行起来之后，才能看到变量的值，像 <code>TensorFlow1.x</code> 中的 <code>session.run</code> 那样。</li><li>动态图是一边运行一边构建，优势是可以在搭建网络的时候看见变量的值，便于检查。缺点是前向运算不好优化，因为根本不知道下一步运算要算什么。动态图模型通过牺牲一些高级特性来换取易用性。</li></ul><p>那么那到底 <code>JIT</code> 有哪些特性，使得 <code>torch</code> 这样的动态图框架也要走 <code>JIT</code> 这条路呢？或者说在什么情况下不得不用到 <code>JIT</code> 呢？下面主要通过介绍 <code>TorchScript</code> 来分析 <code>JIT</code> 到底带来了哪些好处。</p><p><code>JIT</code> 是 <code>Python</code> 和 <code>C++</code> 的桥梁，我们可以使用 <code>Python</code> 训练模型，然后通过 <code>JIT</code> 将模型转为语言无关的模块，从而让 <code>C++</code> 可以非常方便得调用，从此「使用 <code>Python</code> 训练模型，使用 <code>C++</code> 将模型部署到生产环境」对 <code>PyTorch</code> 来说成为了一件很容易的事。而因为使用了 <code>C++</code>，我们现在几乎可以把 <code>PyTorch</code> 模型部署到任意平台和设备上：树莓派、iOS、Android 等等。不然每次都要通过 <code>python</code> 调用模型，性能会大打折扣。</p><p>既然是为部署生产所提供的特性，那免不了在性能上面做了极大的优化，如果推断的场景对性能要求高，则可以考虑将模型（<code>torch.nn.Module</code>）转换为 <code>TorchScript Module</code>，再进行推断。有两种方式可以转换：</p><ol><li>使用 <code>TorchScript Module</code> 的更简单的办法是使用 <code>Tracing</code>，<code>Tracing</code> 可以直接将 <code>PyTorch</code> 模型（<code>torch.nn.Module</code>）转换成 <code>TorchScript Module</code>。「 <code>trace</code> 」顾名思义，就是需要提供一个「输入」来让模型 <code>forward</code> 一遍，以通过该输入的流转路径，获得图的结构。这种方式对于 <code>forward</code> 逻辑简单的模型来说非常实用，但如果 <code>forward</code> 里面本身夹杂了很多流程控制语句，就会存在问题，因为同一个输入不可能遍历到所有的逻辑分枝。<strong>而没有被经过的分支就不会被 <code>trace</code> 。</strong></li><li>可以直接使用 <code>TorchScript Language</code> 来定义一个 <code>PyTorch JIT Module</code>，然后用 <code>torch.jit.script</code> 来将他转换成 <code>TorchScript Module</code> 并保存成文件。而 <code>TorchScript Language</code> 本身也是 <code>Python</code> 代码，所以可以直接写在 <code>Python</code> 文件中。对于 <code>TensorFlow</code> 我们知道不能直接使用 <code>Python</code> 中的 <code>if</code> 等语句来做条件控制，而是需要用 <code>tf.cond</code>，但对于 <code>TorchScript</code> 我们依然能够直接使用 <code>if</code> 和 <code>for</code> 等条件控制语句，所以即使是在静态图上，<code>PyTorch</code> 依然秉承了「易用」的特性。</li></ol><h1 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h1><h2 id="trace-方法"><a href="#trace-方法" class="headerlink" title="trace 方法"></a>trace 方法</h2><p>首先定义一个简单的模型：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDecisionGate</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 分支判断</span></span><br><span class="line">        <span class="keyword">if</span> x.<span class="built_in">sum</span>() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCell</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyCell, self).__init__()</span><br><span class="line">        self.dg = MyDecisionGate()</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, h</span>):</span><br><span class="line">        y = torch.tanh(self.dg(self.linear(x)) + h)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">my_cell = MyCell()</span><br><span class="line"><span class="built_in">print</span>(my_cell)</span><br><span class="line">x, h = torch.rand(<span class="number">1</span>, <span class="number">4</span>), torch.rand(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(my_cell(x, h))</span><br></pre></td></tr></table></figure><p>我们可以绑定输入对模型进行 <code>trace</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDecisionGate</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">if</span> x.<span class="built_in">sum</span>() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCell</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyCell, self).__init__()</span><br><span class="line">        self.dg = MyDecisionGate()</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, h</span>):</span><br><span class="line">        y = torch.tanh(self.dg(self.linear(x)) + h)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">my_cell = MyCell()</span><br><span class="line">x, h = torch.rand(<span class="number">1</span>, <span class="number">4</span>), torch.rand(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">trace_model = torch.jit.trace(my_cell, (x, h))</span><br><span class="line"><span class="built_in">print</span>(trace_model(x, h))</span><br><span class="line"><span class="built_in">print</span>(trace_model.code)</span><br><span class="line"><span class="comment"># def forward(self,</span></span><br><span class="line"><span class="comment">#     x: Tensor,</span></span><br><span class="line"><span class="comment">#     h: Tensor) -&gt; Tensor:</span></span><br><span class="line"><span class="comment">#   dg = self.dg</span></span><br><span class="line"><span class="comment">#   linear = self.linear</span></span><br><span class="line"><span class="comment">#   _0 = torch.add((dg).forward((linear).forward(x, ), ), h)</span></span><br><span class="line"><span class="comment">#   return torch.tanh(_0)</span></span><br></pre></td></tr></table></figure><p>可以看到没有出现 <code>if-else</code> 的分支， <code>trace</code> 做的是：运行代码，记录出现的运算，构建 <code>ScriptModule</code>，但是控制流就丢失了。然后流程丢失并不是好事，在 <code>trace</code> 只会对一个输入进行处理的情况下，对不同的输入得到的结果是不一样的，因为输入只会满足一个分支，因此 <code>trace</code> 的程序也只包含一个分支。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDecisionGate</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">if</span> x.<span class="built_in">sum</span>() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line">my_cell = MyDecisionGate()</span><br><span class="line">x = torch.tensor([-<span class="number">0.1</span>, <span class="number">0.05</span>]) <span class="comment"># 这两个 x trace 到的代码是不一样的</span></span><br><span class="line"><span class="comment"># x = torch.tensor([0.1, -0.05])</span></span><br><span class="line">trace_model = torch.jit.trace(my_cell, (x))</span><br><span class="line"><span class="built_in">print</span>(trace_model(x))</span><br><span class="line"><span class="built_in">print</span>(trace_model.code)</span><br></pre></td></tr></table></figure><p>因此，我们认为这样的 <code>trace</code> 没有泛化能力。而这种现象普遍发生在动态控制流中，即：具体执行哪个算子取决于输入的数据。</p><ul><li><code>if x[0] == 4: x += 1</code> 是动态控制流</li><li><code>model: nn.Sequential = ... [m(x) for x in model]</code> 不是</li><li><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(nn.Module):</span><br><span class="line">  backbone: nn.Module</span><br><span class="line">  head: Optiona[nn.Module]</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">    x = self.backbone(x)</span><br><span class="line">    <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        x = self.head(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>不是</li></ul><p>在之后的文章中，会介绍如何使 <code>trace</code> 具备泛化能力。</p><h2 id="script-方法"><a href="#script-方法" class="headerlink" title="script 方法"></a>script 方法</h2><p><code>script</code> 方法直接分析 <code>python</code> 代码进行转换：使用他们提供的 <code>script</code> 编译器，将 <code>python</code> 的代码进行语法分析，并重新解释为 <code>TorchScript</code>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDecisionGate</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">if</span> x.<span class="built_in">sum</span>() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCell</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dg</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyCell, self).__init__()</span><br><span class="line">        self.dg = dg</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, h</span>):</span><br><span class="line">        new_h = torch.tanh(self.dg(self.linear(x)) + h)</span><br><span class="line">        <span class="keyword">return</span> new_h, new_h</span><br><span class="line"></span><br><span class="line">scripted_gate = torch.jit.script(MyDecisionGate())</span><br><span class="line"><span class="built_in">print</span>(scripted_gate.code) <span class="comment"># 含有流程控制</span></span><br><span class="line">my_cell = MyCell(scripted_gate)</span><br><span class="line">traced_cell = torch.jit.script(my_cell)</span><br><span class="line"><span class="built_in">print</span>(traced_cell.code)</span><br></pre></td></tr></table></figure><ol><li><code>TorchScript</code> 代码可以被它自己的解释器（一个受限的 <code>Python</code> 解释器）调用。这个解释器不需要获得全局解释锁GIL，这样很多请求可以同时处理。</li><li>这个格式可以让我们保存模型到硬盘上，在另一个环境中加载，例如服务器，也可以使用非 <code>python</code> 的语言。</li><li><code>TorchScript</code> 提供的表示可以做编译器优化，做到更有效地执行。</li><li><code>TorchScript</code> 可以与其他后端/设备运行时进行对接，他们只需要处理整个项目，无需关心细节运算。</li></ol><h1 id="Trace-和-Script-谁更好？"><a href="#Trace-和-Script-谁更好？" class="headerlink" title="Trace 和 Script 谁更好？"></a>Trace 和 Script 谁更好？</h1><p>通过上文我们可以了解到：</p><ul><li><p><code>trace</code> 只记录走过的 <code>tensor</code> 和对 <code>tensor</code> 的操作，不会记录任何控制流信息，如 <code>if</code> 条件句和循环。因为没有记录控制流的另外的路，也没办法对其进行优化。好处是 <code>trace</code> 深度嵌入 <code>python</code> 语言，复用了所有 <code>python</code> 的语法，在计算流中记录数据流。</p></li><li><p><code>script</code> 会去理解所有的 <code>code</code>，真正像一个编译器一样去进行词法分析语法分析句法分析，形成 <code>AST</code> 树，最后再将 <code>AST</code> 树线性化。<code>script</code> 相当于一个嵌入在 <code>Python/Pytorch</code> 的 <code>DSL</code>，其语法只是 <code>Pytorch</code> 语法的子集，这意味着存在一些 <code>op</code> 和语法 <code>script</code> 不支持，这样在编译的时候就会遇到问题。此外，<code>script</code> 的编译优化方式更像是 <code>CPU</code> 上的传统编译优化，重点对于图进行硬件无关优化，并对 <code>if</code>、<code>loop</code> 进行优化。</p></li></ul><p>在大模型的部署上 <code>trace</code> 更好，因为可以有效的优化复杂的计算图，如下所示：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(nn.Module):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x1, x2, x3</span>):</span><br><span class="line">    z = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    xs = [x1, x2, x3]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> z: x1 += xs[k]</span><br><span class="line">    <span class="keyword">return</span> x1</span><br><span class="line">model = A()</span><br><span class="line"><span class="built_in">print</span>(torch.jit.script(model).code)</span><br><span class="line"><span class="comment"># def forward(self, x1: Tensor, x2: Tensor, x3: Tensor) -&gt; Tensor:</span></span><br><span class="line"><span class="comment">#   z = [0, 1, 2]</span></span><br><span class="line"><span class="comment">#   xs = [x1, x2, x3]</span></span><br><span class="line"><span class="comment">#   x10 = x1</span></span><br><span class="line"><span class="comment">#   for _0 in range(torch.len(z)):</span></span><br><span class="line"><span class="comment">#     k = z[_0]</span></span><br><span class="line"><span class="comment">#     x10 = torch.add_(x10, xs[k])</span></span><br><span class="line"><span class="comment">#   return x10</span></span><br><span class="line"><span class="built_in">print</span>(torch.jit.trace(model, [torch.tensor(<span class="number">1</span>)] * <span class="number">3</span>).code)</span><br><span class="line"><span class="comment"># def forward(self, x1: Tensor, x2: Tensor, x3: Tensor) -&gt; Tensor:</span></span><br><span class="line"><span class="comment">#   x10 = torch.add_(x1, x1)</span></span><br><span class="line"><span class="comment">#   x11 = torch.add_(x10, x2)</span></span><br><span class="line"><span class="comment">#   return torch.add_(x11, x3)</span></span><br></pre></td></tr></table></figure><p>因为 <code>script</code> 试图忠实地表示 <code>Python</code> 代码，所以即使其中一些是不必要的。例如：并不能对 <code>Python</code> 代码中的某些循环或数据结构进行优化。如上例，所以它实际上有变通方法，或者循环可能会在以后的优化过程中得到优化。但关键是：这个编译器并不总是足够聪明。对于复杂的模型， <code>script</code> 可能会生成一个具有不必要复杂性且难以优化的计算图。</p><p><code>tracing</code> 有许多优点，事实上，在 <code>Facebook/Meta</code> 部署的分割和检测模型中，<code>tracing</code> 是默认的选择，仅当必要的时候使用 <code>scripting</code>。因为 <code>trace</code> 不会破坏代码质量，可以结合 <code>script</code> 来避免一些限制。</p><p><code>python</code> 是一个很大很动态的语言，编译器最多只能支持其语法功能和内置函数的子集，同理，<code>script</code> 也不例外。这个编译器支持 <code>Python</code> 的哪个子集？一个粗略的答案是：编译器对最基本的语法有很好的支持，但对任何更复杂的东西（类、内置函数、动态类型等）的支持度很低或者不支持。但并没有明确的答案：即使是编译器的开发者，通常也需要运行代码，看看能不能编译去判断是否支持。</p><p>所以不完整的 <code>Python</code> 编译器限制了用户编写代码的方式。尽管没有明确的约束列表，但可以从经验中看出它们对大型项目的影响：<code>script</code> 的问题会影响代码质量。很多项目只停留在了代码能 <code>script</code> 成功这一层面，使用基础语法，没有自定义类型，没有继承，没有内置函数，没有 <code>lambda</code> 等等的高级特性。因为这些高级的功能编译器并不支持或者部分支持，就会导致在某些情况下成功，但在其他情况下失败。而且由于没有明确的规范哪些是被支持的，因此用户无法推理或解决故障。因此，最终用户会仅仅停留在代码成功搬移，而不考虑可维护性和性能问题，会导致开发者因为害怕报错而停止进一步的探索高级特性。</p><p>如此下去，代码质量可能会严重恶化：垃圾代码开始积累，因为优良的代码有时无法编译。此外，由于编译器的语法限制，无法轻松进行抽象以清理垃圾代码。该项目的可维护状况逐渐走下坡路。如果认为 <code>script</code> 似乎适用于我的项目，基于过去在一些支持 <code>script</code> 的项目中的经验，我可能会出于以下原因建议不要这样做：</p><ul><li>编译成功可能比你想象的更脆弱（除非将自己限制在基本语法上）：你的代码现在可能恰好可以编译，但是有一天你会在模型中添加一些更改，并发现编译失败；</li><li>基本语法是不够的：即使目前你的项目似乎不需要更复杂的抽象和继承，但如果预计项目会增长，未来将需要更多的语言特性。</li></ul><p>以多任务检测器为例：</p><ul><li>可能有 10 个输入，因此最好使用一些结构/类。</li><li>检测器有许多架构选择，这使得继承很有用。</li><li>大型、不断增长的项目肯定需要不断发展的抽象来保持可维护性。</li></ul><p>因此，这个问题的现状是：<code>script</code> 迫使你编写垃圾的代码，因此我们仅在必要时使用它。</p><h1 id="Trace-细节"><a href="#Trace-细节" class="headerlink" title="Trace 细节"></a>Trace 细节</h1><p><code>trace</code> 让模型的 <code>trace</code> 更清楚，对代码质量有很少的影响。</p><p>如果模型不是以 <code>Pytorch</code> 格式表示的计算图，则 <code>script</code> 和 <code>trace</code> 都不起作用。例如，如果模型具有 <code>DataParallel</code> 子模块，或者如果模型将张量转换为 <code>numpy</code> 数组并调用 <code>OpenCV</code> 函数等，则必须对其进行重构。除了这个明显的限制之外，对 <code>trace</code> 只有两个额外的要求：</p><ul><li><p>输入/输出格式是 <code>Tensor</code> 类型时才能被 <code>trace</code>。但是，这里的格式约束不适用于子模块：子模块可以使用任何输入/输出格式：类、<code>kwargs</code> 以及 <code>Python</code> 支持的任何内容。格式要求仅适用于最外层的模型，因此很容易解决。如果模型使用更丰富的格式，只需围绕它创建一个简单的包装器，它可以与 <code>Tuple[Tensor]</code> 相互转换。</p></li><li><p><code>shape</code>。<code>tensor.size(0)</code> 是 <code>eager</code> 模式下的整数，但它是 <code>tracing mode</code> 下的 <code>tensor</code>。这个差异在 <code>trace</code> 时是必要的，<code>shape</code> 的计算可以被捕获为计算图中的算子。由于不同的返回类型，如果返回的一部分是 <code>shape</code> 是整数则无法 <code>trace</code> ，这通常可以简单的解决。此外，一个有用的函数是 <code>torch.jit.is_tracing</code>，它检查代码是否在 <code>trace</code> 模式下执行。</p></li></ul><p>我们来看个例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = torch.rand(<span class="number">1</span>), torch.rand(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">x</span>): <span class="keyword">return</span> torch.arange(x.shape[<span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">x</span>): <span class="keyword">return</span> torch.arange(<span class="built_in">len</span>(x))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># See if the two traces generalize from a to b:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.jit.trace(f1, a)(b)</span><br><span class="line">tensor([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.jit.trace(f2, a)(b)</span><br><span class="line">tensor([<span class="number">0</span>])  <span class="comment"># WRONG!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Why f2 does not generalize? Let&#x27;s compare their code:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(torch.jit.trace(f1, a).code, torch.jit.trace(f2, a).code)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">x: Tensor</span>) -&gt; Tensor:</span><br><span class="line">  _0 = ops.prim.NumToTensor(torch.size(x, <span class="number">0</span>))</span><br><span class="line">  _1 = torch.arange(annotate(number, _0), dtype=<span class="literal">None</span>, layout=<span class="number">0</span>, device=torch.device(<span class="string">&quot;cpu&quot;</span>), pin_memory=<span class="literal">False</span>)</span><br><span class="line">  <span class="keyword">return</span> _1</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">x: Tensor</span>) -&gt; Tensor:</span><br><span class="line">  _0 = torch.arange(<span class="number">1</span>, dtype=<span class="literal">None</span>, layout=<span class="number">0</span>, device=torch.device(<span class="string">&quot;cpu&quot;</span>), pin_memory=<span class="literal">False</span>)</span><br><span class="line">  <span class="keyword">return</span> _0</span><br></pre></td></tr></table></figure><p>在 <code>trace f2</code> 函数时，<code>lex(x)</code> 是一个定值而非 <code>tensor</code>，这样在传入其他长度的数据时就回报错。除了 <code>len()</code>，这个问题也可能出现在：</p><ul><li><code>.item()</code> 将张量转换为 <code>int/float</code>。</li><li>将 <code>Torch</code> 类型转换为 <code>numpy/python</code> 原语的任何其他代码。</li></ul><p><code>tensor.size()</code> 在 <code>trace</code> 期间返回 <code>Tensor</code>，以便在图中捕获形状计算。用户应避免意外将张量形状转换为常量。使用 <code>tensor.size(0)</code> 而不是 <code>len(tensor)</code>，因为后者是一个 <code>int</code>。这个函数对于将大小转换为张量很有用，在 <code>trace</code> 和 <code>eager</code> 模式下都可以使用。对于自定义类，实现 <code>.size()</code> 方法或使用 <code>.__len__()</code> 而不是 <code>len()</code>，不要通过 <code>int()</code> 转换大小，因为它们会捕获常量。</p><p>这就是 <code>trace</code> 所需要的一切。最重要的是，模型实现中允许使用任何 <code>Python</code> 语法，因为 <code>trace</code> 根本不关心语法。</p><h2 id="Trace-的泛化问题"><a href="#Trace-的泛化问题" class="headerlink" title="Trace 的泛化问题"></a>Trace 的泛化问题</h2><h3 id="Trace-和-Script-混合"><a href="#Trace-和-Script-混合" class="headerlink" title="Trace 和 Script 混合"></a>Trace 和 Script 混合</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">return</span> torch.sqrt(x) <span class="keyword">if</span> x.<span class="built_in">sum</span>() &gt; <span class="number">0</span> <span class="keyword">else</span> torch.square(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = torch.jit.trace(f, torch.tensor(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(m.code)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x: Tensor</span>) -&gt; Tensor:</span><br><span class="line">  <span class="keyword">return</span> torch.sqrt(x)</span><br></pre></td></tr></table></figure><p>注意这种代码在 <code>trace</code> 时不会报错，只有 <code>warning</code> 的输出，因此我们要特别关注。<code>trace</code> 和 <code>script</code> 都有各自的问题，最好的方法是混合使用他们。避免影响代码质量，主要的部分进行 <code>trace</code>，必要时进行 <code>script</code>。如果有一个 <code>module</code> 里面有很多选择，但是我们不希望在 <code>TorchScript</code> 里出现，那么应该使用 <code>tracing</code> 而不是 <code>scripting</code>，这个时候，<code>trace</code> 将内联 <code>script</code> 模块的代码。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDecisionGate</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">if</span> x.<span class="built_in">sum</span>() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCell</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dg</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyCell, self).__init__()</span><br><span class="line">        self.dg = dg</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, h</span>):</span><br><span class="line">        new_h = torch.tanh(self.dg(self.linear(x)) + h)</span><br><span class="line">        <span class="keyword">return</span> new_h, new_h</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRNNLoop</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, scripted_gate, x, h</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyRNNLoop, self).__init__()</span><br><span class="line">        <span class="comment"># 对控制流进行 trace</span></span><br><span class="line">        self.cell = torch.jit.trace(MyCell(scripted_gate), (x, h))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, xs</span>):</span><br><span class="line">        h, y = torch.zeros(<span class="number">3</span>, <span class="number">4</span>), torch.zeros(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(xs.size(<span class="number">0</span>)):</span><br><span class="line">            y, h = self.cell(xs[i], h)</span><br><span class="line">        <span class="keyword">return</span> y, h</span><br><span class="line"></span><br><span class="line">x, h = torch.rand(<span class="number">2</span>, <span class="number">4</span>), torch.rand(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">scripted_gate = torch.jit.script(MyDecisionGate())</span><br><span class="line">rnn_loop = torch.jit.script(MyRNNLoop(scripted_gate, x, h))</span><br><span class="line"><span class="built_in">print</span>(rnn_loop.code)</span><br><span class="line"><span class="built_in">print</span>(rnn_loop.cell.code)</span><br></pre></td></tr></table></figure><p>我们简化一下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.submodule = torch.jit.script(model.submodule)</span><br><span class="line">torch.jit.trace(model, inputs)</span><br></pre></td></tr></table></figure><p>对于不能正确 <code>trace</code> 的子模块，可以进行 <code>script</code> 处理。但是并不推荐，更建议使用 <code>@script_if_tracing</code>，因为这样修改 <code>script</code> 仅限于子模块的内部，而不影响模块的接口。使用 <code>@script_if_tracing</code> 装饰器，在 <code>torch.jit.trace</code> 时，<code>@script_if_tracing</code> 装饰器可以通过 <code>script</code> 编译。通常，这只需要对前向逻辑进行少量重构，以分离需要编译的部分（具有控制流的部分）：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, ...</span>):</span><br><span class="line">  <span class="comment"># ... some forward logic</span></span><br><span class="line"><span class="meta">  @torch.jit.script_if_tracing</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">_inner_impl</span>(<span class="params">x, y, z, flag: <span class="built_in">bool</span></span>):</span><br><span class="line">      <span class="comment"># use control flow, etc.</span></span><br><span class="line">      <span class="keyword">return</span> ...</span><br><span class="line">  output = _inner_impl(x, y, z, flag)</span><br><span class="line">  <span class="comment"># ... other forward logic</span></span><br></pre></td></tr></table></figure><p>只 <code>script</code> 需要的部分，代码质量相对于全部 <code>script</code> 被破坏的很少，被 <code>@script_if_tracing</code> 装饰的函数必须是不包含 <code>tensor</code> 模块运算的纯函数。因此，有时需要进行更多重构：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Before:</span></span><br><span class="line"><span class="keyword">if</span> x.numel() &gt; <span class="number">0</span>:  <span class="comment"># This branch cannot be compiled by @script_if_tracing because it refers to `self.layers`</span></span><br><span class="line">  x = preprocess(x)</span><br><span class="line">  output = self.layers(x)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  output = torch.zeros(...)  <span class="comment"># Create empty outputs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># After:</span></span><br><span class="line"><span class="keyword">if</span> x.numel() &gt; <span class="number">0</span>:  <span class="comment"># This branch can now be compiled by @script_if_tracing</span></span><br><span class="line">  x = preprocess(x)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  x = torch.zeros(...)   <span class="comment"># Create empty inputs</span></span><br><span class="line"><span class="comment"># Needs to make sure self.layers accept empty inputs.</span></span><br><span class="line"><span class="comment"># If necessary, add such condition branch into self.layers as well.</span></span><br><span class="line">output = self.layers(x)</span><br></pre></td></tr></table></figure><p>同样的，我们可以在 <code>script</code> 中嵌套 <code>trace</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.submodule = torch.jit.trace(model.submodule, submodule_inputs)</span><br><span class="line">torch.jit.script(model)</span><br></pre></td></tr></table></figure><p>这里的子模块是 <code>trace</code>，但是实际中并不常用，因为会影响子模块的推理（当且仅当子模块的输入和输出都是 <code>tensor</code> 时才适用），这是很大的限制。但是 <code>trace</code> 作为子模块的时候也有很试用的场景：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(nn.Module):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">    <span class="comment"># Dispatch to different submodules based on a dynamic, data-dependent condition:</span></span><br><span class="line">    <span class="keyword">return</span> self.submodule1(x) <span class="keyword">if</span> x.<span class="built_in">sum</span>() &gt; <span class="number">0</span> <span class="keyword">else</span> self.submodule2(x)</span><br></pre></td></tr></table></figure><p><code>@script_if_tracing</code> 不能处理这样的控制流，因为它只支持纯函数。如果子模块很复杂不能被 <code>script</code>，使用 <code>trace</code>  <code>trace</code> 子模块是很好的选择，这里就是 <code>self.submodule2</code> 和 <code>self.submodule1</code>，类 <code>A</code> 还是要 <code>script</code> 的。</p><h3 id="Script-优势"><a href="#Script-优势" class="headerlink" title="Script 优势"></a>Script 优势</h3><p>事实上，对于大多数视觉模型，动态控制流仅在少数易于编写 <code>script</code> 的子模块中需要。<code>script</code> 相对于 <code>trace</code>，有两个有点：</p><ul><li>一个数据有很多属性的控制流，<code>trace</code> 无法处理</li><li><code>trace</code> 只支持 <code>forward</code> 方法，<code>script</code> 支持更多的方法</li></ul><p>实际上，上述两个功能都在做同样的事情：它们允许以不同的方式使用导出的模型，即根据调用者的请求执行不同的运算符序列。下面是一个这样的特性很有用的示例场景：如果 <code>Detector</code> 是 <code>script</code> 化，调用者可以改变它的 <code>do_keypoint</code> 属性来控制它的行为，或者如果需要直接调用 <code>predict_keypoint</code> 方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Detector</span>(nn.Module):</span><br><span class="line">  do_keypoint: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, img</span>):</span><br><span class="line">      box = self.predict_boxes(img)</span><br><span class="line">      <span class="keyword">if</span> self.do_keypoint:</span><br><span class="line">          kpts = self.predict_keypoint(img, box)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">predict_boxes</span>(<span class="params">self, img</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">predict_keypoint</span>(<span class="params">self, img, box</span>): <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这种要求并不常见。但是如果需要，如何在 <code>trace</code> 中实现这一点？我有一个不是很优雅的解决方案：<code>Tracing</code> 只能捕获一个序列的算子，所以自然的方式是对模型进行两次 <code>Tracing</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">det1 = torch.jit.trace(Detector(do_keypoint=<span class="literal">True</span>), inputs)</span><br><span class="line">det2 = torch.jit.trace(Detector(do_keypoint=<span class="literal">False</span>), inputs)</span><br></pre></td></tr></table></figure><p>然后我们可以为它们的模型设置别名（以不重复存储），并将两个 <code>trace</code> 合并到一个模块中以编写 <code>script</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">det2.submodule.weight = det1.submodule.weight</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span>(nn.ModuleList):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, img, do_keypoint: <span class="built_in">bool</span></span>):</span><br><span class="line">    <span class="keyword">if</span> do_keypoint:</span><br><span class="line">        <span class="keyword">return</span> self[<span class="number">0</span>](img)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self[<span class="number">1</span>](img)</span><br><span class="line">exported = torch.jit.script(Wrapper([det1, det2]))</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>还可以使用单元测试来判断 <code>trace</code> 是否成功：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> allclose(torch.jit.trace(model, input1)(input2), model(input2))</span><br></pre></td></tr></table></figure><h3 id="程序优化"><a href="#程序优化" class="headerlink" title="程序优化"></a>程序优化</h3><p>此外，还可以通过<a href="https://github.com/pytorch/pytorch/issues/56998">优化</a>程序，避免掉不必要的特殊情况：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x.numel() &gt; <span class="number">0</span>:</span><br><span class="line">  output = self.layers(x)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  output = torch.zeros((<span class="number">0</span>, C, H, W))  <span class="comment"># Create empty outputs</span></span><br></pre></td></tr></table></figure><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p>此外还需要注意设备问题，在 <code>trace</code> 期间会记录使用的设备，而 <code>trace</code> 不会对不同的设备进行泛化，但是部署时都会有固定的设备，这个问题不用担心。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">return</span> torch.arange(x.shape[<span class="number">0</span>], device=x.device)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = torch.jit.trace(f, torch.tensor([<span class="number">3</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(m.code)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x: Tensor</span>) -&gt; Tensor:</span><br><span class="line">  _0 = ops.prim.NumToTensor(torch.size(x, <span class="number">0</span>))</span><br><span class="line">  _1 = torch.arange(annotate(number, _0), dtype=<span class="literal">None</span>, layout=<span class="number">0</span>, device=torch.device(<span class="string">&quot;cpu&quot;</span>), pin_memory=<span class="literal">False</span>)</span><br><span class="line">  <span class="keyword">return</span> _1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m(torch.tensor([<span class="number">3</span>]).cuda()).device</span><br><span class="line">device(<span class="built_in">type</span>=<span class="string">&#x27;cpu&#x27;</span>)  <span class="comment"># WRONG!</span></span><br></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><code>trace</code> 有明显的局限性：本文大部分时间都在讨论 <code>trace</code> 的局限性以及如何解决它们。我实际上认为这是 <code>trace</code> 的优点：它有明确的限制和解决方案，所以你可以推断它是否有效。相反， <code>script</code> 更像是一个黑匣子：在尝试之前没有人知道它是否有效。</p><p><code>trace</code> 具有较小的代码破坏范围： <code>trace</code> 和 <code>script</code> 都会影响代码的编写方式，但 <code>trace</code> 的代码破坏范围要小得多，并且造成的损害要小得多：</p><ul><li>它限制了输入/输出格式，但仅限于最外层的模块。</li><li>在 <code>trace</code> 中混合 <code>script</code>，但可以只更改受影响模块的内部实现，而不是它们的接口。</li></ul><p>另一方面， <code>script</code> 对以下方面有影响：</p><ul><li>涉及的每个模块和子模块的接口，接口需要高级语法特性，针对接口编程时，千万别在接口设计上妥协。</li><li>这也可能最终影响训练，因为接口通常在训练和推理之间共享。</li></ul><p>这也是为什么 <code>script</code> 会对代码质量造成很大损害的原因。<code>Detectron2</code> 支持 <code>script</code>，但不推荐其他大型项目以可 <code>script</code> 且不丢失抽象为目标，因为这实在有点难度，除非它们也能像阿里巴巴那样得到 <code>PyTorch</code> 团队的支持。</p><p><code>PyTorch</code> 深受用户喜爱，最重要的是编写 <code>Python</code> 控制流。但是 <code>Python</code> 的其他语法也很重要。如果能够编写 <code>Python</code> 控制流（ 使用 <code>script</code> ）意味着失去其他优秀的语法，我宁愿放弃编写 <code>Python</code> 控制流的能力。事实上，如果 <code>PyTorch</code> 对 <code>Python</code> 控制流不那么执着，并且像这样（类似于 <code>tf.cond</code> 的 <code>API</code>）为我提供了诸如 <code>torch.cond</code> 之类的符号控制流：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="keyword">return</span> torch.cond(x.<span class="built_in">sum</span>() &gt; <span class="number">0</span>, <span class="keyword">lambda</span>: torch.sqrt(x), <span class="keyword">lambda</span>: torch.square(x))</span><br></pre></td></tr></table></figure><p>然后 <code>f</code> 可以正确 <code>trace</code>，不再需要担心 <code>script</code>。</p><h1 id="保存和加载模型"><a href="#保存和加载模型" class="headerlink" title="保存和加载模型"></a>保存和加载模型</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">traced.save(<span class="string">&#x27;wrapped_rnn.pt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">loaded = torch.jit.load(<span class="string">&#x27;wrapped_rnn.pt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(loaded)</span><br><span class="line"><span class="built_in">print</span>(loaded.code)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>基本概念，<a href="https://zhuanlan.zhihu.com/p/370455320">https://zhuanlan.zhihu.com/p/370455320</a></li><li>两者的优势，<a href="https://zhuanlan.zhihu.com/p/410507557">https://zhuanlan.zhihu.com/p/410507557</a></li><li>trace vs script，<a href="https://ppwwyyxx.com/blog/2022/TorchScript-Tracing-vs-Scripting/">https://ppwwyyxx.com/blog/2022/TorchScript-Tracing-vs-Scripting/</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一次正儿八经写博客是今年 2 月，5 月做了个比赛总结，其余的博客竟然都是刷题和算法，实属无聊。艰难的日子已经过去，准备学点模型部署相关的东西以及参与一个实际的开源项目，争取数据、算法和工程全链路打通。众所周知，对于一个不是很常用的东西，学完就忘，如 &lt;code&gt;spark, Go&lt;/code&gt; 等学过的但很少用的东西，已经被我抛到九霄云外了。所以，这次学完模型的 &lt;code&gt;trace&lt;/code&gt; 之后，尝试部署一些能实际运行的软件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Pytorch" scheme="https://muyuuuu.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：双指针</title>
    <link href="https://muyuuuu.github.io/2022/08/06/double-pointer/"/>
    <id>https://muyuuuu.github.io/2022/08/06/double-pointer/</id>
    <published>2022-08-06T15:26:44.000Z</published>
    <updated>2022-08-06T16:20:49.366Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这几天接连遇到了一些双指针的问题，但是说实话，并没有从这些题中看到一种通用的东西，也就不是能很好的做一个总结，但不得不说双指针是一个很神奇的东西，所以做一道记一道吧。</p><span id="more"></span><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><p>快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如fast每次增长两个，slow每次增长一个。</p><p>常用于链表问题，如：slow开始移动，由于移动速度是 fast 的一半，那么 fast 移动到链表的末尾时，slow 就位于链表的中央，可以用这这种方法求链表的中点。</p><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a>26. 删除有序数组中的重复项</h2><p>给你一个升序排列的数组 <code>nums</code>，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。元素的相对顺序应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组 <code>nums</code> 的第一部分。更规范地说，如果在删除重复项之后有 <code>k</code> 个元素，那么 <code>nums</code> 的前 <code>k</code> 个元素应该保存最终结果。将最终结果保存到 <code>nums</code> 的前 <code>k</code> 个位置后返回 <code>k</code> 。</p><p>不要使用额外的空间，你必须在原地修改输入数组 并在使用 $O(1)$ 额外空间的条件下完成。</p><p>这个题乍一看还真不会，于是果断看了题解：</p><ul><li>fast 和 slow 初始为 1，因为就算数组内全是重复元素，那么 1 也可以表示其中不重复的数量</li><li>如果 fast 和 fast-1 对应的元素相等，表示有重复元素，此时 fast++，继续搜索后面的元素</li><li>如果 fast 和 fast-1 不相等，表示没有重复元素，且，不重复的元素是 <code>nums[fast]</code>，此时我们让 <code>nums[slow]=nums[fast]</code>，slow 和 fast 同时向后移动即可</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">1</span>, fast = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[fast<span class="number">-1</span>]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-II-022-链表中环的入口节点"><a href="#剑指-Offer-II-022-链表中环的入口节点" class="headerlink" title="剑指 Offer II 022. 链表中环的入口节点"></a>剑指 Offer II 022. 链表中环的入口节点</h2><p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 next 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p><img data-src="https://s1.ax1x.com/2022/08/06/vubX6J.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>首先明确一点，使用哈希存储地址肯定可以做出来，但这里是为了熟悉双指针。</p><p><img data-src="https://s1.ax1x.com/2022/08/06/vubz01.png" alt></p><ul><li>假设 fast 指针和 slow 指针在紫色节点处相交</li><li>对于 fast 指针，走过的距离为 $a+n(b+c) + b$，$n$ 为任意整数</li><li>对于 slow 指针，走过的距离为 $a+m(b+c) + b$，$m$ 为任意整数</li></ul><p>由于 fast 移动的距离是 slow 的二倍，因此：</p><p>\brgin{equation}<br>a+n(b+c)+b = 2 [a+m(b+c) + b] \\<br>\Rightarrow a = (n-2m)(b+c) - b<br>\end{equation}</p><p>也就是说，$a$ 的长度等于整数倍的环的长度减去 $b$ 的长度。得到这个等式后，我们让一个指针从 <code>head</code> 出发，<code>slow</code> 指针从相交处出发，两者相交时，就是环的入口节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h1><p>对撞数组适用于有序数组、利用数组两侧求最值、只用数组内的两个元素等问题，应该第一时间想到用对撞指针解题。</p><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。</p><p><img data-src="https://s1.ax1x.com/2022/08/06/vubRSg.jpg" alt></p><ul><li>双指针，左指针位于左侧，右指针位于右侧，求一次能存储的最大水量</li><li>如果左边低，为了能求存储的最大水量，就需要将左指针向右移动，同理，如果右边低，就需要将右指针向左移动</li><li>每次移动的时候求极值就可以了</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> t1 = height[l];</span><br><span class="line">            <span class="type">int</span> t2 = height[r];</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(t1, t2) * (r - l));</span><br><span class="line">            <span class="keyword">if</span> (t1 &lt; t2) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="881-救生艇"><a href="#881-救生艇" class="headerlink" title="881. 救生艇"></a>881. 救生艇</h2><p>给定数组 <code>people</code> 。<code>people[i]</code> 表示第 <code>i</code> 个人的体重，船的数量不限，每艘船可以承载的最大重量为 <code>limit</code>。每艘船最多可同时载两人，但条件是这些人的重量之和最多为 <code>limit</code>。返回承载所有人所需的最小船数。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [3,2,2,1], limit = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：3 艘船分别载 (1, 2), (2) 和 (3)</span><br></pre></td></tr></table></figure><p>我们假设一种极端情况，数组排序后是 <code>[1, 2, ..., n-2, n-1]</code>，而船能容纳的极限是 <code>n</code>。那么，最佳分配就是让 <code>1</code> 和 <code>n-1</code> 在一起，<code>2</code> 和 <code>n-2</code> 在一起。此时只用两条船。虽然 <code>1</code> 可以和 <code>2</code> 在一起，那么要承载 <code>n-2</code> 和 <code>n-1</code>，就需要 3 条船。</p><p>基于贪心的思想，我们应该尽可能的把轻的和重的分配到一起，来减少船的使用数量，首先对数组排序：</p><ul><li>设立双指针，<code>l=0, r=n-1</code></li><li>因为船只能坐两个人，因此，如果 <code>nums[l] + nums[n-1] &lt;= limit</code>，就让这两个人坐一起，此时 <code>l++</code></li><li>而无论如何，都需要 <code>r--</code>，因为数组末尾的必须上一个人，而数组左侧的人选择性上或不上 </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numRescueBoats</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;people, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> light = <span class="number">0</span>, heavy = people.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (light &lt;= heavy) &#123;</span><br><span class="line">            <span class="keyword">if</span> (people[light] + people[heavy] &lt;= limit) &#123;</span><br><span class="line">                ++light;</span><br><span class="line">            &#125; </span><br><span class="line">            --heavy;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="红白球"><a href="#红白球" class="headerlink" title="红白球"></a>红白球</h2><p>给定一个长度为 $n$ 的字符串，其中，<code>W</code> 表示白色的球，<code>R</code> 表示红色的球，如果把红色的球放到一起，请问最少移动多少次？示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;WRRWRW&quot;</span><br><span class="line">输出：1</span><br><span class="line">输入：s = &quot;WWRWWWRWR&quot;</span><br><span class="line">输出：4，&quot;WWRWWWRWR&quot; -&gt; &quot;WWWRWWRWR&quot; -&gt; &quot;WWWWRWRWR&quot; -&gt; &quot;WWWWWRRWR&quot; -&gt; &quot;WWWWWWRRRW&quot;</span><br></pre></td></tr></table></figure><p>一个很经典的双指针题目，注：2022年微软秋招笔试题原题。这个题解有点长，日后完善。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> red_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;R&#x27;</span>) red_count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>, result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left] == <span class="string">&#x27;R&#x27;</span> &amp;&amp; s[right] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                red_count -= <span class="number">2</span>;</span><br><span class="line">                result = right - left - <span class="number">1</span> - red_count;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[left] != <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这几天接连遇到了一些双指针的问题，但是说实话，并没有从这些题中看到一种通用的东西，也就不是能很好的做一个总结，但不得不说双指针是一个很神奇的东西，所以做一道记一道吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>由内存分配引发的回忆</title>
    <link href="https://muyuuuu.github.io/2022/07/11/memory-allocation/"/>
    <id>https://muyuuuu.github.io/2022/07/11/memory-allocation/</id>
    <published>2022-07-11T08:52:39.000Z</published>
    <updated>2022-08-06T16:30:48.819Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>闲来无事，在面经上看到了一个问题：在物理机只有 1G 内存的情况下，能否 <code>malloc</code> 出 4G 大小的数组。奇怪的是，这个问题在网上搜不到特别好的解答，于是突发奇想试着解答一下。</p><span id="more"></span><h1 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h1><p>先直接给出结论，<code>malloc</code> 的内存位于堆区，顺便简单了解下 C/C++ 的内存分布。对于 C/C++ 语言，程序内存分布如下：</p><ul><li>栈区(stack)：由编译器自动分配释放，存储函数的参数值，局部变量值等，其操作方法类似于数据结构中的栈</li><li>堆区(heap)：一般由程序员申请和释放，与数据结构中的堆没有任何关系，分配方式类似于链表</li><li>全局/静态区(static)：全局变量和静态变量是存储在一起的，在程序编译时分配</li><li>文字常量区：存储常量字符串</li><li>程序代码区：存储函数体(类的成员函数、全局函数)的二进制代码</li></ul><p>重点是其中的栈区和堆区：</p><ul><li><p>栈区：程序自动向操作系统申请分配以及回收，速度快，使用方便，但是程序员无法控制。如果分配的内存超过了栈区的最大空间，会抛出栈溢出错误。const 局部变量也存储在栈区，栈区向地址减小的方向增长。系统为变量在栈上申请内存后，CPU 需要不断地判断变量是否已结束使用的生命周期，如果生命周期结束，系统就会释放为这个变量申请的栈内存，这样一来随着在栈上申请的变量增多，会对 CPU 造成额外的消耗。</p></li><li><p>堆区：程序员向操作系统申请一段内存，当系统收到程序的申请时，会遍历一个记录空内存结点的链表，找到第一个空间大于或等于所申请空间的堆结点，将该空闲结点从链表中删除，并将该结点的空间分配给程序，如果链表中空闲结点的空间大于申请空间的大小，系统会自动将对于的部分放入空闲链表中，故容易造成内存的碎片化，分配速度较慢，地址不连续。且堆区的内存由程序员申请，也必须由程序员负责管理和释放，否则会导致内存泄漏，堆的增长方向与内存地址的增长方向相同，因此在堆区上申请空间理论上是没有大小限制的，但是受安装内存条的大小和系统以及其他程序的占用，不是无限大的。不像栈上的变量那样，需要消耗 CPU 资源判断变量的生命周期，所以不会对 CPU 造成额外的消耗，这也是程序员申请堆上内存的优点。</p></li></ul><p>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生内存泄露。碎片问题：对于堆来讲，频繁的 <code>malloc/free</code> 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。</p><h1 id="1G-内存-4G-数组"><a href="#1G-内存-4G-数组" class="headerlink" title="1G 内存 4G 数组"></a>1G 内存 4G 数组</h1><p>在了解 <code>malloc</code> 分配到的堆区大小取决于内存剩余的空闲空间后，再来研究能不能分配出大于空闲空间的数据。先给出结论，在虚拟内存足够大的情况下，1G 大小的内存可以开辟出 4G 的数组。虚拟内存是一个假象的内存空间，在程序运行过程中虚拟内存空间中需要被访问的部分会被映射到物理内存空间中。虚拟内空间大只能表示程序运行过程中可访问的空间比较大，不代表物理内存空间占用也大。</p><p><code>malloc</code> 可以申请到超出机器物理内存的大小，为什么说是一部分呢，因为可申请的内存不仅和已占用的内存相关，还和机器的 <code>swap space</code> （虚拟内存）相关，事实上在你给你机器装 Linux 系统的时候应该碰到过，那就是磁盘分区的时候会有一个 <code>swap</code>设定，只需要知道它是一种挂载在物理硬盘上，用来存放一些不太频繁使用的内存，是一种低速的物理内存的扩展。</p><p>当物理内存不够用时，原先一些物理内存中不常访问的内容会被转移到这里以让出空间给其它进程。所以 <code>swap</code> 空间也可以被 <code>malloc</code> 申请到。<code>malloc</code> 这个时候申请了内存，但没有完全申请，这就涉及到一个叫做 <code>Lazy Allocation</code> 的东东，当你使用 <code>malloc</code> 时，系统并没有真正从物理内存中分配，而是等到进程要操作时才提供 <code>allocation</code>。</p><p>因此，正是因为虚拟内存的存在，通过虚拟内存可以让程序可以拥有超过系统物理内存大小的可用内存空间。</p><h2 id="虚拟内存扩展"><a href="#虚拟内存扩展" class="headerlink" title="虚拟内存扩展"></a>虚拟内存扩展</h2><p>这是我研究生第一节课老师讲述的内容（顿时我就觉得那老师才是真正的计算机学者）：虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉。使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区，<strong>不同进程使用的虚拟地址彼此隔离</strong>。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存，如果各个进程之间没有独立的地址空间，一个进程由于执行错误指令或是恶意代码都可以直接修改其它进程的数据，甚至修改内核地址空间的数据，这是操作系统所不愿看到的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;闲来无事，在面经上看到了一个问题：在物理机只有 1G 内存的情况下，能否 &lt;code&gt;malloc&lt;/code&gt; 出 4G 大小的数组。奇怪的是，这个问题在网上搜不到特别好的解答，于是突发奇想试着解答一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OS" scheme="https://muyuuuu.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：链表反转问题</title>
    <link href="https://muyuuuu.github.io/2022/06/24/link/"/>
    <id>https://muyuuuu.github.io/2022/06/24/link/</id>
    <published>2022-06-24T13:44:00.000Z</published>
    <updated>2022-06-24T14:35:18.445Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文集中写链表的反转问题，因为其他的链表相交、链表数量等问题比较简单，即使没啥算法经验也能写个差不多，而链表反转也算一种经典的递归问题。这个文章的文字描述太乱了，有时间回来补图。</p><span id="more"></span><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。反转链表有两种实现方式，一种是迭代式实现，一种是通过递归实现。先来看通过迭代实现：迭代的反转需要使用三个指针，<code>pre</code>，<code>cur</code> 和 <code>nxt</code>，核心思想就是 <code>cur</code> 不断的向后移动过程中，让 <code>cur</code> 指向 <code>pre</code>。而这一过程分为四步：</p><ol><li><code>nxt = nxt-&gt;next</code>，先让 <code>nxt</code> 向后移动，因为 <code>cur</code> 指向 <code>pre</code> 之后，需要通过 <code>nxt</code> 找到下一个节点</li><li><code>cur-&gt;next = pre</code>，实现指针的反转，让 <code>cur</code> 指向上一个指针</li><li><code>pre = cur</code>，为下一次反转做准备，<code>pre</code> 就是在反转中要被指向的节点</li><li><code>cur = nxt</code>，<code>cur</code> 指向下一个节点，为下一次反转做准备</li></ol><p>通过以上四点，我们可以在推出一些细节：</p><ol><li><code>pre</code> 的初始值应该是 <code>null</code>，因为任何一个链表的末尾节点应该是空节点，而第一次反转时 <code>cur</code> 指向了 <code>pre</code>，因此 <code>pre</code> 也就是链表的末尾，因此 <code>pre</code> 初始为空</li><li><code>cur</code> 的初始值就是 <code>head</code> 节点，<code>nxt</code> 的初始值也是 <code>head</code> 节点，因为这样才能让 <code>nxt = nxt-&gt;next</code> 和 <code>cur-&gt;next = pre</code> 有意义</li><li>如果 <code>nxt</code> 指向 <code>null</code>，说明此时链表反转完毕，而 <code>cur</code> 指向的就是 <code>nxt</code>，因此最后要返回 <code>pre</code> 指针</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">ListNode</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : val&#123;x&#125; &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">      ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">      ListNode* cur = head;</span><br><span class="line">      ListNode* nxt = head;</span><br><span class="line">      <span class="keyword">while</span> (nxt != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        nxt = nxt-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至于递归方法就简单了很多：</p><ol><li>如果这个节点是原链表的尾部节点，那么直接将其返回，而且每一层递归函数的返回值都是它。而尾部节点的判断方式就是 <code>head-&gt;next == null</code>。因此先写出部分程序：如下的程序中，任何一个递归函数返回的都是链表的尾部节点。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* last = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>在找到尾部节点后，将其余节点依次反转即可。而且一定是在找到尾部节点后反转，如果在找到尾部节点之前就反转，链表就无法向下递归。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模板</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* last = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head; <span class="comment">// 后面的节点指向自己</span></span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 自己的下一个节点是 nullptr</span></span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h2><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回反转后的链表 。</p><p><img data-src="https://s1.ax1x.com/2022/06/24/jFNxsS.jpg" alt></p><p>我决定以后用递归了，如果用迭代去写，涉及的变量和程序都比较繁琐。基于上面的递归反转：和反转全部链表不同，部分反转链表，需要在反转后，将链表的尾部指向原链表不反转部分的下一个元素。之前指向的是 <code>nullptr</code>，那么这里就需要指向原链表不反转部分的第一个元素。并返回反转链表后的第一个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* node, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// right=1 的时候，下一个元素就是不需要反转的链表的第一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">1</span>) &#123;</span><br><span class="line">            p = node-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* last = <span class="built_in">reverse</span>(node-&gt;next, right - <span class="number">1</span>);</span><br><span class="line">        node-&gt;next-&gt;next = node;</span><br><span class="line">        <span class="comment">// 之前指向 nullptr，现在指向 p</span></span><br><span class="line">        node-&gt;next = p;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是链表的头部</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 反转前 k 个链表</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reverse</span>(head, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归，head-&gt;next 移动一次，left 和 right 都递减</span></span><br><span class="line">        <span class="comment">// head-&gt;next 指向链表的第一个元素，无论反转或不反转，也是递归的精髓</span></span><br><span class="line">        head-&gt;next = <span class="built_in">reverseBetween</span>(head-&gt;next, left<span class="number">-1</span>, right<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。<code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><img data-src="https://s1.ax1x.com/2022/06/24/jFU4Wq.jpg" alt></p><p>和上一题一样，反转后的链表末尾元素需要指向不需要反转的链表的第一个元素。第一题，反转链表的末尾元素指向 <code>nullptr</code>，所以需要和 <code>nullptr</code> 判断关系，这里同理，只是不是 <code>nullptr</code> 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* p1, ListNode* p2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指向谁，就和谁判断，第一题的 nullptr 也是如此</span></span><br><span class="line">        <span class="keyword">if</span> (p1 == p2 || p1-&gt;next == p2) &#123;</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* last = <span class="built_in">reverse</span>(p1-&gt;next, p2);</span><br><span class="line">        p1-&gt;next-&gt;next = p1;</span><br><span class="line">        p1-&gt;next = p2;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是反转链表的头</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        ListNode* p2 = head;</span><br><span class="line">        <span class="comment">// 如果不够反转，就不用反转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p2 == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一次链表反转，的第一个元素一定是最后链表的头，因此要返回</span></span><br><span class="line">        ListNode* last = <span class="built_in">reverse</span>(p1, p2);</span><br><span class="line">        <span class="comment">// 头指针变成局部链表的尾指针，串起整个链表</span></span><br><span class="line">        head-&gt;next = <span class="built_in">reverseKGroup</span>(p2, k);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文集中写链表的反转问题，因为其他的链表相交、链表数量等问题比较简单，即使没啥算法经验也能写个差不多，而链表反转也算一种经典的递归问题。这个文章的文字描述太乱了，有时间回来补图。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：优先遍历</title>
    <link href="https://muyuuuu.github.io/2022/05/30/dfs-bfs/"/>
    <id>https://muyuuuu.github.io/2022/05/30/dfs-bfs/</id>
    <published>2022-05-30T13:42:03.000Z</published>
    <updated>2022-06-24T14:36:44.546Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要收录深度优先遍历和宽度优先遍历，深度优先遍历一般可以与回溯、递归、树等方法联用，达到优雅遍历的效果，而宽度优先搜索可以用到最短路问题的求解中。</p><ul><li>为什么不用 <code>bfs</code> 去遍历？第一是因为 <code>bfs</code> 写起来麻烦，不如 <code>dfs</code> 直观。第二是在某些查找到满足情况即可退出的应用而言，<code>bfs</code> 需要一层一层的去检查，效率很低。</li><li>为什么不用 <code>dfs</code> 去求最短路？如上所示，<code>bfs</code> 可以一层一层的检查，相对 <code>dfs</code> 更容易查到最短路。</li></ul><span id="more"></span><h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><h2 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h2><h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a>130. 被围绕的区域</h3><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><p><img data-src="https://s1.ax1x.com/2022/05/30/X3SX8I.jpg" alt></p><ol><li>那么如何填充内部的 <code>O</code> 呢？这里就要用到 <code>dfs</code>，首先遍历 <code>board</code>，如果遇到了 <code>O</code>，那个和这个 <code>O</code> 相邻的 <code>O</code> 也要被填充，此时就要使用 <code>dfs</code> 来查找相邻的 <code>O</code></li><li>由于只填充被 <code>X</code> 包围的 <code>O</code>，因此，边界上的 <code>O</code> 不能被填充。那么我们预先把和边界相连的 <code>O</code> 都填充为其他符号，在处理完 <code>board</code> 内部的 <code>O</code> 的时候，在把其他符号替换为 <code>O</code> 即可。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>();</span><br><span class="line">        m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 替换边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i, <span class="number">0</span>, board, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(i, m<span class="number">-1</span>, board, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">0</span>, i, board, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(n<span class="number">-1</span>, i, board, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 填充内部的 O</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(i, j, board, <span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换回来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs 查找相连的 O</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">char</span> pad)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= n || c &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[r][c] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            board[r][c] = pad;</span><br><span class="line">            <span class="built_in">dfs</span>(r + <span class="number">1</span>, c, board, pad);</span><br><span class="line">            <span class="built_in">dfs</span>(r - <span class="number">1</span>, c, board, pad);</span><br><span class="line">            <span class="built_in">dfs</span>(r, c + <span class="number">1</span>, board, pad);</span><br><span class="line">            <span class="built_in">dfs</span>(r, c - <span class="number">1</span>, board, pad);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h1><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h2><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。</p><p><img data-src="https://s1.ax1x.com/2022/06/24/jFdQv6.jpg" alt></p><p>求二叉树或者多叉树中根节点到叶子节点的最短路径，一般都是 <code>bfs</code> 遍历算法。给出 <code>bfs</code> 的模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">queue.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (queue.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> s = queue.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = queue.<span class="built_in">top</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != null)</span><br><span class="line">            queue.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != null)</span><br><span class="line">            queue.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在进入 <code>bfs</code> 之前先处理一些极端的特殊情况，比如根节点为空，根节点就是目标节点等</li><li>在处理完特殊情况后，之后就是 <code>bfs</code> 遍历，如果遍历期间的节点满足目标情况，返回结果即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        deque&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">                <span class="comment">// 找到了叶子节点，直接返回深度</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.<span class="built_in">push_back</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.<span class="built_in">push_back</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="752-打开转盘锁"><a href="#752-打开转盘锁" class="headerlink" title="752. 打开转盘锁"></a>752. 打开转盘锁</h2><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有 10 个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。</span><br><span class="line">注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，</span><br><span class="line">因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</span><br></pre></td></tr></table></figure><ul><li>寻找最短路径时，同样需要使用 <code>bfs</code> 算法。我们把这个问题看成一个多叉树问题，如果 <code>00</code> 是根节点，那么叶子节点就是 <code>01, 10, 09, 90</code>，同理，也能得到 <code>0000</code> 为根节点时对应的叶子节点</li><li>同样，先处理极端情况，如根节点被死锁，以及根节点就是目标的特殊情况</li><li>之后，以 <code>0000</code> 为根节点开始 <code>bfs</code> 算法，我们手写两个函数，分别为 <code>_up</code> 和 <code>_down</code> 来对 <code>0000</code> 的每一位进行转动进而得到子节点，如果子节点满足要求，返回此时的深度即可</li><li>与二叉树不同的是，二叉树使用 <code>root-&gt;left, root-&gt;right</code> 能保证不会遍历重复节点，而对于此问题，很有可能从 <code>0000</code> 查找到 <code>5555</code>，又从 <code>5555</code> 查找回 <code>0000</code>，因为只要一直转动下去，<code>0000</code> 也是 <code>5555</code> 的子节点。因此，在遍历期间需要设置一个 <code>map</code>，将遍历过的节点添加进去，保证不会重复遍历一个节点，不走回头路。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    string _up(string node, <span class="type">int</span> idx) &#123;</span><br><span class="line">        string s = node;</span><br><span class="line">        <span class="keyword">if</span> (s[idx] == <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            s[idx] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s[idx] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string _down(string node, <span class="type">int</span> idx) &#123;</span><br><span class="line">        string s = node;</span><br><span class="line">        <span class="keyword">if</span> (s[idx] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            s[idx] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s[idx] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">        deque&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : deadends)</span><br><span class="line">            m[i] = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (m[<span class="string">&quot;0000&quot;</span>] == <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="string">&quot;0000&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    string s1 = _up(node, i);</span><br><span class="line">                    <span class="keyword">if</span> (s1 == target)</span><br><span class="line">                        <span class="keyword">return</span> cnt;</span><br><span class="line">                    <span class="keyword">if</span> (m[s1] != <span class="number">10</span>) &#123;</span><br><span class="line">                        m[s1] = <span class="number">10</span>;</span><br><span class="line">                        q.<span class="built_in">push_back</span>(s1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    string s2 = _down(node, i);</span><br><span class="line">                    <span class="keyword">if</span> (s2 == target)</span><br><span class="line">                        <span class="keyword">return</span> cnt;</span><br><span class="line">                    <span class="keyword">if</span> (m[s2] != <span class="number">10</span>) &#123;</span><br><span class="line">                        m[s2] = <span class="number">10</span>;</span><br><span class="line">                        q.<span class="built_in">push_back</span>(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要收录深度优先遍历和宽度优先遍历，深度优先遍历一般可以与回溯、递归、树等方法联用，达到优雅遍历的效果，而宽度优先搜索可以用到最短路问题的求解中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么不用 &lt;code&gt;bfs&lt;/code&gt; 去遍历？第一是因为 &lt;code&gt;bfs&lt;/code&gt; 写起来麻烦，不如 &lt;code&gt;dfs&lt;/code&gt; 直观。第二是在某些查找到满足情况即可退出的应用而言，&lt;code&gt;bfs&lt;/code&gt; 需要一层一层的去检查，效率很低。&lt;/li&gt;
&lt;li&gt;为什么不用 &lt;code&gt;dfs&lt;/code&gt; 去求最短路？如上所示，&lt;code&gt;bfs&lt;/code&gt; 可以一层一层的检查，相对 &lt;code&gt;dfs&lt;/code&gt; 更容易查到最短路。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：回溯</title>
    <link href="https://muyuuuu.github.io/2022/05/28/backtrack/"/>
    <id>https://muyuuuu.github.io/2022/05/28/backtrack/</id>
    <published>2022-05-28T06:30:27.000Z</published>
    <updated>2022-06-24T14:45:41.644Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>回溯算法是一种暴力枚举的算法。但是，枚举是一个技术活，枚举过程如何保证不重复、剪纸、不遗漏和优先处理可能的结果，这并不简单。</p><p>回溯应该是算法系列中除动态规划外最难的一个，需要很好的明确回溯入口，退出条件，两者保证回溯的不遗漏。而下一步如何回溯，以及如何退出当前状态要保证回溯的不重复。也许有些抽象，我们来看具体例子。</p><span id="more"></span><h1 id="什么是回溯"><a href="#什么是回溯" class="headerlink" title="什么是回溯"></a>什么是回溯</h1><p>如果简单的说回溯，那么如下函数就可以解释清楚：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : arr) &#123;</span><br><span class="line">    <span class="built_in">backtrack</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n)</span><br><span class="line">        退出条件</span><br><span class="line">    <span class="comment">// 回溯入口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> j : arr[i]) &#123;</span><br><span class="line">        vector.<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="comment">// 下一步而回溯</span></span><br><span class="line">        <span class="built_in">backtrack</span>(j);</span><br><span class="line">        <span class="comment">// 退出当前的状态，往回走</span></span><br><span class="line">        <span class="comment">// 因此叫做回溯</span></span><br><span class="line">        vector.<span class="built_in">pop_back</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图路径"><a href="#图路径" class="headerlink" title="图路径"></a>图路径</h1><h2 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797. 所有可能的路径"></a>797. 所有可能的路径</h2><p>给你一个有 <code>n</code> 个节点的 有向无环图 <code>DAG</code>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出，不要求按特定顺序。<code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p><p><img data-src="https://s1.ax1x.com/2022/05/28/Xul4OA.jpg" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure><p>如果说从 0 开始，而 0 又指向 1 和 2，那么只能按照这样的顺序找下去，因为题目并没有说要求最短路径。如果遍历的是 0，1，3，那么在找完这条路径后，需要回退，找到 0，1，2 这条路径。也就是，这算是一道回溯类题目。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 回溯入口</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, n, graph);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 退出条件</span></span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 回溯入口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i : graph[idx]) &#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="built_in">dfs</span>(i, n, graph);</span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h1><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><p>给定一个不含重复数字的数组 <code>nums</code>，返回其所有可能的全排列 。你可以按任意顺序返回答案。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p>和上一题大体相同，我们来分析一下不同点在哪里。</p><ul><li>全排列问题，由于会出现 <code>[3,2,1]</code> 这样的情况，因此回溯的入口每次都是 <code>0</code>，而不能是上次回溯的终点，因为 <code>3</code> 后面没有任何东西</li><li>其次，由于每次入口都是 <code>0</code>，而且每个元素只能出现一次，因此我们需要使用一个 <code>map</code>，根据索引记录该元素是否使用，只有没有使用时才能回溯</li><li>回溯的退出条件为子序列长度等于 <code>nums</code> 的长度</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> idx, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                    m[i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">backtrack</span>(i, nums);</span><br><span class="line">                    m[i] = <span class="number">0</span>;</span><br><span class="line">                    tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h2><p>给定一个可包含重复数字的序列 <code>nums</code> ，按任意顺序返回所有不重复的全排列。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><p>根据前面提到的求解回溯问题的框架，我们可以注意到这个题有两个细节：</p><ul><li>由于 <code>2</code> 可以出现在 <code>1</code> 的前面，因此每次回溯的起点都是 <code>0</code>。而为了避免添加重复元素，我们需要使用一个 <code>map</code>，记录哪些元素被添加过，从过跳过已经被添加的元素</li><li>由于会有重复元素，根据我对回溯问题的了解，我建议先对 <code>nums</code> 进行排序，而后先将结果添加到集合内，最后将结果放入 <code>vector</code> 内</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    set&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>, nums);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : res)</span><br><span class="line">            r.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> idx, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 回溯入口始终为 0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="comment">// 如果没有被添加</span></span><br><span class="line">                <span class="keyword">if</span> (m[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                    m[i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">backtrack</span>(<span class="number">0</span>, nums);</span><br><span class="line">                    m[i] = <span class="number">0</span>;</span><br><span class="line">                    tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h1><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><p>给你一个无重复元素的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的所有不同组合 ，并以列表形式返回。你可以按任意顺序返回这些组合。</p><p><code>candidates</code> 中的同一个数字可以无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p>需要注意的是，如果回溯的入口是 <code>0</code>，那么可以得到 <code>2+2+3=7</code> 的结果，在后续的回溯中，如果入口是 <code>1</code>，而 <code>3</code> 在之前以及的结果中已经使用过了。因此和上一题不一样的是，下一次回溯的入口是上一次回溯的出口，由于一个数值允许多次使用，因此入口和出口的值是可以相等的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    map&lt;vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>, candidates, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _sum(vector&lt;<span class="type">int</span>&gt;&amp; tmp) &#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : tmp)</span><br><span class="line">            s += i;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> idx, vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_sum(tmp) == target) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// idx 是回溯的入口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((candidates[i] &lt;= target) &amp;&amp; (_sum(tmp) + candidates[i] &lt;= target)) &#123;</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">                    <span class="comment">// i 是回溯的出口，也就是下一次回溯的入口</span></span><br><span class="line">                    <span class="built_in">backtrack</span>(i, candidates, target);</span><br><span class="line">                    tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a>40. 组合总和 II</h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的每个数字在每个组合中只能使用一次。注意：解集不能包含重复的组合。示例 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>既然每个数字只能使用一次，根据上一题我们能知道：下一次回溯的入口和上一次回溯的出口不能相同</li><li>此外，这个题的重点是：<strong>可能存在相同数字，因此，我们需要在回溯的过程中进行剪枝</strong>。剪枝发生在：同一层数值相同的结点第 2、3 … 个结点，因为数值相同的第 1 个结点已经搜索出了包含了这个数值的全部结果，同一层的其它结点，候选数的个数更少，搜索出的结果一定不会比第 1 个结点更多，并且是第 1 个结点的子集。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    set&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> tmp_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>, tmp_sum, candidates, target);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; r1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : res) &#123;</span><br><span class="line">            r1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span>&amp; tmp_sum, vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp_sum == target) &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="comment">// 剪枝，i &gt; idx 保证第一个结果计算完了</span></span><br><span class="line">                <span class="comment">// candidates[i] == candidates[i-1] 去除相同的子情况</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; idx &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (tmp_sum + candidates[i] &lt;= target) &#123;</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">                    tmp_sum += candidates[i];</span><br><span class="line">                    <span class="built_in">backtrack</span>(i + <span class="number">1</span>, tmp_sum, candidates, target);</span><br><span class="line">                    tmp_sum -= candidates[i];</span><br><span class="line">                    tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h2><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。你可以按任何顺序返回答案。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>由于出现 <code>[1,2]</code> 后就不会在出现 <code>[2,1]</code>，因此每次回溯的入口是上次回溯的出口 +1</li><li>回溯的退出条件是 <code>tmp.size()==k</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt;= n; i++) &#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="comment">// 下一次回溯的入口，是本次回溯出口 +1</span></span><br><span class="line">                <span class="built_in">backtrack</span>(i + <span class="number">1</span>, n, k);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a>216. 组合总和 III</h2><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字 1 到 9</li><li>每个数字最多使用一次 </li><li>返回所有可能的有效组合的列表。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</li></ul><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><ul><li>由于每个数字只能使用一次，因此每次回溯的入口是上次回溯的出口 +1</li><li>回溯退出的条件有两个，一个是和满足，一个是数量满足</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> tmpSum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">1</span>, k, n, tmpSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span>&amp; tmpSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmpSum == n &amp;&amp; tmp.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmpSum + i &lt;= n) &#123;</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    tmpSum += i;</span><br><span class="line">                    <span class="built_in">backtrack</span>(i + <span class="number">1</span>, k, n, tmpSum);</span><br><span class="line">                    tmpSum -= i;</span><br><span class="line">                    tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h1><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h2><p>给你一个整数数组 <code>nums</code>，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。你可以按任意顺序返回解集。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p>我们发现回溯期间的任何结果都会被返回，即使是一个空集，因此：回溯不在设置退出条件，但此时需要保证回溯的入口条件正确。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> idx, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(i + <span class="number">1</span>, nums);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h2><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。返回的解集中，子集可以按任意顺序排列。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure><p>前文已经提到过，如果有重复元素，对于重复元素，先排序，在将结果存储到集合中，最后转化为 <code>vector</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>, nums);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : res) &#123;</span><br><span class="line">            r.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> idx, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">insert</span>(tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(i + <span class="number">1</span>, nums);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="回溯实战"><a href="#回溯实战" class="headerlink" title="回溯实战"></a>回溯实战</h1><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p>这个和之前的回溯还不太一样，之前的回溯是选择填入一个数字，或者说每次回溯只能选择一个数字，而一般是可以按照顺序选择数字的。但是这个题不同的是，当前的字符取决于前面的字符，如果前面的字符是 <code>(</code>，那么后面的字符可能是 <code>(</code> 或者 <code>)</code>，如果前面的字符是 <code>)</code>，后面的字符可能是 <code>(</code> 或 <code>)</code>，具体是哪一个还需要判断前面的次数，这样程序的逻辑会很复杂。</p><p>也就是说，这种情况，不能用 <code>for</code> 循环遍历 <code>()</code> 来回溯。既然如此，只能在回溯中进行遍历。</p><ul><li>如果此时任何一个括号的使用次数大于 <code>n</code>，退出</li><li>回溯期间，无论如何左括号的使用次数一定大于右括号，因此当右括号的使用次数大于左括号时，退出</li><li>之后就是没有循环的回溯，回溯有两部分，分别是添加 <code>(</code> 和 <code>)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s&#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; <span class="number">0</span> || r &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; l)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 所有括号被添加</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 追加左括号</span></span><br><span class="line">        s += <span class="string">&quot;(&quot;</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(l - <span class="number">1</span>, r);</span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// 追加右括号</span></span><br><span class="line">        s += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(l, r - <span class="number">1</span>);</span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="回溯游戏"><a href="#回溯游戏" class="headerlink" title="回溯游戏"></a>回溯游戏</h1><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。数独的解法需遵循如下规则：</p><ul><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</li><li>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</li></ul><p><img data-src="https://s1.ax1x.com/2022/06/24/jFda8I.png" alt></p><ul><li>对于这个回溯问题，我们发现遍历时有三种状态：行、列和数字，也就是说，不同于之前的数组遍历，选择一个数字就行。这个题在遍历期间，需要处理三种状态。</li><li>一般情况是，回溯本身就能处理一些状态的遍历，此时需要保证本次回溯的入口是上次回溯的出口 +1。</li><li>对于本题目，回溯本身处理行和列的遍历，每次回溯时列自增，当列等于 9 时行自增。而在回溯中，使用训练遍历数字，由于上一个回溯选择数字和本次回溯选择的数字有先后关系，因此数字的循环始终为 <code>1,...,9</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, board);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> row, <span class="type">int</span> col, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (board[row][i] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (board[(row/<span class="number">3</span>)*<span class="number">3</span> + i/<span class="number">3</span>][(col/<span class="number">3</span>)*<span class="number">3</span> + i%<span class="number">3</span>] == c)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row &gt; <span class="number">9</span> || col &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (col == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(row + <span class="number">1</span>, <span class="number">0</span>, board);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[row][col] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(row, col + <span class="number">1</span>, board);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c = <span class="string">&#x27;1&#x27;</span>; c &lt;= <span class="string">&#x27;9&#x27;</span>; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isvalid</span>(c, row, col, board)) &#123;</span><br><span class="line">                board[row][col] = c;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(row, col + <span class="number">1</span>, board))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a>51. N 皇后</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<code>n</code> 皇后问题 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <code>n</code> 皇后问题的解决方案。每一种解法包含一个不同的 <code>n</code> 皇后问题 的棋子放置方案，该方案中 <code>Q</code> 和 <code>.</code> 分别代表了皇后和空位。</p><p>和数独不一样的是，这个题的遍历状态只有行和列，因为棋子的状态只有 <code>Q</code>，回溯前放 <code>Q</code>，回溯后回退为 <code>.</code> 即可。</p><p>既然如此，按照常规的想法，就用循环遍历列，当这一列满足要求时，就进入下一行，开始填充下一行的棋子，想到这里，回溯的程序也就可以写出来了。</p><p>也就是说对于回溯问题，至少要让回溯中的循环控制一个状态的遍历，而回溯本身则控制其他状态的遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        tmp.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                s += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            tmp[i] = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="number">0</span>, tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;string&gt;&amp; tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[row][i] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; ((i &gt;= <span class="number">0</span>) &amp;&amp; (j &gt;= <span class="number">0</span>)); i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; ((i &gt;= <span class="number">0</span>) &amp;&amp; (j &lt; tmp.<span class="built_in">size</span>())); i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> row, vector&lt;string&gt;&amp; tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (row == tmp.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">valid</span>(row, i, tmp)) &#123;</span><br><span class="line">                tmp[row][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">backtrack</span>(row + <span class="number">1</span>, tmp);</span><br><span class="line">                tmp[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;回溯算法是一种暴力枚举的算法。但是，枚举是一个技术活，枚举过程如何保证不重复、剪纸、不遗漏和优先处理可能的结果，这并不简单。&lt;/p&gt;
&lt;p&gt;回溯应该是算法系列中除动态规划外最难的一个，需要很好的明确回溯入口，退出条件，两者保证回溯的不遗漏。而下一步如何回溯，以及如何退出当前状态要保证回溯的不重复。也许有些抽象，我们来看具体例子。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：数学运算与位运算</title>
    <link href="https://muyuuuu.github.io/2022/05/27/math-and-bit/"/>
    <id>https://muyuuuu.github.io/2022/05/27/math-and-bit/</id>
    <published>2022-05-27T13:41:03.000Z</published>
    <updated>2022-07-06T15:53:59.983Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前从未意识到位运算的强大威力，认为与或非只存在大一 C 语言的考试或单片机的设计中，直到今天才发现我错了。做一个常用的位运算和数学运算的整理。</p><span id="more"></span><h1 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h1><p>与运算我们都知道，1 与 1 为 1，其他的与运算结果都是 0。那这有什么用呢？如果一个数用二进制表示，不断的进行 <code>n = n &amp; (n-1)</code> 运算，可以知道这个数的二进制有多少个 1。</p><h2 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a>191. 位1的个数</h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><p>这个题就是上面说的与运算的经典例子，直接写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n = n &amp; (n<span class="number">-1</span>);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="231-2-的幂"><a href="#231-2-的幂" class="headerlink" title="231. 2 的幂"></a>231. 2 的幂</h2><p>给你一个整数 <code>n</code>，请你判断该整数是否是 <code>2</code> 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。如果存在一个整数 <code>x</code> 使得 $n == 2^x$ ，则认为 <code>n</code> 是 <code>2</code> 的幂次方。</p><p>不要急，我们脑部一下 2 的幂那些数，比如 4，8，16 有什么显著特点，答案是他们的二进制只有一个 1，那么就很简单了。利用上一题的结论，直接判断输入的数字二进制中是否有一个 1 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> a = n &amp; (n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> a == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h1><p>如果不出意外的话，这个运算只会在考试前一周牢牢记住，考试完彻底忘记。今天来补充一下，异或运算是指：当两数相同时，输出为 <code>false</code>，不同时，输出为 <code>true</code>。异或具有以下性质：</p><ol><li>交换率：$p \circ q = q \circ p$</li><li>结合率：$p \circ (a \circ b) = p \circ a \circ b$</li><li>恒等率：$p \circ 0 = p$</li><li>归零率：$p \circ p = 0$</li><li>自反率：$p \circ q \circ q = 0$</li></ol><p>其实自反率就是交换率的延伸，而用的最多的也是自反，用于判断数组中只出现一次的元素。只需要异或数组内的全部元素，由于其他元素均重复出现。因此结果只保留只出现一次的元素。</p><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>注意，初始化为 0，因为任何数异或 0 都是它自己。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a>268. 丢失的数字</h2><p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure><p>因为数字的范围是 <code>[0,n]</code> 且丢失了其中一个，那么我们直接异或 <code>[0,...,n]</code>，再去异或输入的数组，结果就是缺失的数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="阶乘问题"><a href="#阶乘问题" class="headerlink" title="阶乘问题"></a>阶乘问题</h1><p>阶乘或数学运算等问题只需要记住一点，不用真的去算，因为结果一定会越界。</p><h2 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a>172. 阶乘后的零</h2><p>给定一个整数 <code>n</code> ，返回 <code>n!</code> 结果中尾随零的数量。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：0</span><br><span class="line">解释：3! = 6 ，不含尾随 0</span><br></pre></td></tr></table></figure><p>我们首先来分析，阶乘的时候只有出现 5 或 5 的倍数时，阶乘才能出现 0。因此，如果阶乘的数字小于 5，可以直接返回 0。而 19 这样的数字能提供 5，10，15 一共 3 个 5，因此末尾 0 的数量就是 3。</p><p>此外，对于 25，125 等 5 的幂次方，25，50，75，100 能提供两个 5。也就是说，针对这种情况需要额外的处理，处理完 5 后要处理 25，然后 125，直到遇到 0 结束。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            res += n / <span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="793-阶乘函数后-K-个零"><a href="#793-阶乘函数后-K-个零" class="headerlink" title="793. 阶乘函数后 K 个零"></a>793. 阶乘函数后 K 个零</h2><p><code>f(x)</code> 是 <code>x!</code> 末尾是 <code>0</code> 的数量。例如，<code>f(3) = 0</code> ，因为 <code>3! = 6</code> 的末尾没有 <code>0</code> ；而 <code>f(11) = 2</code> ，因为  <code>11!= 39916800</code> 末端有 <code>2</code> 个 <code>0</code> 。给定 <code>k</code>，找出返回能满足 <code>f(x) = k</code> 的非负整数 <code>x</code> 的数量。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 0</span><br><span class="line">输出：5</span><br><span class="line">解释：0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。</span><br></pre></td></tr></table></figure><p>分析题意：</p><ol><li>如果末尾没有 0，那么一定是 0，1，2，3，4 这 5 个数</li><li>如果末尾有 0，利用 172 题的结论，二分查找即可。如果满足给定的 0 的个数，那么一定是 5 个数，因为，6 个数的情况下，一定会多出一个 0。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 0 的数量</span></span><br><span class="line">    <span class="function">lng <span class="title">find_</span><span class="params">(lng mid)</span> </span>&#123;</span><br><span class="line">        lng n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (mid) &#123;</span><br><span class="line">            n += mid / <span class="number">5</span>;</span><br><span class="line">            mid /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">preimageSizeFZF</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        lng l = <span class="number">0</span>, r = lNG_MAX;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            lng mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">auto</span> a = <span class="built_in">find_</span>(mid);</span><br><span class="line">            <span class="keyword">if</span> (a == k)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; k) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; k) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h1><h2 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h2><p>给定整数 <code>n</code> ，返回 所有小于非负整数 <code>n</code> 的质数的数量 。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure><p>高效的计数素数。我理解的高效是，如果之前计算过，那么后续就不用计算了。如 2 是素数，那么 4，6，8，10 则都不是素数，如果遍历到 7，那么 14，21 也不是素数。</p><p>按照想法写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">arr</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 素数常见处理，平方小于 n 即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]) &#123;</span><br><span class="line">                <span class="comment">// 这个数的倍数都是素数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i) &#123;</span><br><span class="line">                    arr[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 剩下的都是素数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i])</span><br><span class="line">                res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="超级幂运算"><a href="#超级幂运算" class="headerlink" title="超级幂运算"></a>超级幂运算</h1><h2 id="372-超级次方"><a href="#372-超级次方" class="headerlink" title="372. 超级次方"></a>372. 超级次方</h2><p>你的任务是计算 $a^b$ 对 <code>1337</code> 取模，<code>a</code> 是一个正整数，<code>b</code> 是一个非常大的正整数且会以数组形式给出。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2, b = [3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure><p>如果要计算 $4^{1337}$ 次方，直接暴力计算是愚蠢的行为。我们对问题进行分解：$4^{1337} = 4^7 \times 4^{(133)10}$，分治这不就来了。</p><p>如果说，之前需要运算 1337 次，那么分治后，只需要运算 7 + 3 + 3 + 1 + 10 + 10 + 10 次，显著降低运算次数，算是一种空间换时间吧。</p><p>在补充一条数学运算：<code>(a * b) % c = (a % c) * (b % c) % c</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mod = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _pow(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> s1 = a;</span><br><span class="line">        <span class="type">int</span> s2 = a;</span><br><span class="line">        s2 %= mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            s2 *= (s1 % mod);</span><br><span class="line">            s2 %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">superPow</span><span class="params">(<span class="type">int</span> a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> e = b.<span class="built_in">back</span>();</span><br><span class="line">        b.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="type">int</span> a1 = _pow(a, e);</span><br><span class="line">        <span class="type">int</span> a2 = _pow(<span class="built_in">superPow</span>(a, b), <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> (a1 % mod) * (a2 % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <code>a，b，c</code> ，使得 <code>a + b + c = 0</code> ？请你找出所有和为 <code>0</code> 且不重复的三元组。注意：答案中不可以包含重复的三元组。示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure><p>在此之前，先来看两数之和。在数组中找到两个数，两数之和为 0。此时我们对数组进行排序，并使用两个指针，左指针从左向右移动，右指针从右向左移动，求两者之和，如果和大于 0，说明右指针指向的数据太大，需要将右指针左移，反之将左指针右移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">twoSumTarget</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// nums 数组必须有序</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> sum = nums[l] + nums[hi];</span><br><span class="line">        <span class="type">int</span> left = nums[l], right = nums[hi];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是呢，对于 <code>[-3, -3, 1, 2, 3]</code> 这样的数组而言，第一个 <code>-3</code> 计算过之后，第二个 <code>-3</code> 就没必要计算了。因此，可以在数值相等的情况下省略一些情况，前提是数组必须有序。写出以下优化的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">twoSumTarget</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// nums 数组必须有序</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> sum = nums[l] + nums[r];</span><br><span class="line">        <span class="type">int</span> left = nums[l], right = nums[r];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == left) l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == right) r--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == left) l++;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == right) r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们可以写出三数之和：</p><ul><li>遍历数组，得到第一个数 <code>first</code>，因为数组是有序的，如果 <code>first&gt;0</code> 的情况就可以跳过</li><li>那么另外两个数必须在 <code>first</code> 之后，且另外两数之和需要等于 <code>-first</code>，此时套用上面的两数之和的程序即可</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> first = <span class="number">0</span>; first &lt; n; first++) &#123;</span><br><span class="line">            <span class="comment">// 如果第一个 first 算过了，后面相等的值都可以忽略</span></span><br><span class="line">            <span class="keyword">if</span> (nums[first] &gt; <span class="number">0</span> || (first &gt; <span class="number">0</span> &amp;&amp; nums[first<span class="number">-1</span>] == nums[first])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> target = -nums[first];</span><br><span class="line">            <span class="comment">// third 是双指针中的右指针</span></span><br><span class="line">            <span class="type">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> second = first + <span class="number">1</span>; second &lt; n; second++) &#123;</span><br><span class="line">                <span class="comment">// 忽略算过的值</span></span><br><span class="line">                <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second<span class="number">-1</span>] == nums[second]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (third &gt; second &amp;&amp; nums[third] + nums[second] &gt; target) &#123;</span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不能有相同的值</span></span><br><span class="line">                <span class="keyword">if</span> (third == second) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 保留结果</span></span><br><span class="line">                <span class="keyword">if</span> (nums[third] + nums[second] == target) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前从未意识到位运算的强大威力，认为与或非只存在大一 C 语言的考试或单片机的设计中，直到今天才发现我错了。做一个常用的位运算和数学运算的整理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：滑动窗口</title>
    <link href="https://muyuuuu.github.io/2022/05/24/slide-window/"/>
    <id>https://muyuuuu.github.io/2022/05/24/slide-window/</id>
    <published>2022-05-24T13:21:21.000Z</published>
    <updated>2022-05-24T14:04:57.473Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>听到滑动窗口这个词，让我想起了计算机网络中的 TCP 传输和拥塞控制，可惜时隔多年还给老师了，那老师讲课还很不错。我的大部分本科老师都有着很多年的工作经验，并不像部分硕博留校那种只擅长验证玩具理论和咬文嚼字，而从未到实际环境中实习过一次。所以他们讲课十分形象具体，结合理论和实际环境告诉你这是个什么东西。</p><p>说远了，回到正题。滑动窗口一般用于求接子串中满足某种情况的最值，可以简单的划分为三类：</p><ol><li>给一个字符串，求满足条件的最长子串</li><li>给两个字符串，求其中一个字符串是否能覆盖另一个字符串</li><li>给定一个数组和窗口大小，窗口没滑动一次，求一次最值</li></ol><span id="more"></span><h1 id="满足条件的最长子串"><a href="#满足条件的最长子串" class="headerlink" title="满足条件的最长子串"></a>满足条件的最长子串</h1><p>这个是最简单的一个，也是后面其他滑动窗口的模板。既然是滑动窗口，就必然有一个窗口和滑动的步骤。为了实现窗口，我们定义两个指针，左指针和右指针。随着右指针的移动，窗口逐渐变大，也就是窗口扩张。如果破坏了和满足了题目要求，那么左指针移动，称为窗口收缩，根据题目条件判断窗口收缩的程度，然后当前窗口就是一个满足题意的结果。</p><p>随着左右指针的先后移动，会以此查找子串中所有满足情况的子串，我们保留其中的最值即可。说了这么多，来看一个例题，不然太抽象了。</p><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>我们来分析一下，条件就是不含重复子串，结果就是保留最短的子串长度。既然如此，大概思想就是：</p><ol><li>右指针移动扩张窗口</li><li>当窗口内有重复元素时，收缩窗口，直到没有重复元素</li><li>记录窗口的大小，也就是没有重复字符的子串长度</li><li>重复这个流程，直到求出最长的子串</li></ol><p>我们写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m1;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 右侧指针滑动</span></span><br><span class="line">            <span class="type">char</span> c = s[r];</span><br><span class="line">            r++;</span><br><span class="line">            m1[c] ++;</span><br><span class="line">            <span class="comment">// 不满足重复条件，因此要收缩，直到满足条件</span></span><br><span class="line">            <span class="keyword">while</span> (m1[c] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">char</span> d = s[l];</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">if</span> (m1[d] &gt;= <span class="number">2</span>)</span><br><span class="line">                    m1[d] --;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (m1[d] == <span class="number">1</span>)</span><br><span class="line">                    m1.<span class="built_in">erase</span>(d);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 窗口收缩后，此时满足不重复条件</span></span><br><span class="line">            <span class="comment">// 记录结果</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == <span class="number">0</span> ? n : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="子串包含问题"><a href="#子串包含问题" class="headerlink" title="子串包含问题"></a>子串包含问题</h1><h2 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a>567. 字符串的排列</h2><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code>。换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 子串。如 <code>adc</code> 是 <code>kajihscda</code> 的子串。</p><p>同样，窗口滑动的时候，把条件判断更改为是否能覆盖 <code>s1</code> 即可：</p><ol><li>右指针移动扩张窗口</li><li>如果能覆盖 <code>s1</code>，收缩窗口，直到不能覆盖 <code>s1</code></li><li>记录窗口的大小，也就是 <code>s2</code> 中的窗口大小</li><li>判断这个窗口是否为 <code>s1</code> 的排列组合</li></ol><p>甚至可以看到，这个和最开始的「无重复字符的最长子串」如出一辙，我们写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> valid = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m1;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s1)</span><br><span class="line">            m1[i]++;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="type">char</span> c = s2[r];</span><br><span class="line">            m2[c] ++;</span><br><span class="line">            <span class="comment">// 判断是否覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (m1.<span class="built_in">count</span>(c) &amp;&amp; m1[c] == m2[c]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 覆盖了，满足题中条件，开始收缩</span></span><br><span class="line">            <span class="keyword">while</span> (valid == m1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                res = r - l + <span class="number">1</span>;</span><br><span class="line">                <span class="type">char</span> d = s2[l];</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">if</span> (m1.<span class="built_in">count</span>(d) &amp;&amp; m1[d] == m2[d]) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                m2[d] --;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="comment">// 收缩结束，判断这个窗口是否满足结果</span></span><br><span class="line">            <span class="keyword">if</span> (res == s1.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h2><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure><p>和上一题一模一样，写出程序保存所有结果即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), valid = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m1;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : p)</span><br><span class="line">            m1[i]++;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[r];</span><br><span class="line">            m2[c]++;</span><br><span class="line">            <span class="keyword">if</span> (m1.<span class="built_in">count</span>(c) &amp;&amp; m1[c] == m2[c]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (valid == m1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="type">char</span> d = s[l];</span><br><span class="line">                ans = r - l + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (m1.<span class="built_in">count</span>(d) &amp;&amp; m1[d] == m2[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                m2[d]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans == p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res.<span class="built_in">empty</span>())</span><br><span class="line">                    res.<span class="built_in">push_back</span>(l - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="built_in">back</span>() != l - <span class="number">1</span>)</span><br><span class="line">                    res.<span class="built_in">push_back</span>(l - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p>仿佛不知道说啥，就把上一题的异位词，改成每次保留最短的子串就好了。如出一辙：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; t.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min_l = <span class="number">0</span>, min_r = <span class="number">0</span>, res = INT_MAX;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m1;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : t)</span><br><span class="line">            m1[i]++;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[r];</span><br><span class="line">            m2[c]++;</span><br><span class="line">            <span class="keyword">if</span> (m1.<span class="built_in">count</span>(c) &amp;&amp; m1[c] == m2[c]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (valid == m1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="type">char</span> d = s[l];</span><br><span class="line">                <span class="comment">// 每次都保留最短的</span></span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; res) &#123;</span><br><span class="line">                    res = r - l + <span class="number">1</span>;</span><br><span class="line">                    min_l = l;</span><br><span class="line">                    min_r = r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (m1.<span class="built_in">count</span>(d) &amp;&amp; m1[d] == m2[d]) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                m2[d]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(min_l, min_r - min_l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="窗口滑动时求最值"><a href="#窗口滑动时求最值" class="headerlink" title="窗口滑动时求最值"></a>窗口滑动时求最值</h1><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值 。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p>说实话，这是我见过最好的一个数据结构设计类题目。如果每次滑动都遍历求解最大值，是最简单的方法，也是超时的做法，此时就要发挥算法的魅力了：</p><ol><li>我实现一个数据结构，这个数据结构能很快的返回最大值，不需要用户操作什么。虽然很容易想到使用优先级队列，但是优先级队列是不行的，因为优先级队列会破坏元素进入的先后关系，我们不能破坏这一点</li><li>那我们自己定义一个队列，让队首元素是最大值即可，而且队列中的元素降序排列。既然有了队列，那么每次滑动求最大值就容易了，返回队首即可</li><li>且在滑动过程中，如果被滑出去的元素恰好是最大值，那就删除队列中的最大值。由于队列中的元素降序排列，因此下一个队首元素也一定是下一个窗口的最大值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myque</span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> max_num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myque</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">myque</span>(<span class="type">int</span> s) : size&#123;s&#125; &#123;&#125;;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 自定义队列，保证队列降序</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; num &gt; q.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果滑出去的是最大值，那么就滑走</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == q.<span class="built_in">front</span>())</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队首即最大值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">myque <span class="title">q</span><span class="params">(k)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="comment">// 先填充满窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始滑动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(q.<span class="built_in">getMax</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="乱入"><a href="#乱入" class="headerlink" title="乱入"></a>乱入</h1><p>开头提到讲课的老师，我还是很怀念我大学工程能力很强的老师。</p><ul><li>能力低下的老师讲课：我许多年前多么多么厉害，要参加比赛和科研，别人多么不行，你们多么差劲，两个小时的课说一个半小时没用的，这种老师基本硕博留校，上学期间写玩具代码或让别人写，但一定擅长咬文嚼字发文章，也不懂课程内容，只是被分配到了这里。就像我这个博客一样，内容不怎么样，但废话很多。</li><li>一般老师讲课：念 PPT，讲一些例题。</li><li>比较好的老师讲课：不念 PPT，把课本内容翻译成人话讲出来。</li><li>不错的老师讲课，讲完理念，告诉你实际生产环境该如何处理。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;听到滑动窗口这个词，让我想起了计算机网络中的 TCP 传输和拥塞控制，可惜时隔多年还给老师了，那老师讲课还很不错。我的大部分本科老师都有着很多年的工作经验，并不像部分硕博留校那种只擅长验证玩具理论和咬文嚼字，而从未到实际环境中实习过一次。所以他们讲课十分形象具体，结合理论和实际环境告诉你这是个什么东西。&lt;/p&gt;
&lt;p&gt;说远了，回到正题。滑动窗口一般用于求接子串中满足某种情况的最值，可以简单的划分为三类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给一个字符串，求满足条件的最长子串&lt;/li&gt;
&lt;li&gt;给两个字符串，求其中一个字符串是否能覆盖另一个字符串&lt;/li&gt;
&lt;li&gt;给定一个数组和窗口大小，窗口没滑动一次，求一次最值&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的类型转换</title>
    <link href="https://muyuuuu.github.io/2022/05/22/cpp-type-cast/"/>
    <id>https://muyuuuu.github.io/2022/05/22/cpp-type-cast/</id>
    <published>2022-05-22T14:16:02.000Z</published>
    <updated>2022-05-24T15:18:44.866Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今晚翻了一下 <code>todo list</code>，发现这个条目堆积在未完成列表的末尾，于是来学习一下 <code>C++</code> 中的四种类型转化方式，而 <code>C++</code> 的复习也告一段落。我知道我还差得很远，等某天 <code>C++</code> 功底足够深厚，来写一下 <code>C++</code> 的内存模型。</p><span id="more"></span><h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h1><p><code>static_cast</code> 是一个 <code>c++</code> 运算符，功能是把一个表达式转换为某种类型，依赖编译时得到的类型信息，没有运行时类型检查来保证转换的安全性，用于非多态类型的转换。所以为了安全起见，通常用于转换数值数据类型，如 <code>int</code> 到 <code>double</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">2</span>; </span><br><span class="line"><span class="type">double</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(a) /  b; </span><br></pre></td></tr></table></figure><p>如果涉及到类层次的类型转换，父到子不安全（向下转换），子到父安全（向上转换，也是隐式转换）。由于不检查转换的安全性，因此向下转换为子类类型时，可能有基类不存在的成员变量和函数，会导致未定义行为，直接报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">child</span> : <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    child a;</span><br><span class="line">    base b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> c = <span class="built_in">static_cast</span>&lt;base&gt;(a); <span class="comment">// fine</span></span><br><span class="line">    <span class="keyword">auto</span> d = <span class="built_in">static_cast</span>&lt;child&gt;(b); <span class="comment">// fail</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1><p><code>const_cast</code> 能给变量添加 <code>const</code> 特性或移除变量的 <code>const</code> 特性，其他的任何转换不能移除 <code>const</code> 修饰。因为可以直接将非 <code>const</code> 变量赋值给 <code>const</code> 变量，因此 <code>const_cast</code> 增加 <code>const</code> 修饰很少用到。此外，如果修饰的引用或指针指向的是 <code>const</code> 修饰的变量，将指针和引用修改为 <code>non-const</code> 会导致未定义行为；相反，如果修饰的变量不是 <code>const</code>，那么转换是安全的。</p><p>至于未定义行为是否能编译通过，取决于使用的编译器，不能一概而论。是 UB 不过这样写的话编译器不会报错， 然后一般来说会产生指向一个局部变量的指针， 所以也不会 <code>Segmentation fault</code> 。</p><p>但是如果是字符串常量， 那实现上会存放在 rodata， 运行时加载到了一个只读的页， 如果 <code>const_cast</code> 掉 <code>const</code> 然后写入那么就会 <code>Segmentation fault</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>; <span class="comment">// <span class="doctag">NOTE:</span> non-const object </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pA = &amp;a; <span class="comment">// non-const to const</span></span><br><span class="line">*pA = <span class="number">10</span>; <span class="comment">// compiler error, pA is a pointer to const int  </span></span><br><span class="line"><span class="type">int</span>* pX = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(pA); <span class="comment">// cast away constness </span></span><br><span class="line">*pX = <span class="number">10</span> <span class="comment">// fine and a is now 10 </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>; <span class="comment">// <span class="doctag">NOTE:</span> const object </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pA = &amp;a; </span><br><span class="line"><span class="type">int</span>* pX = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(pA); <span class="comment">// cast away constness  </span></span><br><span class="line">*pX = <span class="number">10</span> <span class="comment">// Free ticket to a long journey of UNDEFINED BEHAVIOR </span></span><br></pre></td></tr></table></figure><p>此外，<code>const_cast</code> 不能修改到其他的数据类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="literal">nullptr</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ptr = <span class="string">&quot;Hello&quot;</span>; </span><br><span class="line">a = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(ptr); <span class="comment">// Fail </span></span><br><span class="line">a = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(ptr); <span class="comment">// Fail, reinterpret_cast can&#x27;t cast away const qualifiers </span></span><br><span class="line">a = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(ptr)); <span class="comment">// Fine, as long as you know why you are doing it </span></span><br></pre></td></tr></table></figure><h1 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h1><p>这个是最危险的转换，如果使用这个转换，相当于告诉了编译器，我知道我在做什么。假如从 <code>A</code> 类型转换为 <code>B</code> 类型，那么就是基于 bit 模式，用 <code>B</code> 类型重新解释 <code>A</code> 类型之前指向的地址，由于是重新解释地址，因此这个转换不会编译为任何 CPU 指令。滥用 <code>reinterpret_cast</code> 运算符可能很容易带来风险，除非所需转换本身是低级别的，比如 int 到 double，否则建议使用其他强制转换运算符之一。</p><p>这个转换允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全），也允许将任何整数类型转换为任何指针类型以及反向转换。这些转换中唯一正确的是 <code>reinterpret_cast</code> 将变量转换为原类型, 会得到相同的值，但是如果中间变量所占内存小的话就不一定了。听着就危险，此外，<code>reinterpret_cast</code> 运算符不能丢掉 <code>const</code> 修饰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="comment">/* ... */</span> &#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; <span class="comment">/* ... */</span> &#125;;  </span><br><span class="line">A *a = <span class="keyword">new</span> A&#123;&#125;;  </span><br><span class="line">B *b = <span class="built_in">reinterpret_cast</span>&lt;B*&gt;(a);  <span class="comment">// Fine </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line"><span class="type">int</span>* data = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(message);  <span class="comment">// can&#x27;t remove const </span></span><br></pre></td></tr></table></figure><h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><p>这个和 <code>RTTI</code> 还有些关系，所以多说一些吧。这个转换应用于用于多态类型的转换，如果被转换的类型不具备多态性，那么向上转换可以在编译时期分析继承关系，确定类型，而且向下转换会直接报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; &#125;; </span><br><span class="line"> </span><br><span class="line">Base a, *ptr_a; </span><br><span class="line">Derived b, *ptr_b; </span><br><span class="line"> </span><br><span class="line">ptr_a = <span class="built_in">dynamic_cast</span>&lt;Base *&gt;(&amp;b);  <span class="comment">// Fine </span></span><br><span class="line">ptr_b = <span class="built_in">dynamic_cast</span>&lt;Derived *&gt;(&amp;a);  <span class="comment">// Fail </span></span><br></pre></td></tr></table></figure><p>假设此时基类具备了多态性，那么这个转换能够去检验具有继承关系的父子类型的指针、引用的转换是否安全。那么可以将一个指针类型或引用转换为其他多态类型，也可以用来向下转换。由于只适用于指针或引用，那么只能进行运行时类型检查，<code>dynamic_cast</code> 将寻找所需的对象并在可能的情况下返回它，对不明确的指针的转换将失败（返回 <code>nullptr</code>），但不引发异常。来看个例子：</p><p>第二个转换失败，因为子类不具有多态性，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125; &#125;; <span class="comment">// polymorphic class </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; <span class="type">int</span> a; &#125;; <span class="comment">// so is this </span></span><br><span class="line"></span><br><span class="line">Base *ptr_a = <span class="keyword">new</span> Derived&#123;&#125;; </span><br><span class="line">Base *ptr_b = <span class="keyword">new</span> Base&#123;&#125;; </span><br><span class="line"> </span><br><span class="line">Derived *ptr_c = <span class="literal">nullptr</span>; </span><br><span class="line">Derived *ptr_d = <span class="literal">nullptr</span>; </span><br><span class="line"> </span><br><span class="line">ptr_c = <span class="built_in">dynamic_cast</span>&lt;Derived *&gt;(ptr_a);  <span class="comment">// Fine, 指向的和转换的一致</span></span><br><span class="line">ptr_d = <span class="built_in">dynamic_cast</span>&lt;Derived *&gt;(ptr_b);  <span class="comment">// ptr_d will be NULL, 指向的和转换的不一致</span></span><br></pre></td></tr></table></figure><p><code>dynamic_cast</code> 在转换之前，就要确定基类究竟指向的是什么类型的对象。由于基类可能指向任何的自身类型对象、子类类型对象。所以，编译期基类指针是无法确定其指向的对象类型的，只能等到运行时。</p><h2 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h2><p>除 <code>dynamic_cast</code> 外，也能通过 <code>typeid</code> 运算符使用运行时堕胎，获得变量的类型。此时，需要重点注意的是，<code>typeid</code> 可以在编译期将获得变量的类型，也可以在运行期获得变量的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于无法在编译时期确认的类型，只能等到运行时期。如下所示的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: base &#123;<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span>&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> B: base &#123;</span><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span>&#125;</span></span><br></pre></td></tr></table></figure><p>但是重点是要把方法声明为虚方法:</p><ul><li>如果一个方法不是虚方法，那么将根据引用类型或指针类型选择执行的方法，静态联编</li><li>如果一个方法是虚方法，将根据指针或引用指向对象的类型选择执行的方法，动态联编</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今晚翻了一下 &lt;code&gt;todo list&lt;/code&gt;，发现这个条目堆积在未完成列表的末尾，于是来学习一下 &lt;code&gt;C++&lt;/code&gt; 中的四种类型转化方式，而 &lt;code&gt;C++&lt;/code&gt; 的复习也告一段落。我知道我还差得很远，等某天 &lt;code&gt;C++&lt;/code&gt; 功底足够深厚，来写一下 &lt;code&gt;C++&lt;/code&gt; 的内存模型。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
</feed>
