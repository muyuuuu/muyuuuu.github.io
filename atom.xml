<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just for Life.</title>
  
  <subtitle>明月更几时</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muyuuuu.github.io/"/>
  <updated>2022-05-24T14:04:57.473Z</updated>
  <id>https://muyuuuu.github.io/</id>
  
  <author>
    <name>兰铃</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法系列：滑动窗口</title>
    <link href="https://muyuuuu.github.io/2022/05/24/slide-window/"/>
    <id>https://muyuuuu.github.io/2022/05/24/slide-window/</id>
    <published>2022-05-24T13:21:21.000Z</published>
    <updated>2022-05-24T14:04:57.473Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>听到滑动窗口这个词，让我想起了计算机网络中的 TCP 传输和拥塞控制，可惜时隔多年还给老师了，那老师讲课还很不错。我的大部分本科老师都有着很多年的工作经验，并不像部分硕博留校那种只擅长验证玩具理论和咬文嚼字，而从未到实际环境中实习过一次。所以他们讲课十分形象具体，结合理论和实际环境告诉你这是个什么东西。</p><p>说远了，回到正题。滑动窗口一般用于求接子串中满足某种情况的最值，可以简单的划分为三类：</p><ol><li>给一个字符串，求满足条件的最长子串</li><li>给两个字符串，求其中一个字符串是否能覆盖另一个字符串</li><li>给定一个数组和窗口大小，窗口没滑动一次，求一次最值</li></ol><a id="more"></a><h1 id="满足条件的最长子串"><a href="#满足条件的最长子串" class="headerlink" title="满足条件的最长子串"></a>满足条件的最长子串</h1><p>这个是最简单的一个，也是后面其他滑动窗口的模板。既然是滑动窗口，就必然有一个窗口和滑动的步骤。为了实现窗口，我们定义两个指针，左指针和右指针。随着右指针的移动，窗口逐渐变大，也就是窗口扩张。如果破坏了和满足了题目要求，那么左指针移动，称为窗口收缩，根据题目条件判断窗口收缩的程度，然后当前窗口就是一个满足题意的结果。</p><p>随着左右指针的先后移动，会以此查找子串中所有满足情况的子串，我们保留其中的最值即可。说了这么多，来看一个例题，不然太抽象了。</p><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>我们来分析一下，条件就是不含重复子串，结果就是保留最短的子串长度。既然如此，大概思想就是：</p><ol><li>右指针移动扩张窗口</li><li>当窗口内有重复元素时，收缩窗口，直到没有重复元素</li><li>记录窗口的大小，也就是没有重复字符的子串长度</li><li>重复这个流程，直到求出最长的子串</li></ol><p>我们写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, n = s.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 右侧指针滑动</span></span><br><span class="line">            <span class="keyword">char</span> c = s[r];</span><br><span class="line">            r++;</span><br><span class="line">            m1[c] ++;</span><br><span class="line">            <span class="comment">// 不满足重复条件，因此要收缩，直到满足条件</span></span><br><span class="line">            <span class="keyword">while</span> (m1[c] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> d = s[l];</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">if</span> (m1[d] &gt;= <span class="number">2</span>)</span><br><span class="line">                    m1[d] --;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (m1[d] == <span class="number">1</span>)</span><br><span class="line">                    m1.erase(d);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 窗口收缩后，此时满足不重复条件</span></span><br><span class="line">            <span class="comment">// 记录结果</span></span><br><span class="line">            ans = max(ans, r - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == <span class="number">0</span> ? n : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="子串包含问题"><a href="#子串包含问题" class="headerlink" title="子串包含问题"></a>子串包含问题</h1><h2 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a>567. 字符串的排列</h2><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code>。换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 子串。如 <code>adc</code> 是 <code>kajihscda</code> 的子串。</p><p>同样，窗口滑动的时候，把条件判断更改为是否能覆盖 <code>s1</code> 即可：</p><ol><li>右指针移动扩张窗口</li><li>如果能覆盖 <code>s1</code>，收缩窗口，直到不能覆盖 <code>s1</code></li><li>记录窗口的大小，也就是 <code>s2</code> 中的窗口大小</li><li>判断这个窗口是否为 <code>s1</code> 的排列组合</li></ol><p>甚至可以看到，这个和最开始的「无重复字符的最长子串」如出一辙，我们写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s2.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s1)</span><br><span class="line">            m1[i]++;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s2[r];</span><br><span class="line">            m2[c] ++;</span><br><span class="line">            <span class="comment">// 判断是否覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (m1.count(c) &amp;&amp; m1[c] == m2[c]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 覆盖了，满足题中条件，开始收缩</span></span><br><span class="line">            <span class="keyword">while</span> (valid == m1.size()) &#123;</span><br><span class="line">                res = r - l + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">char</span> d = s2[l];</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">if</span> (m1.count(d) &amp;&amp; m1[d] == m2[d]) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                m2[d] --;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="comment">// 收缩结束，判断这个窗口是否满足结果</span></span><br><span class="line">            <span class="keyword">if</span> (res == s1.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h2><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure><p>和上一题一模一样，写出程序保存所有结果即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), valid = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : p)</span><br><span class="line">            m1[i]++;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[r];</span><br><span class="line">            m2[c]++;</span><br><span class="line">            <span class="keyword">if</span> (m1.count(c) &amp;&amp; m1[c] == m2[c]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (valid == m1.size()) &#123;</span><br><span class="line">                <span class="keyword">char</span> d = s[l];</span><br><span class="line">                ans = r - l + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (m1.count(d) &amp;&amp; m1[d] == m2[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                m2[d]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans == p.size()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res.empty())</span><br><span class="line">                    res.push_back(l - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (res.back() != l - <span class="number">1</span>)</span><br><span class="line">                    res.push_back(l - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p>仿佛不知道说啥，就把上一题的异位词，改成每次保留最短的子串就好了。如出一辙：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt; t.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_l = <span class="number">0</span>, min_r = <span class="number">0</span>, res = INT_MAX;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : t)</span><br><span class="line">            m1[i]++;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[r];</span><br><span class="line">            m2[c]++;</span><br><span class="line">            <span class="keyword">if</span> (m1.count(c) &amp;&amp; m1[c] == m2[c]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (valid == m1.size()) &#123;</span><br><span class="line">                <span class="keyword">char</span> d = s[l];</span><br><span class="line">                <span class="comment">// 每次都保留最短的</span></span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; res) &#123;</span><br><span class="line">                    res = r - l + <span class="number">1</span>;</span><br><span class="line">                    min_l = l;</span><br><span class="line">                    min_r = r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (m1.count(d) &amp;&amp; m1[d] == m2[d]) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                m2[d]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == <span class="number">0</span> ? <span class="string">""</span> : s.substr(min_l, min_r - min_l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="窗口滑动时求最值"><a href="#窗口滑动时求最值" class="headerlink" title="窗口滑动时求最值"></a>窗口滑动时求最值</h1><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值 。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p>说实话，这是我见过最好的一个数据结构设计类题目。如果每次滑动都遍历求解最大值，是最简单的方法，也是超时的做法，此时就要发挥算法的魅力了：</p><ol><li>我实现一个数据结构，这个数据结构能很快的返回最大值，不需要用户操作什么。虽然很容易想到使用优先级队列，但是优先级队列是不行的，因为优先级队列会破坏元素进入的先后关系，我们不能破坏这一点</li><li>那我们自己定义一个队列，让队首元素是最大值即可，而且队列中的元素降序排列。既然有了队列，那么每次滑动求最大值就容易了，返回队首即可</li><li>且在滑动过程中，如果被滑出去的元素恰好是最大值，那就删除队列中的最大值。由于队列中的元素降序排列，因此下一个队首元素也一定是下一个窗口的最大值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myque</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> max_num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    myque() &#123;&#125;;</span><br><span class="line">    myque(<span class="keyword">int</span> s) : size&#123;s&#125; &#123;&#125;;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 自定义队列，保证队列降序</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (q.size() &amp;&amp; num &gt; q.back()) &#123;</span><br><span class="line">            q.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        q.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果滑出去的是最大值，那么就滑走</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == q.front())</span><br><span class="line">            q.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队首即最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">myque <span class="title">q</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="comment">// 先填充满窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            q.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始滑动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            q.push(nums[i]);</span><br><span class="line">            res.push_back(q.getMax());</span><br><span class="line">            q.pop(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="乱入"><a href="#乱入" class="headerlink" title="乱入"></a>乱入</h1><p>开头提到讲课的老师，我还是很怀念我大学工程能力很强的老师。</p><ul><li>能力低下的老师讲课：我许多年前多么多么厉害，要参加比赛和科研，别人多么不行，你们多么差劲，两个小时的课说一个半小时没用的，这种老师基本硕博留校，上学期间写玩具代码或让别人写，但一定擅长咬文嚼字发文章，也不懂课程内容，只是被分配到了这里。就像我这个博客一样，内容不怎么样，但废话很多。</li><li>一般老师讲课：念 PPT，讲一些例题。</li><li>比较好的老师讲课：不念 PPT，把课本内容翻译成人话讲出来。</li><li>不错的老师讲课，讲完理念，告诉你实际生产环境该如何处理。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听到滑动窗口这个词，让我想起了计算机网络中的 TCP 传输和拥塞控制，可惜时隔多年还给老师了，那老师讲课还很不错。我的大部分本科老师都有着很多年的工作经验，并不像部分硕博留校那种只擅长验证玩具理论和咬文嚼字，而从未到实际环境中实习过一次。所以他们讲课十分形象具体，结合理论和实际环境告诉你这是个什么东西。&lt;/p&gt;
&lt;p&gt;说远了，回到正题。滑动窗口一般用于求接子串中满足某种情况的最值，可以简单的划分为三类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给一个字符串，求满足条件的最长子串&lt;/li&gt;
&lt;li&gt;给两个字符串，求其中一个字符串是否能覆盖另一个字符串&lt;/li&gt;
&lt;li&gt;给定一个数组和窗口大小，窗口没滑动一次，求一次最值&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的类型转换</title>
    <link href="https://muyuuuu.github.io/2022/05/22/cpp-type-cast/"/>
    <id>https://muyuuuu.github.io/2022/05/22/cpp-type-cast/</id>
    <published>2022-05-22T14:16:02.000Z</published>
    <updated>2022-05-24T15:18:44.866Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今晚翻了一下 <code>todo list</code>，发现这个条目堆积在未完成列表的末尾，于是来学习一下 <code>C++</code> 中的四种类型转化方式，而 <code>C++</code> 的复习也告一段落。我知道我还差得很远，等某天 <code>C++</code> 功底足够深厚，来写一下 <code>C++</code> 的内存模型。</p><a id="more"></a><h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h1><p><code>static_cast</code> 是一个 <code>c++</code> 运算符，功能是把一个表达式转换为某种类型，依赖编译时得到的类型信息，没有运行时类型检查来保证转换的安全性，用于非多态类型的转换。所以为了安全起见，通常用于转换数值数据类型，如 <code>int</code> 到 <code>double</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">double</span> result = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a) /  b;</span><br></pre></td></tr></table></figure><p>如果涉及到类层次的类型转换，父到子不安全（向下转换），子到父安全（向上转换，也是隐式转换）。由于不检查转换的安全性，因此向下转换为子类类型时，可能有基类不存在的成员变量和函数，会导致未定义行为，直接报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    child a;</span><br><span class="line">    base b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> c = <span class="keyword">static_cast</span>&lt;base&gt;(a); <span class="comment">// fine</span></span><br><span class="line">    <span class="keyword">auto</span> d = <span class="keyword">static_cast</span>&lt;child&gt;(b); <span class="comment">// fail</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1><p><code>const_cast</code> 能给变量添加 <code>const</code> 特性或移除变量的 <code>const</code> 特性，其他的任何转换不能移除 <code>const</code> 修饰。因为可以直接将非 <code>const</code> 变量赋值给 <code>const</code> 变量，因此 <code>const_cast</code> 增加 <code>const</code> 修饰很少用到。此外，如果修饰的引用或指针指向的是 <code>const</code> 修饰的变量，将指针和引用修改为 <code>non-const</code> 会导致未定义行为；相反，如果修饰的变量不是 <code>const</code>，那么转换是安全的。</p><p>至于未定义行为是否能编译通过，取决于使用的编译器，不能一概而论。是 UB 不过这样写的话编译器不会报错， 然后一般来说会产生指向一个局部变量的指针， 所以也不会 <code>Segmentation fault</code> 。</p><p>但是如果是字符串常量， 那实现上会存放在 rodata， 运行时加载到了一个只读的页， 如果 <code>const_cast</code> 掉 <code>const</code> 然后写入那么就会 <code>Segmentation fault</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// <span class="doctag">NOTE:</span> non-const object </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* pA = &amp;a; <span class="comment">// non-const to const</span></span><br><span class="line">*pA = <span class="number">10</span>; <span class="comment">// compiler error, pA is a pointer to const int  </span></span><br><span class="line"><span class="keyword">int</span>* pX = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(pA); <span class="comment">// cast away constness </span></span><br><span class="line">*pX = <span class="number">10</span> <span class="comment">// fine and a is now 10 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// <span class="doctag">NOTE:</span> const object </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* pA = &amp;a; </span><br><span class="line"><span class="keyword">int</span>* pX = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(pA); <span class="comment">// cast away constness  </span></span><br><span class="line">*pX = <span class="number">10</span> <span class="comment">// Free ticket to a long journey of UNDEFINED BEHAVIOR</span></span><br></pre></td></tr></table></figure><p>此外，<code>const_cast</code> 不能修改到其他的数据类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="literal">nullptr</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ptr = <span class="string">"Hello"</span>; </span><br><span class="line">a = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(ptr); <span class="comment">// Fail </span></span><br><span class="line">a = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(ptr); <span class="comment">// Fail, reinterpret_cast can't cast away const qualifiers </span></span><br><span class="line">a = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr)); <span class="comment">// Fine, as long as you know why you are doing it</span></span><br></pre></td></tr></table></figure><h1 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h1><p>这个是最危险的转换，如果使用这个转换，相当于告诉了编译器，我知道我在做什么。假如从 <code>A</code> 类型转换为 <code>B</code> 类型，那么就是基于 bit 模式，用 <code>B</code> 类型重新解释 <code>A</code> 类型之前指向的地址，由于是重新解释地址，因此这个转换不会编译为任何 CPU 指令。滥用 <code>reinterpret_cast</code> 运算符可能很容易带来风险，除非所需转换本身是低级别的，比如 int 到 double，否则建议使用其他强制转换运算符之一。</p><p>这个转换允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全），也允许将任何整数类型转换为任何指针类型以及反向转换。这些转换中唯一正确的是 <code>reinterpret_cast</code> 将变量转换为原类型, 会得到相同的值，但是如果中间变量所占内存小的话就不一定了。听着就危险，此外，<code>reinterpret_cast</code> 运算符不能丢掉 <code>const</code> 修饰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;  </span><br><span class="line">A *a = <span class="keyword">new</span> A&#123;&#125;;  </span><br><span class="line">B *b = <span class="keyword">reinterpret_cast</span>&lt;B*&gt;(a);  <span class="comment">// Fine </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* message = <span class="string">"hello"</span>;  </span><br><span class="line"><span class="keyword">int</span>* data = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(message);  <span class="comment">// can't remove const</span></span><br></pre></td></tr></table></figure><h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><p>这个和 <code>RTTI</code> 还有些关系，所以多说一些吧。这个转换应用于用于多态类型的转换，如果被转换的类型不具备多态性，那么向上转换可以在编译时期分析继承关系，确定类型，而且向下转换会直接报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> &#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; &#125;; </span><br><span class="line"> </span><br><span class="line">Base a, *ptr_a; </span><br><span class="line">Derived b, *ptr_b; </span><br><span class="line"> </span><br><span class="line">ptr_a = <span class="keyword">dynamic_cast</span>&lt;Base *&gt;(&amp;b);  <span class="comment">// Fine </span></span><br><span class="line">ptr_b = <span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(&amp;a);  <span class="comment">// Fail</span></span><br></pre></td></tr></table></figure><p>假设此时基类具备了多态性，那么这个转换能够去检验具有继承关系的父子类型的指针、引用的转换是否安全。那么可以将一个指针类型或引用转换为其他多态类型，也可以用来向下转换。由于只适用于指针或引用，那么只能进行运行时类型检查，<code>dynamic_cast</code> 将寻找所需的对象并在可能的情况下返回它，对不明确的指针的转换将失败（返回 <code>nullptr</code>），但不引发异常。来看个例子：</p><p>第二个转换失败，因为子类不具有多态性，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125; &#125;; <span class="comment">// polymorphic class </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; <span class="keyword">int</span> a; &#125;; <span class="comment">// so is this </span></span><br><span class="line"></span><br><span class="line">Base *ptr_a = <span class="keyword">new</span> Derived&#123;&#125;; </span><br><span class="line">Base *ptr_b = <span class="keyword">new</span> Base&#123;&#125;; </span><br><span class="line"> </span><br><span class="line">Derived *ptr_c = <span class="literal">nullptr</span>; </span><br><span class="line">Derived *ptr_d = <span class="literal">nullptr</span>; </span><br><span class="line"> </span><br><span class="line">ptr_c = <span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(ptr_a);  <span class="comment">// Fine, 指向的和转换的一致</span></span><br><span class="line">ptr_d = <span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(ptr_b);  <span class="comment">// ptr_d will be NULL, 指向的和转换的不一致</span></span><br></pre></td></tr></table></figure><p><code>dynamic_cast</code> 在转换之前，就要确定基类究竟指向的是什么类型的对象。由于基类可能指向任何的自身类型对象、子类类型对象。所以，编译期基类指针是无法确定其指向的对象类型的，只能等到运行时。</p><h2 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h2><p>除 <code>dynamic_cast</code> 外，也能通过 <code>typeid</code> 运算符使用运行时堕胎，获得变量的类型。此时，需要重点注意的是，<code>typeid</code> 可以在编译期将获得变量的类型，也可以在运行期获得变量的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(a).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于无法在编译时期确认的类型，只能等到运行时期。如下所示的程序：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A: base &#123;virtual void show() override&#125;</span><br><span class="line">class B: base &#123;virtual void show() override&#125;</span><br></pre></td></tr></table></figure><p>但是重点是要把方法声明为虚方法:</p><ul><li>如果一个方法不是虚方法，那么将根据引用类型或指针类型选择执行的方法，静态联编</li><li>如果一个方法是虚方法，将根据指针或引用指向对象的类型选择执行的方法，动态联编</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今晚翻了一下 &lt;code&gt;todo list&lt;/code&gt;，发现这个条目堆积在未完成列表的末尾，于是来学习一下 &lt;code&gt;C++&lt;/code&gt; 中的四种类型转化方式，而 &lt;code&gt;C++&lt;/code&gt; 的复习也告一段落。我知道我还差得很远，等某天 &lt;code&gt;C++&lt;/code&gt; 功底足够深厚，来写一下 &lt;code&gt;C++&lt;/code&gt; 的内存模型。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：数组类题目</title>
    <link href="https://muyuuuu.github.io/2022/05/22/array-series/"/>
    <id>https://muyuuuu.github.io/2022/05/22/array-series/</id>
    <published>2022-05-22T10:48:27.000Z</published>
    <updated>2022-05-24T13:21:06.601Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前没有很留意，没想到大一学过的数组也能有很多精彩的算法题。本文收录了数组类算法常见的：前缀和、差分数组、常数时间查找和删除数组元素和数组去重问题。</p><ul><li>前缀和数组：用于频繁求解给定区间内，数组元素的和</li><li>差分数组：用于频繁更改给定区间内数组元素的取值，最后得到数组</li></ul><p>前面两个侧重频繁修改数组，常规模拟算法必然超时。而至于常数时间内查找和删除数组元素，数组元素去重已经是固定要求的题目了，文末直接给出题解。</p><a id="more"></a><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>前缀和就是输入数组的累计和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">presum[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    presum[i] = presum[i<span class="number">-1</span>] + sum[i];</span><br></pre></td></tr></table></figure><p>因此， <code>presum[r] - presum[l-1]</code> 就是数组在区间 <code>[l,r]</code> 内的和。</p><p>前缀和算法一般用于求解以下问题：需要频繁的调用某个方法，这个方法需要求出数组在给定区间中元素的和。如果每次查询都要遍历数组求和，会超时的很严重，因此需要使用前缀和来解决。但是众所周知算法不可能这么简单，一边看题一边看前缀和的细节。</p><h2 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a>303. 区域和检索 - 数组不可变</h2><p>给定一个整数数组 <code>nums</code>，处理以下类型的多个查询: 计算索引 <code>left</code> 和 <code>right</code> （包含 <code>left</code> 和 <code>right</code>）之间的 <code>nums</code> 元素的和 ，其中 <code>left &lt;= right</code>。实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 中索引 <code>left</code> 和 <code>right</code> 之间的元素的总和 ，包含 <code>left</code> 和 <code>right</code> 两点（也就是 <code>nums[left] + nums[left + 1] + ... + nums[right]</code> ) 。示例 1：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, -1, -3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);</span><br><span class="line">numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)</span><br><span class="line">numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) </span><br><span class="line">numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</span><br></pre></td></tr></table></figure><p>这个是典型的求解区间数组和的题目，如果每次都暴力计算会超时。因此我们使用前缀和数组来解决问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; presum;</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        presum.resize(nums.size());</span><br><span class="line">        presum.assign(nums.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 构建前缀和</span></span><br><span class="line">        presum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            presum[i] = presum[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> presum[right];</span><br><span class="line">        <span class="keyword">return</span> presum[right] - presum[left - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般不建议这么写，因为 <code>left-1</code> 很容易越界，涉及到二维数组十分不好处理。因此，推荐的写法是，<strong>前缀和数组比输入数组大一个维度</strong>。此时，只需要让 <code>right+1</code> 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; presum;</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        presum.resize(nums.size() + <span class="number">1</span>);</span><br><span class="line">        presum.assign(nums.size() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 前缀和数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); i++) &#123;</span><br><span class="line">            presum[i] = presum[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> presum[right + <span class="number">1</span>] - presum[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二维区域和检索-矩阵不可变"><a href="#二维区域和检索-矩阵不可变" class="headerlink" title="二维区域和检索 - 矩阵不可变"></a>二维区域和检索 - 矩阵不可变</h2><p>给定一个二维矩阵 <code>matrix</code>，以下类型的多个请求：计算其子矩形范围内元素的总和，该子矩阵的 左上角为 <code>(row1, col1)</code> ，右下角为 <code>(row2, col2)</code> 。实现 <code>NumMatrix</code> 类：</p><ul><li><code>NumMatrix(int[][] matrix)</code> 给定整数矩阵 <code>matrix</code> 进行初始化</li><li><code>int sumRegion(int row1, int col1, int row2, int col2)</code> 返回左上角 <code>(row1, col1)</code> 、右下角 <code>(row2, col2)</code> 所描述的子矩阵的元素总和。</li></ul><p>对于二维数组，方法还是和一维数组一样，我们求某个坐标对应的前缀和就可以了。但是迫切建议前缀和数组大一个维度，不然边界情况真的很难处理。和一维数组一样，构建数组的前缀和数组，在求解指定区间的数组和时，也是两个边界相减就行，但是有一点点细节要处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; presum;</span><br><span class="line">    NumMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        presum.resize(m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            presum[i].assign(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        presum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 构建二维前缀和数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                presum[i][j] = matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] + presum[i<span class="number">-1</span>][j] + presum[i][j<span class="number">-1</span>] - presum[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间相减，但是要注意 presum[row1][col1] 减了两次</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> presum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - presum[row1][col2+<span class="number">1</span>] - presum[row2+<span class="number">1</span>][col1] + presum[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1124-表现良好的最长时间段"><a href="#1124-表现良好的最长时间段" class="headerlink" title="1124. 表现良好的最长时间段"></a>1124. 表现良好的最长时间段</h2><p>这个是和<a href="https://muyuuuu.github.io/2022/05/20/monotonic-stack/">单调栈</a>的梦幻联动，掌握了这个题，前缀和学的就可以了。</p><p>给你一份工作时间表 <code>hours</code>，上面记录着某一位员工每天的工作小时数。我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格大于「不劳累的天数」。请你返回「表现良好时间段」的最大长度。示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：hours = [9,9,6,0,6,6,9]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长的表现良好时间段是 [9,9,6]。</span><br></pre></td></tr></table></figure><p>一开始的时候毫无头绪，甚至暴力模拟也没有什么太好的思路，直到看了题解。</p><ol><li>因为工作时长以 8 小时为划分，不管是 10 小时还是 13 小时，本质是一样的，7 小时和 8 小时的本质也是一样的。因此，我们新建一个数组 <code>score</code>，大于 8 为 1，否则为 -1。</li><li>根据 <code>score</code> 构建前缀和数组，前缀和数组元素的值越大，表示近期的工作表现越良好。换一种说法，如果 <code>score</code> 数组呈现了上升的趋势，那么说明今天在好好工作。</li><li>因此，我们只需要求前缀和数组中的最大上升跨度，就是劳累天数严格大于不劳累天数，结果即为表现良好的时间段。最大跨度请参考<a href="http://localhost:4000/2022/05/20/monotonic-stack/" target="_blank" rel="noopener">单调栈</a>那篇文章的最后一题。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestWPI</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; hours)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = hours.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">presum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">socre</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            socre[i] = hours[i] &gt; <span class="number">8</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            presum[i] = presum[i<span class="number">-1</span>] + socre[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单调递减栈</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.empty() || presum[stk.top()] &gt; presum[i]) &#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大上升跨度</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stk.size() &amp;&amp; presum[stk.top()] &lt; presum[i]) &#123;</span><br><span class="line">                ans = max(ans, i - stk.top());</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h1><p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减，然后问你修改后的数组是多少。差分数组的构造方式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">diff[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    diff[i] = arr[i] - arr[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果让数组区间 <code>[l, r]</code> 内的元素增加 3，只需要让 <code>diff[l]+3</code>, <code>diff[r]-3</code> 即可 （自己画图理解下）。而通过 <code>diff</code> 也能得到原始的数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    arr[i] = arr[i<span class="number">-1</span>] + diff[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1109-航班预订统计"><a href="#1109-航班预订统计" class="headerlink" title="1109. 航班预订统计"></a>1109. 航班预订统计</h2><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p><p>有一份航班预订表 <code>bookings</code> ，表中第 i 条预订记录 <code>bookings[i] = [first[i], last[i], seats[i]]</code> 意味着在从 <code>first[i]</code> 到 <code>last[i]</code> （包含 <code>first[i]</code> 和 <code>last[i]</code> ）的每个航班上预订了 <code>seats[i]</code> 个座位。请你返回一个长度为 n 的数组 <code>answer</code>，里面的元素是每个航班预定的座位总数。示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2   3   4   5</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       20  20</span><br><span class="line">预订记录 3 ：       25  25  25  25</span><br><span class="line">总座位数：      10  55  45  25  25</span><br><span class="line">因此，answer = [10,55,45,25,25]</span><br></pre></td></tr></table></figure><p>典型的差分数组应用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : bookings) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = i[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> e = i[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> v = i[<span class="number">2</span>];</span><br><span class="line">            diff[s] += v;</span><br><span class="line">            <span class="comment">// 防止越界</span></span><br><span class="line">            <span class="keyword">if</span> (e + <span class="number">1</span> &lt;= n - <span class="number">1</span>)</span><br><span class="line">                diff[e + <span class="number">1</span>] -= v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] = res[i<span class="number">-1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="拼车"><a href="#拼车" class="headerlink" title="拼车"></a>拼车</h2><p>车上最初有 <code>capacity</code> 个空座位。车只能向一个方向行驶（也就是说，不允许掉头或改变方向。给定整数 <code>capacity</code> 和一个数组 <code>trips</code> ,  <code>trip[i] = [numPassengers[i], from[i], to[i]]</code> 表示第 i 次旅行有 <code>numPassengers[i]</code> 乘客，接他们和放他们的位置分别是 <code>from[i]</code> 和 <code>to[i]</code> 。这些位置是从汽车的初始位置向东的公里数。当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：trips = [[2,1,5],[3,3,7]], capacity = 4</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>这里需要注意的是，比如客户 A 在 5 下车，而客户 B 在 5 上车，此时是能顺利交接的。因此，下车的时候，<code>diff[r]-n</code> 即可，不需要占用 <code>r</code> 处的容量。可以理解为，在地点 4 ，车上就没有客户了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(<span class="number">1005</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : trips) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> s = i[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> e = i[<span class="number">2</span>];</span><br><span class="line">            diff[s] += v;</span><br><span class="line">            diff[e] -= v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1005</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 细节判断</span></span><br><span class="line">        <span class="keyword">if</span> (res[<span class="number">0</span>] &gt; capacity)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1005</span>; i++) &#123;</span><br><span class="line">            res[i] = res[i<span class="number">-1</span>] + diff[i];</span><br><span class="line">            <span class="keyword">if</span> (res[i] &gt; capacity)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><p>给你一个字符串 s，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bcabc&quot;</span><br><span class="line">输出：&quot;abc&quot;</span><br></pre></td></tr></table></figure><p>严格来说，这算一个模拟题，只要思路足够清晰，是可以写出代码的：</p><ol><li>每个字符只出现一次，因此在遍历字符串时，如果当前字符已经被添加到结果中时，需要跳过当前字符，避免重复；</li><li>如果当前字符没有在结果中，添加当前字符时需要一些处理来满足字典序。如果这个字符比上一个字符的字典序小，且上一个字符后面还会出现，我们就需要弹出上一个字符，添加当前字符。</li></ol><p>如果要实现以上两点，就需要使用哈希和栈。<code>need</code> 哈希表用于记录每个字符出现的次数，每添加一次，取值就递减，可以判断这个字符之后还会不会出现，以及出现的次数。<code>isin</code> 哈希表判断当前字符是否已经添加。<code>res</code> 栈用来存储结果，因为栈可以方便的弹出末尾元素来使字典序更小。程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need;</span><br><span class="line">        <span class="comment">// 记录次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.size(); i++) &#123;</span><br><span class="line">            need[s[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; res;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">isin</span><span class="params">(<span class="number">26</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">            <span class="comment">// 之后出现的次数递减</span></span><br><span class="line">            need[i]--;</span><br><span class="line">            <span class="comment">// 不在结果中</span></span><br><span class="line">            <span class="keyword">if</span> (isin[i - <span class="string">'a'</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="comment">// 可以弹栈的情况</span></span><br><span class="line">                <span class="keyword">while</span> (res.size() &amp;&amp; need[res.top()] &gt; <span class="number">0</span> &amp;&amp; res.top() &gt; i) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> a = res.top();</span><br><span class="line">                    res.pop();</span><br><span class="line">                    <span class="comment">// 弹栈后不在结果中</span></span><br><span class="line">                    isin[a - <span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res.push(i);</span><br><span class="line">                isin[i - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans&#123;<span class="string">""</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (res.size()) &#123;</span><br><span class="line">            ans += res.top();</span><br><span class="line">            res.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="O-1-时间查找和删除元素"><a href="#O-1-时间查找和删除元素" class="headerlink" title="$O(1)$ 时间查找和删除元素"></a>$O(1)$ 时间查找和删除元素</h1><p>刚开始看到题的时候给我整不会了，众所周知数组内查找元素的时间复杂度为 $O(n)$，有序数组内查找元素的时间复杂度为 $O(\log n)$，怎么可能做到 $O(1)$。</p><p>但看到题目是这种类的时间，频繁的调用方法插入和删除，那么 $O(1)$ 时间的查找和删除也有了可能。只需要在插入的时候通过哈希记录数值的索引，那么能很轻松的查找到数值是否在数组中，以及它的索引。</p><p>而要实现 $O(1)$ 的删除元素，我们知道 C++ 的 STL 支持 $O(1)$ 删除的只有 <code>pop_back()</code>  这样的方法。因此，当需要删除某一个值时，我们把这个数值和数组末尾的数值进行交换，而后 <code>pop_back()</code> 即可。</p><p>实现 <code>RandomizedSet</code> 类：</p><ol><li><code>RandomizedSet()</code> 初始化 <code>RandomizedSet</code> 对象</li><li><code>bool insert(int val)</code> 当元素 <code>val</code> 不存在时，向集合中插入该项，并返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>bool remove(int val)</code> 当元素 <code>val</code> 存在时，从集合中移除该项，并返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>int getRandom()</code> 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。<br>你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">输出</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">RandomizedSet randomizedSet = new RandomizedSet();</span><br><span class="line">randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span><br><span class="line">randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。</span><br><span class="line">randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。</span><br><span class="line">randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span><br><span class="line">randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。</span><br><span class="line">randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">    RandomizedSet() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入时记录索引</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m1.count(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push_back(val);</span><br><span class="line">        m1[val] = arr.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m1.count(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val_idx = m1[val];</span><br><span class="line">        <span class="keyword">int</span> back_val = arr.back();</span><br><span class="line">        <span class="keyword">int</span> back_idx = m1[back_val];</span><br><span class="line">        <span class="comment">// 和末尾元素交换</span></span><br><span class="line">        arr[val_idx] = back_val;</span><br><span class="line">        m1[back_val] = val_idx;</span><br><span class="line">        m1.erase(val);</span><br><span class="line">        arr.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机选择</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = rand() % arr.size();</span><br><span class="line">        <span class="keyword">return</span> arr[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前没有很留意，没想到大一学过的数组也能有很多精彩的算法题。本文收录了数组类算法常见的：前缀和、差分数组、常数时间查找和删除数组元素和数组去重问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前缀和数组：用于频繁求解给定区间内，数组元素的和&lt;/li&gt;
&lt;li&gt;差分数组：用于频繁更改给定区间内数组元素的取值，最后得到数组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面两个侧重频繁修改数组，常规模拟算法必然超时。而至于常数时间内查找和删除数组元素，数组元素去重已经是固定要求的题目了，文末直接给出题解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：单调栈</title>
    <link href="https://muyuuuu.github.io/2022/05/20/monotonic-stack/"/>
    <id>https://muyuuuu.github.io/2022/05/20/monotonic-stack/</id>
    <published>2022-05-20T14:26:12.000Z</published>
    <updated>2022-05-22T13:01:51.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单调栈属于栈的具体应用，而非栈这种数据结构的简单使用。此类问题一般用于求解以下场景：<strong>序列中某个元素的下一个最大元素，元素间的最大跨度，维持某一状态持续的最长时间等</strong>。以序列 <code>[2,1,3,4]</code> 为例，1 的下一个最大元素就是 3，而不是 4；最大上升的跨度为从 2 到 4，跨越了 2 个数。对于这种问题都可以用单调栈求解。</p><a id="more"></a><h1 id="为什么用单调栈"><a href="#为什么用单调栈" class="headerlink" title="为什么用单调栈"></a>为什么用单调栈</h1><p>同样以 <code>[2,1,3,4]</code> 为例，假设此时我们有一个容器，输入一个数，容器顶部的元素是下一个最大的数。对于 1 而言，后面的最大元素是 3，因此可以得到一个结论：3 比 1 先进入容器，更通用一些：<strong>如果判断下一个最大元素，序列就要倒序进入容器，如果判断上一个最大元素，序列就要顺序进入容器</strong>。</p><p>由于 1 比 2 先进入容器，但 2 的下一个最大元素是 3 而不是 1，那么就需要在容器中进行一些操作来删除 1。即 1 比 2 早进入容器，却要先从容器种出来，那么有什么容器是后入先出的呢？当然是栈。这也就是单调栈的由来。我们总结一下：</p><ul><li>如果是求下一个最大元素，就需要倒序遍历序列，否则正序遍历；</li><li>判断输入的元素和栈顶元素的关系，如果是求最大元素，那么就需要弹出栈顶所有的小元素；</li></ul><p>不过还有一些小细节，这个就来看具体的题目了。</p><h1 id="下一个最大-小元素"><a href="#下一个最大-小元素" class="headerlink" title="下一个最大/小元素"></a>下一个最大/小元素</h1><h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a>496. 下一个更大元素 I</h2><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的下一个更大元素 。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出：[-1,3,-1]</span><br><span class="line">解释：nums1 中每个值的下一个更大元素如下所述：</span><br><span class="line">- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</span><br><span class="line">- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。</span><br><span class="line">- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</span><br></pre></td></tr></table></figure><p>根据前面的结论，写出程序并分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">10005</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 求下一个最大元素，因此要倒序进入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums2.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 弹出栈顶的小元素</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; nums2[i] &gt;= stk.top()) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈为空，说明没有比当前元素更大的，只能 -1</span></span><br><span class="line">            <span class="comment">// 否则栈顶比输入大</span></span><br><span class="line">            res[nums2[i]] = stk.empty() ? <span class="number">-1</span> : stk.top();</span><br><span class="line">            <span class="comment">// 并把当前元素放入栈中，用去后面序列元素的判断</span></span><br><span class="line">            stk.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums1) &#123;</span><br><span class="line">            ans.push_back(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指在第 <code>i</code> 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure><p>和上一题不一样的是，这个题不在求下一个最大温度了，而是下一个最大温度的<strong>索引</strong>。因此压入栈中的是索引而不是温度，索引之间的差，就是相差的天数。在判断输入元素和栈顶元素的大小关系时，根据索引访问温度即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = temperatures.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 倒序输入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 抛弃掉温度低的，索引访问温度</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; temperatures[i] &gt;= temperatures[stk.top()]) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果今天温度不是最高的，那么索引的差距就是间隔的天数</span></span><br><span class="line">            res[i] = stk.empty() ? <span class="number">0</span> : stk.top() - i;</span><br><span class="line">            <span class="comment">// 把今天放进去</span></span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a>901. 股票价格跨度</h2><p>编写一个 <code>StockSpanner</code> 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。例如，如果未来7天股票的价格是 <code>[100, 80, 60, 70, 60, 75, 85]</code>，那么股票跨度将是 <code>[1, 1, 1, 2, 1, 4, 6]</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]</span><br><span class="line">输出：[null,1,1,1,2,1,4,6]</span><br><span class="line">解释：</span><br><span class="line">首先，初始化 S = StockSpanner()，然后：</span><br><span class="line">S.next(100) 被调用并返回 1，</span><br><span class="line">S.next(80) 被调用并返回 1，</span><br><span class="line">S.next(60) 被调用并返回 1，</span><br><span class="line">S.next(70) 被调用并返回 2，</span><br><span class="line">S.next(60) 被调用并返回 1，</span><br><span class="line">S.next(75) 被调用并返回 4，</span><br><span class="line">S.next(85) 被调用并返回 6。</span><br><span class="line"></span><br><span class="line">注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格</span><br><span class="line">(包括今天的价格 75) 小于或等于今天的价格。</span><br></pre></td></tr></table></figure><p>这个题问的是：序列中小于等于当前元素，因此需要正序输入，确切来说，只能正序输入。此外，<code>next()</code> 方法会不断的调用，如果每次调用都通过输入来重新构建栈，就会超时。因此，我们把单调栈的核心算法封装进 <code>next()</code> 方法即可，且由于求的是时间跨度，因此压入栈中的是索引。个人认为，能独立把这个题写出来，单调栈就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    StockSpanner() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 序列元素</span></span><br><span class="line">        arr.push_back(price);</span><br><span class="line">        <span class="keyword">int</span> res = build(price);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="comment">// 保留大栈顶，如 100 60 80 则保留为 100 80</span></span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; price &gt;= arr[stk.top()]) &#123;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一天，一定为 1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 否则，如果栈空了，说明前几天都比今天低，就返回天数。否则就求时间跨度</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a = stk.empty() ? n + <span class="number">1</span> : n - stk.top();</span><br><span class="line">        <span class="comment">// 把今天压入，这里先 +1 或先压入都可以，细节自行处理</span></span><br><span class="line">        stk.push(n);</span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockSpanner* obj = new StockSpanner();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="最大跨度问题"><a href="#最大跨度问题" class="headerlink" title="最大跨度问题"></a>最大跨度问题</h1><p>除了可以求解下一个最大元素外，单调栈还能求满足某一条件的<strong>最大跨度</strong>。</p><h2 id="962-最大宽度坡"><a href="#962-最大宽度坡" class="headerlink" title="962. 最大宽度坡"></a>962. 最大宽度坡</h2><p>给定一个整数数组 A，坡是元组 <code>(i, j)</code>，其中 <code>i &lt; j</code> 且 <code>A[i] &lt;= A[j]</code>。这样的坡的宽度为 <code>j - i</code>。找出 A 中的坡的最大宽度，如果不存在，返回 0 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[6,0,8,2,1,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.</span><br></pre></td></tr></table></figure><p>是不是觉得毫无头绪，我刚开始也是这么想的，后来直到看了一个不错的<a href="https://leetcode.cn/problems/maximum-width-ramp/solution/c-962-zui-da-kuan-du-po-ti-jie-dan-diao-5ztod/" target="_blank" rel="noopener">题解</a>。暴力破解能得到答案，但显然会超时，单调栈是如何应用到求最大跨度问题中呢？</p><p>首先来一点点的分析，由于要求解最大跨度，因此存储的肯定为索引。在者，对于 <code>[9,8,1,0,1,9,4,0,4,1]</code> 而言的最大跨度，我们希望在左边找很小的值，在右边找比左边大的值。并且有两个 0，显然第一个 0 能贡献的跨度更大。因此，基于以上两点，我们可以使用栈来存储单调递减序列的而索引，即：<code>[9,8,1,0]</code>，对应的索引是 <code>[0,1,2,3]</code>。如此，满足了找左侧很小值的目标，也满足了不考虑后面的 0。</p><p>之后，我们只要倒序遍历序列，依次和栈顶元素比较大小，如果大于，那么记录跨度并弹栈。随着弹栈的进行，索引会越来越小，也求到了更大的跨度。具体理解一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：[9,8,1,0,1,9,4,0,4,1]</span><br><span class="line">单调递减元素:[9,8,1,0], 对应下标:[0,1,2,3], 严格单调递减栈s:[0,1,2,3]</span><br><span class="line">j=9, nums[j]=1 &gt; nums[s.top()]=nums[3]=0, pos=s.top()=3, pop出3, res=max(res, j-pos)=(0, 9-3)=6</span><br><span class="line">     nums[j]=1 = nums[s.top()]=nums[2]=1, pos=s.top()=2, pop出2, res=max(res, j-pos)=(6, 9-2)=7</span><br><span class="line">     nums[j]=1 &lt; nums[s.top()]=nums[1]=8, 遍历下一个j</span><br><span class="line">j=8, nums[j]=4 &lt; nums[s.top()]=nums[1]=8, 遍历下一个j</span><br><span class="line">     ... </span><br><span class="line">     ...</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure><p>不难写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxWidthRamp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.empty() || nums[stk.top()] &gt; nums[i]) &#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stk.size() &amp;&amp; nums[j] &gt;= nums[stk.top()]) &#123;</span><br><span class="line">                res = max(res, j - stk.top());</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="维持某一状态最长的持续时间"><a href="#维持某一状态最长的持续时间" class="headerlink" title="维持某一状态最长的持续时间"></a>维持某一状态最长的持续时间</h1><p>这个题需要用到一些其他知识，因此和前缀和数组整理到一起了，可以观看下一篇博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单调栈属于栈的具体应用，而非栈这种数据结构的简单使用。此类问题一般用于求解以下场景：&lt;strong&gt;序列中某个元素的下一个最大元素，元素间的最大跨度，维持某一状态持续的最长时间等&lt;/strong&gt;。以序列 &lt;code&gt;[2,1,3,4]&lt;/code&gt; 为例，1 的下一个最大元素就是 3，而不是 4；最大上升的跨度为从 2 到 4，跨越了 2 个数。对于这种问题都可以用单调栈求解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：动态规划</title>
    <link href="https://muyuuuu.github.io/2022/05/16/dp-series/"/>
    <id>https://muyuuuu.github.io/2022/05/16/dp-series/</id>
    <published>2022-05-16T15:51:06.000Z</published>
    <updated>2022-05-22T12:59:33.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>动态规划作为算法中较难的部分，还是下定决心慢慢整理。人生建议：遇到太难的动态规划，建议直接放弃。动态规划解题也有技巧，一般而言题目的问题都是：移动最少的次数到达终点。此时我们只需要：</p><ol><li>设置 dp 数组，数组大小一般和输入相同，但细节需要微操。dp[i] 的含义是，到达 i 的最少次数</li><li>对 dp 数组进行初始化，即开始动态规划时，起始所需的次数，一般为 0，不过也有特殊情况</li><li>dp 的转移，如何从上一状态计算当前状态</li></ol><p>掌握这三点，一般难度的动态规划是可以做出来的。</p><a id="more"></a><h1 id="一维状态转移"><a href="#一维状态转移" class="headerlink" title="一维状态转移"></a>一维状态转移</h1><h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h2><p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><p>一维的状态转移是较为简单的动态规划。直接动态规划三步走，我们设 <code>dp[i]</code> 表示到达数组第 <code>i</code> 个位置需要的最少次数。第 <code>i</code> 个位置最小次数这个状态 <code>dp[i]</code>，有两种方式得到，要么本身最小，要么由上一个状态 +1 的来，即：<code>dp[i] = min(dp[i], dp[i-1] +1)</code>。</p><p>因此，我们的初始值要为 <code>INT_MAX</code>，因为如果用 0 初始化，<code>dp[i]</code> 始终为 0。我们写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 从 i 开始，能跳到的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums[i]; j++) &#123;</span><br><span class="line">                <span class="comment">// 这些位置的状态</span></span><br><span class="line">                <span class="keyword">if</span> (i + j &lt; n) &#123;</span><br><span class="line">                    dp[i + j] = min(dp[i + j], dp[i] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过这一题，顺便补充一点：动态规划中，$O(n^2)$ 时间复杂度的程序比较常见，不必担心超时。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划作为算法中较难的部分，还是下定决心慢慢整理。人生建议：遇到太难的动态规划，建议直接放弃。动态规划解题也有技巧，一般而言题目的问题都是：移动最少的次数到达终点。此时我们只需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置 dp 数组，数组大小一般和输入相同，但细节需要微操。dp[i] 的含义是，到达 i 的最少次数&lt;/li&gt;
&lt;li&gt;对 dp 数组进行初始化，即开始动态规划时，起始所需的次数，一般为 0，不过也有特殊情况&lt;/li&gt;
&lt;li&gt;dp 的转移，如何从上一状态计算当前状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;掌握这三点，一般难度的动态规划是可以做出来的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：区间问题</title>
    <link href="https://muyuuuu.github.io/2022/05/12/interval-algo/"/>
    <id>https://muyuuuu.github.io/2022/05/12/interval-algo/</id>
    <published>2022-05-12T15:45:46.000Z</published>
    <updated>2022-05-20T14:41:59.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>算法继续整理系列之区间问题。这类问题可以总结或者变化为：给定多个区间，求满足覆盖范围的最小相交区间的数量。一般而言都是：题目给定一个乱序的区间。我们需要对区间进行排序调整和统计结果，来满足题目条件。<strong>其中变化的部分只有如何处理相交区间</strong>，因此整理一个通用的算法模板。</p><a id="more"></a><h1 id="区间固定"><a href="#区间固定" class="headerlink" title="区间固定"></a>区间固定</h1><h2 id="986-固定区间的交集"><a href="#986-固定区间的交集" class="headerlink" title="986. 固定区间的交集"></a>986. 固定区间的交集</h2><p>先看一道简单的题目，这个题目中我们不需要对区间进行排序调整，因此相对简单一些。</p><p><img data-src="/2022/05/12/interval-algo/interval1.png" alt></p><p>这个题目很简单，我们只需要按照顺序遍历区间，处理相交部分：</p><ol><li>判断两个区间是否相交，如果不相交，右侧区间靠前的那一组，索引向后移动</li><li>如果相交，取出交集，右侧区间靠前的那一组，索引向后移动</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">intervalIntersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; firstList, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; secondList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; firstList.size() &amp;&amp; j &lt; secondList.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> l1 = firstList[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r1 = firstList[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> l2 = secondList[j][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r2 = secondList[j][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 没有交集</span></span><br><span class="line">            <span class="keyword">if</span> (l1 &gt; r2 || r1 &lt; l2) &#123;</span><br><span class="line">                <span class="comment">// r2 比较小，为了尽快和 l1 相交，需要向后移动</span></span><br><span class="line">                <span class="keyword">if</span> (l1 &gt; r2) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> a = max(l1, l2);</span><br><span class="line">            <span class="keyword">int</span> b = min(r1, r2);</span><br><span class="line">            <span class="comment">// 交集</span></span><br><span class="line">            res.push_back(&#123;a, b&#125;);</span><br><span class="line">            <span class="keyword">if</span> (r2 &gt; r1) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="区间可变"><a href="#区间可变" class="headerlink" title="区间可变"></a>区间可变</h1><p>代表题目：1288 删除覆盖区间，56 合并区间，452 射箭引爆气球，1024 视频拼接 和 435 无重叠区间。</p><h2 id="1288-删除覆盖区间"><a href="#1288-删除覆盖区间" class="headerlink" title="1288. 删除覆盖区间"></a>1288. 删除覆盖区间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[3,6],[2,8]]</span><br><span class="line">输出：2</span><br><span class="line">解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。</span><br></pre></td></tr></table></figure><p>题目意思比较明确，删除大区间覆盖的小区间，那么如何统计被覆盖的区间呢？我们看来看图：</p><p><img data-src="/2022/05/12/interval-algo/cover.png" alt></p><p>如果想统计一个区间覆盖更多的区间，乱序状态下用暴力算法肯定是可以破解的，大不了一个一个统计。但是如果我们对区间排序一下，按照左侧区间升序或者右侧区间降序，问题会简单很多：</p><p><img data-src="/2022/05/12/interval-algo/sort.png" alt></p><p>以按照左侧区间排序为例，排序结果如图 (c) 中所示的三种情况：</p><ul><li>如果是<strong>覆盖的相交情况</strong>，统计数量</li><li>如果<strong>相交的情况</strong>，表示上面区间没有能力覆盖下面的区间了，不再考虑上面的区间，开始往下移动</li><li>如果没有重叠也就是不相交，同样表示上面区间没有能力覆盖下面的区间了，不再考虑上面的区间</li></ul><p>图(a)是按照左侧的区间升序，我们只需要顺序遍历区间，依次判断上面的区间的右侧值是否能覆盖下面的区间的右侧值即可，因为左侧区间已经排好序了，是肯定能覆盖的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> r = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 相交时的处理</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt;= intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有覆盖，向后移动</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.size() - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同理，图(b)是我们按照右侧区间降序排列，此时统计上一个左侧区间能覆盖下一个左侧区间的数量即可，因为右侧区间肯定能覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] == b[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> l = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l = intervals[i][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.size() - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p>至此，leetcode 的第 56 题区间合并也可以轻松写出程序。思路和覆盖是一样的：</p><ul><li>如果上一个区间覆盖了下一个区间，那么合并区间，<strong>也就是相交区间的处理</strong></li><li>如果上一个区间没有覆盖下一个区间，那么从头开始</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> r = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 相交处理，合并</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                l = min(l, intervals[i][<span class="number">0</span>]);</span><br><span class="line">                r = max(r, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不能覆盖，先把之前的结果添加进来</span></span><br><span class="line">                <span class="comment">// 并重新更新区间</span></span><br><span class="line">                res.push_back(&#123;l, r&#125;);</span><br><span class="line">                l = intervals[i][<span class="number">0</span>];</span><br><span class="line">                r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一组没有被添加进来</span></span><br><span class="line">        res.push_back(&#123;l, r&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">10</span>,<span class="number">16</span>],[<span class="number">2</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">12</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：气球可以用<span class="number">2</span>支箭来爆破:</span><br><span class="line">-在x = <span class="number">6</span>处射出箭，击破气球[<span class="number">2</span>,<span class="number">8</span>]和[<span class="number">1</span>,<span class="number">6</span>]。</span><br><span class="line">-在x = <span class="number">11</span>处发射箭，击破气球[<span class="number">10</span>,<span class="number">16</span>]和[<span class="number">7</span>,<span class="number">12</span>]。</span><br></pre></td></tr></table></figure><p>只需要对区间排序，每次<strong>统计相交区间</strong>的交集，直到交集没有重叠时，射箭数量需要加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        sort(points.begin(), points.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> l = points[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> r = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; points[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                l = points[i][<span class="number">0</span>];</span><br><span class="line">                r = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 相交处理，有相交区间，缩小相交区间</span></span><br><span class="line">                l = max(l, points[i][<span class="number">0</span>]);</span><br><span class="line">                r = min(r, points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h2><p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 移除 [<span class="number">1</span>,<span class="number">3</span>] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p>注意，这个题目和之前的题目不太相同，具体体现在<strong>相交时的处理</strong>，而相交分为覆盖和非覆盖：</p><ol><li>如果上一个区间覆盖了下面的区间，说明上面的区间太大了。由于我们要删除最少数量的区间，因此首先考虑删除覆盖更广的区间</li><li>如果上一个区间和下一个区间相交，此时不能像之前的合并、相交一样，直接移动到下一个区间或处抛弃上面的区间。因为区间在排序后，如果上一个区间和第二个区间相交，上一个区间和第三个区间不相交，此时我们要删除第二个区间，而不是上一个和第三个区间。因此，相交时我们应该保留上一个区间。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> r = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 覆盖，往下移动</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt;= intervals[i][<span class="number">0</span>] &amp;&amp; r &gt;= intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">                l = intervals[i][<span class="number">0</span>];</span><br><span class="line">                r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r &gt; intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// 相交，不移动，保留上一个区间</span></span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不相交，往后移动，看看后面有多少相交的要处理</span></span><br><span class="line">                r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a>1024. 视频拼接</h2><p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 time 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, time]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">选中 [0,2], [8,10], [1,9] 这三个片段。</span><br><span class="line">然后，按下面的方案重制比赛片段：</span><br><span class="line">将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。</span><br><span class="line">现在手上的片段为 [0,2] + [2,8] + [8,10]，而这些覆盖了整场比赛 [0, 10]。</span><br></pre></td></tr></table></figure><p>从题面上我们能看出来：在多个片段相交的基础上，我们尽可能选择时间长的片段，这样才能使用的碎片最少。同样，重点就在于：<strong>相交时，我们要选择最长的片段</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; clips, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        sort(clips.begin(), clips.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, i = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从起点开始</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; clips.size() &amp;&amp; clips[i][<span class="number">0</span>] &lt;= l) &#123;</span><br><span class="line">            <span class="comment">// 碎片部分和起点相交，选择片段最长的</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; clips.size() &amp;&amp; clips[i][<span class="number">0</span>] &lt;= l) &#123;</span><br><span class="line">                r = max(clips[i][<span class="number">1</span>], r);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= time)</span><br><span class="line">                <span class="keyword">return</span> cnt;</span><br><span class="line">            <span class="comment">// 最长的片段，是下个片段的起点</span></span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>更像是把 labuladong 上区间的题目整理到了一起，写出自己风格的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法继续整理系列之区间问题。这类问题可以总结或者变化为：给定多个区间，求满足覆盖范围的最小相交区间的数量。一般而言都是：题目给定一个乱序的区间。我们需要对区间进行排序调整和统计结果，来满足题目条件。&lt;strong&gt;其中变化的部分只有如何处理相交区间&lt;/strong&gt;，因此整理一个通用的算法模板。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的 this 和 Python 中的 self</title>
    <link href="https://muyuuuu.github.io/2022/05/12/Cpp-this-and-python-self/"/>
    <id>https://muyuuuu.github.io/2022/05/12/Cpp-this-and-python-self/</id>
    <published>2022-05-12T15:10:54.000Z</published>
    <updated>2022-05-16T15:30:41.823Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前一直好奇 <code>C++</code> 中的 <code>this</code> 和 <code>python</code> 中的 <code>self</code> 到底是什么关系，为什么 <code>C++</code> 要显式的写出来，<code>python</code> 则不需要。顺便深入了解一下 <code>this</code>。</p><a id="more"></a><h2 id="self"><a href="#self" class="headerlink" title="self"></a>self</h2><p><code>python</code> 当对象调用类中的函数的时候，系统会自动把当前对象传入函数，且参数就是第一个 <code>self</code>，不过可以用其他 <code>token</code> 代替 <code>self</code>。因此在定义的时候，需要声明 <code>self</code> 这个参数，调用时，却不需要手动传入对象。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x 接收 12 这个参数</span></span><br><span class="line">A.test(<span class="number">12</span>)</span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># x 接收 a 这个对象</span></span><br><span class="line">a.test()</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(mine, x)</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mine 接收 1，x 接收 12</span></span><br><span class="line">A.test(<span class="number">1</span>, <span class="number">12</span>)</span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># mine 接收 a，x 接收 12</span></span><br><span class="line">a.test(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>对于 <code>C++</code> 而言，每个对象都要操作自己内部的数据，如何知道哪里的数据是自己的内部数据，而不会发生调用对象 <code>A</code>，而修改了对象 <code>B</code> 的数据呢？答案是 <code>this</code> 指针。</p><p><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针，被隐含地声明为: <code>ClassName \*const this</code>，也就是地址不能改变，这意味着不能给 <code>this</code> 指针赋值；在类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）。对象被创建以后才会给 <code>this</code> 赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，且 <code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址。</p><p>当对象调用类中的非静态函数时，自动向它传递一个隐含的 <code>this</code> 指针参数，该参数是一个指向这个成员函数所在的对象的指针，在函数体内作为局部变量，且每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</p><p>总结一下的话就是：</p><ul><li><code>this</code> 是关键字而 <code>self</code> 不是。</li><li><code>C++</code> 类内的函数默认都是给对象调用的，而 <code>python</code> 不是。</li><li><code>python</code> 中的 <code>self</code> 还可以用于声明和创建变量，而 <code>C++</code> 在类中声明和创建则不需要。</li><li>定义、传参和调用中，<code>this</code> 参数始终隐藏，而 <code>self</code> 不是。</li><li>两者有相同点，在类的函数内部可以显式的使用它，来调用类内的变量和函数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直好奇 &lt;code&gt;C++&lt;/code&gt; 中的 &lt;code&gt;this&lt;/code&gt; 和 &lt;code&gt;python&lt;/code&gt; 中的 &lt;code&gt;self&lt;/code&gt; 到底是什么关系，为什么 &lt;code&gt;C++&lt;/code&gt; 要显式的写出来，&lt;code&gt;python&lt;/code&gt; 则不需要。顺便深入了解一下 &lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
      <category term="Python" scheme="https://muyuuuu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的 static</title>
    <link href="https://muyuuuu.github.io/2022/05/12/cpp-static/"/>
    <id>https://muyuuuu.github.io/2022/05/12/cpp-static/</id>
    <published>2022-05-12T13:54:28.000Z</published>
    <updated>2022-05-12T15:53:43.800Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前对 <code>static</code> 的理解仅限于：在类中声明这种类型的变量，可以通过这个变量知道这个类被创建了多少个对象。但是前些日子刷 <code>leetcode</code> 的时候，发现类中自定义的 <code>cmp</code> 函数如果不是 <code>static</code> 类型，就无法被类内的 <code>sort</code> 函数识别。所以今天来一探究竟。</p><a id="more"></a><h1 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h1><p>其实 C 语言中也有 <code>static</code> 这个关键字，在全局区分配内存，或者说可以理解为全局变量，来回顾一下：</p><ol><li>在全局区分配内存，自动初始化为 0，注：全局区就是静态区</li><li>在声明的整个文件是可见的</li><li>不会因子函数的退出而被释放空间，即子函数被执行完成初始化后，之后的调用不会再初始化，但作用域是局部的</li><li>修饰普通函数，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li></ol><p>全局变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    sub_func();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> test;</span><br><span class="line">    test += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无法访问 test</span></span><br><span class="line">    sub_func(); <span class="comment">// 1</span></span><br><span class="line">    sub_func(); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="static-成员变量"><a href="#static-成员变量" class="headerlink" title="static 成员变量"></a>static 成员变量</h2><ol><li>这个类的所有对象都可以访问静态成员变量，一个对象修改，其他对象也会改变。说高级一些，不随对象创建而分配内存，不随对象销毁而释放内存</li><li>存储在全局区</li><li>必须类外初始化</li><li>可以通过类名访问</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">    A()&#123;</span><br><span class="line">        A::num += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 类名访问</span></span><br><span class="line">        A::num += a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类声明的外部初始化</span></span><br><span class="line"><span class="keyword">int</span> A::num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; A::num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">    b.increase(<span class="number">18</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; A::num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><ol><li>静态成员函数仅可以访问静态成员、函数；不能访问非静态成员、函数</li><li>非静态成员函数可以任意访问静态成员、函数</li><li>不需要 <code>this</code> 指针的额外操作</li><li>可以通过类名访问</li></ol><p>来看一个 <code>static</code> 的成员函数，顺便解答本文开始的疑问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">auto</span> <span class="title">get_num</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 错误，不能访问非 static 变量</span></span><br><span class="line">        <span class="comment">// 毕竟全局区不能访问堆栈区</span></span><br><span class="line">        <span class="comment">// return a + A::num;</span></span><br><span class="line">        <span class="keyword">return</span> A::num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不加 static</span></span><br><span class="line">    <span class="comment">// 错误：对非静态成员函数‘bool A::cmp(int&amp;, int&amp;)’的使用无效</span></span><br><span class="line">    <span class="comment">// 因为 sort 这个函数是全局的，找不到类内的 cmp</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(arr.begin(), arr.end(), cmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类声明的外部初始化</span></span><br><span class="line"><span class="keyword">int</span> A::num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    a.sort(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : arr) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title=":: 扩展"></a><code>::</code> 扩展</h2><p>上面写了很多 <code>::</code>，江湖人称范围解析运算符，顺手总结一下：</p><ol><li><code>::variable</code>，全局作用域符，作用域是全局空间，如 <code>::isspace</code></li><li><code>class::variable</code>，某个类的作用域范围</li><li><code>namespace::variable</code>，某个<a href="https://muyuuuu.github.io/2021/06/20/cpp-namespace/">命名空间</a>的作用域范围。重点是，<code>static</code> 声明的链接性为内部静态变量的东西，可以使用未命名的 <code>namespace</code> 代替。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前对 &lt;code&gt;static&lt;/code&gt; 的理解仅限于：在类中声明这种类型的变量，可以通过这个变量知道这个类被创建了多少个对象。但是前些日子刷 &lt;code&gt;leetcode&lt;/code&gt; 的时候，发现类中自定义的 &lt;code&gt;cmp&lt;/code&gt; 函数如果不是 &lt;code&gt;static&lt;/code&gt; 类型，就无法被类内的 &lt;code&gt;sort&lt;/code&gt; 函数识别。所以今天来一探究竟。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>从 python 中的垃圾回收回顾下内存碎片化</title>
    <link href="https://muyuuuu.github.io/2022/05/03/python-gc/"/>
    <id>https://muyuuuu.github.io/2022/05/03/python-gc/</id>
    <published>2022-05-03T15:46:01.000Z</published>
    <updated>2022-05-06T15:18:54.117Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不出意外的话，这应该是 <code>python</code> 复习的最后一部分了，之前写 <code>python</code> 的时候，一般是在实践中积累一些常见的用法而后系统的学习，比如生成器装饰器、高级数据结构、各种工具库乃至 <code>__init__.py</code> 等细节。但 <code>python</code> 帮开发者自动进行了垃圾回收，所以一直没涉足这个领域，今天来了解一下 <code>python</code> 中垃圾回收的三种机制：引用计数、标记清除和分代回收。</p><a id="more"></a><h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><p>引用计数是 <code>python</code> 中默认使用的垃圾回收方法，思想也比较简单，每个对象有一个字段来记录对象被引用的次数，如果对象引用次数是 0，那么这个对象就会被回收并释放空间。优势是想法简单容易实现，能够处理对象创建、引用、传参、被存储至容器等引用计数增加的场景，以及 <code>del</code> 显式删除、对象别名被赋予新对象、离开作用域、容器被销毁等计数器减少的场景。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This Obj Address: &#123;&#125;"</span>.format(id(self)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obj_ref_count</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">"Obj Ref Count: &#123;&#125;"</span>.format(sys.getrefcount(obj)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># create</span></span><br><span class="line">a = Demo()</span><br><span class="line">print(sys.getrefcount(a)) <span class="comment"># output 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create</span></span><br><span class="line">a = Demo()</span><br><span class="line">obj_ref_count(a) <span class="comment"># output 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ref</span></span><br><span class="line">b = a</span><br><span class="line">obj_ref_count(a) <span class="comment"># output 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># change ref</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">obj_ref_count(a) <span class="comment"># output 4</span></span><br></pre></td></tr></table></figure><p>这里的引用次数为 4 是因为创建、函数调用堆栈帧、参数、<code>sys</code> 调用累积得到的，小缺点就是需要开辟额外的空间来维护<del>这仿佛是废话</del>，主要的缺点是不能处理循环引用问题。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> _ctypes</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.child = <span class="literal">None</span></span><br><span class="line">        print(<span class="string">"This Obj Address: &#123;&#125;"</span>.format(id(self)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obj_ref_count</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">"Obj Ref Count: &#123;&#125;"</span>.format(sys.getrefcount(obj)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Loop &#123;&#125;"</span>.format(i + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    a = Demo()</span><br><span class="line">    b = Demo()</span><br><span class="line"></span><br><span class="line">    obj_ref_count(a)</span><br><span class="line">    obj_ref_count(b)</span><br><span class="line"></span><br><span class="line">    a.child = b</span><br><span class="line">    b.child = a</span><br><span class="line"></span><br><span class="line">    obj_ref_count(a)</span><br><span class="line">    obj_ref_count(b)</span><br><span class="line"></span><br><span class="line">    a_addr = id(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> a</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 引用次数为 5，没回收，内存泄漏</span></span><br><span class="line">    a = _ctypes.PyObj_FromPtr(int(a_addr))</span><br><span class="line">    obj_ref_count(a)</span><br></pre></td></tr></table></figure><p>上述的程序存在循环引用问题，如果去掉循环引用的部分，我们会发现每个循环创建对象的地址都是一样的，说明之前的对象经过 <code>del</code> 之后会被回收。而如果增加循环引用的语句，每个循环都会创建新的对象，也就是垃圾没有被回收。</p><h1 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h1><p>标记清除顾名思义，首先给所有的活动对象打上标记，然后清除没有被标记的非活动对象。所以问题转移为：如何判断对象是活动的？</p><p><code>python</code> 中的对象通过引用连接在一起构成一个有向图，对象是图中的节点，引用关系就是有向边。从根对象出发，沿着有向边遍历对象，如果能到达这个节点，那么这个节点就是活动对象，否则就是非活动对象。如下图所示。</p><p><img data-src="https://s1.ax1x.com/2022/05/06/OKT1UK.gif" alt></p><p>这个方法主要来解决前文提到的循环引用问题，也可以扩展到 <code>list</code>、<code>dict</code> 和 <code>tuple</code> 等容器对象，因为数值、字符串等字面常量不会被循环引用。</p><p>虽然能清除循环引用的对象，但是需要扫描整个堆内存，这可能只有一小部分非活动对象。而且当这个算法启动去清除垃圾时，程序会挂起运行，因为这两者显然不能同时执行。</p><h2 id="标记清除与操作系统"><a href="#标记清除与操作系统" class="headerlink" title="标记清除与操作系统"></a>标记清除与操作系统</h2><p>标记清除容易导致内存碎片化。非活动对象可能位于内存的不同位置，当执行这个算法后，这些对象被释放，就导致了内存的不同位置空缺出现外碎片问题，但没有大单位的可用内存。而内存碎片化也是操作系统中的常见问题，导致内存利用率不高。</p><p><img data-src="https://s1.ax1x.com/2022/05/06/OK7kqI.jpg" alt></p><p>既然说到了内存碎片问题，就来回顾一下大三学过的操作系统，一般解决方法有连续分配方案和离散分配方案，对于连续分配方案：</p><ul><li>固定分区，内存划分为固定大小的分区，会面临内碎片问题</li><li>动态分区，包括分区匹配和分区释放，分区匹配一般有最先匹配算法（找到合适分区立刻划分，不容易保留大分区）、最佳适应算法（找到大小最合适的分区，容易形成外碎片）和最差适应算法（避免外碎片，分配最大的分区，不容易保留大分区），分区释放阶段将两个空闲分区合并为一个空闲分区。</li></ul><p>连续分配中内存碎片是不可避免的，为了解决这个问题，一般会进行<strong>紧缩</strong>：将小的内存碎片调整位置，组合成大的可用空间去装载新的进程。因为紧缩会移动内存改变进程的地址，因此这种带有额外开销的操作一般会在特定时期进行，如释放分区后或者新的进程不被满足时。</p><p>离散分配方案，允许进程所在的物理地址空间非连续：</p><ul><li>页式管理，将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，也把内存空间分成与页面相同大小的若干个存储块，称为页框，也同样为它们加以编号。在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的页框中。这种方式消减外部碎片，由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称为页内碎片。虽然仍然有内碎片，但控制了内碎片的大小范围。优势是程序不必连续存放，所需的空间可以动态改变。但是程序需要一次性放入内存；几个子函数位于同一页面时，不利于程序和数据的共享和动态链接。</li><li>段式管理，为了解决共享数据和动态链接的问题，将程序的地址空间按内容或函数关系划分为若干段，每个段是逻辑上完整的程序或数据。将不同的段装入内存的不同位置，就可以支持逻辑共享了。所以通常段长不固定，决定于用户所编写的程序，所以这部分内存可以进行动态分区的管理。</li><li>段页式系统的基本原理是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页。</li></ul><h1 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h1><p><code>python</code> 根据对象的存活时间划分为三个的集合：年轻、中年和老年，新创建的对象位于年轻代，当年轻代的数量到达上限就会触发回收机制，不会被回收的对象会放在中年代中，依次类推，因此老年代是存活最久的对象。</p><p>清除过程是基于前文提到的标记清除算法实现的，这也是上文没写代码举例的原因，也能解释引用计数中，标记清除算法为什么没有清除循环引用的对象。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> _ctypes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obj_ref_count</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">"Obj Ref Count: &#123;&#125;"</span>.format(sys.getrefcount(obj)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.child = <span class="literal">None</span></span><br><span class="line">        print(<span class="string">"This Obj Address: &#123;&#125;"</span>.format(id(self)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gc.enable()</span><br><span class="line"><span class="keyword">assert</span> gc.isenabled() <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    a = Demo()</span><br><span class="line">    b = Demo()</span><br><span class="line"></span><br><span class="line">    a.child = b</span><br><span class="line">    b.child = a</span><br><span class="line"></span><br><span class="line">    a_addr = id(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> a</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2 表示检查 1 2 3 代的对象</span></span><br><span class="line">    <span class="comment"># 回收，并返回不活动对象的数目</span></span><br><span class="line">    print(gc.collect(<span class="number">2</span>)) <span class="comment"># output 4</span></span><br><span class="line">    <span class="comment"># 每代已经回收的数目</span></span><br><span class="line">    print(gc.get_count())</span><br><span class="line"></span><br><span class="line">    tmp = _ctypes.PyObj_FromPtr(int(a_addr))</span><br><span class="line">    obj_ref_count(tmp)</span><br></pre></td></tr></table></figure><p>最后的输出为 4，表示被清除了。<strong>强行使用被删除对象的地址很危险</strong>，不建议这么写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">This Obj Address: 1968923570128</span><br><span class="line">This Obj Address: 1968923570032</span><br><span class="line">4</span><br><span class="line">(1, 0, 0)</span><br><span class="line">Obj Ref Count: 4</span><br><span class="line">This Obj Address: 1968923570128</span><br><span class="line">This Obj Address: 1968923570032</span><br><span class="line">0</span><br><span class="line">(1, 0, 0)</span><br><span class="line">Obj Ref Count: 4</span><br><span class="line">This Obj Address: 1968923569840</span><br><span class="line">This Obj Address: 1968923567488</span><br><span class="line">4</span><br><span class="line">(1, 0, 0)</span><br><span class="line">Obj Ref Count: 4</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.geeksforgeeks.org/mark-and-sweep-garbage-collection-algorithm/" target="_blank" rel="noopener">mark &amp; sweep</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不出意外的话，这应该是 &lt;code&gt;python&lt;/code&gt; 复习的最后一部分了，之前写 &lt;code&gt;python&lt;/code&gt; 的时候，一般是在实践中积累一些常见的用法而后系统的学习，比如生成器装饰器、高级数据结构、各种工具库乃至 &lt;code&gt;__init__.py&lt;/code&gt; 等细节。但 &lt;code&gt;python&lt;/code&gt; 帮开发者自动进行了垃圾回收，所以一直没涉足这个领域，今天来了解一下 &lt;code&gt;python&lt;/code&gt; 中垃圾回收的三种机制：引用计数、标记清除和分代回收。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="https://muyuuuu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>轻量的神经网络</title>
    <link href="https://muyuuuu.github.io/2022/04/30/light-net/"/>
    <id>https://muyuuuu.github.io/2022/04/30/light-net/</id>
    <published>2022-04-30T12:43:59.000Z</published>
    <updated>2022-05-11T14:47:09.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很久之前我觉得移动端应用几百兆的模型不切实际，在不考虑蒸馏、量化等压缩方法下，发现了 MobileNet 设计的很神奇，大小只有几 MB，可以说是一股清流了。就整理发布了一下，然后今天发现找不到了，神奇。（于是顺手和 ShuffleNet 一并整理到轻量化的神经网络中）</p><a id="more"></a><h1 id="MobileNet-V1"><a href="#MobileNet-V1" class="headerlink" title="MobileNet-V1"></a>MobileNet-V1</h1><p>基本上可以说这个版本是后面几个版本的出发点。先来看一下创新点：提出 depthwise separable conv 和 pointwise conv 来降低网络的计算次数。还是直接画图吧：</p><p><img data-src="https://s1.ax1x.com/2022/04/30/OpcCxU.png" alt></p><p>对于传统卷积而言，输入一个三通道的图片，如果想要输出五通道，那么就需要 5 个 $3\times 3 \times 3$ 的卷积核。一般一些，假设传统卷积处理图像的大小是 $D_F\times D_F$，有 $M$ 个通道，卷积核的大小是 $D_K$，输出的通道数数 $N$，那么计算量就是 $D_K \cdot D_K \cdot M \cdot N \cdot D_F \cdot D_F$。</p><p>在得到相同大小输出的情况下，使用 DW 卷积和 PW 卷积来简化一下这个计算过程：</p><p><img data-src="https://s1.ax1x.com/2022/04/30/OpcFr4.png" alt></p><p>如果换成深度可分离卷积和逐点卷积，可以看到达到同样的输出，参数量从 $27\times 5$ 减少到了 $27+15$，而且计算量为 $D_K \cdot D_K \cdot M \cdot D_F \cdot D_F + M \cdot N \cdot D_F \cdot D_F$。两者的比值是 $1/N+1/D_K^2$。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileNetV1</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ch_in, n_classes)</span>:</span></span><br><span class="line">        super(MobileNetV1, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">conv_bn</span><span class="params">(inp, oup, stride)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">                nn.Conv2d(inp, oup, <span class="number">3</span>, stride, <span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">                nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">conv_dw</span><span class="params">(inp, oup, stride)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">                <span class="comment"># dw</span></span><br><span class="line">                <span class="comment"># 输入通道和输出通道相等，groups 表示每个卷积核只处理一个通道</span></span><br><span class="line">                nn.Conv2d(inp, inp, <span class="number">3</span>, stride, <span class="number">1</span>, groups=inp, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(inp),</span><br><span class="line">                nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line"></span><br><span class="line">                <span class="comment"># pw</span></span><br><span class="line">                <span class="comment"># 卷积核大小为 1X1</span></span><br><span class="line">                nn.Conv2d(inp, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">                nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            conv_bn(ch_in, <span class="number">32</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">32</span>, <span class="number">64</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">128</span>, <span class="number">128</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">256</span>, <span class="number">256</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">1024</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">1024</span>, <span class="number">1024</span>, <span class="number">1</span>),</span><br><span class="line">            nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">        self.fc = nn.Linear(<span class="number">1024</span>, n_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.model(x)</span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">1024</span>)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h1 id="MobileNet-V2"><a href="#MobileNet-V2" class="headerlink" title="MobileNet-V2"></a>MobileNet-V2</h1><p>V1 的思想可以概括为：首先利用 3×3 的深度可分离卷积提取特征，然后利用 1×1 的卷积来扩张通道。但是有人在实际使用的时候，发现训完之后发现 dw 卷积核有不少是空的。</p><p>作者认为这是 ReLU 激活函数导致的。于是做了一个实验，就是对一个 n 维空间中的一个东西乘以矩阵 $T$，而后做 ReLU 运算，然后利用 $T$ 的逆矩阵恢复，对比 ReLU 之后的结果与 Input 的结果相差有多大。作者发现：低维度做 ReLU 运算，很容易造成信息的丢失。而在高维度进行 ReLU 运算的话，信息的丢失则会很少。</p><p>由于卷积本身没有改变通道的能力，来的是多少通道输出就是多少通道。上面又得出低维通道不好的结论，因此使用 PW 卷积升维再降维，这也就形成了 Inverted Residuals 这种结构，因为传统的残差结构和本文相反，传统的是先降维在升维。</p><p>这样高维的仍然使用 ReLU 激活函数，低维的换成线性激活函数。因为有先升维在降维的结构，因此使用了残差连接来提升性能。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvertedResidual</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inp, oup, stride, expand_ratio)</span>:</span></span><br><span class="line">        super(InvertedResidual, self).__init__()</span><br><span class="line">        self.stride = stride</span><br><span class="line">        <span class="keyword">assert</span> stride <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        hidden_dim = int(inp * expand_ratio)</span><br><span class="line">        self.use_res_connect = self.stride == <span class="number">1</span> <span class="keyword">and</span> inp == oup</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> expand_ratio == <span class="number">1</span>:</span><br><span class="line">            self.conv = nn.Sequential(</span><br><span class="line">                <span class="comment"># dw</span></span><br><span class="line">                nn.Conv2d(hidden_dim, hidden_dim, <span class="number">3</span>, stride, <span class="number">1</span>, groups=hidden_dim, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                nn.ReLU6(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># pw-linear</span></span><br><span class="line">                nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv = nn.Sequential(</span><br><span class="line">                <span class="comment"># pw 升维</span></span><br><span class="line">                nn.Conv2d(inp, hidden_dim, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                nn.ReLU6(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># dw 深度可分离卷积</span></span><br><span class="line">                nn.Conv2d(hidden_dim, hidden_dim, <span class="number">3</span>, stride, <span class="number">1</span>, groups=hidden_dim, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                nn.ReLU6(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># pw-linear 激活</span></span><br><span class="line">                nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.use_res_connect:</span><br><span class="line">            <span class="keyword">return</span> x + self.conv(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.conv(x)</span><br></pre></td></tr></table></figure><h1 id="MobileNet-V3"><a href="#MobileNet-V3" class="headerlink" title="MobileNet-V3"></a>MobileNet-V3</h1><p>主要做了两点创新，一个是在 MobileNet V2 残差分支加入了 SE（Squeeze-and-Excitation） 注意力机制的模块，一个是更新了激活函数。SE 注意力就是通过池化得到每个通道的值，并输入到全连接层学习到每个通道的权重，对每个通道的数值进行更新。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SELayer</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, channel, reduction=<span class="number">4</span>)</span>:</span></span><br><span class="line">        super(SELayer, self).__init__()</span><br><span class="line">        self.avg_pool = nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 输入维度和输出维度相同</span></span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(channel, _make_divisible(channel // reduction, <span class="number">8</span>)),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(_make_divisible(channel // reduction, <span class="number">8</span>), channel),</span><br><span class="line">            h_sigmoid()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        b, c, _, _ = x.size()</span><br><span class="line">        y = self.avg_pool(x).view(b, c)</span><br><span class="line">        y = self.fc(y).view(b, c, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># y 是每个通道的权重</span></span><br><span class="line">        <span class="keyword">return</span> x * y</span><br></pre></td></tr></table></figure><p>在重新设计激活函数方面，使用 h-swish 激活函数代替了 swish 激活函数，因为更容易计算。对于 swish 激活函数：</p><p>\begin{equation}<br>    \begin{aligned}<br>        \text{swish} x &amp;= x \cdot \sigma(x) \\<br>        \sigma(x) &amp;= \frac{1}{1+e^{-x}}<br>    \end{aligned}<br>\end{equation}</p><p>这个反向传播和激活的计算过程略显复杂，对量化不够友好。于是使用较为接近的 h-swish 激活函数代替：</p><p>\begin{equation}<br>    \begin{aligned}<br>        \text{h-sigmoid} &amp;= \frac{\text{ReLU6}(x+3)}{6} \\<br>        \text{h-swish} &amp;= x \cdot \text{h-sigmoid}<br>    \end{aligned}<br>\end{equation}</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">h_sigmoid</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inplace=True)</span>:</span></span><br><span class="line">        super(h_sigmoid, self).__init__()</span><br><span class="line">        self.relu = nn.ReLU6(inplace=inplace)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.relu(x + <span class="number">3</span>) / <span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">h_swish</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inplace=True)</span>:</span></span><br><span class="line">        super(h_swish, self).__init__()</span><br><span class="line">        self.sigmoid = h_sigmoid(inplace=inplace)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x * self.sigmoid(x)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvertedResidual</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inp, hidden_dim, oup, kernel_size, stride, use_se, use_hs)</span>:</span></span><br><span class="line">        super(InvertedResidual, self).__init__()</span><br><span class="line">        <span class="keyword">assert</span> stride <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        self.identity = stride == <span class="number">1</span> <span class="keyword">and</span> inp == oup</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> inp == hidden_dim:</span><br><span class="line">            self.conv = nn.Sequential(</span><br><span class="line">                <span class="comment"># dw</span></span><br><span class="line">                nn.Conv2d(hidden_dim, hidden_dim, kernel_size, stride, (kernel_size - <span class="number">1</span>) // <span class="number">2</span>, groups=hidden_dim, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                h_swish() <span class="keyword">if</span> use_hs <span class="keyword">else</span> nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># Squeeze-and-Excite</span></span><br><span class="line">                SELayer(hidden_dim) <span class="keyword">if</span> use_se <span class="keyword">else</span> nn.Identity(),</span><br><span class="line">                <span class="comment"># pw-linear</span></span><br><span class="line">                nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv = nn.Sequential(</span><br><span class="line">                <span class="comment"># pw 升维</span></span><br><span class="line">                nn.Conv2d(inp, hidden_dim, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                h_swish() <span class="keyword">if</span> use_hs <span class="keyword">else</span> nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># dw 提取特征</span></span><br><span class="line">                nn.Conv2d(hidden_dim, hidden_dim, kernel_size, stride, (kernel_size - <span class="number">1</span>) // <span class="number">2</span>, groups=hidden_dim, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                <span class="comment"># Squeeze-and-Excite</span></span><br><span class="line">                SELayer(hidden_dim) <span class="keyword">if</span> use_se <span class="keyword">else</span> nn.Identity(),</span><br><span class="line">                h_swish() <span class="keyword">if</span> use_hs <span class="keyword">else</span> nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># pw-linear 先行激活，降维</span></span><br><span class="line">                nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.identity:</span><br><span class="line">            <span class="keyword">return</span> x + self.conv(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.conv(x)</span><br></pre></td></tr></table></figure><h1 id="ShuffleNet-V1"><a href="#ShuffleNet-V1" class="headerlink" title="ShuffleNet-V1"></a>ShuffleNet-V1</h1><p>group 卷积能有效的减少卷积参数。假设输入图像的大小为 $c_1\times H \times W$，卷积核大小为 $c_1 \times h \times w$，想要得到 $c_2 \times H \times W$ 的输出目标，那么需要的卷积层参数量就是：$c_2 \times c_1 \times h \times w$。</p><p>如果使用 group 卷积，将通道分成 $g$ 组，那么每个输入就是 $c_1/g \times H \times W$，对应的卷积核大小为 $c_1/g \times h \times w$，为了得到同样大小的输出，一组卷积的输出大小就是 $c_2/g \times H \times W$，将 $g$ 组卷积核的输出拼接到一起得到同等大小的输出 $c_2 \times H \times W$，此时的参数量为 $c_2 \times c_1 / g\times h \times w$。</p><p><img data-src="https://s1.ax1x.com/2022/05/02/OFVjDH.jpg" alt></p><ul><li>图 a 中，对于 group 卷积而言，channel 特征只在组内传递</li><li>图 b 中，对 channel 进行打乱，特征在多个 channel 中传递</li></ul><p>综上，使用 group 卷积替换传统卷积，并在 group 卷积后使用 channel shuffle 操作。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">channel_shuffle</span><span class="params">(x, groups)</span>:</span></span><br><span class="line">    batchsize, num_channels, height, width = x.data.size()</span><br><span class="line"></span><br><span class="line">    channels_per_group = num_channels // groups</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># reshape</span></span><br><span class="line">    x = x.view(batchsize, groups, </span><br><span class="line">        channels_per_group, height, width)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通道那个矩阵发生了转置</span></span><br><span class="line">    <span class="comment"># - contiguous() required if transpose() is used before view()</span></span><br><span class="line">    x = torch.transpose(x, <span class="number">1</span>, <span class="number">2</span>).contiguous()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># flatten</span></span><br><span class="line">    x = x.view(batchsize, <span class="number">-1</span>, height, width)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h1 id="ShuffleNet-V2"><a href="#ShuffleNet-V2" class="headerlink" title="ShuffleNet-V2"></a>ShuffleNet-V2</h1><p>在众多影响模型推理速度的因素中，理论计算量只是一部分，额外的还有内存访问（memory access cost, MAC）、平台架构和并行等级；而 数据 IO、逐元素运算也会占用时间。因此作者给出了设计轻量网络的四条准则和实验验证：</p><p>\begin{equation}<br>    \begin{aligned}<br>        \text{MAC} &amp;= hw(c_1+c_2)+c_1c_2 \\<br>        { } &amp; \geq 2hw\sqrt{c_1c_2}+c_1c_2\\<br>        { } &amp; \geq 2\sqrt{hwB} + \frac{B}{hw}\\<br>        B &amp;= hwc_1c_2 (\text{FLOPs})<br>    \end{aligned}<br>\end{equation}</p><ol><li>如上的 MAC 计算中，可以发现当 $c_1=c_2$ 的时候取等号。也就是当卷积的输入和输出 channel 相等时，内存访问代价最低，因此尽可能使通道不变</li></ol><p>\begin{equation}<br>    \begin{aligned}<br>        \text{Group-MAC} &amp;= hw(c_1+c_2)+c_1c_2/g \\<br>        { } &amp;=hwc_1 + \frac{Bg}{c_1} + \frac{B}{hw}\\<br>        B &amp;= hwc_1c_2/g (\text{FLOPs})<br>    \end{aligned}<br>\end{equation}</p><ol><li>在 Group-MAC 计算中，因为其他是定植，那么大小取决于 $g$，因此分组卷积分的越多时，内存访问代价会增大</li><li>网络的碎片化程度越高（分支越多的意思），速度越慢。对于 GPU 的并行计算不友好，而且涉及不同分支的同步问题</li><li>逐元素相加也会带来不可忽视的开销，如 relu，残差的 add 运算</li></ol><p><img data-src="https://s1.ax1x.com/2022/05/02/OFVXKe.jpg" alt></p><p>图左侧的 a（stride=1） 和 b（stride=2） 是 ShuffleNetV1 的结构，右侧的 c（stride=1） 和 d（stride=2） 是 ShuffleNetV2 的结构。</p><p>图 c 中，为了减少碎片化，在 c 中取消了左侧分支没有运算，右侧分支满足第一个准则，而最开始的 channel split 到最后的 concat，再次满足第一个准则，不选择 add 操作满足第 4 个准则。只对右侧的分支进行 relu 激活，并取消最终输出的 relu，满足第 4 个准则。而 concat，channel shuffle 和下一层输入的 channel split 可以合并为一个逐元素操作，不得不说太细了。</p><p>然后 ShuffleNetV2+ 在借鉴 MobileNetV3 的想法，也使用了 h-swish 激活函数和 SE 注意力机制，结果上超过了 MobileNetV3，这一部分可以在旷视的 github 上找到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久之前我觉得移动端应用几百兆的模型不切实际，在不考虑蒸馏、量化等压缩方法下，发现了 MobileNet 设计的很神奇，大小只有几 MB，可以说是一股清流了。就整理发布了一下，然后今天发现找不到了，神奇。（于是顺手和 ShuffleNet 一并整理到轻量化的神经网络中）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>IoU Loss 系列</title>
    <link href="https://muyuuuu.github.io/2022/04/23/iou-loss/"/>
    <id>https://muyuuuu.github.io/2022/04/23/iou-loss/</id>
    <published>2022-04-23T15:41:49.000Z</published>
    <updated>2022-04-23T16:10:34.410Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在之前 <a href="https://muyuuuu.github.io/2022/02/26/yolox/">yolox 解析与改进</a> 的文章中，提到了使用 CIoU Loss 改进 SimOTA 分配正样本机制导致的小目标检测精度低的问题，就顺手来整理一些常用定位损失与演化过程。本文所有的图，绿色为 Truth，蓝色为预测结果。</p><a id="more"></a><h1 id="IoU-Loss"><a href="#IoU-Loss" class="headerlink" title="IoU Loss"></a>IoU Loss</h1><p>这个是最常见的定位 loss，假设预测框为 $A$，目标框为 $B$，那么 IoU Loss 就是：</p><p>\begin{equation}<br>L = 1 - \frac{A\cap B}{A \cup B}<br>\end{equation}</p><p>同样这个 loss 会带来一些问题：</p><ul><li>当 $A$ 和 $B$ 没有交集的时候，损失恒定为 1</li><li>当 $A\cap B$ 为定值时，直观上某些相交情况并不好</li></ul><p><img data-src="https://s1.ax1x.com/2022/04/24/LhMPDx.png" alt></p><h1 id="GIoU-Loss"><a href="#GIoU-Loss" class="headerlink" title="GIoU Loss"></a>GIoU Loss</h1><p>为了缓解 $A$ 和 $B$ 没有交集的时候，损失恒定为 1 的缺陷，GIoU Loss 的表示如下：</p><p>\begin{equation}<br>L = 1 - IoU + \frac{A_c - U}{A_c}<br>\end{equation}</p><p>$A_c$ 是包含预测结果和真实标注数据的最小覆盖矩形。当最小覆盖矩形越小，损失也就越小。但是实际使用中这个损失的表现可能不是很好，因为目标检测都会有样本匹配机制，根据 IoU 匹配筛选出来的正样本至少能和真实标注相交。</p><h1 id="DIoU-Loss"><a href="#DIoU-Loss" class="headerlink" title="DIoU Loss"></a>DIoU Loss</h1><p>为了解决上述的 $A\cap B$ 为定值时，直观上某些相交情况并不好的缺陷，或者说，期望使预测结果落在真实数据的中心位置：</p><p>\begin{equation}<br>L = 1 - IoU + \frac{\rho^2 (b, b^{gt})}{c^2}<br>\end{equation}</p><p>其中 $\rho$ 是预测结果中心点和真实框中心点的距离，$c$ 是最小闭包区域对角线的长度。</p><h1 id="CIoU-Loss"><a href="#CIoU-Loss" class="headerlink" title="CIoU Loss"></a>CIoU Loss</h1><p>在目标检测中，目标常常有着不同的尺寸，如下图所示，在 IoU 取值固定的情况下，右侧的预测结果更符合目标框的尺寸。</p><p><img data-src="https://s1.ax1x.com/2022/04/24/LhME5D.png" alt></p><p>因此做了如下的修改：</p><p>\begin{equation}<br>    \begin{aligned}<br>        L &amp;= 1 - IoU + \frac{\rho^2 (b, b^{gt})}{c^2} + \alpha v \\<br>        \alpha &amp;= \frac{v}{(1-IoU) + v} \\<br>        v &amp;= \frac{4}{\pi^2} \bigl( arc \tan \frac{w^{gt}}{h^{gt}} - arc \tan \frac{w}{h} \bigr) \\<br>    \end{aligned}<br>\end{equation}</p><p>如果 IoU 越大，那么 $\alpha$ 也会越大，公式的最后一项也会越大。由于 $arc \tan$ 的取值范围是 -1 到 1，且当 $x$ 较为接近时，$y$ 也接近，那么就期望两者的长宽比越来越接近。</p><h1 id="alpha-IoU-Loss"><a href="#alpha-IoU-Loss" class="headerlink" title="$\alpha-IoU$ Loss"></a>$\alpha-IoU$ Loss</h1><p>$\alpha-IoU$ Loss 是在之前的一些列 IoU Loss 上进行的修改，增加了 $\alpha$ 这个指数，实验显示 $\alpha=3$ 比较有效。</p><p><img data-src="https://s1.ax1x.com/2022/04/24/LhMKKI.png" alt></p><p>以简单的 IoU Loss 来可视化一下这是为什么。我们可视化一下 IoU Loss 和 $\alpha-IoU$ Loss ，得到如下的图：</p><p><img data-src="https://s1.ax1x.com/2022/04/24/LhMQqP.png" alt></p><p>在 $x=0.5$ 之后，$\alpha-IoU$ 显示收敛的梯度更大。因为目标检测会根据 IoU 为预测结果分配真实框，因此不用太担心 IoU 很小的情况，当然这一部分可以手动修改。</p><h1 id="L1-L2-Smooth-L1-Loss"><a href="#L1-L2-Smooth-L1-Loss" class="headerlink" title="L1, L2, Smooth-L1 Loss"></a>L1, L2, Smooth-L1 Loss</h1><p>这个 loss 的形式比较简洁：</p><p>\begin{equation}<br>L = |x-y|<br>\end{equation}</p><p>也就是预测坐标和目标坐标相减的绝对值。而 L2 loss 的形式则是预测值和目标值差的平方：</p><p>\begin{equation}<br>L = (x-y)^2<br>\end{equation}</p><p>如下图所示：</p><p><img data-src="https://s1.ax1x.com/2022/04/24/LhM8IS.png" alt></p><ul><li>对于 L1 loss，在 -1 左侧和 1 的右侧收敛稳定，但是 -1 到 1 之间表示目标很接近了，应该减缓梯度</li><li>对于 L2 loss，在 -1 左侧和 1 的右侧呈现爆炸增长，存在梯度爆炸、异常值敏感的缺陷，但是 -1 到 1 之间梯度较为缓和</li></ul><p>而 Smooth Loss 综合了两者的优点，得到新的表达形式：</p><p>\begin{equation}<br>    L(x) =<br>    \begin{cases}<br>        0.5x^2 &amp;, |x| \leq 1 \\<br>        |x|-0.5 &amp;, \text{otherwise} \\<br>    \end{cases}<br>\end{equation}</p><p><img data-src="https://s1.ax1x.com/2022/04/24/LhMdrq.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前 &lt;a href=&quot;https://muyuuuu.github.io/2022/02/26/yolox/&quot;&gt;yolox 解析与改进&lt;/a&gt; 的文章中，提到了使用 CIoU Loss 改进 SimOTA 分配正样本机制导致的小目标检测精度低的问题，就顺手来整理一些常用定位损失与演化过程。本文所有的图，绿色为 Truth，蓝色为预测结果。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="CV" scheme="https://muyuuuu.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：计算器问题</title>
    <link href="https://muyuuuu.github.io/2022/04/13/calculator/"/>
    <id>https://muyuuuu.github.io/2022/04/13/calculator/</id>
    <published>2022-04-13T11:56:58.000Z</published>
    <updated>2022-05-20T14:42:44.629Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算器问题大约在大二数据结构的课程上学过，当时是使用栈来解决，此外还需要设置很多符号的优先级，以此判断是否弹栈，代码写的很长很麻烦。今天又遇到了这种题，也有了简单的解法，做一个整理。</p><a id="more"></a><p>计算器的难点在于先算乘除后算加减，如果有小括号，需要先算括号里面的内容。因此从简往难，一点点的来看问题如何解决。</p><h2 id="无括号"><a href="#无括号" class="headerlink" title="无括号"></a>无括号</h2><p>无括号相对简单一些，我们只需要考虑先算乘除后算加减即可。那么思路就是：如果当前符号是加法或减法，那么将符号连带数字压入栈中，比如 +10 或 -11；如果遇到的是乘法或除法，那么就需要把栈尾的元素拿出来，做乘法或除法运算在放入栈中。最后，对栈内的元素求和即可。</p><p>我们来看程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> subcal(s, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subcal</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span>&amp; idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                num = <span class="number">10</span> * num + (c - <span class="string">'0'</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">' '</span> || i == s.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sign == <span class="string">'+'</span>) &#123;</span><br><span class="line">                    stk.push(num);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'-'</span>) &#123;</span><br><span class="line">                    stk.push(-num);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(tmp * num);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'/'</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(tmp / num);</span><br><span class="line">                &#125;</span><br><span class="line">                sign = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (stk.size()) &#123;</span><br><span class="line">            res += stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>程序中有很多的细节，一点点来分析：</p><ul><li><code>sign</code> 初始值为 <code>+</code>，这样如果开头的数字是正数，那么这个数会被放入栈中；如果开头的数字是负数，那么栈中先放入 0，在放入负数，不影响。</li><li>符号 <code>c</code> 的判断不构成 if-else-if 关系，因为当 <code>i=s.size()-1</code> 的时候，需要处理最后一个数字。即，<code>c</code> 是数字且是最后一个字符的情况下，需要经过这两个分支的处理。</li></ul><h2 id="有括号"><a href="#有括号" class="headerlink" title="有括号"></a>有括号</h2><p>右括号就比较烦人，因为括号的优先级高于一切，需要找到最内部的括号，逐层往外回退得到答案。而这，也让人容易联想到传说中的递归。</p><p>那么递归需要记录关于括号的哪些东西呢？想法自然是遇到一个左括号，那么就计算括号内部的东西，遇到右括号返回。之后跳过括号里面的内容，计算下一个表达式。括号中的括号也是同理。我们来看程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> subcal(s, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subcal</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span>&amp; idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">                num = <span class="number">10</span> * num + (c - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                num = subcal(s.substr(i+<span class="number">1</span>), idx);</span><br><span class="line">                i += (idx + <span class="number">2</span>);</span><br><span class="line">                c = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">' '</span> || i == s.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sign == <span class="string">'+'</span>)</span><br><span class="line">                    stk.push(num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'-'</span>)</span><br><span class="line">                    stk.push(-num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(num * tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'/'</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(tmp / num);</span><br><span class="line">                &#125;</span><br><span class="line">                sign = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(stk.size()) &#123;</span><br><span class="line">            res += stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样来解读一下：</p><ul><li>如果遇到右括号，记录索引，表示当前括号的内容计算完了，退出。</li><li>如果遇到左括号，那么计算左括号后面子串的内容得到数字，<code>i=i+(idx+2)</code> 的意思是，跳到右括号后面第一个字符继续计算，+2 为什么是后面第一个字符呢？因为 substr(i+1) 了，这里向后移动了一位，对于 i 来说，+2 才是后面的第一位。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算器问题大约在大二数据结构的课程上学过，当时是使用栈来解决，此外还需要设置很多符号的优先级，以此判断是否弹栈，代码写的很长很麻烦。今天又遇到了这种题，也有了简单的解法，做一个整理。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>遥感图像分割，类别不平衡损失为何失效了？</title>
    <link href="https://muyuuuu.github.io/2022/04/04/deal-unbalance-label/"/>
    <id>https://muyuuuu.github.io/2022/04/04/deal-unbalance-label/</id>
    <published>2022-04-04T11:54:49.000Z</published>
    <updated>2022-05-11T14:10:00.372Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>去年寒假接到了一个遥感图像语义分割的任务，存在着严重的类别不平衡问题。当时想着使用经典的类别不平衡损失 focal loss 和 dice loss 解决一下，但是效果不升反降，甚至不如传统的交叉熵损失函数。</p><p>而且我在 github 上搜类似的项目，也都不推荐使用这些 loss。但是在 mmseg 的文档中，我们又发现 dice loss 有明显的提升，来冷静分析一下这是为什么。本文默认读者了解 focal loss 和 dice loss，因此不会对损失函数进行讲解。</p><a id="more"></a><p>其实我也不是第一次遇到这种经典损失函数失效的现象，之前 triplet loss 也频频失效，一度上了我的黑名单。关于 trilet loss 何时失效以及为什么 and 如何解决，可以参考之前的文章，<a href="https://muyuuuu.github.io/2022/03/24/E-commerce-Search-Recall/">如何更好的提取文本表示</a>。但是我们需要知道的是，失效分两种情况，一种是实现错误，一种是不适用于当前场景。</p><h1 id="focal-loss"><a href="#focal-loss" class="headerlink" title="focal loss"></a>focal loss</h1><p>focal loss 是目标检测领域中很经典的存在，focal loss 和 retinanet 发在同一篇论文，我看源程序，<strong>发现在实现上有一些小细节是网上常见博客不曾提及的</strong>。我们知道基于 anchor 生成检测框时，会有大量的无效检测框，这些框和真实目标毫不相交，这就导致了样本不平衡的问题。而 focal loss 的解决方案也是简单粗暴，使用 $\alpha$ 控制正负样本不平衡问题，使用 $\gamma$ 控制难易样本的区分。</p><p>在实现中，作者将与真实目标框 IoU 大于 0.5 的视为正样本，IoU 小于 0.4 的视为负样本，还有介于两者之间模棱两可的模糊样本。将所有的预测结果和真实标签计算损失，我们希望正样本的分类结果接近 1，其余样本接近 0，因此有严重的类别不平衡问题，于是使用了 focal loss 进行缓解。但是在反向传播的时候，<strong>并不是所有预测结果都要反向传播</strong>，而是对损失进行筛选，只回传正样本部分的损失，其余损失不考虑。</p><p>不然那么多负样本在那里，假设有 10000 个预测结果，只有 10 个真实目标，我就算输出 10000 个 0 损失也不会低，但是检测不到目标，俗称模型坍塌。因此源程序中做了这样的处理。</p><p>那么为什么语义分割的时候失效了呢？看完程序我大概给出我的猜测（目前实在没有精力做消融实验），我看了一些语义分割经典仓库中 focal loss 的实现，发现了一个问题。假设分割时的图像大小是 $512\times 512$，那么这就有将近 27 万个预测结果，遗憾的是，这些全部参与了反向传播。尤其是遥感领域的图像分割，目标区域小，背景占据大部分面积，前景目标的面积占比很小时，这就导致了模型坍塌的问题：模型把所有像素点预测为背景，损失不低，但结果无效。</p><p>因此，一个简单的解决方案就是：像 retinanet 一样，并不是所有的预测结果都参与反向传播。只需按照真实标签，只选择前景区域所在位置的损失，而忽略掉大部分背景区域的损失。而我遇到的原因也是这样，smp 的实现是全部反向传播，<del>提交个 PR 吧</del>。而 mmseg 的实现则是取消其他类别的影响。</p><h2 id="focal-程序实现"><a href="#focal-程序实现" class="headerlink" title="focal 程序实现"></a>focal 程序实现</h2><ul><li><a href="https://github.com/yhenon/pytorch-retinanet/blob/master/retinanet/losses.py#L120-L123" target="_blank" rel="noopener">retinanet 实现</a></li><li><a href="https://github.com/qubvel/segmentation_models.pytorch/blob/master/segmentation_models_pytorch/losses/_functional.py#L70-L96" target="_blank" rel="noopener">smp 实现，没有处理</a></li><li><a href="https://github.com/open-mmlab/mmcv/blob/master/mmcv/ops/csrc/common/cuda/sigmoid_focal_loss_cuda_kernel.cuh#L32-L33" target="_blank" rel="noopener">mmseg 实现</a></li></ul><h1 id="dice-loss"><a href="#dice-loss" class="headerlink" title="dice loss"></a>dice loss</h1><p>dice loss 很神奇，可以说是为语义分割而诞生的。因为交叉熵定义的是分类损失，评估衡量结果时却用 mIoU，也就是优化目标和期望目标不一致，所以 dice loss 以类似 IoU 损失的想法优化目标。dice loss 的一个形式如下：</p><p>\begin{equation}<br>L=1-\frac{2I+\epsilon}{U+\epsilon}<br>\end{equation}</p><p>$I$ 表示预测结果和真实标签的交集，$U$ 表示两者的并集。而程序实现也非常简单，交集两者求乘积，并集两者求和即可。</p><p>我们以二分类为例，假设模型最后的逻辑输出为 $x$，预测输出 $\hat{y}=\text{sigmoid}(x)$。于是：</p><p>\begin{equation}<br>\hat{y}=\frac{1}{1+e^{-x}} \quad \frac{d\hat{y}}{dx}=\hat{y}(1-\hat{y})<br>\end{equation}</p><p>我们设真实标签为 $t$，那么 dice loss 为：</p><p>\begin{equation}\label{dice}<br>L=1-\frac{2t\hat{y}+\epsilon}{t+\hat{y}+\epsilon}<br>\end{equation}</p><p>对 $\hat{y}$ 求一个偏导：</p><p>\begin{equation}\label{grad}<br>\frac{dL}{d\hat{y}}=-\frac{2t(t+\hat{y}+\epsilon)-2t\hat{y}-\epsilon}{(t+\hat{y}+\epsilon)^2}<br>\end{equation}</p><p>画出这个损失和梯度的图像：</p><p><img data-src="https://s1.ax1x.com/2022/04/05/qOwNPH.png" alt></p><p>这也就解释了为什么 dice 训练损失不稳定的原因，当 $t=0$ 的时候，虽然损失很大，但更新网络时对应的梯度为 0。损失值不稳定还可以理解，但是如果 $\hat{y}$ 预测结果也很小时，梯度会飞升。那为什么推荐和 CE 一起使用呢？看上图就可以知道，$t=0$ 的部分没有梯度。那为什么还是结果十分不好呢？继续往下看。</p><h2 id="dice-loss-与不平衡问题"><a href="#dice-loss-与不平衡问题" class="headerlink" title="dice loss 与不平衡问题"></a>dice loss 与不平衡问题</h2><p>我们可以观察到 dice loss 不管图片有多大，固定大小的正样本的区域计算的 loss 是一样的，对网络起到的监督贡献不会随着图片的大小而变化。而 ce loss 会公平处理正负样本，当出现正样本占比较小时，就会被更多的负样本淹没。</p><p>而 mmseg 给出这两个损失的比例是 1（CE）：3（dice），我也天真的用了这个比例。通过上面的分析，为了平衡样本，这个比例应该是目标面积和背景面积的比值。但是，我的数据集有多个类，每个类的面积占比跨度很大，也就是正负样本的梯度难以平衡，我十分不建议使用这个 loss，真的。</p><h2 id="dice-loss-画图程序"><a href="#dice-loss-画图程序" class="headerlink" title="dice loss 画图程序"></a>dice loss 画图程序</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_y</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial</span><span class="params">(y, t=<span class="number">0</span>)</span>:</span></span><br><span class="line">    f1 = <span class="number">-2</span>*t*(t+y+eps) +<span class="number">2</span>*t*y+eps</span><br><span class="line">    f2 = (t+y+eps) **<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> f1 / f2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">"ggplot"</span>)</span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">12</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-20</span>, <span class="number">20</span>, <span class="number">1000</span>)</span><br><span class="line">y = get_y(x)</span><br><span class="line">y0 = partial_0(y, t=<span class="number">0</span>)</span><br><span class="line">y1 = partial_1(y, t=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ax1.plot(y, y0)</span><br><span class="line">ax1.set_title(<span class="string">r"$t=0$"</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">r"$\hat&#123;y&#125;$"</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">r"Gradient"</span>)</span><br><span class="line"></span><br><span class="line">ax2.plot(y, y1)</span><br><span class="line">ax2.set_title(<span class="string">r"$t=1$"</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">r"$\hat&#123;y&#125;$"</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">r"Gradient"</span>)</span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">"1.png"</span>, bbox_inches=<span class="string">"tight"</span>, dpi=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我使用 mmseg 的 focal loss，结果要比 smp 的 focal loss 好很多，验证了我的猜想。此外需要注意的是，focal loss 能处理类别不平衡和正负样本不平衡，而 dice loss 只能处理正负样本不平衡。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年寒假接到了一个遥感图像语义分割的任务，存在着严重的类别不平衡问题。当时想着使用经典的类别不平衡损失 focal loss 和 dice loss 解决一下，但是效果不升反降，甚至不如传统的交叉熵损失函数。&lt;/p&gt;
&lt;p&gt;而且我在 github 上搜类似的项目，也都不推荐使用这些 loss。但是在 mmseg 的文档中，我们又发现 dice loss 有明显的提升，来冷静分析一下这是为什么。本文默认读者了解 focal loss 和 dice loss，因此不会对损失函数进行讲解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="CV" scheme="https://muyuuuu.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>算法系列：分治枚举</title>
    <link href="https://muyuuuu.github.io/2022/04/04/divide-conquer-enumerate/"/>
    <id>https://muyuuuu.github.io/2022/04/04/divide-conquer-enumerate/</id>
    <published>2022-04-04T08:36:29.000Z</published>
    <updated>2022-05-20T14:43:01.523Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之后的日子，大概会放缓刷题的脚步进行简单的整理，因为有些题目是有规律的，需要做号总结和整理，不能刷一个忘一个。<strong>今日总结：题目要求返回所有结果，且能找到分界点分解为子问题的，都可以套用分治枚举算法。</strong></p><a id="more"></a><h1 id="分治算法枚举"><a href="#分治算法枚举" class="headerlink" title="分治算法枚举"></a>分治算法枚举</h1><p>众所周知，枚举是个技术活，如何合理的枚举所有结果、避免重复和剪枝，并没有想象的那么简单。而分治枚举就是，通过将原问题分割为多个子问题，多个子问题的解<strong>排列组合</strong>能产生多种答案，我们收集多种答案并返回。</p><p>对于此类问题，我们需要确定三个东西：分界点，递归函数，如何排列组合。这样，给定一个分界点，我们把问题分解为左侧问题和右侧问题，两者答案的组合就是当前分界点对应的所有结果。然后再移动分界点，得到其他所有结果即可。此外，再分割得到子问题并求解时，需要设置 base case 用于退出递归。</p><h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a>96. 不同的二叉搜索树</h2><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。如下的示例，3 个节点能组成 5 种二叉树。</p><p><img data-src="/2022/04/04/divide-conquer-enumerate/1.jpg" alt></p><p>那我们考虑给出那三个东西：</p><ol><li>分界节点，以不同的值作为根节点，遍历所有的情况</li><li>既然有了根节点，就需要构建左子树。定义一个函数，返回某子树对应的情况，也就能得到分界点左子树有多少情况，同理得到右子树的排列组合</li><li>而左子树和右子树的乘积就是当前根节点对应的结果</li></ol><p>我们定义一个函数，函数有两个参数，这两个参数是子树的取值范围，因此，退出递归的 base case 就是子树的左侧值大于右侧值，此时返回 1，因为表示调用者的结果是 1，不能再划分为子问题了。函数的返回值是这种取值范围下，有多少结果。我们写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">tmp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        memo = tmp;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[l<span class="number">-1</span>][r<span class="number">-1</span>] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[l<span class="number">-1</span>][r<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = build(l, i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> b = build(i + <span class="number">1</span>, r);</span><br><span class="line">            <span class="comment">// 累积所有的结果</span></span><br><span class="line">            memo[l<span class="number">-1</span>][r<span class="number">-1</span>] += a*b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[l<span class="number">-1</span>][r<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>memo</code> 起到剪枝的效果。</p><h2 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a>95. 不同的二叉搜索树 II</h2><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。如下的示例，3 个节点能组成 5 种二叉树。</p><p><img data-src="/2022/04/04/divide-conquer-enumerate/1.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br></pre></td></tr></table></figure><p>同上一题，既然要给出所有的子树结果，那么此时就不需要计数，而是需要创建子树。同样以根节点的取值为分界点，统计出所有可能的左子树，统计出所有可能的右子树，上一题为结果相加，那么这个题目需要对左右子树的结果进行排列组合。因为这题不会超时，因此没有设置剪枝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> leftTree = build(l, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> rightTree = build(i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 创建子树，等价于上一题的相加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : leftTree) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> b : rightTree) &#123;</span><br><span class="line">                TreeNode* node = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                node-&gt;left = a;</span><br><span class="line">                node-&gt;right = b;</span><br><span class="line">                res.emplace_back(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="241-为运算表达式设计优先级"><a href="#241-为运算表达式设计优先级" class="headerlink" title="241. 为运算表达式设计优先级"></a>241. 为运算表达式设计优先级</h2><p>给你一个由数字和运算符组成的字符串 expession ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = &quot;2*3-4*5&quot;</span><br><span class="line">输出：[-34,-14,-10,-10,10]</span><br><span class="line">解释：</span><br><span class="line">(2*(3-(4*5))) = -34 </span><br><span class="line">((2*3)-(4*5)) = -14 </span><br><span class="line">((2*(3-4))*5) = -10 </span><br><span class="line">(2*((3-4)*5)) = -10 </span><br><span class="line">(((2*3)-4)*5) = 10</span><br></pre></td></tr></table></figure><p>最开始我以为这是回溯，后来发现不是，因此总结出一个规律：<strong>题目要求返回所有结果，且能找到分界点分解为子问题的，都可以套用分治枚举算法</strong>。对于这个题而言，运算符就是分界点，然后枚举左侧和右侧有几种结果即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(<span class="built_in">string</span> expression)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expression[i] == <span class="string">'-'</span> || expression[i] == <span class="string">'*'</span> || expression[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            <span class="comment">// 分治，左侧有几种结果</span></span><br><span class="line">            <span class="keyword">auto</span> res1 = diffWaysToCompute(expression.substr(<span class="number">0</span>, i));</span><br><span class="line">            <span class="keyword">auto</span> res2 = diffWaysToCompute(expression.substr(i + <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 枚举所有结果，并追加，和第一题的 += 一样</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it1 : res1) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it2 : res2) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (expression[i] == <span class="string">'-'</span>)</span><br><span class="line">                        res.push_back(it1 - it2);</span><br><span class="line">                    <span class="keyword">if</span> (expression[i] == <span class="string">'+'</span>)</span><br><span class="line">                        res.push_back(it1 + it2);</span><br><span class="line">                    <span class="keyword">if</span> (expression[i] == <span class="string">'*'</span>)</span><br><span class="line">                        res.push_back(it1 * it2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;stoi(expression)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之后的日子，大概会放缓刷题的脚步进行简单的整理，因为有些题目是有规律的，需要做号总结和整理，不能刷一个忘一个。&lt;strong&gt;今日总结：题目要求返回所有结果，且能找到分界点分解为子问题的，都可以套用分治枚举算法。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>什么是 bert</title>
    <link href="https://muyuuuu.github.io/2022/03/28/bert/"/>
    <id>https://muyuuuu.github.io/2022/03/28/bert/</id>
    <published>2022-03-28T14:16:12.000Z</published>
    <updated>2022-04-30T12:38:24.567Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>书接上文，因为参加 NLP 的比赛不知道什么是 bert 实在有点说不过去，于是花了三天时间看了下 bert 的基本概念和代码。不得不说，网上阳间的 bert 预训练代码太少了，大多是转载，mark 甚至文不对题之类没啥用的东西，但占据了搜索引擎的首页的热度，像无耻的营销号一样。</p><a id="more"></a><h1 id="从-transformer-开始"><a href="#从-transformer-开始" class="headerlink" title="从 transformer 开始"></a>从 transformer 开始</h1><p>这个就不得不提一下 Attention is all your need. 由于处理序列的时候 RNN 不容易并行化，输出 $b_4$ 的时候需要输入 $a_1, a_2, a_3, a_4$。所以就象使用 CNN 来代替 RNN，一个 CNN 按顺序划过序列输入产生一个输出，那么就不用看完一个句子才会有输出，因为先算后面和先算前面得到的结果是一样的，这样就可以并行化。而多个 CNN 就可以产生多个输出，能提升模型的表达能力。如下图所示，同颜色之前可以并行化，不同颜色之间也可以并行化。不需要等待红色的输出算完，再算黄色的输出。</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1mct.jpg" alt></p><p>如果考虑让一个 CNN 看到更多的输入，那么只需要在模型的隐层叠加另外的 CNN 即可，也就是上图的蓝色三角。基于这个概念，就有了后面的 self-attention。</p><h2 id="self-attention"><a href="#self-attention" class="headerlink" title="self-attention"></a>self-attention</h2><p>attention 本质上是一些矩阵乘法，$A=Wx, Q=W_qA, K=W_kA, V=W_vA$，这里其实就是乘以一个大矩阵，只不过图里分开写清楚一些。</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1Y3n.png" alt></p><p>之后每个 $q^i$ 和每个 $k^i$ 做 attention，也就是内积，得到如下的 $\alpha$ 输出，然后再除以维度数，防止维度过高导致的内积过大。</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1auV.png" alt></p><p>然后将 $\alpha$ 经过 softmax 操作得到 $\hat{\alpha}$：</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1wHU.png" alt></p><p>对于 $b_1$ 输出，只需要让 $\hat{\alpha_{1,i}}$ 和所有的 $v_i$ 做乘积并求和即可。同理，可以得到 $b_2,b_3,b_4$ 的输出。</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1DN4.png" alt></p><p>对应的，下图左上角就是我们的 self-attention 层，其中的运算可以总结成矩阵乘法：</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1r4J.png" alt></p><h3 id="multi-head-self-attention"><a href="#multi-head-self-attention" class="headerlink" title="multi-head-self-attention"></a>multi-head-self-attention</h3><p>多注意力头机制，可以在计算 $Q,K,V$ 的时候产生多个结果，然后在输出 $b$ 的时候再通过一个矩阵将多个结果融合成一个。而我看的程序，就是将矩阵 $Q,K,V$ 分开，计算完最后 view 到一起。</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1Ru6.png" alt></p><h3 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional Encoding"></a>Positional Encoding</h3><p>现在的 self-attention 没有考虑到序列的位置信息，而是使用全局信息，不能利用单词的顺序信息，而这部分信息对于 NLP 来说非常重要，所以需要加入位置的 embedding。人工设定每一个位置的 embedding，和 $A$ 加在一起作为新的 $A$ 参与后面的运算，等价于在 $X$ 拼接一个 one-hot 向量后再做运算：</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1fHO.png" alt></p><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>网上最常见的图就是它了，在看完理论后还是由些许的疑惑之处，比如位置编码如何实现，比如注意力机制具体如何执行，只能看代码来解决。</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs178A.png" alt></p><h2 id="MultiHeadAttention"><a href="#MultiHeadAttention" class="headerlink" title="MultiHeadAttention"></a>MultiHeadAttention</h2><ol><li>在这个类的初始化阶段，首先初始化 $W_Q,W_K,W_V$ 三个全连接层，输入维度和输出维度保持一致。假设输入维度是 512，有 8 个头；</li><li>计算 $Q,K,V$，大小是 <code>B, L, 8, 64</code>，毕竟有 8 个头。在 softmax 之后经过 0.1 的 dropout，最后在把这 8 个头 view 到一起，加上最开始的 $Q$</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiHeadAttention</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">''' Multi-Head Attention module '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_head, d_model, d_k, d_v, dropout=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">        self.n_head = n_head</span><br><span class="line">        self.d_k = d_k</span><br><span class="line">        self.d_v = d_v</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输出维度是之前的 8 倍，也就是 8 个头</span></span><br><span class="line">        self.w_qs = nn.Linear(d_model, n_head * d_k, bias=<span class="literal">False</span>)</span><br><span class="line">        self.w_ks = nn.Linear(d_model, n_head * d_k, bias=<span class="literal">False</span>)</span><br><span class="line">        self.w_vs = nn.Linear(d_model, n_head * d_v, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 最后的输出维度保持不变</span></span><br><span class="line">        self.fc = nn.Linear(n_head * d_v, d_model, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        self.attention = ScaledDotProductAttention(temperature=d_k ** <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line">        self.layer_norm = nn.LayerNorm(d_model, eps=<span class="number">1e-6</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, q, k, v, mask=None)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单个 k v 的输出维度，头的数量</span></span><br><span class="line">        d_k, d_v, n_head = self.d_k, self.d_v, self.n_head</span><br><span class="line">        sz_b, len_q, len_k, len_v = q.size(<span class="number">0</span>), q.size(<span class="number">1</span>), k.size(<span class="number">1</span>), v.size(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        residual = q</span><br><span class="line"></span><br><span class="line">        <span class="comment">#  batch x len_q x (n_head * dv) -&gt; batch x len_q x n_head x dv</span></span><br><span class="line">        q = self.w_qs(q).view(sz_b, len_q, n_head, d_k)</span><br><span class="line">        k = self.w_ks(k).view(sz_b, len_k, n_head, d_k)</span><br><span class="line">        v = self.w_vs(v).view(sz_b, len_v, n_head, d_v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Transpose for attention dot product: b x n x lq x dv</span></span><br><span class="line">        q, k, v = q.transpose(<span class="number">1</span>, <span class="number">2</span>), k.transpose(<span class="number">1</span>, <span class="number">2</span>), v.transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            mask = mask.unsqueeze(<span class="number">1</span>)   <span class="comment"># For head axis broadcasting.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># mask to pad zero</span></span><br><span class="line">        <span class="comment"># q \cdot k and matmul v</span></span><br><span class="line">        q, attn = self.attention(q, k, v, mask=mask)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Transpose to move the head dimension back: b x lq x n x dv</span></span><br><span class="line">        <span class="comment"># Combine the last two dimensions to concatenate all the heads together: b x lq x (n*dv)</span></span><br><span class="line">        q = q.transpose(<span class="number">1</span>, <span class="number">2</span>).contiguous().view(sz_b, len_q, <span class="number">-1</span>)</span><br><span class="line">        q = self.dropout(self.fc(q))</span><br><span class="line">        q += residual</span><br><span class="line"></span><br><span class="line">        q = self.layer_norm(q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q, attn</span><br></pre></td></tr></table></figure><h2 id="PositionalEncoding"><a href="#PositionalEncoding" class="headerlink" title="PositionalEncoding"></a>PositionalEncoding</h2><p>这个就是生成一个 $200\times dim$ 的表，每次输入一个 $x$，查看 $x$ 的维度，从表中取到对应维度的数值，和 $A$ 直接相加。这个表采用的是 sin-cos 规则，使用了 sin 和 cos 函数的线性变换来提供给模型位置信息。</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1HgI.png" alt></p><p>如上图所示，随着维度越来越大，周期变化会越来越慢，而产生一种包含位置信息的纹理。</p><h2 id="Encoder-Layer"><a href="#Encoder-Layer" class="headerlink" title="Encoder Layer"></a>Encoder Layer</h2><ol><li>输入： $x$ 经过 embedding layer 层后得到一个表示，并加上 position embedding 表示向下传播</li><li>经过 dropout 后进入堆叠 6 层的 encoder layer，单个 encode layer 由 multiheadattention 和 PositionwiseFeedForward 组成，后者是简单的全连接与残差结构。</li></ol><h2 id="Decoder-Layer"><a href="#Decoder-Layer" class="headerlink" title="Decoder Layer"></a>Decoder Layer</h2><p>大部分内容和 Encoder Layer 一样，先将 target 经过 embedding layer 之后得到表示，并叠加位置的 embedding 表示向后传播。</p><p>首先计算 target 的自注意力，也就是当前翻译和已经翻译的前文之间的关系；而后将输出视为 $Q$，encoder 的输出视为 $K,V$，再次计算注意力，得到新的解码输出，也就是计算一下当前输出结果和编码的特征向量之间的关系。在拿到 decoder 的输出后，经过一个全连接层，将 dim 映射到 n_vocab。</p><p><img data-src="https://s1.ax1x.com/2022/04/30/OpKlzF.png" alt></p><p>不过这里需要注意的事，为了防止 see the future，decoder 计算 target 的自注意力时需要添加 target mask，就是对角线及其以上的元素都是 0，防止预测当前元素时看到后面的元素。具体来说，真实的句子输入 decoder，经过 embedding 和 position embedding，在自己和自己的注意力矩阵中，对角线及以上的元素全部为 -inf，这样 softmax 之后对角线以上的元素为 0。那么在预测第一个单词时，只能根据 encoder output 的输出，而在预测之后的单词时，可以根据目前预测的结果预测之后的单词。</p><p><img data-src="https://s1.ax1x.com/2022/04/30/OpKboq.png" alt></p><h1 id="bert-程序"><a href="#bert-程序" class="headerlink" title="bert 程序"></a>bert 程序</h1><p>而 bert 的结构就是 transformer 的多个 Encoder 双向堆叠到一起：</p><p><img data-src="https://s1.ax1x.com/2022/04/30/OpKfW8.jpg" alt></p><p>其输入的 embedding 为：</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1Xb8.jpg" alt></p><ul><li>Token Embeddings 是词向量，第一个单词是CLS标志，可以用于之后的分类任务，通过 embedding 层实现。如果句子很短，pad 为 0。程序传入的参数是 input_dis，输入到 embedding 层中。</li><li>Segment Embeddings 用来区别两种句子，因为预训练还要做 NSP 任务，同样是 embedding 层。程序传入的参数是 <code>token_type_ids</code>，输入到 embedding 层中。</li><li>Position Embeddings 和之前的 Transformer 不一样，不是三角函数而是学习出来的，非人工设定，而是 embedding 层。输入到 embedding 层中。</li></ul><p>将这三个不同的 embedding 层的输出相加之和作为 encoder 输入，经过 layernorm 和 dropout 后输出。大概理论就是这些，不过它的预训练是真的靠谱，或者说，应用到具体任务，可以针对具体任务设计与训练。借着预训练，解释一下上面的符号，也是困扰我很久的东西。</p><p>之前一直不知道 CLS 这种东西是干什么的，直到看了代码才清楚，这个符号输入网络，bert encoder 输出的所有状态第一个位置的均值或最后一层的第一个位置的输出，经过全连接和激活，得到的输出，所以这个符号对应位置的输出能用于下游分类任务。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BertPooler</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.dense = nn.Linear(config.hidden_size, config.hidden_size)</span><br><span class="line">        self.activation = nn.Tanh()</span><br><span class="line">        self.config = config</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, hidden_states)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param hidden_states:  [src_len, batch_size, hidden_size]</span></span><br><span class="line"><span class="string">        :return: [batch_size, hidden_size]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.config.pooler_type == <span class="string">"first_token_transform"</span>:</span><br><span class="line">            token_tensor = hidden_states[<span class="number">0</span>, :].reshape(<span class="number">-1</span>, self.config.hidden_size)</span><br><span class="line">        <span class="keyword">elif</span> self.config.pooler_type == <span class="string">"all_token_average"</span>:</span><br><span class="line">            token_tensor = torch.mean(hidden_states, dim=<span class="number">0</span>)</span><br><span class="line">        pooled_output = self.dense(token_tensor)  <span class="comment"># [batch_size, hidden_size]</span></span><br><span class="line">        pooled_output = self.activation(pooled_output)</span><br><span class="line">        <span class="keyword">return</span> pooled_output</span><br></pre></td></tr></table></figure><h1 id="MASK"><a href="#MASK" class="headerlink" title="MASK"></a>MASK</h1><p>bert 有效的原因取决于它的预训练，比如 MLM（Mask language model） 和 NSP （Next sentence prediction），而这其中依赖的主要是 mask。</p><h2 id="处理非定长序列"><a href="#处理非定长序列" class="headerlink" title="处理非定长序列"></a>处理非定长序列</h2><p>在NLP中，文本一般是不定长的，所以在进行 batch训练之前，要先进行长度的统一，过长的句子可以通过truncating 截断到固定的长度，过短的句子可以通过 padding 增加到固定的长度，但是 padding 对应的字符只是为了统一长度，并没有实际的价值，因此希望在之后的计算中屏蔽它们，这时候就需要 Mask。此外，self-attention中，$Q$ 和 $K$ 在点积之后，需要先经过 mask 再进行 softmax，因此，对于要屏蔽的部分，mask之后的输出需要为负无穷，这样softmax之后输出才为0。</p><h2 id="辅助预训练"><a href="#辅助预训练" class="headerlink" title="辅助预训练"></a>辅助预训练</h2><p>做 MLM 预训练时，需要对句子进行 mask，使得模型看不到输入句子的单词。而后，其 label 为被 mask 掉单词的 id。由于 bert 本身的结构，由于预训练的时候，需要做 NSP 和 MLM，而 NSP 是二分类任务，MLM 是多分类任务，因此需要在 bert 上插入两个头分别实现这两个功能，前者就是将缺失的词汇预测回去，后者加入一个全连接输入 pooler output，判断句子是否为上下文。</p><h2 id="防止-see-the-future"><a href="#防止-see-the-future" class="headerlink" title="防止 see the future"></a>防止 see the future</h2><p>这个已经在前文说过了，因为循环神经网络是时间驱动的，只有当时刻 $t$ 运算结束了，才能看到 $t+1$ 时刻的词。而 Transformer Decoder 抛弃了 RNN，改为 Self-Attention，由此就产生了一个问题，在训练过程中，整个 ground truth 都暴露在 Decoder 中，这显然是不对的。因此需要加入 mask 来防止预测过程中看到后面的词汇。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/jadore801120/attention-is-all-you-need-pytorch/blob/master/transformer/Models.py" target="_blank" rel="noopener">transformer程序</a></li><li><a href="https://qixinbo.info/2021/11/09/transformer/" target="_blank" rel="noopener">一个不错的transformer博客</a></li><li><a href="https://www.ylkz.life/deeplearning/p10602241/" target="_blank" rel="noopener">月来客栈解析的 bert 源码</a></li><li><a href="https://zhuanlan.zhihu.com/p/139595546" target="_blank" rel="noopener">mask 机制</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书接上文，因为参加 NLP 的比赛不知道什么是 bert 实在有点说不过去，于是花了三天时间看了下 bert 的基本概念和代码。不得不说，网上阳间的 bert 预训练代码太少了，大多是转载，mark 甚至文不对题之类没啥用的东西，但占据了搜索引擎的首页的热度，像无耻的营销号一样。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NLP" scheme="https://muyuuuu.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>电商搜索召回</title>
    <link href="https://muyuuuu.github.io/2022/03/24/E-commerce-Search-Recall/"/>
    <id>https://muyuuuu.github.io/2022/03/24/E-commerce-Search-Recall/</id>
    <published>2022-03-24T03:50:43.000Z</published>
    <updated>2022-05-11T14:08:16.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://s1.ax1x.com/2022/03/24/q806pT.png" alt></p><p>阿里灵杰问天引擎电商搜索算法赛，来详细的记录一下参加这个天池比赛的流程以及我眼中的检索。因为之前从未涉足 NLP 领域，对 NLP 的了解也仅限于大二的时候看完《数学之美》手写过 TF-IDF 算法，我甚至不知道什么是 bert。</p><p>为了防止更多的人踩坑，能愉快的参与进来，于是决定把我的做法和程序分享出来，供参赛选手参考。之前在交流群里大概说了我的做法，私聊我的人我也都告诉了他们大概怎么去做，在那几天看到好多人在排名突飞猛进保送到了 0.2 分左右，甚至超过了我，还是比较开心的。这次做一个系统的分享，我甚至会告诉你怎么做是不对的，也希望你能有更创新的想法。<strong>走过路过给我的 github 点个 star 就行了，孩子要秋招了，这对我比较重要</strong>。（2022年3月20日，0.22的得分排名 21，3月24日，这个得分只能90名，大家太卷了）。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每天坐在电脑面前查方案、读论文、写代码，每天都加班到凌晨，提交了近一周的 0.0X 的成绩，提交这么多成绩意味着我写了更多的代码。可还是排名倒数，提交成绩的时候一度不敢看排行榜。还有很多反向优化的操作，期间写错代码的次数更是数不胜数。单刷比赛确实感觉不容易，尤其是对我这种到处借显卡的人。除了思路出错和程序出错，读论文和尝试代码的速度也不如组队，写完程序满心欢喜，出来结果满眼失望，经历了一周这样的反反复复，还好稳住了心态，坚持了下来。<del>大型诉苦现场。</del></p><p>在 21 年 7 月的时候，接到了某互联网研究院的项目。我这里简化一下，给定一张图片，在数据库中快速的检索出相似的图片。因为对面采用的方法是使用欧式距离一张一张的比对，速度很慢，我表示对这种做法很震惊，从大学随便找个本科生至少也知道不应该这么做。而检索任务可以分为两阶段，第一阶段为特征提取，第二阶段为特征比对。因为当时对面提供了原始数据提取后的特征，于是当时只完成了特征比对任务。</p><p>时隔半年，我又遇到了相同场景的任务，不过此时要解决的是第一阶段，如何将原始数据提取为一个好的表示，也是这个比赛的关键内容。本文从数据、损失、模型等多个方面来阐述一下如何才能 work，以及为什么能 work。</p><h1 id="关于向量索引"><a href="#关于向量索引" class="headerlink" title="关于向量索引"></a>关于向量索引</h1><p>从计算机视觉、自然语言与语音处理，这三大类的搜索与推荐，只要物品能够被向量化表示，就可能会看到向量索引的身影。因为向量索引不是本文的重点，这里就简单略过。可以参考我之前的文章：<a href="https://muyuuuu.github.io/2021/08/04/LSH-consine/">局部敏感哈希算法的C++实现</a>。</p><p>特征检索也叫向量索引，学术上对应的专有名词叫 Approximate Nearest Neighbor Search (ANNS)，即近似最近邻搜索。为什么是近似，而不是我们想要的精确？这就是精度与时间、算力资源的折中，采用了牺牲精度换取时间和空间的方式，从海量的样本中实时获取跟查询最相似的样本。一种高效的向量索引算法，应该满足3个基本条件：</p><ol><li>实时查询，支持海量（百亿、千亿级别）规模库量级的实时查询；</li><li>存储高效，要求构建的向量索引模型数据压缩比高，达到大幅缩减内存使占用的目的；</li><li>召回精度好，top@K有比较好的召回率；</li></ol><p>目前主要的方法有：基于树的索引（KD 树）、基于哈希的索引（局部敏感哈希方法）、矢量量化方法（OPQ）和基于图的索引（HNSW ）等。更多内容可以参考这里：<a href="https://yongyuan.name/blog/vector-ann-search.html" target="_blank" rel="noopener">https://yongyuan.name/blog/vector-ann-search.html</a></p><p>当时通过编写线程池、空间换时间等操作优化了他人开源的局部敏感哈希算法，修复了他人开源线程池存在的 bug，达到了令人满意的速度和精度。</p><h1 id="关于特征提取"><a href="#关于特征提取" class="headerlink" title="关于特征提取"></a>关于特征提取</h1><p>这是一个很经典也很实用的问题，在 2022 年的今天，随着对比学习的发展，特征提取也迎来了新的热度。而 TF-IDF（文本），SIFT（图像）等非深度学习提取特征的方法本文就不谈了。</p><p>如果使用深度学习来提取特征，如果是图像，模型可以使用 resnet 或者 ViT 等成功的模型，如果是本文，那么可以使用他人预训练好的 bert，我比较推荐 hugging face 和 Nezha。因为前些日子看了 CV 领域的自监督论文，随着模型结构越来越简单，改进集中体现在损失函数上，常用的就是 SimCLR 论文中的对比损失，也叫 InfoNCE 损失函数，而好巧不巧，SimCSE 也用的是这个损失函数。因此，详细来讨论一下这些损失函数，<del>我也没有足够的算力去调网络结构</del>。</p><h2 id="简单的优化距离"><a href="#简单的优化距离" class="headerlink" title="简单的优化距离"></a>简单的优化距离</h2><p>一开始我的想法很简单，既然标注了样本对，那么一个样本视为 anchor，人工标注的答案视为 positive，在数据库中随机选取一个视为 negative，当然在这里也可以进行在线难例挖掘，不过这种改进还是要在实现 baseline 之后再进行。</p><p>选择样本后，将提取到的特征进行标准化，优化 anchor 和 positive 的距离，使他们更加接近，使 anchor 和 negative 的距离更远。为了达到这个目标，在叠加一个交叉熵损失。距离可以选择余弦距离或者欧氏距离，我看 github 的开源项目大部分是余弦距离。具体示意图如下所示：</p><p><img data-src="https://s1.ax1x.com/2022/03/24/q8D2w9.png" alt></p><p>我想大部分人最开始的想法都是这样，但是这么做合理嘛？显然不合理。</p><ol><li>因为即使使用随机数，两者的余弦距离也会很高：<br><img data-src="https://s1.ax1x.com/2022/03/24/q8sADe.png" alt></li><li><blockquote><p>负样本对的目标都“过低”了，因为对于“困难样本”来说，虽然语义不同，但依然是“相似”，相似度不至于0甚至-1那么低，如果强行让它们往0、-1学，那么通常的后果就是造成过度学习，从而失去了泛化能力，又或者是优化过于困难，导致根本学不动。这句话引自科学空间。</p></blockquote></li></ol><p>别看这种损失函数差劲，triplet loss 也一样，面临模型坍塌损失持续为零的现象。至少我两次在工程中使用 triplet loss 都出现了这种情况，而 triplet loss 模型坍塌在 ECCV 2020 的一篇论文【Semi-Siamese Training for Shallow Face Learning】中也解释过，出现坍塌的场景均为：样本种类多，但是每类的样本很少。而实际证明，这种方案做出来的特征向量，检索的 MRR@10 指标很低，大概在 0.05 就是极限了。心态爆炸的一周：</p><p><img data-src="https://s1.ax1x.com/2022/03/24/q8yfFs.png" alt></p><h2 id="CoSENT-使用"><a href="#CoSENT-使用" class="headerlink" title="CoSENT 使用"></a>CoSENT 使用</h2><p>顺着这个思路，查到了苏神的 CoSENT，不得不说从思路到代码都很新颖。如果让我总结一下，那么就是只需要让负样本之间的距离比正样本之间的距离更远就好了，远多少让模型去决定。遂有如下的损失函数（以我的使用经验，损失值会收敛到 0.0X 左右，而且很稳定），而且这个损失函数的代码写法也很棒，建议仔细阅读源码。</p><p>\begin{equation}<br>\log \Biggl(1 + \sum_{(i,j)\in \Omega_{pos}, (k,l)\in \Omega_{neg}} e^{\lambda (\cos(x_k, x_l)-\cos(x_i, x_j))}\Biggr)<br>\end{equation}</p><p>在最开始的时候，我设置正样本和负样本的比例为 1：1，效果不怎么好，可以说是负优化。我又读了一些论文，发现公司的模型都有两部分，其中离线的部分数据量大且训练慢，这么做的好处是训练到更多的数据。那么思路来了，我把正负样本调节到 1：10，负样本并不随机选取，而是顺序遍历全部语料库，因为 1:10 的比例可以囊括所有的样本，这种方法训练时常线性增加，毕竟数据量大了，但是效果好了很多。在 3080 卡，batch size = 2 的情况下，训练时间为 36 小时，得分在 0.15 左右。</p><p><img data-src="https://s1.ax1x.com/2022/03/24/q8ct5d.png" alt></p><h2 id="SimCSE"><a href="#SimCSE" class="headerlink" title="SimCSE"></a>SimCSE</h2><p>SimCSE 是做 NLP 的，但是仔细看了它的损失函数，会发现这种对比损失在 CV 领域也是存在的，比如 SimCLR 算法。这篇论文的想法简单却有效：</p><ul><li>如果是无监督，同一个 batch 中，同一个句子经过模型两次会得到不同的结果视为正样本，不同句子视为负样本。使得正样本之间距离近，负样本之间距离远。</li><li>如果是有监督，那么输入三个句子，一个为 anchor，一个为 positive，一个为 negative，使同一个 batch 中，正样本距离近，负样本距离远。正样本只有同一个句子的 anchor 和 positive，负样本包括两部分：anchor 和 negative，当前 anchor 和其他句子的 positive 与 negative。</li></ul><p>因为 SimCSE 支持无监督和有监督训练，那么想法自然也就来了：我看之前的比赛，RMB 玩家为了使得模型更加贴合当前任务的数据集，都要进行 MLM 预训练，但这种方法很耗时间，不适合我这种到处借显卡的人。所以，我用 SimCSE 的无监督方法训练语料库，使得模型贴合当前任务，在这之后，使用标注数据再训练模型来完成任务，岂不完美。个人的参数是，无监督训练 1 个 epoch，有监督训练 5 个 epoch（损失还很大，没有收敛），得分在 0.2 左右，而且 batch 越大，得分越好。</p><p><img data-src="https://s1.ax1x.com/2022/03/24/q82rNQ.png" alt></p><p>那么 SimCSE 和 CoSENT 如此相似，都是不优化距离，为什么 SimCSE 简单有效呢？这得从他们的损失函数说起：</p><ul><li>对于 CoSENT，只让负样本的距离大于正样本的距离，但是：负样本对之间的不同，正样本对之间的不同却没有考虑到，也就是利用的信息少。</li><li>而 SimCSE 却没有这个缺陷，一个 anchor 会计算 batch 中全部句子的距离并 softmax，并经过交叉熵损失，仅仅将与 positive 的距离视为标签 1，其他视为距离 0。也就是说，读取 batch 含有的全部的信息，并抑制除正样本对外其他表示的距离，利用的信息更多。这也就是前文说的，为什么 batch 越大效果越好。</li></ul><h1 id="其他-trick"><a href="#其他-trick" class="headerlink" title="其他 trick"></a>其他 trick</h1><p>数据不做任何形式的预处理，为什么呢？因为 query 来自用户的输入，这里面存在特殊字符、语序错误、错别字等现象很正常，处理掉反而不好。至于 item 则是商品信息，大家逛淘宝也会发现，商品信息的标注文字几乎没有标点符号，而是很多形容词的堆叠，处理掉也不好。比如：优质木制办公室家用卧室可调接高度带灯光插座多功能折叠桌，它是病句吗？是的，但是就是要查找这样的句子，没必要纠错和预处理。（我没有做消融实验，也没有做数据预处理的实验，这一点仅凭个人分析）。</p><p>使用 pool output 而不是 max pool 最后的隐层输出，也许你会问：使用 max pool 捕获最强的特征，也就是捕获句子中最关键的词，只要词匹配对就匹配完成了。但是想一个例子：优质木制办公室家用卧室可调接高度带灯光插座多功能<strong>折叠桌</strong> 和 优质木制办公室家用卧室可调接高度带灯光插座多功能<strong>支架</strong>，如果使用 max pool，模型初始阶段很容易捕捉错关键词，但是 pool output 就不一样了，我是全部的语义表示，哪怕只有一个词不一样，输出的表示也不一样。（这个我做了实验）。</p><p>模型输出的最后经过 normalization（p=2），为什么呢？我们来看个例子：假设 anchor 的表示是 <code>[0.5, 0.8]</code>，positive 的表示是 <code>[0.6, 0.7]</code>，如果计算欧式距离，此时是 0.14。如果我标准化之后，anchor 的表示是 <code>[0.53, 0.85]</code>，positive 的表示是 <code>[0.65, 0.76]</code>，此时的欧氏距离是 0.15。那么有什么用呢？<code>[0.6, 0.7]</code> 和 <code>[0.5, 0.8]</code> 虽然在每一维都很接近，但是维度间的差距却很大，因此 <code>[0.6, 0.7]</code> 并不是很好的表示，需要加大惩罚力度。而 <code>[0.4, 0.9]</code> 这样的 positive 的表示在标准化之后，和 anchor 的距离是 0.14。可见，如果不标准化，那么 <code>[0.4, 0.9]</code> 和 <code>[0.6, 0.7]</code> 等价；如果标准化，<code>[0.6, 0.7]</code> 就不是一个好表示。（这个也做了实验）。</p><p>交互式匹配（我没有尝试）。这个灵感来自于早年间看过的一个<a href="https://github.com/Lanping-Tech/Multi-modal-Valuation-Forecast-System" target="_blank" rel="noopener">多模态项目</a>，这个项目通过评论和股票的时序数据作为两个模态来预测股价，两个模态进行了四不像的 <a href="https://github.com/Lanping-Tech/Multi-modal-Valuation-Forecast-System/blob/main/models/fusion.py#L37-L45" target="_blank" rel="noopener">transformer</a> 操作，我没理解这是为什么，两者进行了注意力的融合，但是取得了不错的结果。我在想，这次任务没办法进行交互式匹配，但我可以在模型的隐层进行这样的注意力融合，并增加一个分类的分支给注意力提供标签。</p><ul><li>Dense Passage Retrieval for Open-Domain Question Answering 这个论文我看了，想法粗暴简洁，和 SimCSE 差不多，但我没算力去尝试。</li><li>SWA（stochastic weight averaging），我查别人的比赛代码看到了它，效果看着不错。而且早年间用 mmdetection 的时候，确实发现模型在最后几个 epoch 涨分很厉害，但是调参不够友好，在最后阶段我会尝试，现阶段不考虑。</li><li>难例挖掘，我觉得付出和收益不成正比，没有尝试。</li><li>以上 trick 可以拿到一个不错的分数，另外其他的 trick 我会在初赛结束后分享，真心太卷了。</li></ul><h1 id="排雷"><a href="#排雷" class="headerlink" title="排雷"></a>排雷</h1><ul><li>双塔结构不要尝试了，即 query 一个全连接，doc 一个全连接，两者共享一个 bert，企图让两者的表示分开不混杂在一起，但效果奇差无比。</li><li>SimCSE 的损失函数在 CV 的自监督领域也有应用，我尝试把 CV 自监督领域最新的损失套用到这里，但结果很难收敛。</li></ul><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p><a href="https://github.com/muyuuuu/E-commerce-Search-Recall" target="_blank" rel="noopener">https://github.com/muyuuuu/E-commerce-Search-Recall</a></p><p>为什么不用 tensorflow？我 17 年 10 月学 tf 的时候，它那个 with session 和 placeholder 我实在理解不了，那会儿才大二，编程功底很差。19 年 4 月再去看的时候，编程风格和语法大改，好像是什么磁带？梯度一会儿有一会儿没有，混乱的api设计导致代码写的晕晕的，而且和 keras 的关系我也没理解。20 年 7 月的时候我又去看，仿佛完全 keras 化，<code>tf.keras</code> 我实在是被震惊到了，编程风格和语法又又又有改动。我怕我学会了它又出现了 <code>tf.torch</code>，20 年 10 月左右入坑 pytorch，API 稳定，用着也很顺手，也就放弃了学 tf。</p><p>不过还是建议各位用 tf，毕竟这个项目最终要落地到工程，这就涉及到部署和性能优化，不是简简单单实现一个算法就可以完美解决所有问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>CoSENT：<a href="https://kexue.fm/archives/8847/comment-page-1" target="_blank" rel="noopener">https://kexue.fm/archives/8847/comment-page-1</a></li><li>Pytorch CoSENT 损失函数：<a href="https://github.com/shawroad/CoSENT_Pytorch" target="_blank" rel="noopener">https://github.com/shawroad/CoSENT_Pytorch</a></li><li>simcse 的有监督和无监督训练：<a href="https://github.com/zhengyanzhao1997/NLP-model/tree/main/model/model/Torch_model/SimCSE-Chinese" target="_blank" rel="noopener">https://github.com/zhengyanzhao1997/NLP-model/tree/main/model/model/Torch_model/SimCSE-Chinese</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2022/03/24/q806pT.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;阿里灵杰问天引擎电商搜索算法赛，来详细的记录一下参加这个天池比赛的流程以及我眼中的检索。因为之前从未涉足 NLP 领域，对 NLP 的了解也仅限于大二的时候看完《数学之美》手写过 TF-IDF 算法，我甚至不知道什么是 bert。&lt;/p&gt;
&lt;p&gt;为了防止更多的人踩坑，能愉快的参与进来，于是决定把我的做法和程序分享出来，供参赛选手参考。之前在交流群里大概说了我的做法，私聊我的人我也都告诉了他们大概怎么去做，在那几天看到好多人在排名突飞猛进保送到了 0.2 分左右，甚至超过了我，还是比较开心的。这次做一个系统的分享，我甚至会告诉你怎么做是不对的，也希望你能有更创新的想法。&lt;strong&gt;走过路过给我的 github 点个 star 就行了，孩子要秋招了，这对我比较重要&lt;/strong&gt;。（2022年3月20日，0.22的得分排名 21，3月24日，这个得分只能90名，大家太卷了）。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NLP" scheme="https://muyuuuu.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>YOLOX 源码解析与小目标检测调优</title>
    <link href="https://muyuuuu.github.io/2022/02/26/yolox/"/>
    <id>https://muyuuuu.github.io/2022/02/26/yolox/</id>
    <published>2022-02-26T08:31:59.000Z</published>
    <updated>2022-05-06T15:10:16.895Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近用 yolox 的发现了一个很神奇的现象，简而言之 <code>yolox-tiny</code> 在单目标检测的效果比 <code>yolox-small</code> 好上很多（3.2mAP%），且 <code>yolox-small</code> 能大幅提升检测精度的方法到了 <code>yolox-tiny</code> 也不起作用了。网上很多 yolox 的解读基本都是翻译论文，没啥价值，还是决定仔细读一下代码，这大概也是全网第一份从源代码的角度解析 yolox 的文章。</p><p>阅读源码后发现 yolox 的 SimOTA 机制存在一些漏洞，并使用对应的方法调优。调优过程明确不采用的方案：增大模型规模、模型融合和其他消耗算力的方法，专注算法本身。</p><a id="more"></a><h1 id="Model-部分"><a href="#Model-部分" class="headerlink" title="Model 部分"></a>Model 部分</h1><p>和其他检测模型一样，<code>model</code> 分为 <code>backbone</code>，<code>neck</code> 和 <code>head</code>。</p><h2 id="backbone"><a href="#backbone" class="headerlink" title="backbone"></a>backbone</h2><p><code>backbone</code> 采用 <code>CSPDarkNet</code>，包括 <code>stem</code>，<code>dark2</code>，<code>dark3</code>，<code>dark4</code> 和 <code>dark5</code>。</p><ul><li>数据经过增强处理并缩放到 <code>640X640</code> 大小后进入 <code>stem</code> 完成图像通道的升维，从 <code>3</code> 通道提升到 <code>X</code> 通道，<code>X</code> 取决于 <code>backbone</code> 规模的 <code>width_factor</code> 参数。图像经过这一层之前，会被均匀切分为左上、右上、左下和右下四个区域并按通道拼接得到 <code>160X160X12</code> 的数据，也就是 12 个通道，每个通道的图像大小占据原图像大小的 <code>1/4</code>，在经过卷积、<code>BN</code> 层和激活层，得到输出。</li><li><code>stem</code> 的输出进入 <code>dark2</code>，经过一个卷积模块，维度提升一倍后尺寸减半。而后经过 <code>CSPLayer</code>，<code>CSPLayer</code> 的结构和残差网络相似，一个分支只对输入卷积一次，另一个分支进行深度特征提取，深度的层数取决于 <code>backbone</code> 的 <code>depth_factor</code> 参数，而后两个分支的输出按照通道数拼接到一起，完成升维。</li><li><code>dark3, dark4, dark5</code> 的东西和 <code>dark2</code> 一致，无非是尺寸减半，通道数翻倍，同理得到 <code>dark3, dark4, dark5</code> 的输出。</li></ul><p><img data-src="https://s4.ax1x.com/2022/02/26/bZ86nH.png" alt></p><p>这里补充一下：</p><ul><li><code>dark3</code> 的输出维度：<code>256X80X80</code></li><li><code>dark4</code> 的输出维度：<code>512X40X30</code></li><li><code>dark5</code> 的输出维度：<code>1024X20X20</code></li></ul><h2 id="neck"><a href="#neck" class="headerlink" title="neck"></a>neck</h2><p>获取 <code>backbone</code> 的 <code>dark3, dark4, dark5</code> 的输出作为输入。这里用文字描述的话太复杂了，简单的画图展示一下大概结构，精细的结构还是要看源代码：</p><p><img data-src="https://s4.ax1x.com/2022/02/26/bZ8gHA.png" alt></p><p>也就是说，这三个输出都融合了模型深层的语义特征和模型浅层的细节特征。</p><h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>因为 <code>neck</code> 有三组输出，所以 <code>head</code> 对 <code>neck</code> 的每一组输出都要进行处理。对每一个输入经过不同的 <code>stem</code> 把通道数降维到 256，而后接入解耦的任务分支，包括分类（<code>cls</code>）、位置框（<code>reg</code>）和前背景（<code>obj</code>）三个网络。</p><p>分类网络的输出通道数是类别数，这里假设为 2，回归网络的输出通道数是 4，负责预测中心点坐标和高宽尺寸，前背景网络的输出通道数是 1，因此输出的通道数是 2+4+1=7。将这三个网络的输出然后拼接到一起，放到一个列表中。因此，<code>head</code> 部分得到的输出为三组数据：<code>7X80X80, 7X40X40, 7X20X20</code>。以 <code>7X80X80</code> 为例，表示预测了 <code>80X80</code> 个目标，每个目标包括位置、类别和前背景共 7 个参数。</p><p><img data-src="https://s4.ax1x.com/2022/02/26/bZ8cBd.png" alt></p><h1 id="训练部分"><a href="#训练部分" class="headerlink" title="训练部分"></a>训练部分</h1><p>这一部分是难点，或者说，是任何目标检测算法的实现难点，代码量也是最大。</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>在这一部分，将对 <code>head</code> 的三个输出进行一些转换并生成对应的 <code>grid</code> 信息，将预测输出对应到图像中的实际位置。<code>grid</code> 可以理解为特征点的位置吧，是固定的，如下图所示黑色的那一个个格子（其他颜色不用看，我实在找不到类似的图了）：</p><p><img data-src="https://s4.ax1x.com/2022/02/27/beHtnP.png" alt></p><p>这一部分大概分以下步骤：</p><ol><li>获取输出特征的的宽度和高度，如 80 和 80，或者 40 和 40，那么就生成对应的 <code>grid</code>，如 [0, 1] [0, 2] … [80, 80] 共 6400 个，维度是 [1, 6400, 2]</li><li>将预测结果 <code>reshape</code> 成 <code>Batch, HxW, C</code> 大小，坐标的 <code>x</code> 和 <code>y</code> 加上 <code>grid</code> 会映射到每个预测特征点的中心位置，在乘以 8，也就是理想情况下位置信息的运算结果会在 640 X 640 之间，也就是图像上目标的中心点</li><li>计算 <code>w</code> 和 <code>h</code> 的 $e$ 次方，再乘以 8，得到目标框的高度和宽度。此时返回得到的 <code>grid</code> 和变换过后的 <code>output</code>。（80 对应的扩张步是 8，40 对应的扩张步是 16，20 对应的扩张步是 32）</li></ol><p>将每一个输出经过上面 3 个步骤的处理后，按照 <code>dim=1</code> 拼接到一起，也就是会得到 <code>Batch, 8400, 7</code> 的输出。（80X80 + 40X40 + 20X20 = 8400）。</p><h2 id="计算损失"><a href="#计算损失" class="headerlink" title="计算损失"></a>计算损失</h2><p>针对 <code>batch</code> 中的每一个图像开始处理：</p><ul><li>如果真实标签显示这个图像没有目标，全部真实标签就是清一色的 0，分类个数全部是 0，位置参数是 4 个 0，有无目标是 8400 个 0，<code>fg_mask</code> 全部是 <code>false</code>。（<code>fg_mask</code> 的用途后面会讲）</li><li>否则，取出这个图像包含的全部真实目标框，与预测结果进行 SimOTA 样本分配，为预测结果分配标签，或者说为标签分配预测结果，因为 8400 个预测结果不可能同时参与训练，只选择部分样本视为正样本进行训练。</li></ul><h3 id="SimOTA"><a href="#SimOTA" class="headerlink" title="SimOTA"></a>SimOTA</h3><p>首先计算真实框覆盖的 <code>grid</code> 中心点，将这些 <code>grid</code> 中心点称为 <code>fg_mask</code> 也就是正样本，从所有的预测结果中通过 <code>fg_mask</code> 把正样本取出来，包括位置，类别和前背景。此外，选择落入真实目标框的周围的预测结果并记录下来，周围的度量方式是：当前特征点乘以 2.5 倍的步长所覆盖的格子。</p><ul><li>之后计算选中的位置和真实位置的 <code>iou</code> 得分和损失；</li><li>将类别的输出激活后和 <code>obj</code> 的激活输出相乘得到类别得分，以此得到类别损失；</li><li>将没有被选中的预测结果视为负样本，也就是上面没有落入真实目标框及周围的预测结果视为预测失败，计算预测失败的损失，有一个预测结果不在，损失就是1，有 100 个不在，就是 100，然后计算这三个损失的和。</li></ul><p>之后进行动态 k 分配，这里的 k 计算比较简单，在 10 和上一步骤选中的 <code>fg_mask</code> 数量取最小值就是 <code>k</code>，给每个真实框选取损失最小的 <code>k</code> 个预测结果。如果当某一个特征点指向多个真实框的时候，选取 <code>cost</code> 最小的真实框，之后对 <code>fg_mask</code> 进行更新。</p><h3 id="计算损失-1"><a href="#计算损失-1" class="headerlink" title="计算损失"></a>计算损失</h3><ul><li><code>obj</code> 损失是全部的预测结果和动态 k 分配后得到的 <code>fg_mask</code> 做交叉熵，提升检测到目标的能力</li><li><code>cls</code> 损失基于 <code>fg_mask</code> 选中的预测结果，将类别的 <code>one-hot</code> 向量与正样本和真实框的 iou 做乘积视为目标。比如预测框和真实框的 iou 是 0.4，那么对应的类别得分就是 0.4，毕竟相交面积小。预测结果和目标做交叉熵损失</li><li><code>reg</code> 损失是就是预测盒子和真实盒子的 iou 损失</li></ul><h1 id="问题分析与调优"><a href="#问题分析与调优" class="headerlink" title="问题分析与调优"></a>问题分析与调优</h1><p>如何解释开头的问题以及如何调优呢？通过一路 <code>debug</code> 找到了一些问题，我目前只发现了一点点问题，<del>等我彻底解决完毕回来填坑（因为又又又摸不到显卡了）。</del></p><ul><li>第一点，由于是单目标检测任务，也就是说只有一个目标，那么小模型参数少，很容易聚焦和收敛；而大模型参数大，解空间也会更多，相对小模型难以探索到更好的解，因此一些常见的 <code>trick</code> （比如预训练 <code>backbone</code>）才会有效的提升大模型的检测效果，而对小模型而言，参数少，搜索空间小，很容易找到更优的解，因此一些 <code>trick</code> 并不会起到很大的作用。</li><li>第二点，由于检测任务绝大多数目标是小目标，而 yolox-tiny 模型尺寸小，输出的通道数也少，底层的特征信息的保留程度好于大模型，因为模型越深，对图像细节的保留程度就越低。</li><li>第三点，也是最重要的一点，由于 YOLOX 选取正样本的机制是：预测结果落入真实框，或者落入真实框的周围，这些落入真实框周围的正样本在模型初期会侥幸存活下来并通过 <code>SimOTA</code> ，但是，由于大部分都是小目标，会导致预测结果和真实目标毫不相交的场景，这就 <code>reg</code> 分支的 IoU Loss 面临难以优化的场景，我们换成 CIoU Loss 就可以了。具体可以参考这里：<a href="https://muyuuuu.github.io/2022/04/23/iou-loss/">IoU Loss 系列</a>。</li></ul><p><img data-src="https://s4.ax1x.com/2022/02/27/beHJXt.png" alt></p><p>如图所示，红色是真实框，绿色是落入真实框周围的预测结果（正样本），灰色表示不参与训练。可以看到，由于目标较小，预测结果和真实标签毫不相交，IoU Loss 的损失恒定是 1，这显然是不合理的。应该根据距离预测结果与真实目标的远近而定，而 CIoU Loss 能很好的解决这一点。</p><p>如果你要从发论文的角度调优 yolox，那么建议改动它的 SimOTA 机制，但是这也只能是为了毕业而发的一篇普通的论文，还远远达不到 yolov6 问世的高度。如果是工程的角度，那么 CIoU Loss 会很适合你。结果也显示，使用 CIoU Loss 的 mAP 要远远高于不使用和 yolox-tiny，提升 4.1 的 mAP。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近用 yolox 的发现了一个很神奇的现象，简而言之 &lt;code&gt;yolox-tiny&lt;/code&gt; 在单目标检测的效果比 &lt;code&gt;yolox-small&lt;/code&gt; 好上很多（3.2mAP%），且 &lt;code&gt;yolox-small&lt;/code&gt; 能大幅提升检测精度的方法到了 &lt;code&gt;yolox-tiny&lt;/code&gt; 也不起作用了。网上很多 yolox 的解读基本都是翻译论文，没啥价值，还是决定仔细读一下代码，这大概也是全网第一份从源代码的角度解析 yolox 的文章。&lt;/p&gt;
&lt;p&gt;阅读源码后发现 yolox 的 SimOTA 机制存在一些漏洞，并使用对应的方法调优。调优过程明确不采用的方案：增大模型规模、模型融合和其他消耗算力的方法，专注算法本身。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="CV" scheme="https://muyuuuu.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>PyQt 打造的图像预览软件</title>
    <link href="https://muyuuuu.github.io/2022/02/12/pyqt5-view-image/"/>
    <id>https://muyuuuu.github.io/2022/02/12/pyqt5-view-image/</id>
    <published>2022-02-12T10:08:59.000Z</published>
    <updated>2022-02-12T10:26:30.630Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>寒假某天下午的突发奇想，想实现一款图像预览软件。大概思路是：在软件的左侧点击图片，软件的右侧就能实时预览图片，因为感觉这个功能有一定的应用场景，所以实现了一下。</p><p><img data-src="https://s4.ax1x.com/2022/02/12/H0ywWQ.png" alt></p><a id="more"></a><p>简单说一下设计思路吧，代码没啥难度：</p><ol><li>使用 GridLayout 手动布局提升美感，左侧是文件列表，右侧是图片预览</li><li>当从左侧文件列表点击文件时，判断点击的文件是否为图像类型，如果是，右侧显示图像。关于如何显示高清图像，可以参考我之前的<a href="https://muyuuuu.github.io/2021/04/10/pyqt5-load-huge-image/">博客</a></li><li>文件列表使用 <code>QTreeView</code> 和 <code>QListView</code> 实现，<code>QTreeView</code> 负责显示文件夹层级关系，<code>QListView</code> 负责显示文件。两者都挂载文件模型。</li><li><del>Qt 的使用就是学会基础操作后大量翻阅官方库的过程。</del></li></ol><p><img data-src="https://s4.ax1x.com/2022/02/12/H0sJ5F.gif" alt></p><p>可以看到里面还有加载模型、识别等按钮，也能猜出来这是深度学习应用的软件。</p><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QMainWindow, QWidget, QGridLayout, QApplication,</span><br><span class="line">                             QPushButton, QStatusBar, QProgressBar, QLabel,</span><br><span class="line">                             QTreeView, QListView, QFileSystemModel, QLineEdit,</span><br><span class="line">                             QInputDialog, QFileDialog, QTextEdit, QMessageBox)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QDir</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QPixmap, QFont</span><br><span class="line"><span class="keyword">from</span> PyQt5.Qt <span class="keyword">import</span> QSize, QImageReader</span><br><span class="line"><span class="keyword">import</span> qdarkstyle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondWindow</span><span class="params">(QWidget)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        super(SecondWindow, self).__init__()</span><br><span class="line">        self.resize(<span class="number">400</span>, <span class="number">400</span>)</span><br><span class="line">        self.move(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">        layout = QGridLayout()</span><br><span class="line">        self.info = QTextEdit()</span><br><span class="line">        layout.addWidget(self.info)</span><br><span class="line">        self.info.setText(msg)</span><br><span class="line">        self.setLayout(layout)</span><br><span class="line">        self.setWindowTitle(<span class="string">'详细信息'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mainwindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(mainwindow, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.setWindowTitle(<span class="string">"天然草地类型识别系统"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示正在加载</span></span><br><span class="line">        self.status = QStatusBar()</span><br><span class="line">        self.status.setStyleSheet(<span class="string">'QStatusBar::item &#123;border: none;&#125;'</span>)</span><br><span class="line">        self.setStatusBar(self.status)</span><br><span class="line"></span><br><span class="line">        self.progressBar = QProgressBar()</span><br><span class="line">        self.label = QLabel()</span><br><span class="line">        self.label.setText(<span class="string">"加载中，请稍后... "</span>)</span><br><span class="line">        self.status.addPermanentWidget(self.label, stretch=<span class="number">2</span>)</span><br><span class="line">        self.status.addPermanentWidget(self.progressBar, stretch=<span class="number">4</span>)</span><br><span class="line">        self.progressBar.setRange(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">        self.progressBar.setMinimum(<span class="number">0</span>)</span><br><span class="line">        self.progressBar.setMaximum(<span class="number">0</span>)</span><br><span class="line">        self.statusBar().setVisible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        self.setMinimumSize(<span class="number">1500</span>, <span class="number">720</span>)</span><br><span class="line"></span><br><span class="line">        layout = QGridLayout()</span><br><span class="line">        w = QWidget()</span><br><span class="line">        w.setLayout(layout)</span><br><span class="line">        self.setCentralWidget(w)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 文件树</span></span><br><span class="line">        self.treeview = QTreeView()</span><br><span class="line">        self.listview = QListView()</span><br><span class="line">        layout.addWidget(self.treeview, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>)</span><br><span class="line">        layout.addWidget(self.listview, <span class="number">0</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        path = QDir.rootPath()</span><br><span class="line"></span><br><span class="line">        self.dirModel = QFileSystemModel()</span><br><span class="line">        self.dirModel.setRootPath(QDir.rootPath())</span><br><span class="line">        self.dirModel.setFilter(QDir.NoDotAndDotDot | QDir.AllDirs)</span><br><span class="line"></span><br><span class="line">        self.fileModel = QFileSystemModel()</span><br><span class="line">        self.fileModel.setFilter(QDir.NoDotAndDotDot | QDir.Files)</span><br><span class="line"></span><br><span class="line">        self.treeview.setModel(self.dirModel)</span><br><span class="line">        self.listview.setModel(self.fileModel)</span><br><span class="line"></span><br><span class="line">        self.treeview.setRootIndex(self.dirModel.index(path))</span><br><span class="line">        self.listview.setRootIndex(self.fileModel.index(path))</span><br><span class="line"></span><br><span class="line">        self.treeview.clicked.connect(self.on_clicked)</span><br><span class="line">        self.listview.clicked.connect(self.run_model)</span><br><span class="line"></span><br><span class="line">        self.treeview.hideColumn(<span class="number">1</span>)</span><br><span class="line">        self.treeview.hideColumn(<span class="number">2</span>)</span><br><span class="line">        self.treeview.hideColumn(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示图片</span></span><br><span class="line">        self.image_label = QLabel()</span><br><span class="line">        self.image_label.setMinimumSize(<span class="number">800</span>, <span class="number">700</span>)</span><br><span class="line">        layout.addWidget(self.image_label, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加载模型</span></span><br><span class="line">        btn = QPushButton(<span class="string">"加载模型"</span>)</span><br><span class="line">        layout.addWidget(btn, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        btn.clicked.connect(self.load_model)</span><br><span class="line"></span><br><span class="line">        more_btn = QPushButton(<span class="string">"详细信息"</span>)</span><br><span class="line">        layout.addWidget(more_btn, <span class="number">7</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        more_btn.clicked.connect(self.show_info)</span><br><span class="line"></span><br><span class="line">        reco_btn = QPushButton(<span class="string">"识别"</span>)</span><br><span class="line">        layout.addWidget(reco_btn, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        reco_btn.clicked.connect(self.predict)</span><br><span class="line"></span><br><span class="line">        clear_btn = QPushButton(<span class="string">"清空"</span>)</span><br><span class="line">        layout.addWidget(clear_btn, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        clear_btn.clicked.connect(self.clear)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预测结果</span></span><br><span class="line">        self.res = QLineEdit()</span><br><span class="line">        self.res.setReadOnly(<span class="literal">True</span>)</span><br><span class="line">        layout.addWidget(self.res, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        self.model = <span class="literal">None</span></span><br><span class="line">        self.fname = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res.clear()</span><br><span class="line">        self.image_label.setVisible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.fname <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 调用你的图片信息代码，我这里没对应的 excel</span></span><br><span class="line">            <span class="comment"># 详细信息赋值给 msg 即可</span></span><br><span class="line">            msg = <span class="string">"详细信息"</span></span><br><span class="line">            self.child = SecondWindow(msg)</span><br><span class="line">            self.child.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当选中图片的时候，直接进行预测</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_model</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.image_label.setVisible(<span class="literal">True</span>)</span><br><span class="line">        idx = self.listview.currentIndex()</span><br><span class="line">        fname = self.fileModel.filePath(idx)</span><br><span class="line">        img_type = fname.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 判断下是不是图片</span></span><br><span class="line">        <span class="keyword">if</span> img_type <span class="keyword">in</span> [<span class="string">"png"</span>, <span class="string">"jpg"</span>]:</span><br><span class="line">            img = QImageReader(fname)</span><br><span class="line">            scale = self.image_label.width() / img.size().width()</span><br><span class="line">            height = int(img.size().height() * scale)</span><br><span class="line">            img.setScaledSize(QSize(self.image_label.width(), height))</span><br><span class="line">            img = img.read()</span><br><span class="line">            pixmap = QPixmap(img)</span><br><span class="line">            self.image_label.setPixmap(pixmap)</span><br><span class="line">            self.fname = fname</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试代码放在这里</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.fname <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># y = self.model(x)</span></span><br><span class="line">            <span class="comment"># y = str(y)</span></span><br><span class="line">            self.res.setText(<span class="string">"cls 1: 0.9, cls 2: 0.8, cls 3: 0.9"</span>)</span><br><span class="line">        <span class="comment"># res = self.model(img)</span></span><br><span class="line">        <span class="comment"># self.res.setText(res)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msgBox = QMessageBox()</span><br><span class="line">            msgBox.setIcon(QMessageBox.Warning)</span><br><span class="line">            msgBox.warning(self, <span class="string">"警告"</span>, <span class="string">"请选择图片后再预测"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_clicked</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        path = self.dirModel.fileInfo(index).absoluteFilePath()</span><br><span class="line">        self.listview.setRootIndex(self.fileModel.setRootPath(path))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载模型的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_model</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.status.setVisible(<span class="literal">True</span>)</span><br><span class="line">        file_filter = <span class="string">'PKL File (*.pt *.pth *.pkl)'</span></span><br><span class="line">        response = QFileDialog.getOpenFileName(</span><br><span class="line">            parent=self,</span><br><span class="line">            caption=<span class="string">'Select a data file'</span>,</span><br><span class="line">            directory=os.getcwd(),</span><br><span class="line">            filter=file_filter,</span><br><span class="line">        )</span><br><span class="line">        pth_file, _ = response</span><br><span class="line">        <span class="comment"># torch load model</span></span><br><span class="line">        <span class="comment"># self.model.load_state_dict(torch.load(pth_file))</span></span><br><span class="line">        self.status.setVisible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QApplication([])</span><br><span class="line">    dark_stylesheet = qdarkstyle.load_stylesheet_pyqt5()</span><br><span class="line">    <span class="comment"># 如果想美化就取消注释</span></span><br><span class="line">    <span class="comment"># app.setStyleSheet(dark_stylesheet)</span></span><br><span class="line">    m = mainwindow()</span><br><span class="line">    m.show()</span><br><span class="line">    sys.exit(app.exec())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;寒假某天下午的突发奇想，想实现一款图像预览软件。大概思路是：在软件的左侧点击图片，软件的右侧就能实时预览图片，因为感觉这个功能有一定的应用场景，所以实现了一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s4.ax1x.com/2022/02/12/H0ywWQ.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="GUI" scheme="https://muyuuuu.github.io/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>算是一个陈述句流水帐的年终总结吧</title>
    <link href="https://muyuuuu.github.io/2022/02/04/2021/"/>
    <id>https://muyuuuu.github.io/2022/02/04/2021/</id>
    <published>2022-02-04T09:44:53.000Z</published>
    <updated>2022-05-24T14:16:27.387Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时间有些晚了，选一个词来描述今年的话，现实魔幻主义，孤魂野鬼又一年。现实比魔幻还要魔幻，魔幻比现实还要现实。</p><a id="more"></a><p>还是那句话，悲观是我的状态，努力是我的态度，不冲突。</p><ul><li><p>1 月，那会儿在期末考试吧，并趁考试的时候忙里偷闲学完了操作系统和 C++。至于为什么研究生在考试的时候才是一年中最清闲的时光，懂得都懂。大概又说错了一些话，又错过了，以后只在适当的时候和懂得人去说，也要少说，不要人别人觉得很烦。也是在这时候完成的心态的转变，放弃科研。这个月看完了火影，仿佛自己是宇智波，被生活的重压的反噬了。</p></li><li><p>2 月，忘记了，大概是返校，选课。有一门老师的课极度恶心，又是说论文多么多么重要，不注重实践的东西反手退课。我至今羡慕学完计算机原理能写 RISC 五级流水的人。这个月印象最深的是初次尝试去淘宝开代码店了，这也是今年值得记录的大事之一。实在穷的揭不开锅，接近没钱吃饭的程度，实在没办法。接的前两个业务是 LaTeX 排版的，第一笔业务挣了 20 块钱，我当时在想我能免费用 5 次学校的洗衣机。我成为了我曾经讨厌的人，也许并不是。不接毕设，不接大作业，不接考试，这是原则问题。更多的是项目合作和程序指导。</p></li><li><p>3 月，连夜买票参加了同学的婚礼，在凌晨的唐山骑着共享单车疯狂前往目的地。同学在大学所在地结婚，正好我大学毕业很匆忙，没和同学告别，趁此机会好多同学都回来了，大家一起吃个饭，一起聊聊天，弥补当年没有告别的遗憾。不像上次，这次分别没有哭的稀里哗啦。</p></li><li><p>4 月，同学来了西安，和他一起在西安、咸阳转了转，是我第一次正经在西安旅游吧。之后爬了华山，和她矛盾愈演愈烈，不喜欢阴阳的聊天，索性不聊了。这个月应该是接业务的顶峰，啥都接，凌晨一点写代码头很晕的那种，不上课不科研一直在陪客户，很累，像个孤魂野鬼。在某一天，听了很久的音乐，推了所有的业务，退款道歉，准备收手。</p></li><li><p>5 月，学了下 mmdetection，shell 和设计模式，之后就是研三毕业的节奏占据实验室的主流，真好，解脱了。业务并没有彻底放弃，一个月一两笔，多了就不接了，第一点没啥营养，第二点我没钱吃饭。</p></li><li><p>6 月，准备期末？和几个客户确定了长期关系。</p></li><li><p>7 月，暑假放 10 天，但接了个华为的项目，旅行计划泡汤。想临时冲一下项目，加上暑假回去也没想见的人，索性留校了。被老师虚晃了好几枪，答应的事情都没了后续。于是自己学了一些自监督、高维索引和线程池的东西，自己把项目解决了。</p></li><li><p>8 月，被折腾去投论文，很累，累的原因倒不是多难，而是这个字体加粗，这里行间距，这里符号替换，和换成及，去掉空格，加粗，换成楷体，真的很没意思。开始打游戏缓解压力，一天一天又一天。</p></li><li><p>9 月，在华为项目基础上又做了上游的开发，算是体验了一下一整套系统吧，然后打游戏，打游戏，打游戏…… 置身现实魔幻主义，被搞的很累。</p></li><li><p>10 月，又被抓去投论文，真的很没意思。不是落地的项目，只在玩具数据集上追求比 A 高 2 个点，比 B 高 3 个点，比 C 高 10 个点，仿佛前人的工作都是垃圾，自己论文无与伦比的新颖，晚诞生一年就是这个世界的损失，用各种词汇体现论文的创新，但本来就是很简单的东西。因此对这种东西深恶痛绝。一个同学考上了清华，给我介绍了一笔大业务，会持续到明年 4 月吧，能写到简历里。所以除了老客户的业务，新业务都不接了。</p></li><li><p>11 月，接到了第二个华为的项目，补了一下 C++ 的高级特性，然后就去开发了。体验了面向生产环境该如何编程，如何设计数据结构，代码如何检验，很棒。开发之余还是打游戏缓解压力，接业务。仿佛脱离了现实进入了魔幻。</p></li><li><p>12 月，大四的师弟来了，帮着我搞项目，也请了几顿饭，我又又又被抓去投论文了，真的恶心，持续性头晕。其中一点是，做深度学习但没有显卡，实验得不到保障。时隔 8 个月，和他关系有所缓和，他也理解了我所处环境的苦衷，终于能好好说话了，不容易。我也尝试不再去抱怨，可总是没话题去说，也许随缘吧。开始不带手机回宿舍，好好睡一觉。买了把静电容键盘。</p></li></ul><p>生活总是这样，不给半点希望的星光，把人压的苟延残喘却无可奈何，难过的时候都要去 b 站算卦占卜来看一下接下来的日子走势，企图获得一星半点的慰籍。可能是自己想太多，进入了精神内耗，经历过很多难熬的日子，似乎也不差这几百天。可能有什么办法呢？今年就要秋招了，努力一下，等找完工作稳定下来，好好休息吧，不再去想乱七八糟的东西。</p><p>我觉得师兄有句话很好，毕业了绝对不能立刻买房，先玩几年。学校里跟个孙子似的，没必要一毕业立刻成为孙子，每天一挣钱欠银行几百块钱的日子也不好受。虽然早晚是孙子，但先玩几年，快乐几年再说。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间有些晚了，选一个词来描述今年的话，现实魔幻主义，孤魂野鬼又一年。现实比魔幻还要魔幻，魔幻比现实还要现实。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Life" scheme="https://muyuuuu.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>半监督浅显入门</title>
    <link href="https://muyuuuu.github.io/2022/01/30/semi-intro/"/>
    <id>https://muyuuuu.github.io/2022/01/30/semi-intro/</id>
    <published>2022-01-30T12:15:16.000Z</published>
    <updated>2022-01-30T12:21:34.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>寒假开始前还是把在学校里遗留的工作先搞完，所接项目的目标是实现半监督语义分割。既然是半监督，就先来看一下半监督的经典论文，我选了经典的、结构相似的三篇论文。</p><p>第一篇是：NIPS 2017 的 Mean teachers are better role models: Weight-averaged consistency targets improve semi-supervised deep learning results，因为我发现伪标签相关的论文或多或少有它的影子。</p><p>第二篇是：ICCV 2021 的 End-to-End Semi-Supervised Object Detection with Soft Teacher，微软出品的半监督目标检测，质量上还是比较让人相信的，且语义分割也可以借鉴目标检测的东西。</p><p>第三篇是：ECCV 2021 的 Semi-supervised Semantic Segmentation via Strong-weak Dual-branch Network，因为搜半监督语义分割，最新的进展论文就是它了。</p><p>文章最后有代码实现。<del>才发现好久没更新博客了。</del></p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因为现实世界标注数据比较昂贵，但无标注的数据很容易获得，那么基于少量标注数据和大量无标注数据的训练，也就是半监督训练也成为了研究的热门。简单来说，半监督分为两类：</p><ul><li>伪标签，用有标签数据训练一个分类器，然后用这个分类器对无标签数据进行分类，这样就会产生伪标签(<code>pseudo label</code>)，挑选其中认为分类正确的无标签样本，把选出来的无标签样本用来训练分类器，这样就使用了无标签数据。</li><li>协同训练，假设每个数据可以从不同的视角（对应到 <code>torch</code> 的话，就是不同的 <code>torchvision.transform</code>）进行分类。不同视角可以训练出不同的分类器，分类器对不同视角的图片分类结果应该相同。然后用这些从不同视角训练出来的分类器对无标签样本进行分类，再选出认为可信的无标签样本加入训练集中。由于这些分类器从不同视角训练出来的，可以形成一种互补，而提高分类精度，就如同从不同视角可以更好地理解事物一样。</li></ul><h1 id="半监督图像分类"><a href="#半监督图像分类" class="headerlink" title="半监督图像分类"></a>半监督图像分类</h1><p>这篇论文还是很简单的：</p><p><img data-src="https://s4.ax1x.com/2022/01/30/HC2TpQ.png" alt></p><p>但论文中的训练过程写的不是很清楚，看了<a href="https://github.com/CuriousAI/mean-teacher/tree/546348ff863c998c26be4339021425df973b4a36/pytorch" target="_blank" rel="noopener">代码</a>了解了完整的训练流程：</p><ul><li>有标签输入学生的预测输出和 <code>one-hot label</code> 进行对比，这个是分类损失；和教师的输出使用 <code>consistency cost</code> 进行对比，论文中用的是两个模型输出的二阶范数，代码提供了 <code>mse</code> 和 <code>kl</code> 散度两个损失。第二个 <code>loss</code> 根据 <code>epoch</code> 调整权重，<code>epoch</code> 越大，权重越大。</li><li>两个权重相加，反向传播更新学生的模型，<code>exponential moving average (EMA)</code> 更新教师模型，能在每个 <code>batch</code> 后聚合信息而不是每个 <code>epoch</code> 后才聚合信息，这样能获取更好的表示。</li><li>最后使用教师模型进行预测。</li></ul><p>至于<a href="https://github.com/CuriousAI/mean-teacher/blob/546348ff863c998c26be4339021425df973b4a36/pytorch/mean_teacher/data.py#L72-L79" target="_blank" rel="noopener">无标签数据部分</a>，就是一批数据作两次变换，第一组视为有标签，第二组数视为无标签。</p><p>这篇论文的思想可以总结为：作为教师，用来产生学生学习时的目标；作为学生，则利用教师模型产生的目标来进行学习。</p><h1 id="半监督目标检测"><a href="#半监督目标检测" class="headerlink" title="半监督目标检测"></a>半监督目标检测</h1><p>如果说分类图像的数据难以标注，那么目标检测的数据更加难以标注。</p><p>半监督目标检测的重点是：提升伪标签质量，伪标签质量好了也利于后续的训练。传统的半监督目标检测是多阶段方法：使用标签数据训练一个检测器，之后对无标签数据生成伪标签，再次训练检测器。但是也很容易受到限制：如何保证伪标签的质量？标签数据和无标签数据分布不一致怎么办？且不是端到端的，多年前写 <code>MTCNN</code> 的时候就感觉不是端到端就很不方便。</p><p>同样类似 <code>mean teacher</code> 的结构，创建两个模型，并使用 <code>EMA</code> 更新教师模型。教师模型指导学生模型的训练，而不是简单的提供伪标签就结束了。在获取学生模型生成的预测后，得分大于某个阈值的视为前景，以此保证伪标签的质量，但即使这样仍然有很多预测结果是背景，后文会给出解决方案。</p><p>对于无标签数据，控制标签数据和无标签数据在一个 <code>batch</code> 中的比率，从 <code>0.5</code> 开始，衰减到最后的 <code>epoch</code> 为 0。</p><p><img data-src="https://s4.ax1x.com/2022/01/30/HC2bXn.png" alt></p><p>在图里可以看到：教师模型对无标签数据进行弱数据增强，并生成盒子的伪标签和类别的伪标签。学生模型读入有标签数据，得到一个损失 $L_u$ ，对无标签数据使用强数据增强，预测结果和教师模型生成的伪标签对比，又得到一个损失 $L_s$ 。最后的损失为 $L_s + \alpha L_u$。</p><p>对于 $L_u$ 的分类部分，与半监督分类的一致性分布损失相反，目标检测的伪标签相对复杂，无标签数据上能检测出上千个盒子，即使 <code>NMS</code> 之后也会留下很多盒子，所以选择前景分数大于某个阈值的作为盒子，但是阈值高导致召回率低，也就是说，学习模型的前景被匹配为背景。为了避免这个问题，在得到学生模型计算出的前景和背景后，前景直接和伪标签进行对比，背景使用可靠性分数进行加权。</p><p>对于 $L_u$ 的盒子部分，前景得分并没有提供很好的定位信息，也就是说使用得分作为阈值筛选教师提供的盒子伪标签没啥用，那么如何使盒子的定位信息更加可靠呢？论文是这么做的，在教师生成的标签盒子周围附近进行随机采样，再次得到预测的盒子，重复这个过程$N$（实验部分取 10）次得到多个盒子，计算这些盒子的标准差，标准茶大于 0.5 的才视为前景的盒子。</p><p>代码是用 mmdetection 写的，几年前我用过这个东西，暂时不考虑精读代码，这个并不是大众用户的东西，暂时不考虑精读代码。</p><h1 id="半监督语义分割"><a href="#半监督语义分割" class="headerlink" title="半监督语义分割"></a>半监督语义分割</h1><p><img data-src="https://s4.ax1x.com/2022/01/30/HC2xtU.png" alt></p><p>这篇论文的结构和上面两篇论文的结构很像，在这一瞬间仿佛世界线收束了，虽然这个论文没提供代码，但个人感觉这个方法是靠谱的。</p><p>它在语义分割的时候分为有标签样本和弱标签样本，弱标签样本是用别的方法生成的，我没有细看生成的方法。因为我准备在这篇论文的结构上在加一个教师网络，用教师网络生成伪标签，剩下的东西和半监督图像分类差不多了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码用的 <code>segmentation model pytorch</code>，我看了下代码，魔改成半监督的话还是比较简单的，思路有了，代码都好说。会在不久的将来开源程序和结果，预计三月初。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/437754834" target="_blank" rel="noopener">半监督目标检测 MMdetection 实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;寒假开始前还是把在学校里遗留的工作先搞完，所接项目的目标是实现半监督语义分割。既然是半监督，就先来看一下半监督的经典论文，我选了经典的、结构相似的三篇论文。&lt;/p&gt;
&lt;p&gt;第一篇是：NIPS 2017 的 Mean teachers are better role models: Weight-averaged consistency targets improve semi-supervised deep learning results，因为我发现伪标签相关的论文或多或少有它的影子。&lt;/p&gt;
&lt;p&gt;第二篇是：ICCV 2021 的 End-to-End Semi-Supervised Object Detection with Soft Teacher，微软出品的半监督目标检测，质量上还是比较让人相信的，且语义分割也可以借鉴目标检测的东西。&lt;/p&gt;
&lt;p&gt;第三篇是：ECCV 2021 的 Semi-supervised Semantic Segmentation via Strong-weak Dual-branch Network，因为搜半监督语义分割，最新的进展论文就是它了。&lt;/p&gt;
&lt;p&gt;文章最后有代码实现。&lt;del&gt;才发现好久没更新博客了。&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="CV" scheme="https://muyuuuu.github.io/tags/CV/"/>
    
  </entry>
  
</feed>
