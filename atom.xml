<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just for Life.</title>
  
  <subtitle>明月更几时</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muyuuuu.github.io/"/>
  <updated>2022-05-15T15:06:00.555Z</updated>
  <id>https://muyuuuu.github.io/</id>
  
  <author>
    <name>兰铃</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>区间算法问题</title>
    <link href="https://muyuuuu.github.io/2022/05/12/interval-algo/"/>
    <id>https://muyuuuu.github.io/2022/05/12/interval-algo/</id>
    <published>2022-05-12T15:45:46.000Z</published>
    <updated>2022-05-15T15:06:00.555Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>算法继续整理系列之区间问题。这类问题可以总结或者变化为：给定多个区间，求满足覆盖范围的最小相交区间的数量。一般而言都是：题目给定一个乱序的区间。我们需要对区间进行排序调整和统计结果，来满足题目条件。<strong>其中变化的部分只有如何处理相交区间</strong>，因此整理一个通用的算法模板。</p><a id="more"></a><h1 id="区间固定"><a href="#区间固定" class="headerlink" title="区间固定"></a>区间固定</h1><h2 id="986-固定区间的交集"><a href="#986-固定区间的交集" class="headerlink" title="986. 固定区间的交集"></a>986. 固定区间的交集</h2><p>先看一道简单的题目，这个题目中我们不需要对区间进行排序调整，因此相对简单一些。</p><p><img data-src="/2022/05/12/interval-algo/interval1.png" alt></p><p>这个题目很简单，我们只需要按照顺序遍历区间，处理相交部分：</p><ol><li>判断两个区间是否相交，如果不相交，右侧区间靠前的那一组，索引向后移动</li><li>如果相交，取出交集，右侧区间靠前的那一组，索引向后移动</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">intervalIntersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; firstList, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; secondList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; firstList.size() &amp;&amp; j &lt; secondList.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> l1 = firstList[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r1 = firstList[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> l2 = secondList[j][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r2 = secondList[j][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 没有交集</span></span><br><span class="line">            <span class="keyword">if</span> (l1 &gt; r2 || r1 &lt; l2) &#123;</span><br><span class="line">                <span class="comment">// r2 比较小，为了尽快和 l1 相交，需要向后移动</span></span><br><span class="line">                <span class="keyword">if</span> (l1 &gt; r2) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> a = max(l1, l2);</span><br><span class="line">            <span class="keyword">int</span> b = min(r1, r2);</span><br><span class="line">            <span class="comment">// 交集</span></span><br><span class="line">            res.push_back(&#123;a, b&#125;);</span><br><span class="line">            <span class="keyword">if</span> (r2 &gt; r1) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="区间可变"><a href="#区间可变" class="headerlink" title="区间可变"></a>区间可变</h1><p>代表题目：1288 删除覆盖区间，56 合并区间，452 射箭引爆气球，1024 视频拼接 和 435 无重叠区间。</p><h2 id="1288-删除覆盖区间"><a href="#1288-删除覆盖区间" class="headerlink" title="1288. 删除覆盖区间"></a>1288. 删除覆盖区间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[3,6],[2,8]]</span><br><span class="line">输出：2</span><br><span class="line">解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。</span><br></pre></td></tr></table></figure><p>题目意思比较明确，删除大区间覆盖的小区间，那么如何统计被覆盖的区间呢？我们看来看图：</p><p><img data-src="/2022/05/12/interval-algo/cover.png" alt></p><p>如果想统计一个区间覆盖更多的区间，乱序状态下用暴力算法肯定是可以破解的，大不了一个一个统计。但是如果我们对区间排序一下，按照左侧区间升序或者右侧区间降序，问题会简单很多：</p><p><img data-src="/2022/05/12/interval-algo/sort.png" alt></p><p>以按照左侧区间排序为例，排序结果如图 (c) 中所示的三种情况：</p><ul><li>如果是<strong>覆盖的相交情况</strong>，统计数量</li><li>如果<strong>相交的情况</strong>，表示上面区间没有能力覆盖下面的区间了，不再考虑上面的区间，开始往下移动</li><li>如果没有重叠也就是不相交，同样表示上面区间没有能力覆盖下面的区间了，不再考虑上面的区间</li></ul><p>图(a)是按照左侧的区间升序，我们只需要顺序遍历区间，依次判断上面的区间的右侧值是否能覆盖下面的区间的右侧值即可，因为左侧区间已经排好序了，是肯定能覆盖的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> r = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 相交时的处理</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt;= intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有覆盖，向后移动</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.size() - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同理，图(b)是我们按照右侧区间降序排列，此时统计上一个左侧区间能覆盖下一个左侧区间的数量即可，因为右侧区间肯定能覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] == b[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> l = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l = intervals[i][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.size() - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p>至此，leetcode 的第 56 题区间合并也可以轻松写出程序。思路和覆盖是一样的：</p><ul><li>如果上一个区间覆盖了下一个区间，那么合并区间，<strong>也就是相交区间的处理</strong></li><li>如果上一个区间没有覆盖下一个区间，那么从头开始</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> r = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 相交处理，合并</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                l = min(l, intervals[i][<span class="number">0</span>]);</span><br><span class="line">                r = max(r, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不能覆盖，先把之前的结果添加进来</span></span><br><span class="line">                <span class="comment">// 并重新更新区间</span></span><br><span class="line">                res.push_back(&#123;l, r&#125;);</span><br><span class="line">                l = intervals[i][<span class="number">0</span>];</span><br><span class="line">                r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一组没有被添加进来</span></span><br><span class="line">        res.push_back(&#123;l, r&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">10</span>,<span class="number">16</span>],[<span class="number">2</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">12</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：气球可以用<span class="number">2</span>支箭来爆破:</span><br><span class="line">-在x = <span class="number">6</span>处射出箭，击破气球[<span class="number">2</span>,<span class="number">8</span>]和[<span class="number">1</span>,<span class="number">6</span>]。</span><br><span class="line">-在x = <span class="number">11</span>处发射箭，击破气球[<span class="number">10</span>,<span class="number">16</span>]和[<span class="number">7</span>,<span class="number">12</span>]。</span><br></pre></td></tr></table></figure><p>只需要对区间排序，每次<strong>统计相交区间</strong>的交集，直到交集没有重叠时，射箭数量需要加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        sort(points.begin(), points.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> l = points[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> r = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; points[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                l = points[i][<span class="number">0</span>];</span><br><span class="line">                r = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 相交处理，有相交区间，缩小相交区间</span></span><br><span class="line">                l = max(l, points[i][<span class="number">0</span>]);</span><br><span class="line">                r = min(r, points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h2><p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 移除 [<span class="number">1</span>,<span class="number">3</span>] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p>注意，这个题目和之前的题目不太相同，具体体现在<strong>相交时的处理</strong>，而相交分为覆盖和非覆盖：</p><ol><li>如果上一个区间覆盖了下面的区间，说明上面的区间太大了。由于我们要删除最少数量的区间，因此首先考虑删除覆盖更广的区间</li><li>如果上一个区间和下一个区间相交，此时不能像之前的合并、相交一样，直接移动到下一个区间或处抛弃上面的区间。因为区间在排序后，如果上一个区间和第二个区间相交，上一个区间和第三个区间不相交，此时我们要删除第二个区间，而不是上一个和第三个区间。因此，相交时我们应该保留上一个区间。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> r = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 覆盖，往下移动</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt;= intervals[i][<span class="number">0</span>] &amp;&amp; r &gt;= intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">                l = intervals[i][<span class="number">0</span>];</span><br><span class="line">                r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r &gt; intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// 相交，不移动，保留上一个区间</span></span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不相交，往后移动，看看后面有多少相交的要处理</span></span><br><span class="line">                r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a>1024. 视频拼接</h2><p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 time 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, time]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">选中 [0,2], [8,10], [1,9] 这三个片段。</span><br><span class="line">然后，按下面的方案重制比赛片段：</span><br><span class="line">将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。</span><br><span class="line">现在手上的片段为 [0,2] + [2,8] + [8,10]，而这些覆盖了整场比赛 [0, 10]。</span><br></pre></td></tr></table></figure><p>从题面上我们能看出来：在多个片段相交的基础上，我们尽可能选择时间长的片段，这样才能使用的碎片最少。同样，重点就在于：<strong>相交时，我们要选择最长的片段</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; clips, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        sort(clips.begin(), clips.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, i = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从起点开始</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; clips.size() &amp;&amp; clips[i][<span class="number">0</span>] &lt;= l) &#123;</span><br><span class="line">            <span class="comment">// 碎片部分和起点相交，选择片段最长的</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; clips.size() &amp;&amp; clips[i][<span class="number">0</span>] &lt;= l) &#123;</span><br><span class="line">                r = max(clips[i][<span class="number">1</span>], r);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= time)</span><br><span class="line">                <span class="keyword">return</span> cnt;</span><br><span class="line">            <span class="comment">// 最长的片段，是下个片段的起点</span></span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>更像是把 labuladong 上区间的题目整理到了一起，写出自己风格的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法继续整理系列之区间问题。这类问题可以总结或者变化为：给定多个区间，求满足覆盖范围的最小相交区间的数量。一般而言都是：题目给定一个乱序的区间。我们需要对区间进行排序调整和统计结果，来满足题目条件。&lt;strong&gt;其中变化的部分只有如何处理相交区间&lt;/strong&gt;，因此整理一个通用的算法模板。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的 this 和 Python 中的 self</title>
    <link href="https://muyuuuu.github.io/2022/05/12/Cpp-this-and-python-self/"/>
    <id>https://muyuuuu.github.io/2022/05/12/Cpp-this-and-python-self/</id>
    <published>2022-05-12T15:10:54.000Z</published>
    <updated>2022-05-16T15:30:41.823Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前一直好奇 <code>C++</code> 中的 <code>this</code> 和 <code>python</code> 中的 <code>self</code> 到底是什么关系，为什么 <code>C++</code> 要显式的写出来，<code>python</code> 则不需要。顺便深入了解一下 <code>this</code>。</p><a id="more"></a><h2 id="self"><a href="#self" class="headerlink" title="self"></a>self</h2><p><code>python</code> 当对象调用类中的函数的时候，系统会自动把当前对象传入函数，且参数就是第一个 <code>self</code>，不过可以用其他 <code>token</code> 代替 <code>self</code>。因此在定义的时候，需要声明 <code>self</code> 这个参数，调用时，却不需要手动传入对象。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x 接收 12 这个参数</span></span><br><span class="line">A.test(<span class="number">12</span>)</span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># x 接收 a 这个对象</span></span><br><span class="line">a.test()</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(mine, x)</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mine 接收 1，x 接收 12</span></span><br><span class="line">A.test(<span class="number">1</span>, <span class="number">12</span>)</span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># mine 接收 a，x 接收 12</span></span><br><span class="line">a.test(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>对于 <code>C++</code> 而言，每个对象都要操作自己内部的数据，如何知道哪里的数据是自己的内部数据，而不会发生调用对象 <code>A</code>，而修改了对象 <code>B</code> 的数据呢？答案是 <code>this</code> 指针。</p><p><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针，被隐含地声明为: <code>ClassName \*const this</code>，也就是地址不能改变，这意味着不能给 <code>this</code> 指针赋值；在类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）。对象被创建以后才会给 <code>this</code> 赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，且 <code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址。</p><p>当对象调用类中的非静态函数时，自动向它传递一个隐含的 <code>this</code> 指针参数，该参数是一个指向这个成员函数所在的对象的指针，在函数体内作为局部变量，且每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</p><p>总结一下的话就是：</p><ul><li><code>this</code> 是关键字而 <code>self</code> 不是。</li><li><code>C++</code> 类内的函数默认都是给对象调用的，而 <code>python</code> 不是。</li><li><code>python</code> 中的 <code>self</code> 还可以用于声明和创建变量，而 <code>C++</code> 在类中声明和创建则不需要。</li><li>定义、传参和调用中，<code>this</code> 参数始终隐藏，而 <code>self</code> 不是。</li><li>两者有相同点，在类的函数内部可以显式的使用它，来调用类内的变量和函数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直好奇 &lt;code&gt;C++&lt;/code&gt; 中的 &lt;code&gt;this&lt;/code&gt; 和 &lt;code&gt;python&lt;/code&gt; 中的 &lt;code&gt;self&lt;/code&gt; 到底是什么关系，为什么 &lt;code&gt;C++&lt;/code&gt; 要显式的写出来，&lt;code&gt;python&lt;/code&gt; 则不需要。顺便深入了解一下 &lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
      <category term="Python" scheme="https://muyuuuu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的 static</title>
    <link href="https://muyuuuu.github.io/2022/05/12/cpp-static/"/>
    <id>https://muyuuuu.github.io/2022/05/12/cpp-static/</id>
    <published>2022-05-12T13:54:28.000Z</published>
    <updated>2022-05-12T15:53:43.800Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前对 <code>static</code> 的理解仅限于：在类中声明这种类型的变量，可以通过这个变量知道这个类被创建了多少个对象。但是前些日子刷 <code>leetcode</code> 的时候，发现类中自定义的 <code>cmp</code> 函数如果不是 <code>static</code> 类型，就无法被类内的 <code>sort</code> 函数识别。所以今天来一探究竟。</p><a id="more"></a><h1 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h1><p>其实 C 语言中也有 <code>static</code> 这个关键字，在全局区分配内存，或者说可以理解为全局变量，来回顾一下：</p><ol><li>在全局区分配内存，自动初始化为 0，注：全局区就是静态区</li><li>在声明的整个文件是可见的</li><li>不会因子函数的退出而被释放空间，即子函数被执行完成初始化后，之后的调用不会再初始化，但作用域是局部的</li><li>修饰普通函数，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li></ol><p>全局变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    sub_func();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> test;</span><br><span class="line">    test += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无法访问 test</span></span><br><span class="line">    sub_func(); <span class="comment">// 1</span></span><br><span class="line">    sub_func(); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="static-成员变量"><a href="#static-成员变量" class="headerlink" title="static 成员变量"></a>static 成员变量</h2><ol><li>这个类的所有对象都可以访问静态成员变量，一个对象修改，其他对象也会改变。说高级一些，不随对象创建而分配内存，不随对象销毁而释放内存</li><li>存储在全局区</li><li>必须类外初始化</li><li>可以通过类名访问</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">    A()&#123;</span><br><span class="line">        A::num += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 类名访问</span></span><br><span class="line">        A::num += a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类声明的外部初始化</span></span><br><span class="line"><span class="keyword">int</span> A::num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; A::num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">    b.increase(<span class="number">18</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; A::num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><ol><li>静态成员函数仅可以访问静态成员、函数；不能访问非静态成员、函数</li><li>非静态成员函数可以任意访问静态成员、函数</li><li>不需要 <code>this</code> 指针的额外操作</li><li>可以通过类名访问</li></ol><p>来看一个 <code>static</code> 的成员函数，顺便解答本文开始的疑问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">auto</span> <span class="title">get_num</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 错误，不能访问非 static 变量</span></span><br><span class="line">        <span class="comment">// 毕竟全局区不能访问堆栈区</span></span><br><span class="line">        <span class="comment">// return a + A::num;</span></span><br><span class="line">        <span class="keyword">return</span> A::num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不加 static</span></span><br><span class="line">    <span class="comment">// 错误：对非静态成员函数‘bool A::cmp(int&amp;, int&amp;)’的使用无效</span></span><br><span class="line">    <span class="comment">// 因为 sort 这个函数是全局的，找不到类内的 cmp</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(arr.begin(), arr.end(), cmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类声明的外部初始化</span></span><br><span class="line"><span class="keyword">int</span> A::num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    a.sort(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : arr) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title=":: 扩展"></a><code>::</code> 扩展</h2><p>上面写了很多 <code>::</code>，江湖人称范围解析运算符，顺手总结一下：</p><ol><li><code>::variable</code>，全局作用域符，作用域是全局空间，如 <code>::isspace</code></li><li><code>class::variable</code>，某个类的作用域范围</li><li><code>namespace::variable</code>，某个<a href="https://muyuuuu.github.io/2021/06/20/cpp-namespace/">命名空间</a>的作用域范围。重点是，<code>static</code> 声明的链接性为内部静态变量的东西，可以使用未命名的 <code>namespace</code> 代替。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前对 &lt;code&gt;static&lt;/code&gt; 的理解仅限于：在类中声明这种类型的变量，可以通过这个变量知道这个类被创建了多少个对象。但是前些日子刷 &lt;code&gt;leetcode&lt;/code&gt; 的时候，发现类中自定义的 &lt;code&gt;cmp&lt;/code&gt; 函数如果不是 &lt;code&gt;static&lt;/code&gt; 类型，就无法被类内的 &lt;code&gt;sort&lt;/code&gt; 函数识别。所以今天来一探究竟。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>从 python 中的垃圾回收回顾下内存碎片化</title>
    <link href="https://muyuuuu.github.io/2022/05/03/python-gc/"/>
    <id>https://muyuuuu.github.io/2022/05/03/python-gc/</id>
    <published>2022-05-03T15:46:01.000Z</published>
    <updated>2022-05-06T15:18:54.117Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不出意外的话，这应该是 <code>python</code> 复习的最后一部分了，之前写 <code>python</code> 的时候，一般是在实践中积累一些常见的用法而后系统的学习，比如生成器装饰器、高级数据结构、各种工具库乃至 <code>__init__.py</code> 等细节。但 <code>python</code> 帮开发者自动进行了垃圾回收，所以一直没涉足这个领域，今天来了解一下 <code>python</code> 中垃圾回收的三种机制：引用计数、标记清除和分代回收。</p><a id="more"></a><h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><p>引用计数是 <code>python</code> 中默认使用的垃圾回收方法，思想也比较简单，每个对象有一个字段来记录对象被引用的次数，如果对象引用次数是 0，那么这个对象就会被回收并释放空间。优势是想法简单容易实现，能够处理对象创建、引用、传参、被存储至容器等引用计数增加的场景，以及 <code>del</code> 显式删除、对象别名被赋予新对象、离开作用域、容器被销毁等计数器减少的场景。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This Obj Address: &#123;&#125;"</span>.format(id(self)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obj_ref_count</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">"Obj Ref Count: &#123;&#125;"</span>.format(sys.getrefcount(obj)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># create</span></span><br><span class="line">a = Demo()</span><br><span class="line">print(sys.getrefcount(a)) <span class="comment"># output 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create</span></span><br><span class="line">a = Demo()</span><br><span class="line">obj_ref_count(a) <span class="comment"># output 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ref</span></span><br><span class="line">b = a</span><br><span class="line">obj_ref_count(a) <span class="comment"># output 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># change ref</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">obj_ref_count(a) <span class="comment"># output 4</span></span><br></pre></td></tr></table></figure><p>这里的引用次数为 4 是因为创建、函数调用堆栈帧、参数、<code>sys</code> 调用累积得到的，小缺点就是需要开辟额外的空间来维护<del>这仿佛是废话</del>，主要的缺点是不能处理循环引用问题。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> _ctypes</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.child = <span class="literal">None</span></span><br><span class="line">        print(<span class="string">"This Obj Address: &#123;&#125;"</span>.format(id(self)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obj_ref_count</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">"Obj Ref Count: &#123;&#125;"</span>.format(sys.getrefcount(obj)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Loop &#123;&#125;"</span>.format(i + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    a = Demo()</span><br><span class="line">    b = Demo()</span><br><span class="line"></span><br><span class="line">    obj_ref_count(a)</span><br><span class="line">    obj_ref_count(b)</span><br><span class="line"></span><br><span class="line">    a.child = b</span><br><span class="line">    b.child = a</span><br><span class="line"></span><br><span class="line">    obj_ref_count(a)</span><br><span class="line">    obj_ref_count(b)</span><br><span class="line"></span><br><span class="line">    a_addr = id(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> a</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 引用次数为 5，没回收，内存泄漏</span></span><br><span class="line">    a = _ctypes.PyObj_FromPtr(int(a_addr))</span><br><span class="line">    obj_ref_count(a)</span><br></pre></td></tr></table></figure><p>上述的程序存在循环引用问题，如果去掉循环引用的部分，我们会发现每个循环创建对象的地址都是一样的，说明之前的对象经过 <code>del</code> 之后会被回收。而如果增加循环引用的语句，每个循环都会创建新的对象，也就是垃圾没有被回收。</p><h1 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h1><p>标记清除顾名思义，首先给所有的活动对象打上标记，然后清除没有被标记的非活动对象。所以问题转移为：如何判断对象是活动的？</p><p><code>python</code> 中的对象通过引用连接在一起构成一个有向图，对象是图中的节点，引用关系就是有向边。从根对象出发，沿着有向边遍历对象，如果能到达这个节点，那么这个节点就是活动对象，否则就是非活动对象。如下图所示。</p><p><img data-src="https://s1.ax1x.com/2022/05/06/OKT1UK.gif" alt></p><p>这个方法主要来解决前文提到的循环引用问题，也可以扩展到 <code>list</code>、<code>dict</code> 和 <code>tuple</code> 等容器对象，因为数值、字符串等字面常量不会被循环引用。</p><p>虽然能清除循环引用的对象，但是需要扫描整个堆内存，这可能只有一小部分非活动对象。而且当这个算法启动去清除垃圾时，程序会挂起运行，因为这两者显然不能同时执行。</p><h2 id="标记清除与操作系统"><a href="#标记清除与操作系统" class="headerlink" title="标记清除与操作系统"></a>标记清除与操作系统</h2><p>标记清除容易导致内存碎片化。非活动对象可能位于内存的不同位置，当执行这个算法后，这些对象被释放，就导致了内存的不同位置空缺出现外碎片问题，但没有大单位的可用内存。而内存碎片化也是操作系统中的常见问题，导致内存利用率不高。</p><p><img data-src="https://s1.ax1x.com/2022/05/06/OK7kqI.jpg" alt></p><p>既然说到了内存碎片问题，就来回顾一下大三学过的操作系统，一般解决方法有连续分配方案和离散分配方案，对于连续分配方案：</p><ul><li>固定分区，内存划分为固定大小的分区，会面临内碎片问题</li><li>动态分区，包括分区匹配和分区释放，分区匹配一般有最先匹配算法（找到合适分区立刻划分，不容易保留大分区）、最佳适应算法（找到大小最合适的分区，容易形成外碎片）和最差适应算法（避免外碎片，分配最大的分区，不容易保留大分区），分区释放阶段将两个空闲分区合并为一个空闲分区。</li></ul><p>连续分配中内存碎片是不可避免的，为了解决这个问题，一般会进行<strong>紧缩</strong>：将小的内存碎片调整位置，组合成大的可用空间去装载新的进程。因为紧缩会移动内存改变进程的地址，因此这种带有额外开销的操作一般会在特定时期进行，如释放分区后或者新的进程不被满足时。</p><p>离散分配方案，允许进程所在的物理地址空间非连续：</p><ul><li>页式管理，将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，也把内存空间分成与页面相同大小的若干个存储块，称为页框，也同样为它们加以编号。在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的页框中。这种方式消减外部碎片，由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称为页内碎片。虽然仍然有内碎片，但控制了内碎片的大小范围。优势是程序不必连续存放，所需的空间可以动态改变。但是程序需要一次性放入内存；几个子函数位于同一页面时，不利于程序和数据的共享和动态链接。</li><li>段式管理，为了解决共享数据和动态链接的问题，将程序的地址空间按内容或函数关系划分为若干段，每个段是逻辑上完整的程序或数据。将不同的段装入内存的不同位置，就可以支持逻辑共享了。所以通常段长不固定，决定于用户所编写的程序，所以这部分内存可以进行动态分区的管理。</li><li>段页式系统的基本原理是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页。</li></ul><h1 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h1><p><code>python</code> 根据对象的存活时间划分为三个的集合：年轻、中年和老年，新创建的对象位于年轻代，当年轻代的数量到达上限就会触发回收机制，不会被回收的对象会放在中年代中，依次类推，因此老年代是存活最久的对象。</p><p>清除过程是基于前文提到的标记清除算法实现的，这也是上文没写代码举例的原因，也能解释引用计数中，标记清除算法为什么没有清除循环引用的对象。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> _ctypes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obj_ref_count</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">"Obj Ref Count: &#123;&#125;"</span>.format(sys.getrefcount(obj)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.child = <span class="literal">None</span></span><br><span class="line">        print(<span class="string">"This Obj Address: &#123;&#125;"</span>.format(id(self)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gc.enable()</span><br><span class="line"><span class="keyword">assert</span> gc.isenabled() <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    a = Demo()</span><br><span class="line">    b = Demo()</span><br><span class="line"></span><br><span class="line">    a.child = b</span><br><span class="line">    b.child = a</span><br><span class="line"></span><br><span class="line">    a_addr = id(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> a</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2 表示检查 1 2 3 代的对象</span></span><br><span class="line">    <span class="comment"># 回收，并返回不活动对象的数目</span></span><br><span class="line">    print(gc.collect(<span class="number">2</span>)) <span class="comment"># output 4</span></span><br><span class="line">    <span class="comment"># 每代已经回收的数目</span></span><br><span class="line">    print(gc.get_count())</span><br><span class="line"></span><br><span class="line">    tmp = _ctypes.PyObj_FromPtr(int(a_addr))</span><br><span class="line">    obj_ref_count(tmp)</span><br></pre></td></tr></table></figure><p>最后的输出为 4，表示被清除了。<strong>强行使用被删除对象的地址很危险</strong>，不建议这么写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">This Obj Address: 1968923570128</span><br><span class="line">This Obj Address: 1968923570032</span><br><span class="line">4</span><br><span class="line">(1, 0, 0)</span><br><span class="line">Obj Ref Count: 4</span><br><span class="line">This Obj Address: 1968923570128</span><br><span class="line">This Obj Address: 1968923570032</span><br><span class="line">0</span><br><span class="line">(1, 0, 0)</span><br><span class="line">Obj Ref Count: 4</span><br><span class="line">This Obj Address: 1968923569840</span><br><span class="line">This Obj Address: 1968923567488</span><br><span class="line">4</span><br><span class="line">(1, 0, 0)</span><br><span class="line">Obj Ref Count: 4</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.geeksforgeeks.org/mark-and-sweep-garbage-collection-algorithm/" target="_blank" rel="noopener">mark &amp; sweep</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不出意外的话，这应该是 &lt;code&gt;python&lt;/code&gt; 复习的最后一部分了，之前写 &lt;code&gt;python&lt;/code&gt; 的时候，一般是在实践中积累一些常见的用法而后系统的学习，比如生成器装饰器、高级数据结构、各种工具库乃至 &lt;code&gt;__init__.py&lt;/code&gt; 等细节。但 &lt;code&gt;python&lt;/code&gt; 帮开发者自动进行了垃圾回收，所以一直没涉足这个领域，今天来了解一下 &lt;code&gt;python&lt;/code&gt; 中垃圾回收的三种机制：引用计数、标记清除和分代回收。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="https://muyuuuu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>轻量的神经网络</title>
    <link href="https://muyuuuu.github.io/2022/04/30/light-net/"/>
    <id>https://muyuuuu.github.io/2022/04/30/light-net/</id>
    <published>2022-04-30T12:43:59.000Z</published>
    <updated>2022-05-11T14:47:09.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很久之前我觉得移动端应用几百兆的模型不切实际，在不考虑蒸馏、量化等压缩方法下，发现了 MobileNet 设计的很神奇，大小只有几 MB，可以说是一股清流了。就整理发布了一下，然后今天发现找不到了，神奇。（于是顺手和 ShuffleNet 一并整理到轻量化的神经网络中）</p><a id="more"></a><h1 id="MobileNet-V1"><a href="#MobileNet-V1" class="headerlink" title="MobileNet-V1"></a>MobileNet-V1</h1><p>基本上可以说这个版本是后面几个版本的出发点。先来看一下创新点：提出 depthwise separable conv 和 pointwise conv 来降低网络的计算次数。还是直接画图吧：</p><p><img data-src="https://s1.ax1x.com/2022/04/30/OpcCxU.png" alt></p><p>对于传统卷积而言，输入一个三通道的图片，如果想要输出五通道，那么就需要 5 个 $3\times 3 \times 3$ 的卷积核。一般一些，假设传统卷积处理图像的大小是 $D_F\times D_F$，有 $M$ 个通道，卷积核的大小是 $D_K$，输出的通道数数 $N$，那么计算量就是 $D_K \cdot D_K \cdot M \cdot N \cdot D_F \cdot D_F$。</p><p>在得到相同大小输出的情况下，使用 DW 卷积和 PW 卷积来简化一下这个计算过程：</p><p><img data-src="https://s1.ax1x.com/2022/04/30/OpcFr4.png" alt></p><p>如果换成深度可分离卷积和逐点卷积，可以看到达到同样的输出，参数量从 $27\times 5$ 减少到了 $27+15$，而且计算量为 $D_K \cdot D_K \cdot M \cdot D_F \cdot D_F + M \cdot N \cdot D_F \cdot D_F$。两者的比值是 $1/N+1/D_K^2$。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileNetV1</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ch_in, n_classes)</span>:</span></span><br><span class="line">        super(MobileNetV1, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">conv_bn</span><span class="params">(inp, oup, stride)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">                nn.Conv2d(inp, oup, <span class="number">3</span>, stride, <span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">                nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">conv_dw</span><span class="params">(inp, oup, stride)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">                <span class="comment"># dw</span></span><br><span class="line">                <span class="comment"># 输入通道和输出通道相等，groups 表示每个卷积核只处理一个通道</span></span><br><span class="line">                nn.Conv2d(inp, inp, <span class="number">3</span>, stride, <span class="number">1</span>, groups=inp, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(inp),</span><br><span class="line">                nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line"></span><br><span class="line">                <span class="comment"># pw</span></span><br><span class="line">                <span class="comment"># 卷积核大小为 1X1</span></span><br><span class="line">                nn.Conv2d(inp, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">                nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            conv_bn(ch_in, <span class="number">32</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">32</span>, <span class="number">64</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">128</span>, <span class="number">128</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">256</span>, <span class="number">256</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">512</span>, <span class="number">1</span>),</span><br><span class="line">            conv_dw(<span class="number">512</span>, <span class="number">1024</span>, <span class="number">2</span>),</span><br><span class="line">            conv_dw(<span class="number">1024</span>, <span class="number">1024</span>, <span class="number">1</span>),</span><br><span class="line">            nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">        self.fc = nn.Linear(<span class="number">1024</span>, n_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.model(x)</span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">1024</span>)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h1 id="MobileNet-V2"><a href="#MobileNet-V2" class="headerlink" title="MobileNet-V2"></a>MobileNet-V2</h1><p>V1 的思想可以概括为：首先利用 3×3 的深度可分离卷积提取特征，然后利用 1×1 的卷积来扩张通道。但是有人在实际使用的时候，发现训完之后发现 dw 卷积核有不少是空的。</p><p>作者认为这是 ReLU 激活函数导致的。于是做了一个实验，就是对一个 n 维空间中的一个东西乘以矩阵 $T$，而后做 ReLU 运算，然后利用 $T$ 的逆矩阵恢复，对比 ReLU 之后的结果与 Input 的结果相差有多大。作者发现：低维度做 ReLU 运算，很容易造成信息的丢失。而在高维度进行 ReLU 运算的话，信息的丢失则会很少。</p><p>由于卷积本身没有改变通道的能力，来的是多少通道输出就是多少通道。上面又得出低维通道不好的结论，因此使用 PW 卷积升维再降维，这也就形成了 Inverted Residuals 这种结构，因为传统的残差结构和本文相反，传统的是先降维在升维。</p><p>这样高维的仍然使用 ReLU 激活函数，低维的换成线性激活函数。因为有先升维在降维的结构，因此使用了残差连接来提升性能。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvertedResidual</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inp, oup, stride, expand_ratio)</span>:</span></span><br><span class="line">        super(InvertedResidual, self).__init__()</span><br><span class="line">        self.stride = stride</span><br><span class="line">        <span class="keyword">assert</span> stride <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        hidden_dim = int(inp * expand_ratio)</span><br><span class="line">        self.use_res_connect = self.stride == <span class="number">1</span> <span class="keyword">and</span> inp == oup</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> expand_ratio == <span class="number">1</span>:</span><br><span class="line">            self.conv = nn.Sequential(</span><br><span class="line">                <span class="comment"># dw</span></span><br><span class="line">                nn.Conv2d(hidden_dim, hidden_dim, <span class="number">3</span>, stride, <span class="number">1</span>, groups=hidden_dim, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                nn.ReLU6(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># pw-linear</span></span><br><span class="line">                nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv = nn.Sequential(</span><br><span class="line">                <span class="comment"># pw 升维</span></span><br><span class="line">                nn.Conv2d(inp, hidden_dim, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                nn.ReLU6(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># dw 深度可分离卷积</span></span><br><span class="line">                nn.Conv2d(hidden_dim, hidden_dim, <span class="number">3</span>, stride, <span class="number">1</span>, groups=hidden_dim, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                nn.ReLU6(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># pw-linear 激活</span></span><br><span class="line">                nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.use_res_connect:</span><br><span class="line">            <span class="keyword">return</span> x + self.conv(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.conv(x)</span><br></pre></td></tr></table></figure><h1 id="MobileNet-V3"><a href="#MobileNet-V3" class="headerlink" title="MobileNet-V3"></a>MobileNet-V3</h1><p>主要做了两点创新，一个是在 MobileNet V2 残差分支加入了 SE（Squeeze-and-Excitation） 注意力机制的模块，一个是更新了激活函数。SE 注意力就是通过池化得到每个通道的值，并输入到全连接层学习到每个通道的权重，对每个通道的数值进行更新。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SELayer</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, channel, reduction=<span class="number">4</span>)</span>:</span></span><br><span class="line">        super(SELayer, self).__init__()</span><br><span class="line">        self.avg_pool = nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 输入维度和输出维度相同</span></span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(channel, _make_divisible(channel // reduction, <span class="number">8</span>)),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(_make_divisible(channel // reduction, <span class="number">8</span>), channel),</span><br><span class="line">            h_sigmoid()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        b, c, _, _ = x.size()</span><br><span class="line">        y = self.avg_pool(x).view(b, c)</span><br><span class="line">        y = self.fc(y).view(b, c, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># y 是每个通道的权重</span></span><br><span class="line">        <span class="keyword">return</span> x * y</span><br></pre></td></tr></table></figure><p>在重新设计激活函数方面，使用 h-swish 激活函数代替了 swish 激活函数，因为更容易计算。对于 swish 激活函数：</p><p>\begin{equation}<br>    \begin{aligned}<br>        \text{swish} x &amp;= x \cdot \sigma(x) \\<br>        \sigma(x) &amp;= \frac{1}{1+e^{-x}}<br>    \end{aligned}<br>\end{equation}</p><p>这个反向传播和激活的计算过程略显复杂，对量化不够友好。于是使用较为接近的 h-swish 激活函数代替：</p><p>\begin{equation}<br>    \begin{aligned}<br>        \text{h-sigmoid} &amp;= \frac{\text{ReLU6}(x+3)}{6} \\<br>        \text{h-swish} &amp;= x \cdot \text{h-sigmoid}<br>    \end{aligned}<br>\end{equation}</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">h_sigmoid</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inplace=True)</span>:</span></span><br><span class="line">        super(h_sigmoid, self).__init__()</span><br><span class="line">        self.relu = nn.ReLU6(inplace=inplace)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.relu(x + <span class="number">3</span>) / <span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">h_swish</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inplace=True)</span>:</span></span><br><span class="line">        super(h_swish, self).__init__()</span><br><span class="line">        self.sigmoid = h_sigmoid(inplace=inplace)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x * self.sigmoid(x)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvertedResidual</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inp, hidden_dim, oup, kernel_size, stride, use_se, use_hs)</span>:</span></span><br><span class="line">        super(InvertedResidual, self).__init__()</span><br><span class="line">        <span class="keyword">assert</span> stride <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        self.identity = stride == <span class="number">1</span> <span class="keyword">and</span> inp == oup</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> inp == hidden_dim:</span><br><span class="line">            self.conv = nn.Sequential(</span><br><span class="line">                <span class="comment"># dw</span></span><br><span class="line">                nn.Conv2d(hidden_dim, hidden_dim, kernel_size, stride, (kernel_size - <span class="number">1</span>) // <span class="number">2</span>, groups=hidden_dim, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                h_swish() <span class="keyword">if</span> use_hs <span class="keyword">else</span> nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># Squeeze-and-Excite</span></span><br><span class="line">                SELayer(hidden_dim) <span class="keyword">if</span> use_se <span class="keyword">else</span> nn.Identity(),</span><br><span class="line">                <span class="comment"># pw-linear</span></span><br><span class="line">                nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv = nn.Sequential(</span><br><span class="line">                <span class="comment"># pw 升维</span></span><br><span class="line">                nn.Conv2d(inp, hidden_dim, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                h_swish() <span class="keyword">if</span> use_hs <span class="keyword">else</span> nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># dw 提取特征</span></span><br><span class="line">                nn.Conv2d(hidden_dim, hidden_dim, kernel_size, stride, (kernel_size - <span class="number">1</span>) // <span class="number">2</span>, groups=hidden_dim, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                <span class="comment"># Squeeze-and-Excite</span></span><br><span class="line">                SELayer(hidden_dim) <span class="keyword">if</span> use_se <span class="keyword">else</span> nn.Identity(),</span><br><span class="line">                h_swish() <span class="keyword">if</span> use_hs <span class="keyword">else</span> nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># pw-linear 先行激活，降维</span></span><br><span class="line">                nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.identity:</span><br><span class="line">            <span class="keyword">return</span> x + self.conv(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.conv(x)</span><br></pre></td></tr></table></figure><h1 id="ShuffleNet-V1"><a href="#ShuffleNet-V1" class="headerlink" title="ShuffleNet-V1"></a>ShuffleNet-V1</h1><p>group 卷积能有效的减少卷积参数。假设输入图像的大小为 $c_1\times H \times W$，卷积核大小为 $c_1 \times h \times w$，想要得到 $c_2 \times H \times W$ 的输出目标，那么需要的卷积层参数量就是：$c_2 \times c_1 \times h \times w$。</p><p>如果使用 group 卷积，将通道分成 $g$ 组，那么每个输入就是 $c_1/g \times H \times W$，对应的卷积核大小为 $c_1/g \times h \times w$，为了得到同样大小的输出，一组卷积的输出大小就是 $c_2/g \times H \times W$，将 $g$ 组卷积核的输出拼接到一起得到同等大小的输出 $c_2 \times H \times W$，此时的参数量为 $c_2 \times c_1 / g\times h \times w$。</p><p><img data-src="https://s1.ax1x.com/2022/05/02/OFVjDH.jpg" alt></p><ul><li>图 a 中，对于 group 卷积而言，channel 特征只在组内传递</li><li>图 b 中，对 channel 进行打乱，特征在多个 channel 中传递</li></ul><p>综上，使用 group 卷积替换传统卷积，并在 group 卷积后使用 channel shuffle 操作。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">channel_shuffle</span><span class="params">(x, groups)</span>:</span></span><br><span class="line">    batchsize, num_channels, height, width = x.data.size()</span><br><span class="line"></span><br><span class="line">    channels_per_group = num_channels // groups</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># reshape</span></span><br><span class="line">    x = x.view(batchsize, groups, </span><br><span class="line">        channels_per_group, height, width)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通道那个矩阵发生了转置</span></span><br><span class="line">    <span class="comment"># - contiguous() required if transpose() is used before view()</span></span><br><span class="line">    x = torch.transpose(x, <span class="number">1</span>, <span class="number">2</span>).contiguous()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># flatten</span></span><br><span class="line">    x = x.view(batchsize, <span class="number">-1</span>, height, width)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h1 id="ShuffleNet-V2"><a href="#ShuffleNet-V2" class="headerlink" title="ShuffleNet-V2"></a>ShuffleNet-V2</h1><p>在众多影响模型推理速度的因素中，理论计算量只是一部分，额外的还有内存访问（memory access cost, MAC）、平台架构和并行等级；而 数据 IO、逐元素运算也会占用时间。因此作者给出了设计轻量网络的四条准则和实验验证：</p><p>\begin{equation}<br>    \begin{aligned}<br>        \text{MAC} &amp;= hw(c_1+c_2)+c_1c_2 \\<br>        { } &amp; \geq 2hw\sqrt{c_1c_2}+c_1c_2\\<br>        { } &amp; \geq 2\sqrt{hwB} + \frac{B}{hw}\\<br>        B &amp;= hwc_1c_2 (\text{FLOPs})<br>    \end{aligned}<br>\end{equation}</p><ol><li>如上的 MAC 计算中，可以发现当 $c_1=c_2$ 的时候取等号。也就是当卷积的输入和输出 channel 相等时，内存访问代价最低，因此尽可能使通道不变</li></ol><p>\begin{equation}<br>    \begin{aligned}<br>        \text{Group-MAC} &amp;= hw(c_1+c_2)+c_1c_2/g \\<br>        { } &amp;=hwc_1 + \frac{Bg}{c_1} + \frac{B}{hw}\\<br>        B &amp;= hwc_1c_2/g (\text{FLOPs})<br>    \end{aligned}<br>\end{equation}</p><ol><li>在 Group-MAC 计算中，因为其他是定植，那么大小取决于 $g$，因此分组卷积分的越多时，内存访问代价会增大</li><li>网络的碎片化程度越高（分支越多的意思），速度越慢。对于 GPU 的并行计算不友好，而且涉及不同分支的同步问题</li><li>逐元素相加也会带来不可忽视的开销，如 relu，残差的 add 运算</li></ol><p><img data-src="https://s1.ax1x.com/2022/05/02/OFVXKe.jpg" alt></p><p>图左侧的 a（stride=1） 和 b（stride=2） 是 ShuffleNetV1 的结构，右侧的 c（stride=1） 和 d（stride=2） 是 ShuffleNetV2 的结构。</p><p>图 c 中，为了减少碎片化，在 c 中取消了左侧分支没有运算，右侧分支满足第一个准则，而最开始的 channel split 到最后的 concat，再次满足第一个准则，不选择 add 操作满足第 4 个准则。只对右侧的分支进行 relu 激活，并取消最终输出的 relu，满足第 4 个准则。而 concat，channel shuffle 和下一层输入的 channel split 可以合并为一个逐元素操作，不得不说太细了。</p><p>然后 ShuffleNetV2+ 在借鉴 MobileNetV3 的想法，也使用了 h-swish 激活函数和 SE 注意力机制，结果上超过了 MobileNetV3，这一部分可以在旷视的 github 上找到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久之前我觉得移动端应用几百兆的模型不切实际，在不考虑蒸馏、量化等压缩方法下，发现了 MobileNet 设计的很神奇，大小只有几 MB，可以说是一股清流了。就整理发布了一下，然后今天发现找不到了，神奇。（于是顺手和 ShuffleNet 一并整理到轻量化的神经网络中）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>IoU Loss 系列</title>
    <link href="https://muyuuuu.github.io/2022/04/23/iou-loss/"/>
    <id>https://muyuuuu.github.io/2022/04/23/iou-loss/</id>
    <published>2022-04-23T15:41:49.000Z</published>
    <updated>2022-04-23T16:10:34.410Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在之前 <a href="https://muyuuuu.github.io/2022/02/26/yolox/">yolox 解析与改进</a> 的文章中，提到了使用 CIoU Loss 改进 SimOTA 分配正样本机制导致的小目标检测精度低的问题，就顺手来整理一些常用定位损失与演化过程。本文所有的图，绿色为 Truth，蓝色为预测结果。</p><a id="more"></a><h1 id="IoU-Loss"><a href="#IoU-Loss" class="headerlink" title="IoU Loss"></a>IoU Loss</h1><p>这个是最常见的定位 loss，假设预测框为 $A$，目标框为 $B$，那么 IoU Loss 就是：</p><p>\begin{equation}<br>L = 1 - \frac{A\cap B}{A \cup B}<br>\end{equation}</p><p>同样这个 loss 会带来一些问题：</p><ul><li>当 $A$ 和 $B$ 没有交集的时候，损失恒定为 1</li><li>当 $A\cap B$ 为定值时，直观上某些相交情况并不好</li></ul><p><img data-src="https://s1.ax1x.com/2022/04/24/LhMPDx.png" alt></p><h1 id="GIoU-Loss"><a href="#GIoU-Loss" class="headerlink" title="GIoU Loss"></a>GIoU Loss</h1><p>为了缓解 $A$ 和 $B$ 没有交集的时候，损失恒定为 1 的缺陷，GIoU Loss 的表示如下：</p><p>\begin{equation}<br>L = 1 - IoU + \frac{A_c - U}{A_c}<br>\end{equation}</p><p>$A_c$ 是包含预测结果和真实标注数据的最小覆盖矩形。当最小覆盖矩形越小，损失也就越小。但是实际使用中这个损失的表现可能不是很好，因为目标检测都会有样本匹配机制，根据 IoU 匹配筛选出来的正样本至少能和真实标注相交。</p><h1 id="DIoU-Loss"><a href="#DIoU-Loss" class="headerlink" title="DIoU Loss"></a>DIoU Loss</h1><p>为了解决上述的 $A\cap B$ 为定值时，直观上某些相交情况并不好的缺陷，或者说，期望使预测结果落在真实数据的中心位置：</p><p>\begin{equation}<br>L = 1 - IoU + \frac{\rho^2 (b, b^{gt})}{c^2}<br>\end{equation}</p><p>其中 $\rho$ 是预测结果中心点和真实框中心点的距离，$c$ 是最小闭包区域对角线的长度。</p><h1 id="CIoU-Loss"><a href="#CIoU-Loss" class="headerlink" title="CIoU Loss"></a>CIoU Loss</h1><p>在目标检测中，目标常常有着不同的尺寸，如下图所示，在 IoU 取值固定的情况下，右侧的预测结果更符合目标框的尺寸。</p><p><img data-src="https://s1.ax1x.com/2022/04/24/LhME5D.png" alt></p><p>因此做了如下的修改：</p><p>\begin{equation}<br>    \begin{aligned}<br>        L &amp;= 1 - IoU + \frac{\rho^2 (b, b^{gt})}{c^2} + \alpha v \\<br>        \alpha &amp;= \frac{v}{(1-IoU) + v} \\<br>        v &amp;= \frac{4}{\pi^2} \bigl( arc \tan \frac{w^{gt}}{h^{gt}} - arc \tan \frac{w}{h} \bigr) \\<br>    \end{aligned}<br>\end{equation}</p><p>如果 IoU 越大，那么 $\alpha$ 也会越大，公式的最后一项也会越大。由于 $arc \tan$ 的取值范围是 -1 到 1，且当 $x$ 较为接近时，$y$ 也接近，那么就期望两者的长宽比越来越接近。</p><h1 id="alpha-IoU-Loss"><a href="#alpha-IoU-Loss" class="headerlink" title="$\alpha-IoU$ Loss"></a>$\alpha-IoU$ Loss</h1><p>$\alpha-IoU$ Loss 是在之前的一些列 IoU Loss 上进行的修改，增加了 $\alpha$ 这个指数，实验显示 $\alpha=3$ 比较有效。</p><p><img data-src="https://s1.ax1x.com/2022/04/24/LhMKKI.png" alt></p><p>以简单的 IoU Loss 来可视化一下这是为什么。我们可视化一下 IoU Loss 和 $\alpha-IoU$ Loss ，得到如下的图：</p><p><img data-src="https://s1.ax1x.com/2022/04/24/LhMQqP.png" alt></p><p>在 $x=0.5$ 之后，$\alpha-IoU$ 显示收敛的梯度更大。因为目标检测会根据 IoU 为预测结果分配真实框，因此不用太担心 IoU 很小的情况，当然这一部分可以手动修改。</p><h1 id="L1-L2-Smooth-L1-Loss"><a href="#L1-L2-Smooth-L1-Loss" class="headerlink" title="L1, L2, Smooth-L1 Loss"></a>L1, L2, Smooth-L1 Loss</h1><p>这个 loss 的形式比较简洁：</p><p>\begin{equation}<br>L = |x-y|<br>\end{equation}</p><p>也就是预测坐标和目标坐标相减的绝对值。而 L2 loss 的形式则是预测值和目标值差的平方：</p><p>\begin{equation}<br>L = (x-y)^2<br>\end{equation}</p><p>如下图所示：</p><p><img data-src="https://s1.ax1x.com/2022/04/24/LhM8IS.png" alt></p><ul><li>对于 L1 loss，在 -1 左侧和 1 的右侧收敛稳定，但是 -1 到 1 之间表示目标很接近了，应该减缓梯度</li><li>对于 L2 loss，在 -1 左侧和 1 的右侧呈现爆炸增长，存在梯度爆炸、异常值敏感的缺陷，但是 -1 到 1 之间梯度较为缓和</li></ul><p>而 Smooth Loss 综合了两者的优点，得到新的表达形式：</p><p>\begin{equation}<br>    L(x) =<br>    \begin{cases}<br>        0.5x^2 &amp;, |x| \leq 1 \\<br>        |x|-0.5 &amp;, \text{otherwise} \\<br>    \end{cases}<br>\end{equation}</p><p><img data-src="https://s1.ax1x.com/2022/04/24/LhMdrq.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前 &lt;a href=&quot;https://muyuuuu.github.io/2022/02/26/yolox/&quot;&gt;yolox 解析与改进&lt;/a&gt; 的文章中，提到了使用 CIoU Loss 改进 SimOTA 分配正样本机制导致的小目标检测精度低的问题，就顺手来整理一些常用定位损失与演化过程。本文所有的图，绿色为 Truth，蓝色为预测结果。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="CV" scheme="https://muyuuuu.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>计算器问题</title>
    <link href="https://muyuuuu.github.io/2022/04/13/calculator/"/>
    <id>https://muyuuuu.github.io/2022/04/13/calculator/</id>
    <published>2022-04-13T11:56:58.000Z</published>
    <updated>2022-04-13T12:32:33.704Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算器问题大约在大二数据结构的课程上学过，当时是使用栈来解决，此外还需要设置很多符号的优先级，以此判断是否弹栈，代码写的很长很麻烦。今天又遇到了这种题，也有了简单的解法，做一个整理。</p><a id="more"></a><p>计算器的难点在于先算乘除后算加减，如果有小括号，需要先算括号里面的内容。因此从简往难，一点点的来看问题如何解决。</p><h2 id="无括号"><a href="#无括号" class="headerlink" title="无括号"></a>无括号</h2><p>无括号相对简单一些，我们只需要考虑先算乘除后算加减即可。那么思路就是：如果当前符号是加法或减法，那么将符号连带数字压入栈中，比如 +10 或 -11；如果遇到的是乘法或除法，那么就需要把栈尾的元素拿出来，做乘法或除法运算在放入栈中。最后，对栈内的元素求和即可。</p><p>我们来看程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> subcal(s, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subcal</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span>&amp; idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                num = <span class="number">10</span> * num + (c - <span class="string">'0'</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">' '</span> || i == s.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sign == <span class="string">'+'</span>) &#123;</span><br><span class="line">                    stk.push(num);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'-'</span>) &#123;</span><br><span class="line">                    stk.push(-num);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(tmp * num);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'/'</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(tmp / num);</span><br><span class="line">                &#125;</span><br><span class="line">                sign = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (stk.size()) &#123;</span><br><span class="line">            res += stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>程序中有很多的细节，一点点来分析：</p><ul><li><code>sign</code> 初始值为 <code>+</code>，这样如果开头的数字是正数，那么这个数会被放入栈中；如果开头的数字是负数，那么栈中先放入 0，在放入负数，不影响。</li><li>符号 <code>c</code> 的判断不构成 if-else-if 关系，因为当 <code>i=s.size()-1</code> 的时候，需要处理最后一个数字。即，<code>c</code> 是数字且是最后一个字符的情况下，需要经过这两个分支的处理。</li></ul><h2 id="有括号"><a href="#有括号" class="headerlink" title="有括号"></a>有括号</h2><p>右括号就比较烦人，因为括号的优先级高于一切，需要找到最内部的括号，逐层往外回退得到答案。而这，也让人容易联想到传说中的递归。</p><p>那么递归需要记录关于括号的哪些东西呢？想法自然是遇到一个左括号，那么就计算括号内部的东西，遇到右括号返回。之后跳过括号里面的内容，计算下一个表达式。括号中的括号也是同理。我们来看程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> subcal(s, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subcal</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span>&amp; idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">                num = <span class="number">10</span> * num + (c - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                num = subcal(s.substr(i+<span class="number">1</span>), idx);</span><br><span class="line">                i += (idx + <span class="number">2</span>);</span><br><span class="line">                c = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">' '</span> || i == s.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sign == <span class="string">'+'</span>)</span><br><span class="line">                    stk.push(num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'-'</span>)</span><br><span class="line">                    stk.push(-num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(num * tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">'/'</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(tmp / num);</span><br><span class="line">                &#125;</span><br><span class="line">                sign = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(stk.size()) &#123;</span><br><span class="line">            res += stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样来解读一下：</p><ul><li>如果遇到右括号，记录索引，表示当前括号的内容计算完了，退出。</li><li>如果遇到左括号，那么计算左括号后面子串的内容得到数字，<code>i=i+(idx+2)</code> 的意思是，跳到右括号后面第一个字符继续计算，+2 为什么是后面第一个字符呢？因为 substr(i+1) 了，这里向后移动了一位，对于 i 来说，+2 才是后面的第一位。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算器问题大约在大二数据结构的课程上学过，当时是使用栈来解决，此外还需要设置很多符号的优先级，以此判断是否弹栈，代码写的很长很麻烦。今天又遇到了这种题，也有了简单的解法，做一个整理。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>遥感图像分割，类别不平衡损失为何失效了？</title>
    <link href="https://muyuuuu.github.io/2022/04/04/deal-unbalance-label/"/>
    <id>https://muyuuuu.github.io/2022/04/04/deal-unbalance-label/</id>
    <published>2022-04-04T11:54:49.000Z</published>
    <updated>2022-05-11T14:10:00.372Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>去年寒假接到了一个遥感图像语义分割的任务，存在着严重的类别不平衡问题。当时想着使用经典的类别不平衡损失 focal loss 和 dice loss 解决一下，但是效果不升反降，甚至不如传统的交叉熵损失函数。</p><p>而且我在 github 上搜类似的项目，也都不推荐使用这些 loss。但是在 mmseg 的文档中，我们又发现 dice loss 有明显的提升，来冷静分析一下这是为什么。本文默认读者了解 focal loss 和 dice loss，因此不会对损失函数进行讲解。</p><a id="more"></a><p>其实我也不是第一次遇到这种经典损失函数失效的现象，之前 triplet loss 也频频失效，一度上了我的黑名单。关于 trilet loss 何时失效以及为什么 and 如何解决，可以参考之前的文章，<a href="https://muyuuuu.github.io/2022/03/24/E-commerce-Search-Recall/">如何更好的提取文本表示</a>。但是我们需要知道的是，失效分两种情况，一种是实现错误，一种是不适用于当前场景。</p><h1 id="focal-loss"><a href="#focal-loss" class="headerlink" title="focal loss"></a>focal loss</h1><p>focal loss 是目标检测领域中很经典的存在，focal loss 和 retinanet 发在同一篇论文，我看源程序，<strong>发现在实现上有一些小细节是网上常见博客不曾提及的</strong>。我们知道基于 anchor 生成检测框时，会有大量的无效检测框，这些框和真实目标毫不相交，这就导致了样本不平衡的问题。而 focal loss 的解决方案也是简单粗暴，使用 $\alpha$ 控制正负样本不平衡问题，使用 $\gamma$ 控制难易样本的区分。</p><p>在实现中，作者将与真实目标框 IoU 大于 0.5 的视为正样本，IoU 小于 0.4 的视为负样本，还有介于两者之间模棱两可的模糊样本。将所有的预测结果和真实标签计算损失，我们希望正样本的分类结果接近 1，其余样本接近 0，因此有严重的类别不平衡问题，于是使用了 focal loss 进行缓解。但是在反向传播的时候，<strong>并不是所有预测结果都要反向传播</strong>，而是对损失进行筛选，只回传正样本部分的损失，其余损失不考虑。</p><p>不然那么多负样本在那里，假设有 10000 个预测结果，只有 10 个真实目标，我就算输出 10000 个 0 损失也不会低，但是检测不到目标，俗称模型坍塌。因此源程序中做了这样的处理。</p><p>那么为什么语义分割的时候失效了呢？看完程序我大概给出我的猜测（目前实在没有精力做消融实验），我看了一些语义分割经典仓库中 focal loss 的实现，发现了一个问题。假设分割时的图像大小是 $512\times 512$，那么这就有将近 27 万个预测结果，遗憾的是，这些全部参与了反向传播。尤其是遥感领域的图像分割，目标区域小，背景占据大部分面积，前景目标的面积占比很小时，这就导致了模型坍塌的问题：模型把所有像素点预测为背景，损失不低，但结果无效。</p><p>因此，一个简单的解决方案就是：像 retinanet 一样，并不是所有的预测结果都参与反向传播。只需按照真实标签，只选择前景区域所在位置的损失，而忽略掉大部分背景区域的损失。而我遇到的原因也是这样，smp 的实现是全部反向传播，<del>提交个 PR 吧</del>。而 mmseg 的实现则是取消其他类别的影响。</p><h2 id="focal-程序实现"><a href="#focal-程序实现" class="headerlink" title="focal 程序实现"></a>focal 程序实现</h2><ul><li><a href="https://github.com/yhenon/pytorch-retinanet/blob/master/retinanet/losses.py#L120-L123" target="_blank" rel="noopener">retinanet 实现</a></li><li><a href="https://github.com/qubvel/segmentation_models.pytorch/blob/master/segmentation_models_pytorch/losses/_functional.py#L70-L96" target="_blank" rel="noopener">smp 实现，没有处理</a></li><li><a href="https://github.com/open-mmlab/mmcv/blob/master/mmcv/ops/csrc/common/cuda/sigmoid_focal_loss_cuda_kernel.cuh#L32-L33" target="_blank" rel="noopener">mmseg 实现</a></li></ul><h1 id="dice-loss"><a href="#dice-loss" class="headerlink" title="dice loss"></a>dice loss</h1><p>dice loss 很神奇，可以说是为语义分割而诞生的。因为交叉熵定义的是分类损失，评估衡量结果时却用 mIoU，也就是优化目标和期望目标不一致，所以 dice loss 以类似 IoU 损失的想法优化目标。dice loss 的一个形式如下：</p><p>\begin{equation}<br>L=1-\frac{2I+\epsilon}{U+\epsilon}<br>\end{equation}</p><p>$I$ 表示预测结果和真实标签的交集，$U$ 表示两者的并集。而程序实现也非常简单，交集两者求乘积，并集两者求和即可。</p><p>我们以二分类为例，假设模型最后的逻辑输出为 $x$，预测输出 $\hat{y}=\text{sigmoid}(x)$。于是：</p><p>\begin{equation}<br>\hat{y}=\frac{1}{1+e^{-x}} \quad \frac{d\hat{y}}{dx}=\hat{y}(1-\hat{y})<br>\end{equation}</p><p>我们设真实标签为 $t$，那么 dice loss 为：</p><p>\begin{equation}\label{dice}<br>L=1-\frac{2t\hat{y}+\epsilon}{t+\hat{y}+\epsilon}<br>\end{equation}</p><p>对 $\hat{y}$ 求一个偏导：</p><p>\begin{equation}\label{grad}<br>\frac{dL}{d\hat{y}}=-\frac{2t(t+\hat{y}+\epsilon)-2t\hat{y}-\epsilon}{(t+\hat{y}+\epsilon)^2}<br>\end{equation}</p><p>画出这个损失和梯度的图像：</p><p><img data-src="https://s1.ax1x.com/2022/04/05/qOwNPH.png" alt></p><p>这也就解释了为什么 dice 训练损失不稳定的原因，当 $t=0$ 的时候，虽然损失很大，但更新网络时对应的梯度为 0。损失值不稳定还可以理解，但是如果 $\hat{y}$ 预测结果也很小时，梯度会飞升。那为什么推荐和 CE 一起使用呢？看上图就可以知道，$t=0$ 的部分没有梯度。那为什么还是结果十分不好呢？继续往下看。</p><h2 id="dice-loss-与不平衡问题"><a href="#dice-loss-与不平衡问题" class="headerlink" title="dice loss 与不平衡问题"></a>dice loss 与不平衡问题</h2><p>我们可以观察到 dice loss 不管图片有多大，固定大小的正样本的区域计算的 loss 是一样的，对网络起到的监督贡献不会随着图片的大小而变化。而 ce loss 会公平处理正负样本，当出现正样本占比较小时，就会被更多的负样本淹没。</p><p>而 mmseg 给出这两个损失的比例是 1（CE）：3（dice），我也天真的用了这个比例。通过上面的分析，为了平衡样本，这个比例应该是目标面积和背景面积的比值。但是，我的数据集有多个类，每个类的面积占比跨度很大，也就是正负样本的梯度难以平衡，我十分不建议使用这个 loss，真的。</p><h2 id="dice-loss-画图程序"><a href="#dice-loss-画图程序" class="headerlink" title="dice loss 画图程序"></a>dice loss 画图程序</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_y</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial</span><span class="params">(y, t=<span class="number">0</span>)</span>:</span></span><br><span class="line">    f1 = <span class="number">-2</span>*t*(t+y+eps) +<span class="number">2</span>*t*y+eps</span><br><span class="line">    f2 = (t+y+eps) **<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> f1 / f2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">"ggplot"</span>)</span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">12</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-20</span>, <span class="number">20</span>, <span class="number">1000</span>)</span><br><span class="line">y = get_y(x)</span><br><span class="line">y0 = partial_0(y, t=<span class="number">0</span>)</span><br><span class="line">y1 = partial_1(y, t=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ax1.plot(y, y0)</span><br><span class="line">ax1.set_title(<span class="string">r"$t=0$"</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">r"$\hat&#123;y&#125;$"</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">r"Gradient"</span>)</span><br><span class="line"></span><br><span class="line">ax2.plot(y, y1)</span><br><span class="line">ax2.set_title(<span class="string">r"$t=1$"</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">r"$\hat&#123;y&#125;$"</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">r"Gradient"</span>)</span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">"1.png"</span>, bbox_inches=<span class="string">"tight"</span>, dpi=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我使用 mmseg 的 focal loss，结果要比 smp 的 focal loss 好很多，验证了我的猜想。此外需要注意的是，focal loss 能处理类别不平衡和正负样本不平衡，而 dice loss 只能处理正负样本不平衡。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年寒假接到了一个遥感图像语义分割的任务，存在着严重的类别不平衡问题。当时想着使用经典的类别不平衡损失 focal loss 和 dice loss 解决一下，但是效果不升反降，甚至不如传统的交叉熵损失函数。&lt;/p&gt;
&lt;p&gt;而且我在 github 上搜类似的项目，也都不推荐使用这些 loss。但是在 mmseg 的文档中，我们又发现 dice loss 有明显的提升，来冷静分析一下这是为什么。本文默认读者了解 focal loss 和 dice loss，因此不会对损失函数进行讲解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="CV" scheme="https://muyuuuu.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>分治枚举</title>
    <link href="https://muyuuuu.github.io/2022/04/04/divide-conquer-enumerate/"/>
    <id>https://muyuuuu.github.io/2022/04/04/divide-conquer-enumerate/</id>
    <published>2022-04-04T08:36:29.000Z</published>
    <updated>2022-04-04T08:42:55.121Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之后的日子，大概会放缓刷题的脚步进行简单的整理，因为有些题目是有规律的，需要做号总结和整理，不能刷一个忘一个。<strong>今日总结：题目要求返回所有结果，且能找到分界点分解为子问题的，都可以套用分治枚举算法。</strong></p><a id="more"></a><h1 id="分治算法枚举"><a href="#分治算法枚举" class="headerlink" title="分治算法枚举"></a>分治算法枚举</h1><p>众所周知，枚举是个技术活，如何合理的枚举所有结果、避免重复和剪枝，并没有想象的那么简单。而分治枚举就是，通过将原问题分割为多个子问题，多个子问题的解<strong>排列组合</strong>能产生多种答案，我们收集多种答案并返回。</p><p>对于此类问题，我们需要确定三个东西：分界点，递归函数，如何排列组合。这样，给定一个分界点，我们把问题分解为左侧问题和右侧问题，两者答案的组合就是当前分界点对应的所有结果。然后再移动分界点，得到其他所有结果即可。此外，再分割得到子问题并求解时，需要设置 base case 用于退出递归。</p><h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a>96. 不同的二叉搜索树</h2><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。如下的示例，3 个节点能组成 5 种二叉树。</p><p><img data-src="/2022/04/04/divide-conquer-enumerate/1.jpg" alt></p><p>那我们考虑给出那三个东西：</p><ol><li>分界节点，以不同的值作为根节点，遍历所有的情况</li><li>既然有了根节点，就需要构建左子树。定义一个函数，返回某子树对应的情况，也就能得到分界点左子树有多少情况，同理得到右子树的排列组合</li><li>而左子树和右子树的乘积就是当前根节点对应的结果</li></ol><p>我们定义一个函数，函数有两个参数，这两个参数是子树的取值范围，因此，退出递归的 base case 就是子树的左侧值大于右侧值，此时返回 1，因为表示调用者的结果是 1，不能再划分为子问题了。函数的返回值是这种取值范围下，有多少结果。我们写出程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">tmp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        memo = tmp;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[l<span class="number">-1</span>][r<span class="number">-1</span>] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[l<span class="number">-1</span>][r<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = build(l, i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> b = build(i + <span class="number">1</span>, r);</span><br><span class="line">            <span class="comment">// 累积所有的结果</span></span><br><span class="line">            memo[l<span class="number">-1</span>][r<span class="number">-1</span>] += a*b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[l<span class="number">-1</span>][r<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>memo</code> 起到剪枝的效果。</p><h2 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a>95. 不同的二叉搜索树 II</h2><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。如下的示例，3 个节点能组成 5 种二叉树。</p><p><img data-src="/2022/04/04/divide-conquer-enumerate/1.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br></pre></td></tr></table></figure><p>同上一题，既然要给出所有的子树结果，那么此时就不需要计数，而是需要创建子树。同样以根节点的取值为分界点，统计出所有可能的左子树，统计出所有可能的右子树，上一题为结果相加，那么这个题目需要对左右子树的结果进行排列组合。因为这题不会超时，因此没有设置剪枝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> leftTree = build(l, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> rightTree = build(i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 创建子树，等价于上一题的相加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : leftTree) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> b : rightTree) &#123;</span><br><span class="line">                TreeNode* node = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                node-&gt;left = a;</span><br><span class="line">                node-&gt;right = b;</span><br><span class="line">                res.emplace_back(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="241-为运算表达式设计优先级"><a href="#241-为运算表达式设计优先级" class="headerlink" title="241. 为运算表达式设计优先级"></a>241. 为运算表达式设计优先级</h2><p>给你一个由数字和运算符组成的字符串 expession ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = &quot;2*3-4*5&quot;</span><br><span class="line">输出：[-34,-14,-10,-10,10]</span><br><span class="line">解释：</span><br><span class="line">(2*(3-(4*5))) = -34 </span><br><span class="line">((2*3)-(4*5)) = -14 </span><br><span class="line">((2*(3-4))*5) = -10 </span><br><span class="line">(2*((3-4)*5)) = -10 </span><br><span class="line">(((2*3)-4)*5) = 10</span><br></pre></td></tr></table></figure><p>最开始我以为这是回溯，后来发现不是，因此总结出一个规律：<strong>题目要求返回所有结果，且能找到分界点分解为子问题的，都可以套用分治枚举算法</strong>。对于这个题而言，运算符就是分界点，然后枚举左侧和右侧有几种结果即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(<span class="built_in">string</span> expression)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expression[i] == <span class="string">'-'</span> || expression[i] == <span class="string">'*'</span> || expression[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            <span class="comment">// 分治，左侧有几种结果</span></span><br><span class="line">            <span class="keyword">auto</span> res1 = diffWaysToCompute(expression.substr(<span class="number">0</span>, i));</span><br><span class="line">            <span class="keyword">auto</span> res2 = diffWaysToCompute(expression.substr(i + <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 枚举所有结果，并追加，和第一题的 += 一样</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it1 : res1) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it2 : res2) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (expression[i] == <span class="string">'-'</span>)</span><br><span class="line">                        res.push_back(it1 - it2);</span><br><span class="line">                    <span class="keyword">if</span> (expression[i] == <span class="string">'+'</span>)</span><br><span class="line">                        res.push_back(it1 + it2);</span><br><span class="line">                    <span class="keyword">if</span> (expression[i] == <span class="string">'*'</span>)</span><br><span class="line">                        res.push_back(it1 * it2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;stoi(expression)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之后的日子，大概会放缓刷题的脚步进行简单的整理，因为有些题目是有规律的，需要做号总结和整理，不能刷一个忘一个。&lt;strong&gt;今日总结：题目要求返回所有结果，且能找到分界点分解为子问题的，都可以套用分治枚举算法。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DataStructure" scheme="https://muyuuuu.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>什么是 bert</title>
    <link href="https://muyuuuu.github.io/2022/03/28/bert/"/>
    <id>https://muyuuuu.github.io/2022/03/28/bert/</id>
    <published>2022-03-28T14:16:12.000Z</published>
    <updated>2022-04-30T12:38:24.567Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>书接上文，因为参加 NLP 的比赛不知道什么是 bert 实在有点说不过去，于是花了三天时间看了下 bert 的基本概念和代码。不得不说，网上阳间的 bert 预训练代码太少了，大多是转载，mark 甚至文不对题之类没啥用的东西，但占据了搜索引擎的首页的热度，像无耻的营销号一样。</p><a id="more"></a><h1 id="从-transformer-开始"><a href="#从-transformer-开始" class="headerlink" title="从 transformer 开始"></a>从 transformer 开始</h1><p>这个就不得不提一下 Attention is all your need. 由于处理序列的时候 RNN 不容易并行化，输出 $b_4$ 的时候需要输入 $a_1, a_2, a_3, a_4$。所以就象使用 CNN 来代替 RNN，一个 CNN 按顺序划过序列输入产生一个输出，那么就不用看完一个句子才会有输出，因为先算后面和先算前面得到的结果是一样的，这样就可以并行化。而多个 CNN 就可以产生多个输出，能提升模型的表达能力。如下图所示，同颜色之前可以并行化，不同颜色之间也可以并行化。不需要等待红色的输出算完，再算黄色的输出。</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1mct.jpg" alt></p><p>如果考虑让一个 CNN 看到更多的输入，那么只需要在模型的隐层叠加另外的 CNN 即可，也就是上图的蓝色三角。基于这个概念，就有了后面的 self-attention。</p><h2 id="self-attention"><a href="#self-attention" class="headerlink" title="self-attention"></a>self-attention</h2><p>attention 本质上是一些矩阵乘法，$A=Wx, Q=W_qA, K=W_kA, V=W_vA$，这里其实就是乘以一个大矩阵，只不过图里分开写清楚一些。</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1Y3n.png" alt></p><p>之后每个 $q^i$ 和每个 $k^i$ 做 attention，也就是内积，得到如下的 $\alpha$ 输出，然后再除以维度数，防止维度过高导致的内积过大。</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1auV.png" alt></p><p>然后将 $\alpha$ 经过 softmax 操作得到 $\hat{\alpha}$：</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1wHU.png" alt></p><p>对于 $b_1$ 输出，只需要让 $\hat{\alpha_{1,i}}$ 和所有的 $v_i$ 做乘积并求和即可。同理，可以得到 $b_2,b_3,b_4$ 的输出。</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1DN4.png" alt></p><p>对应的，下图左上角就是我们的 self-attention 层，其中的运算可以总结成矩阵乘法：</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1r4J.png" alt></p><h3 id="multi-head-self-attention"><a href="#multi-head-self-attention" class="headerlink" title="multi-head-self-attention"></a>multi-head-self-attention</h3><p>多注意力头机制，可以在计算 $Q,K,V$ 的时候产生多个结果，然后在输出 $b$ 的时候再通过一个矩阵将多个结果融合成一个。而我看的程序，就是将矩阵 $Q,K,V$ 分开，计算完最后 view 到一起。</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1Ru6.png" alt></p><h3 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional Encoding"></a>Positional Encoding</h3><p>现在的 self-attention 没有考虑到序列的位置信息，而是使用全局信息，不能利用单词的顺序信息，而这部分信息对于 NLP 来说非常重要，所以需要加入位置的 embedding。人工设定每一个位置的 embedding，和 $A$ 加在一起作为新的 $A$ 参与后面的运算，等价于在 $X$ 拼接一个 one-hot 向量后再做运算：</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1fHO.png" alt></p><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>网上最常见的图就是它了，在看完理论后还是由些许的疑惑之处，比如位置编码如何实现，比如注意力机制具体如何执行，只能看代码来解决。</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs178A.png" alt></p><h2 id="MultiHeadAttention"><a href="#MultiHeadAttention" class="headerlink" title="MultiHeadAttention"></a>MultiHeadAttention</h2><ol><li>在这个类的初始化阶段，首先初始化 $W_Q,W_K,W_V$ 三个全连接层，输入维度和输出维度保持一致。假设输入维度是 512，有 8 个头；</li><li>计算 $Q,K,V$，大小是 <code>B, L, 8, 64</code>，毕竟有 8 个头。在 softmax 之后经过 0.1 的 dropout，最后在把这 8 个头 view 到一起，加上最开始的 $Q$</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiHeadAttention</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">''' Multi-Head Attention module '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_head, d_model, d_k, d_v, dropout=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">        self.n_head = n_head</span><br><span class="line">        self.d_k = d_k</span><br><span class="line">        self.d_v = d_v</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输出维度是之前的 8 倍，也就是 8 个头</span></span><br><span class="line">        self.w_qs = nn.Linear(d_model, n_head * d_k, bias=<span class="literal">False</span>)</span><br><span class="line">        self.w_ks = nn.Linear(d_model, n_head * d_k, bias=<span class="literal">False</span>)</span><br><span class="line">        self.w_vs = nn.Linear(d_model, n_head * d_v, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 最后的输出维度保持不变</span></span><br><span class="line">        self.fc = nn.Linear(n_head * d_v, d_model, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        self.attention = ScaledDotProductAttention(temperature=d_k ** <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line">        self.layer_norm = nn.LayerNorm(d_model, eps=<span class="number">1e-6</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, q, k, v, mask=None)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单个 k v 的输出维度，头的数量</span></span><br><span class="line">        d_k, d_v, n_head = self.d_k, self.d_v, self.n_head</span><br><span class="line">        sz_b, len_q, len_k, len_v = q.size(<span class="number">0</span>), q.size(<span class="number">1</span>), k.size(<span class="number">1</span>), v.size(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        residual = q</span><br><span class="line"></span><br><span class="line">        <span class="comment">#  batch x len_q x (n_head * dv) -&gt; batch x len_q x n_head x dv</span></span><br><span class="line">        q = self.w_qs(q).view(sz_b, len_q, n_head, d_k)</span><br><span class="line">        k = self.w_ks(k).view(sz_b, len_k, n_head, d_k)</span><br><span class="line">        v = self.w_vs(v).view(sz_b, len_v, n_head, d_v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Transpose for attention dot product: b x n x lq x dv</span></span><br><span class="line">        q, k, v = q.transpose(<span class="number">1</span>, <span class="number">2</span>), k.transpose(<span class="number">1</span>, <span class="number">2</span>), v.transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            mask = mask.unsqueeze(<span class="number">1</span>)   <span class="comment"># For head axis broadcasting.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># mask to pad zero</span></span><br><span class="line">        <span class="comment"># q \cdot k and matmul v</span></span><br><span class="line">        q, attn = self.attention(q, k, v, mask=mask)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Transpose to move the head dimension back: b x lq x n x dv</span></span><br><span class="line">        <span class="comment"># Combine the last two dimensions to concatenate all the heads together: b x lq x (n*dv)</span></span><br><span class="line">        q = q.transpose(<span class="number">1</span>, <span class="number">2</span>).contiguous().view(sz_b, len_q, <span class="number">-1</span>)</span><br><span class="line">        q = self.dropout(self.fc(q))</span><br><span class="line">        q += residual</span><br><span class="line"></span><br><span class="line">        q = self.layer_norm(q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q, attn</span><br></pre></td></tr></table></figure><h2 id="PositionalEncoding"><a href="#PositionalEncoding" class="headerlink" title="PositionalEncoding"></a>PositionalEncoding</h2><p>这个就是生成一个 $200\times dim$ 的表，每次输入一个 $x$，查看 $x$ 的维度，从表中取到对应维度的数值，和 $A$ 直接相加。这个表采用的是 sin-cos 规则，使用了 sin 和 cos 函数的线性变换来提供给模型位置信息。</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1HgI.png" alt></p><p>如上图所示，随着维度越来越大，周期变化会越来越慢，而产生一种包含位置信息的纹理。</p><h2 id="Encoder-Layer"><a href="#Encoder-Layer" class="headerlink" title="Encoder Layer"></a>Encoder Layer</h2><ol><li>输入： $x$ 经过 embedding layer 层后得到一个表示，并加上 position embedding 表示向下传播</li><li>经过 dropout 后进入堆叠 6 层的 encoder layer，单个 encode layer 由 multiheadattention 和 PositionwiseFeedForward 组成，后者是简单的全连接与残差结构。</li></ol><h2 id="Decoder-Layer"><a href="#Decoder-Layer" class="headerlink" title="Decoder Layer"></a>Decoder Layer</h2><p>大部分内容和 Encoder Layer 一样，先将 target 经过 embedding layer 之后得到表示，并叠加位置的 embedding 表示向后传播。</p><p>首先计算 target 的自注意力，也就是当前翻译和已经翻译的前文之间的关系；而后将输出视为 $Q$，encoder 的输出视为 $K,V$，再次计算注意力，得到新的解码输出，也就是计算一下当前输出结果和编码的特征向量之间的关系。在拿到 decoder 的输出后，经过一个全连接层，将 dim 映射到 n_vocab。</p><p><img data-src="https://s1.ax1x.com/2022/04/30/OpKlzF.png" alt></p><p>不过这里需要注意的事，为了防止 see the future，decoder 计算 target 的自注意力时需要添加 target mask，就是对角线及其以上的元素都是 0，防止预测当前元素时看到后面的元素。具体来说，真实的句子输入 decoder，经过 embedding 和 position embedding，在自己和自己的注意力矩阵中，对角线及以上的元素全部为 -inf，这样 softmax 之后对角线以上的元素为 0。那么在预测第一个单词时，只能根据 encoder output 的输出，而在预测之后的单词时，可以根据目前预测的结果预测之后的单词。</p><p><img data-src="https://s1.ax1x.com/2022/04/30/OpKboq.png" alt></p><h1 id="bert-程序"><a href="#bert-程序" class="headerlink" title="bert 程序"></a>bert 程序</h1><p>而 bert 的结构就是 transformer 的多个 Encoder 双向堆叠到一起：</p><p><img data-src="https://s1.ax1x.com/2022/04/30/OpKfW8.jpg" alt></p><p>其输入的 embedding 为：</p><p><img data-src="https://s1.ax1x.com/2022/03/28/qs1Xb8.jpg" alt></p><ul><li>Token Embeddings 是词向量，第一个单词是CLS标志，可以用于之后的分类任务，通过 embedding 层实现。如果句子很短，pad 为 0。程序传入的参数是 input_dis，输入到 embedding 层中。</li><li>Segment Embeddings 用来区别两种句子，因为预训练还要做 NSP 任务，同样是 embedding 层。程序传入的参数是 <code>token_type_ids</code>，输入到 embedding 层中。</li><li>Position Embeddings 和之前的 Transformer 不一样，不是三角函数而是学习出来的，非人工设定，而是 embedding 层。输入到 embedding 层中。</li></ul><p>将这三个不同的 embedding 层的输出相加之和作为 encoder 输入，经过 layernorm 和 dropout 后输出。大概理论就是这些，不过它的预训练是真的靠谱，或者说，应用到具体任务，可以针对具体任务设计与训练。借着预训练，解释一下上面的符号，也是困扰我很久的东西。</p><p>之前一直不知道 CLS 这种东西是干什么的，直到看了代码才清楚，这个符号输入网络，bert encoder 输出的所有状态第一个位置的均值或最后一层的第一个位置的输出，经过全连接和激活，得到的输出，所以这个符号对应位置的输出能用于下游分类任务。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BertPooler</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.dense = nn.Linear(config.hidden_size, config.hidden_size)</span><br><span class="line">        self.activation = nn.Tanh()</span><br><span class="line">        self.config = config</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, hidden_states)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param hidden_states:  [src_len, batch_size, hidden_size]</span></span><br><span class="line"><span class="string">        :return: [batch_size, hidden_size]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.config.pooler_type == <span class="string">"first_token_transform"</span>:</span><br><span class="line">            token_tensor = hidden_states[<span class="number">0</span>, :].reshape(<span class="number">-1</span>, self.config.hidden_size)</span><br><span class="line">        <span class="keyword">elif</span> self.config.pooler_type == <span class="string">"all_token_average"</span>:</span><br><span class="line">            token_tensor = torch.mean(hidden_states, dim=<span class="number">0</span>)</span><br><span class="line">        pooled_output = self.dense(token_tensor)  <span class="comment"># [batch_size, hidden_size]</span></span><br><span class="line">        pooled_output = self.activation(pooled_output)</span><br><span class="line">        <span class="keyword">return</span> pooled_output</span><br></pre></td></tr></table></figure><h1 id="MASK"><a href="#MASK" class="headerlink" title="MASK"></a>MASK</h1><p>bert 有效的原因取决于它的预训练，比如 MLM（Mask language model） 和 NSP （Next sentence prediction），而这其中依赖的主要是 mask。</p><h2 id="处理非定长序列"><a href="#处理非定长序列" class="headerlink" title="处理非定长序列"></a>处理非定长序列</h2><p>在NLP中，文本一般是不定长的，所以在进行 batch训练之前，要先进行长度的统一，过长的句子可以通过truncating 截断到固定的长度，过短的句子可以通过 padding 增加到固定的长度，但是 padding 对应的字符只是为了统一长度，并没有实际的价值，因此希望在之后的计算中屏蔽它们，这时候就需要 Mask。此外，self-attention中，$Q$ 和 $K$ 在点积之后，需要先经过 mask 再进行 softmax，因此，对于要屏蔽的部分，mask之后的输出需要为负无穷，这样softmax之后输出才为0。</p><h2 id="辅助预训练"><a href="#辅助预训练" class="headerlink" title="辅助预训练"></a>辅助预训练</h2><p>做 MLM 预训练时，需要对句子进行 mask，使得模型看不到输入句子的单词。而后，其 label 为被 mask 掉单词的 id。由于 bert 本身的结构，由于预训练的时候，需要做 NSP 和 MLM，而 NSP 是二分类任务，MLM 是多分类任务，因此需要在 bert 上插入两个头分别实现这两个功能，前者就是将缺失的词汇预测回去，后者加入一个全连接输入 pooler output，判断句子是否为上下文。</p><h2 id="防止-see-the-future"><a href="#防止-see-the-future" class="headerlink" title="防止 see the future"></a>防止 see the future</h2><p>这个已经在前文说过了，因为循环神经网络是时间驱动的，只有当时刻 $t$ 运算结束了，才能看到 $t+1$ 时刻的词。而 Transformer Decoder 抛弃了 RNN，改为 Self-Attention，由此就产生了一个问题，在训练过程中，整个 ground truth 都暴露在 Decoder 中，这显然是不对的。因此需要加入 mask 来防止预测过程中看到后面的词汇。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/jadore801120/attention-is-all-you-need-pytorch/blob/master/transformer/Models.py" target="_blank" rel="noopener">transformer程序</a></li><li><a href="https://qixinbo.info/2021/11/09/transformer/" target="_blank" rel="noopener">一个不错的transformer博客</a></li><li><a href="https://www.ylkz.life/deeplearning/p10602241/" target="_blank" rel="noopener">月来客栈解析的 bert 源码</a></li><li><a href="https://zhuanlan.zhihu.com/p/139595546" target="_blank" rel="noopener">mask 机制</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书接上文，因为参加 NLP 的比赛不知道什么是 bert 实在有点说不过去，于是花了三天时间看了下 bert 的基本概念和代码。不得不说，网上阳间的 bert 预训练代码太少了，大多是转载，mark 甚至文不对题之类没啥用的东西，但占据了搜索引擎的首页的热度，像无耻的营销号一样。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NLP" scheme="https://muyuuuu.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>电商搜索召回</title>
    <link href="https://muyuuuu.github.io/2022/03/24/E-commerce-Search-Recall/"/>
    <id>https://muyuuuu.github.io/2022/03/24/E-commerce-Search-Recall/</id>
    <published>2022-03-24T03:50:43.000Z</published>
    <updated>2022-05-11T14:08:16.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://s1.ax1x.com/2022/03/24/q806pT.png" alt></p><p>阿里灵杰问天引擎电商搜索算法赛，来详细的记录一下参加这个天池比赛的流程以及我眼中的检索。因为之前从未涉足 NLP 领域，对 NLP 的了解也仅限于大二的时候看完《数学之美》手写过 TF-IDF 算法，我甚至不知道什么是 bert。</p><p>为了防止更多的人踩坑，能愉快的参与进来，于是决定把我的做法和程序分享出来，供参赛选手参考。之前在交流群里大概说了我的做法，私聊我的人我也都告诉了他们大概怎么去做，在那几天看到好多人在排名突飞猛进保送到了 0.2 分左右，甚至超过了我，还是比较开心的。这次做一个系统的分享，我甚至会告诉你怎么做是不对的，也希望你能有更创新的想法。<strong>走过路过给我的 github 点个 star 就行了，孩子要秋招了，这对我比较重要</strong>。（2022年3月20日，0.22的得分排名 21，3月24日，这个得分只能90名，大家太卷了）。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每天坐在电脑面前查方案、读论文、写代码，每天都加班到凌晨，提交了近一周的 0.0X 的成绩，提交这么多成绩意味着我写了更多的代码。可还是排名倒数，提交成绩的时候一度不敢看排行榜。还有很多反向优化的操作，期间写错代码的次数更是数不胜数。单刷比赛确实感觉不容易，尤其是对我这种到处借显卡的人。除了思路出错和程序出错，读论文和尝试代码的速度也不如组队，写完程序满心欢喜，出来结果满眼失望，经历了一周这样的反反复复，还好稳住了心态，坚持了下来。<del>大型诉苦现场。</del></p><p>在 21 年 7 月的时候，接到了某互联网研究院的项目。我这里简化一下，给定一张图片，在数据库中快速的检索出相似的图片。因为对面采用的方法是使用欧式距离一张一张的比对，速度很慢，我表示对这种做法很震惊，从大学随便找个本科生至少也知道不应该这么做。而检索任务可以分为两阶段，第一阶段为特征提取，第二阶段为特征比对。因为当时对面提供了原始数据提取后的特征，于是当时只完成了特征比对任务。</p><p>时隔半年，我又遇到了相同场景的任务，不过此时要解决的是第一阶段，如何将原始数据提取为一个好的表示，也是这个比赛的关键内容。本文从数据、损失、模型等多个方面来阐述一下如何才能 work，以及为什么能 work。</p><h1 id="关于向量索引"><a href="#关于向量索引" class="headerlink" title="关于向量索引"></a>关于向量索引</h1><p>从计算机视觉、自然语言与语音处理，这三大类的搜索与推荐，只要物品能够被向量化表示，就可能会看到向量索引的身影。因为向量索引不是本文的重点，这里就简单略过。可以参考我之前的文章：<a href="https://muyuuuu.github.io/2021/08/04/LSH-consine/">局部敏感哈希算法的C++实现</a>。</p><p>特征检索也叫向量索引，学术上对应的专有名词叫 Approximate Nearest Neighbor Search (ANNS)，即近似最近邻搜索。为什么是近似，而不是我们想要的精确？这就是精度与时间、算力资源的折中，采用了牺牲精度换取时间和空间的方式，从海量的样本中实时获取跟查询最相似的样本。一种高效的向量索引算法，应该满足3个基本条件：</p><ol><li>实时查询，支持海量（百亿、千亿级别）规模库量级的实时查询；</li><li>存储高效，要求构建的向量索引模型数据压缩比高，达到大幅缩减内存使占用的目的；</li><li>召回精度好，top@K有比较好的召回率；</li></ol><p>目前主要的方法有：基于树的索引（KD 树）、基于哈希的索引（局部敏感哈希方法）、矢量量化方法（OPQ）和基于图的索引（HNSW ）等。更多内容可以参考这里：<a href="https://yongyuan.name/blog/vector-ann-search.html" target="_blank" rel="noopener">https://yongyuan.name/blog/vector-ann-search.html</a></p><p>当时通过编写线程池、空间换时间等操作优化了他人开源的局部敏感哈希算法，修复了他人开源线程池存在的 bug，达到了令人满意的速度和精度。</p><h1 id="关于特征提取"><a href="#关于特征提取" class="headerlink" title="关于特征提取"></a>关于特征提取</h1><p>这是一个很经典也很实用的问题，在 2022 年的今天，随着对比学习的发展，特征提取也迎来了新的热度。而 TF-IDF（文本），SIFT（图像）等非深度学习提取特征的方法本文就不谈了。</p><p>如果使用深度学习来提取特征，如果是图像，模型可以使用 resnet 或者 ViT 等成功的模型，如果是本文，那么可以使用他人预训练好的 bert，我比较推荐 hugging face 和 Nezha。因为前些日子看了 CV 领域的自监督论文，随着模型结构越来越简单，改进集中体现在损失函数上，常用的就是 SimCLR 论文中的对比损失，也叫 InfoNCE 损失函数，而好巧不巧，SimCSE 也用的是这个损失函数。因此，详细来讨论一下这些损失函数，<del>我也没有足够的算力去调网络结构</del>。</p><h2 id="简单的优化距离"><a href="#简单的优化距离" class="headerlink" title="简单的优化距离"></a>简单的优化距离</h2><p>一开始我的想法很简单，既然标注了样本对，那么一个样本视为 anchor，人工标注的答案视为 positive，在数据库中随机选取一个视为 negative，当然在这里也可以进行在线难例挖掘，不过这种改进还是要在实现 baseline 之后再进行。</p><p>选择样本后，将提取到的特征进行标准化，优化 anchor 和 positive 的距离，使他们更加接近，使 anchor 和 negative 的距离更远。为了达到这个目标，在叠加一个交叉熵损失。距离可以选择余弦距离或者欧氏距离，我看 github 的开源项目大部分是余弦距离。具体示意图如下所示：</p><p><img data-src="https://s1.ax1x.com/2022/03/24/q8D2w9.png" alt></p><p>我想大部分人最开始的想法都是这样，但是这么做合理嘛？显然不合理。</p><ol><li>因为即使使用随机数，两者的余弦距离也会很高：<br><img data-src="https://s1.ax1x.com/2022/03/24/q8sADe.png" alt></li><li><blockquote><p>负样本对的目标都“过低”了，因为对于“困难样本”来说，虽然语义不同，但依然是“相似”，相似度不至于0甚至-1那么低，如果强行让它们往0、-1学，那么通常的后果就是造成过度学习，从而失去了泛化能力，又或者是优化过于困难，导致根本学不动。这句话引自科学空间。</p></blockquote></li></ol><p>别看这种损失函数差劲，triplet loss 也一样，面临模型坍塌损失持续为零的现象。至少我两次在工程中使用 triplet loss 都出现了这种情况，而 triplet loss 模型坍塌在 ECCV 2020 的一篇论文【Semi-Siamese Training for Shallow Face Learning】中也解释过，出现坍塌的场景均为：样本种类多，但是每类的样本很少。而实际证明，这种方案做出来的特征向量，检索的 MRR@10 指标很低，大概在 0.05 就是极限了。心态爆炸的一周：</p><p><img data-src="https://s1.ax1x.com/2022/03/24/q8yfFs.png" alt></p><h2 id="CoSENT-使用"><a href="#CoSENT-使用" class="headerlink" title="CoSENT 使用"></a>CoSENT 使用</h2><p>顺着这个思路，查到了苏神的 CoSENT，不得不说从思路到代码都很新颖。如果让我总结一下，那么就是只需要让负样本之间的距离比正样本之间的距离更远就好了，远多少让模型去决定。遂有如下的损失函数（以我的使用经验，损失值会收敛到 0.0X 左右，而且很稳定），而且这个损失函数的代码写法也很棒，建议仔细阅读源码。</p><p>\begin{equation}<br>\log \Biggl(1 + \sum_{(i,j)\in \Omega_{pos}, (k,l)\in \Omega_{neg}} e^{\lambda (\cos(x_k, x_l)-\cos(x_i, x_j))}\Biggr)<br>\end{equation}</p><p>在最开始的时候，我设置正样本和负样本的比例为 1：1，效果不怎么好，可以说是负优化。我又读了一些论文，发现公司的模型都有两部分，其中离线的部分数据量大且训练慢，这么做的好处是训练到更多的数据。那么思路来了，我把正负样本调节到 1：10，负样本并不随机选取，而是顺序遍历全部语料库，因为 1:10 的比例可以囊括所有的样本，这种方法训练时常线性增加，毕竟数据量大了，但是效果好了很多。在 3080 卡，batch size = 2 的情况下，训练时间为 36 小时，得分在 0.15 左右。</p><p><img data-src="https://s1.ax1x.com/2022/03/24/q8ct5d.png" alt></p><h2 id="SimCSE"><a href="#SimCSE" class="headerlink" title="SimCSE"></a>SimCSE</h2><p>SimCSE 是做 NLP 的，但是仔细看了它的损失函数，会发现这种对比损失在 CV 领域也是存在的，比如 SimCLR 算法。这篇论文的想法简单却有效：</p><ul><li>如果是无监督，同一个 batch 中，同一个句子经过模型两次会得到不同的结果视为正样本，不同句子视为负样本。使得正样本之间距离近，负样本之间距离远。</li><li>如果是有监督，那么输入三个句子，一个为 anchor，一个为 positive，一个为 negative，使同一个 batch 中，正样本距离近，负样本距离远。正样本只有同一个句子的 anchor 和 positive，负样本包括两部分：anchor 和 negative，当前 anchor 和其他句子的 positive 与 negative。</li></ul><p>因为 SimCSE 支持无监督和有监督训练，那么想法自然也就来了：我看之前的比赛，RMB 玩家为了使得模型更加贴合当前任务的数据集，都要进行 MLM 预训练，但这种方法很耗时间，不适合我这种到处借显卡的人。所以，我用 SimCSE 的无监督方法训练语料库，使得模型贴合当前任务，在这之后，使用标注数据再训练模型来完成任务，岂不完美。个人的参数是，无监督训练 1 个 epoch，有监督训练 5 个 epoch（损失还很大，没有收敛），得分在 0.2 左右，而且 batch 越大，得分越好。</p><p><img data-src="https://s1.ax1x.com/2022/03/24/q82rNQ.png" alt></p><p>那么 SimCSE 和 CoSENT 如此相似，都是不优化距离，为什么 SimCSE 简单有效呢？这得从他们的损失函数说起：</p><ul><li>对于 CoSENT，只让负样本的距离大于正样本的距离，但是：负样本对之间的不同，正样本对之间的不同却没有考虑到，也就是利用的信息少。</li><li>而 SimCSE 却没有这个缺陷，一个 anchor 会计算 batch 中全部句子的距离并 softmax，并经过交叉熵损失，仅仅将与 positive 的距离视为标签 1，其他视为距离 0。也就是说，读取 batch 含有的全部的信息，并抑制除正样本对外其他表示的距离，利用的信息更多。这也就是前文说的，为什么 batch 越大效果越好。</li></ul><h1 id="其他-trick"><a href="#其他-trick" class="headerlink" title="其他 trick"></a>其他 trick</h1><p>数据不做任何形式的预处理，为什么呢？因为 query 来自用户的输入，这里面存在特殊字符、语序错误、错别字等现象很正常，处理掉反而不好。至于 item 则是商品信息，大家逛淘宝也会发现，商品信息的标注文字几乎没有标点符号，而是很多形容词的堆叠，处理掉也不好。比如：优质木制办公室家用卧室可调接高度带灯光插座多功能折叠桌，它是病句吗？是的，但是就是要查找这样的句子，没必要纠错和预处理。（我没有做消融实验，也没有做数据预处理的实验，这一点仅凭个人分析）。</p><p>使用 pool output 而不是 max pool 最后的隐层输出，也许你会问：使用 max pool 捕获最强的特征，也就是捕获句子中最关键的词，只要词匹配对就匹配完成了。但是想一个例子：优质木制办公室家用卧室可调接高度带灯光插座多功能<strong>折叠桌</strong> 和 优质木制办公室家用卧室可调接高度带灯光插座多功能<strong>支架</strong>，如果使用 max pool，模型初始阶段很容易捕捉错关键词，但是 pool output 就不一样了，我是全部的语义表示，哪怕只有一个词不一样，输出的表示也不一样。（这个我做了实验）。</p><p>模型输出的最后经过 normalization（p=2），为什么呢？我们来看个例子：假设 anchor 的表示是 <code>[0.5, 0.8]</code>，positive 的表示是 <code>[0.6, 0.7]</code>，如果计算欧式距离，此时是 0.14。如果我标准化之后，anchor 的表示是 <code>[0.53, 0.85]</code>，positive 的表示是 <code>[0.65, 0.76]</code>，此时的欧氏距离是 0.15。那么有什么用呢？<code>[0.6, 0.7]</code> 和 <code>[0.5, 0.8]</code> 虽然在每一维都很接近，但是维度间的差距却很大，因此 <code>[0.6, 0.7]</code> 并不是很好的表示，需要加大惩罚力度。而 <code>[0.4, 0.9]</code> 这样的 positive 的表示在标准化之后，和 anchor 的距离是 0.14。可见，如果不标准化，那么 <code>[0.4, 0.9]</code> 和 <code>[0.6, 0.7]</code> 等价；如果标准化，<code>[0.6, 0.7]</code> 就不是一个好表示。（这个也做了实验）。</p><p>交互式匹配（我没有尝试）。这个灵感来自于早年间看过的一个<a href="https://github.com/Lanping-Tech/Multi-modal-Valuation-Forecast-System" target="_blank" rel="noopener">多模态项目</a>，这个项目通过评论和股票的时序数据作为两个模态来预测股价，两个模态进行了四不像的 <a href="https://github.com/Lanping-Tech/Multi-modal-Valuation-Forecast-System/blob/main/models/fusion.py#L37-L45" target="_blank" rel="noopener">transformer</a> 操作，我没理解这是为什么，两者进行了注意力的融合，但是取得了不错的结果。我在想，这次任务没办法进行交互式匹配，但我可以在模型的隐层进行这样的注意力融合，并增加一个分类的分支给注意力提供标签。</p><ul><li>Dense Passage Retrieval for Open-Domain Question Answering 这个论文我看了，想法粗暴简洁，和 SimCSE 差不多，但我没算力去尝试。</li><li>SWA（stochastic weight averaging），我查别人的比赛代码看到了它，效果看着不错。而且早年间用 mmdetection 的时候，确实发现模型在最后几个 epoch 涨分很厉害，但是调参不够友好，在最后阶段我会尝试，现阶段不考虑。</li><li>难例挖掘，我觉得付出和收益不成正比，没有尝试。</li><li>以上 trick 可以拿到一个不错的分数，另外其他的 trick 我会在初赛结束后分享，真心太卷了。</li></ul><h1 id="排雷"><a href="#排雷" class="headerlink" title="排雷"></a>排雷</h1><ul><li>双塔结构不要尝试了，即 query 一个全连接，doc 一个全连接，两者共享一个 bert，企图让两者的表示分开不混杂在一起，但效果奇差无比。</li><li>SimCSE 的损失函数在 CV 的自监督领域也有应用，我尝试把 CV 自监督领域最新的损失套用到这里，但结果很难收敛。</li></ul><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p><a href="https://github.com/muyuuuu/E-commerce-Search-Recall" target="_blank" rel="noopener">https://github.com/muyuuuu/E-commerce-Search-Recall</a></p><p>为什么不用 tensorflow？我 17 年 10 月学 tf 的时候，它那个 with session 和 placeholder 我实在理解不了，那会儿才大二，编程功底很差。19 年 4 月再去看的时候，编程风格和语法大改，好像是什么磁带？梯度一会儿有一会儿没有，混乱的api设计导致代码写的晕晕的，而且和 keras 的关系我也没理解。20 年 7 月的时候我又去看，仿佛完全 keras 化，<code>tf.keras</code> 我实在是被震惊到了，编程风格和语法又又又有改动。我怕我学会了它又出现了 <code>tf.torch</code>，20 年 10 月左右入坑 pytorch，API 稳定，用着也很顺手，也就放弃了学 tf。</p><p>不过还是建议各位用 tf，毕竟这个项目最终要落地到工程，这就涉及到部署和性能优化，不是简简单单实现一个算法就可以完美解决所有问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>CoSENT：<a href="https://kexue.fm/archives/8847/comment-page-1" target="_blank" rel="noopener">https://kexue.fm/archives/8847/comment-page-1</a></li><li>Pytorch CoSENT 损失函数：<a href="https://github.com/shawroad/CoSENT_Pytorch" target="_blank" rel="noopener">https://github.com/shawroad/CoSENT_Pytorch</a></li><li>simcse 的有监督和无监督训练：<a href="https://github.com/zhengyanzhao1997/NLP-model/tree/main/model/model/Torch_model/SimCSE-Chinese" target="_blank" rel="noopener">https://github.com/zhengyanzhao1997/NLP-model/tree/main/model/model/Torch_model/SimCSE-Chinese</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2022/03/24/q806pT.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;阿里灵杰问天引擎电商搜索算法赛，来详细的记录一下参加这个天池比赛的流程以及我眼中的检索。因为之前从未涉足 NLP 领域，对 NLP 的了解也仅限于大二的时候看完《数学之美》手写过 TF-IDF 算法，我甚至不知道什么是 bert。&lt;/p&gt;
&lt;p&gt;为了防止更多的人踩坑，能愉快的参与进来，于是决定把我的做法和程序分享出来，供参赛选手参考。之前在交流群里大概说了我的做法，私聊我的人我也都告诉了他们大概怎么去做，在那几天看到好多人在排名突飞猛进保送到了 0.2 分左右，甚至超过了我，还是比较开心的。这次做一个系统的分享，我甚至会告诉你怎么做是不对的，也希望你能有更创新的想法。&lt;strong&gt;走过路过给我的 github 点个 star 就行了，孩子要秋招了，这对我比较重要&lt;/strong&gt;。（2022年3月20日，0.22的得分排名 21，3月24日，这个得分只能90名，大家太卷了）。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NLP" scheme="https://muyuuuu.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>YOLOX 源码解析与小目标检测调优</title>
    <link href="https://muyuuuu.github.io/2022/02/26/yolox/"/>
    <id>https://muyuuuu.github.io/2022/02/26/yolox/</id>
    <published>2022-02-26T08:31:59.000Z</published>
    <updated>2022-05-06T15:10:16.895Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近用 yolox 的发现了一个很神奇的现象，简而言之 <code>yolox-tiny</code> 在单目标检测的效果比 <code>yolox-small</code> 好上很多（3.2mAP%），且 <code>yolox-small</code> 能大幅提升检测精度的方法到了 <code>yolox-tiny</code> 也不起作用了。网上很多 yolox 的解读基本都是翻译论文，没啥价值，还是决定仔细读一下代码，这大概也是全网第一份从源代码的角度解析 yolox 的文章。</p><p>阅读源码后发现 yolox 的 SimOTA 机制存在一些漏洞，并使用对应的方法调优。调优过程明确不采用的方案：增大模型规模、模型融合和其他消耗算力的方法，专注算法本身。</p><a id="more"></a><h1 id="Model-部分"><a href="#Model-部分" class="headerlink" title="Model 部分"></a>Model 部分</h1><p>和其他检测模型一样，<code>model</code> 分为 <code>backbone</code>，<code>neck</code> 和 <code>head</code>。</p><h2 id="backbone"><a href="#backbone" class="headerlink" title="backbone"></a>backbone</h2><p><code>backbone</code> 采用 <code>CSPDarkNet</code>，包括 <code>stem</code>，<code>dark2</code>，<code>dark3</code>，<code>dark4</code> 和 <code>dark5</code>。</p><ul><li>数据经过增强处理并缩放到 <code>640X640</code> 大小后进入 <code>stem</code> 完成图像通道的升维，从 <code>3</code> 通道提升到 <code>X</code> 通道，<code>X</code> 取决于 <code>backbone</code> 规模的 <code>width_factor</code> 参数。图像经过这一层之前，会被均匀切分为左上、右上、左下和右下四个区域并按通道拼接得到 <code>160X160X12</code> 的数据，也就是 12 个通道，每个通道的图像大小占据原图像大小的 <code>1/4</code>，在经过卷积、<code>BN</code> 层和激活层，得到输出。</li><li><code>stem</code> 的输出进入 <code>dark2</code>，经过一个卷积模块，维度提升一倍后尺寸减半。而后经过 <code>CSPLayer</code>，<code>CSPLayer</code> 的结构和残差网络相似，一个分支只对输入卷积一次，另一个分支进行深度特征提取，深度的层数取决于 <code>backbone</code> 的 <code>depth_factor</code> 参数，而后两个分支的输出按照通道数拼接到一起，完成升维。</li><li><code>dark3, dark4, dark5</code> 的东西和 <code>dark2</code> 一致，无非是尺寸减半，通道数翻倍，同理得到 <code>dark3, dark4, dark5</code> 的输出。</li></ul><p><img data-src="https://s4.ax1x.com/2022/02/26/bZ86nH.png" alt></p><p>这里补充一下：</p><ul><li><code>dark3</code> 的输出维度：<code>256X80X80</code></li><li><code>dark4</code> 的输出维度：<code>512X40X30</code></li><li><code>dark5</code> 的输出维度：<code>1024X20X20</code></li></ul><h2 id="neck"><a href="#neck" class="headerlink" title="neck"></a>neck</h2><p>获取 <code>backbone</code> 的 <code>dark3, dark4, dark5</code> 的输出作为输入。这里用文字描述的话太复杂了，简单的画图展示一下大概结构，精细的结构还是要看源代码：</p><p><img data-src="https://s4.ax1x.com/2022/02/26/bZ8gHA.png" alt></p><p>也就是说，这三个输出都融合了模型深层的语义特征和模型浅层的细节特征。</p><h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>因为 <code>neck</code> 有三组输出，所以 <code>head</code> 对 <code>neck</code> 的每一组输出都要进行处理。对每一个输入经过不同的 <code>stem</code> 把通道数降维到 256，而后接入解耦的任务分支，包括分类（<code>cls</code>）、位置框（<code>reg</code>）和前背景（<code>obj</code>）三个网络。</p><p>分类网络的输出通道数是类别数，这里假设为 2，回归网络的输出通道数是 4，负责预测中心点坐标和高宽尺寸，前背景网络的输出通道数是 1，因此输出的通道数是 2+4+1=7。将这三个网络的输出然后拼接到一起，放到一个列表中。因此，<code>head</code> 部分得到的输出为三组数据：<code>7X80X80, 7X40X40, 7X20X20</code>。以 <code>7X80X80</code> 为例，表示预测了 <code>80X80</code> 个目标，每个目标包括位置、类别和前背景共 7 个参数。</p><p><img data-src="https://s4.ax1x.com/2022/02/26/bZ8cBd.png" alt></p><h1 id="训练部分"><a href="#训练部分" class="headerlink" title="训练部分"></a>训练部分</h1><p>这一部分是难点，或者说，是任何目标检测算法的实现难点，代码量也是最大。</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>在这一部分，将对 <code>head</code> 的三个输出进行一些转换并生成对应的 <code>grid</code> 信息，将预测输出对应到图像中的实际位置。<code>grid</code> 可以理解为特征点的位置吧，是固定的，如下图所示黑色的那一个个格子（其他颜色不用看，我实在找不到类似的图了）：</p><p><img data-src="https://s4.ax1x.com/2022/02/27/beHtnP.png" alt></p><p>这一部分大概分以下步骤：</p><ol><li>获取输出特征的的宽度和高度，如 80 和 80，或者 40 和 40，那么就生成对应的 <code>grid</code>，如 [0, 1] [0, 2] … [80, 80] 共 6400 个，维度是 [1, 6400, 2]</li><li>将预测结果 <code>reshape</code> 成 <code>Batch, HxW, C</code> 大小，坐标的 <code>x</code> 和 <code>y</code> 加上 <code>grid</code> 会映射到每个预测特征点的中心位置，在乘以 8，也就是理想情况下位置信息的运算结果会在 640 X 640 之间，也就是图像上目标的中心点</li><li>计算 <code>w</code> 和 <code>h</code> 的 $e$ 次方，再乘以 8，得到目标框的高度和宽度。此时返回得到的 <code>grid</code> 和变换过后的 <code>output</code>。（80 对应的扩张步是 8，40 对应的扩张步是 16，20 对应的扩张步是 32）</li></ol><p>将每一个输出经过上面 3 个步骤的处理后，按照 <code>dim=1</code> 拼接到一起，也就是会得到 <code>Batch, 8400, 7</code> 的输出。（80X80 + 40X40 + 20X20 = 8400）。</p><h2 id="计算损失"><a href="#计算损失" class="headerlink" title="计算损失"></a>计算损失</h2><p>针对 <code>batch</code> 中的每一个图像开始处理：</p><ul><li>如果真实标签显示这个图像没有目标，全部真实标签就是清一色的 0，分类个数全部是 0，位置参数是 4 个 0，有无目标是 8400 个 0，<code>fg_mask</code> 全部是 <code>false</code>。（<code>fg_mask</code> 的用途后面会讲）</li><li>否则，取出这个图像包含的全部真实目标框，与预测结果进行 SimOTA 样本分配，为预测结果分配标签，或者说为标签分配预测结果，因为 8400 个预测结果不可能同时参与训练，只选择部分样本视为正样本进行训练。</li></ul><h3 id="SimOTA"><a href="#SimOTA" class="headerlink" title="SimOTA"></a>SimOTA</h3><p>首先计算真实框覆盖的 <code>grid</code> 中心点，将这些 <code>grid</code> 中心点称为 <code>fg_mask</code> 也就是正样本，从所有的预测结果中通过 <code>fg_mask</code> 把正样本取出来，包括位置，类别和前背景。此外，选择落入真实目标框的周围的预测结果并记录下来，周围的度量方式是：当前特征点乘以 2.5 倍的步长所覆盖的格子。</p><ul><li>之后计算选中的位置和真实位置的 <code>iou</code> 得分和损失；</li><li>将类别的输出激活后和 <code>obj</code> 的激活输出相乘得到类别得分，以此得到类别损失；</li><li>将没有被选中的预测结果视为负样本，也就是上面没有落入真实目标框及周围的预测结果视为预测失败，计算预测失败的损失，有一个预测结果不在，损失就是1，有 100 个不在，就是 100，然后计算这三个损失的和。</li></ul><p>之后进行动态 k 分配，这里的 k 计算比较简单，在 10 和上一步骤选中的 <code>fg_mask</code> 数量取最小值就是 <code>k</code>，给每个真实框选取损失最小的 <code>k</code> 个预测结果。如果当某一个特征点指向多个真实框的时候，选取 <code>cost</code> 最小的真实框，之后对 <code>fg_mask</code> 进行更新。</p><h3 id="计算损失-1"><a href="#计算损失-1" class="headerlink" title="计算损失"></a>计算损失</h3><ul><li><code>obj</code> 损失是全部的预测结果和动态 k 分配后得到的 <code>fg_mask</code> 做交叉熵，提升检测到目标的能力</li><li><code>cls</code> 损失基于 <code>fg_mask</code> 选中的预测结果，将类别的 <code>one-hot</code> 向量与正样本和真实框的 iou 做乘积视为目标。比如预测框和真实框的 iou 是 0.4，那么对应的类别得分就是 0.4，毕竟相交面积小。预测结果和目标做交叉熵损失</li><li><code>reg</code> 损失是就是预测盒子和真实盒子的 iou 损失</li></ul><h1 id="问题分析与调优"><a href="#问题分析与调优" class="headerlink" title="问题分析与调优"></a>问题分析与调优</h1><p>如何解释开头的问题以及如何调优呢？通过一路 <code>debug</code> 找到了一些问题，我目前只发现了一点点问题，<del>等我彻底解决完毕回来填坑（因为又又又摸不到显卡了）。</del></p><ul><li>第一点，由于是单目标检测任务，也就是说只有一个目标，那么小模型参数少，很容易聚焦和收敛；而大模型参数大，解空间也会更多，相对小模型难以探索到更好的解，因此一些常见的 <code>trick</code> （比如预训练 <code>backbone</code>）才会有效的提升大模型的检测效果，而对小模型而言，参数少，搜索空间小，很容易找到更优的解，因此一些 <code>trick</code> 并不会起到很大的作用。</li><li>第二点，由于检测任务绝大多数目标是小目标，而 yolox-tiny 模型尺寸小，输出的通道数也少，底层的特征信息的保留程度好于大模型，因为模型越深，对图像细节的保留程度就越低。</li><li>第三点，也是最重要的一点，由于 YOLOX 选取正样本的机制是：预测结果落入真实框，或者落入真实框的周围，这些落入真实框周围的正样本在模型初期会侥幸存活下来并通过 <code>SimOTA</code> ，但是，由于大部分都是小目标，会导致预测结果和真实目标毫不相交的场景，这就 <code>reg</code> 分支的 IoU Loss 面临难以优化的场景，我们换成 CIoU Loss 就可以了。具体可以参考这里：<a href="https://muyuuuu.github.io/2022/04/23/iou-loss/">IoU Loss 系列</a>。</li></ul><p><img data-src="https://s4.ax1x.com/2022/02/27/beHJXt.png" alt></p><p>如图所示，红色是真实框，绿色是落入真实框周围的预测结果（正样本），灰色表示不参与训练。可以看到，由于目标较小，预测结果和真实标签毫不相交，IoU Loss 的损失恒定是 1，这显然是不合理的。应该根据距离预测结果与真实目标的远近而定，而 CIoU Loss 能很好的解决这一点。</p><p>如果你要从发论文的角度调优 yolox，那么建议改动它的 SimOTA 机制，但是这也只能是为了毕业而发的一篇普通的论文，还远远达不到 yolov6 问世的高度。如果是工程的角度，那么 CIoU Loss 会很适合你。结果也显示，使用 CIoU Loss 的 mAP 要远远高于不使用和 yolox-tiny，提升 4.1 的 mAP。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近用 yolox 的发现了一个很神奇的现象，简而言之 &lt;code&gt;yolox-tiny&lt;/code&gt; 在单目标检测的效果比 &lt;code&gt;yolox-small&lt;/code&gt; 好上很多（3.2mAP%），且 &lt;code&gt;yolox-small&lt;/code&gt; 能大幅提升检测精度的方法到了 &lt;code&gt;yolox-tiny&lt;/code&gt; 也不起作用了。网上很多 yolox 的解读基本都是翻译论文，没啥价值，还是决定仔细读一下代码，这大概也是全网第一份从源代码的角度解析 yolox 的文章。&lt;/p&gt;
&lt;p&gt;阅读源码后发现 yolox 的 SimOTA 机制存在一些漏洞，并使用对应的方法调优。调优过程明确不采用的方案：增大模型规模、模型融合和其他消耗算力的方法，专注算法本身。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="CV" scheme="https://muyuuuu.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>PyQt 打造的图像预览软件</title>
    <link href="https://muyuuuu.github.io/2022/02/12/pyqt5-view-image/"/>
    <id>https://muyuuuu.github.io/2022/02/12/pyqt5-view-image/</id>
    <published>2022-02-12T10:08:59.000Z</published>
    <updated>2022-02-12T10:26:30.630Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>寒假某天下午的突发奇想，想实现一款图像预览软件。大概思路是：在软件的左侧点击图片，软件的右侧就能实时预览图片，因为感觉这个功能有一定的应用场景，所以实现了一下。</p><p><img data-src="https://s4.ax1x.com/2022/02/12/H0ywWQ.png" alt></p><a id="more"></a><p>简单说一下设计思路吧，代码没啥难度：</p><ol><li>使用 GridLayout 手动布局提升美感，左侧是文件列表，右侧是图片预览</li><li>当从左侧文件列表点击文件时，判断点击的文件是否为图像类型，如果是，右侧显示图像。关于如何显示高清图像，可以参考我之前的<a href="https://muyuuuu.github.io/2021/04/10/pyqt5-load-huge-image/">博客</a></li><li>文件列表使用 <code>QTreeView</code> 和 <code>QListView</code> 实现，<code>QTreeView</code> 负责显示文件夹层级关系，<code>QListView</code> 负责显示文件。两者都挂载文件模型。</li><li><del>Qt 的使用就是学会基础操作后大量翻阅官方库的过程。</del></li></ol><p><img data-src="https://s4.ax1x.com/2022/02/12/H0sJ5F.gif" alt></p><p>可以看到里面还有加载模型、识别等按钮，也能猜出来这是深度学习应用的软件。</p><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> (QMainWindow, QWidget, QGridLayout, QApplication,</span><br><span class="line">                             QPushButton, QStatusBar, QProgressBar, QLabel,</span><br><span class="line">                             QTreeView, QListView, QFileSystemModel, QLineEdit,</span><br><span class="line">                             QInputDialog, QFileDialog, QTextEdit, QMessageBox)</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QDir</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QPixmap, QFont</span><br><span class="line"><span class="keyword">from</span> PyQt5.Qt <span class="keyword">import</span> QSize, QImageReader</span><br><span class="line"><span class="keyword">import</span> qdarkstyle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondWindow</span><span class="params">(QWidget)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        super(SecondWindow, self).__init__()</span><br><span class="line">        self.resize(<span class="number">400</span>, <span class="number">400</span>)</span><br><span class="line">        self.move(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">        layout = QGridLayout()</span><br><span class="line">        self.info = QTextEdit()</span><br><span class="line">        layout.addWidget(self.info)</span><br><span class="line">        self.info.setText(msg)</span><br><span class="line">        self.setLayout(layout)</span><br><span class="line">        self.setWindowTitle(<span class="string">'详细信息'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mainwindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(mainwindow, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.setWindowTitle(<span class="string">"天然草地类型识别系统"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示正在加载</span></span><br><span class="line">        self.status = QStatusBar()</span><br><span class="line">        self.status.setStyleSheet(<span class="string">'QStatusBar::item &#123;border: none;&#125;'</span>)</span><br><span class="line">        self.setStatusBar(self.status)</span><br><span class="line"></span><br><span class="line">        self.progressBar = QProgressBar()</span><br><span class="line">        self.label = QLabel()</span><br><span class="line">        self.label.setText(<span class="string">"加载中，请稍后... "</span>)</span><br><span class="line">        self.status.addPermanentWidget(self.label, stretch=<span class="number">2</span>)</span><br><span class="line">        self.status.addPermanentWidget(self.progressBar, stretch=<span class="number">4</span>)</span><br><span class="line">        self.progressBar.setRange(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">        self.progressBar.setMinimum(<span class="number">0</span>)</span><br><span class="line">        self.progressBar.setMaximum(<span class="number">0</span>)</span><br><span class="line">        self.statusBar().setVisible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        self.setMinimumSize(<span class="number">1500</span>, <span class="number">720</span>)</span><br><span class="line"></span><br><span class="line">        layout = QGridLayout()</span><br><span class="line">        w = QWidget()</span><br><span class="line">        w.setLayout(layout)</span><br><span class="line">        self.setCentralWidget(w)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 文件树</span></span><br><span class="line">        self.treeview = QTreeView()</span><br><span class="line">        self.listview = QListView()</span><br><span class="line">        layout.addWidget(self.treeview, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>)</span><br><span class="line">        layout.addWidget(self.listview, <span class="number">0</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        path = QDir.rootPath()</span><br><span class="line"></span><br><span class="line">        self.dirModel = QFileSystemModel()</span><br><span class="line">        self.dirModel.setRootPath(QDir.rootPath())</span><br><span class="line">        self.dirModel.setFilter(QDir.NoDotAndDotDot | QDir.AllDirs)</span><br><span class="line"></span><br><span class="line">        self.fileModel = QFileSystemModel()</span><br><span class="line">        self.fileModel.setFilter(QDir.NoDotAndDotDot | QDir.Files)</span><br><span class="line"></span><br><span class="line">        self.treeview.setModel(self.dirModel)</span><br><span class="line">        self.listview.setModel(self.fileModel)</span><br><span class="line"></span><br><span class="line">        self.treeview.setRootIndex(self.dirModel.index(path))</span><br><span class="line">        self.listview.setRootIndex(self.fileModel.index(path))</span><br><span class="line"></span><br><span class="line">        self.treeview.clicked.connect(self.on_clicked)</span><br><span class="line">        self.listview.clicked.connect(self.run_model)</span><br><span class="line"></span><br><span class="line">        self.treeview.hideColumn(<span class="number">1</span>)</span><br><span class="line">        self.treeview.hideColumn(<span class="number">2</span>)</span><br><span class="line">        self.treeview.hideColumn(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示图片</span></span><br><span class="line">        self.image_label = QLabel()</span><br><span class="line">        self.image_label.setMinimumSize(<span class="number">800</span>, <span class="number">700</span>)</span><br><span class="line">        layout.addWidget(self.image_label, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加载模型</span></span><br><span class="line">        btn = QPushButton(<span class="string">"加载模型"</span>)</span><br><span class="line">        layout.addWidget(btn, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        btn.clicked.connect(self.load_model)</span><br><span class="line"></span><br><span class="line">        more_btn = QPushButton(<span class="string">"详细信息"</span>)</span><br><span class="line">        layout.addWidget(more_btn, <span class="number">7</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        more_btn.clicked.connect(self.show_info)</span><br><span class="line"></span><br><span class="line">        reco_btn = QPushButton(<span class="string">"识别"</span>)</span><br><span class="line">        layout.addWidget(reco_btn, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        reco_btn.clicked.connect(self.predict)</span><br><span class="line"></span><br><span class="line">        clear_btn = QPushButton(<span class="string">"清空"</span>)</span><br><span class="line">        layout.addWidget(clear_btn, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        clear_btn.clicked.connect(self.clear)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预测结果</span></span><br><span class="line">        self.res = QLineEdit()</span><br><span class="line">        self.res.setReadOnly(<span class="literal">True</span>)</span><br><span class="line">        layout.addWidget(self.res, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        self.model = <span class="literal">None</span></span><br><span class="line">        self.fname = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res.clear()</span><br><span class="line">        self.image_label.setVisible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.fname <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 调用你的图片信息代码，我这里没对应的 excel</span></span><br><span class="line">            <span class="comment"># 详细信息赋值给 msg 即可</span></span><br><span class="line">            msg = <span class="string">"详细信息"</span></span><br><span class="line">            self.child = SecondWindow(msg)</span><br><span class="line">            self.child.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当选中图片的时候，直接进行预测</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_model</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.image_label.setVisible(<span class="literal">True</span>)</span><br><span class="line">        idx = self.listview.currentIndex()</span><br><span class="line">        fname = self.fileModel.filePath(idx)</span><br><span class="line">        img_type = fname.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 判断下是不是图片</span></span><br><span class="line">        <span class="keyword">if</span> img_type <span class="keyword">in</span> [<span class="string">"png"</span>, <span class="string">"jpg"</span>]:</span><br><span class="line">            img = QImageReader(fname)</span><br><span class="line">            scale = self.image_label.width() / img.size().width()</span><br><span class="line">            height = int(img.size().height() * scale)</span><br><span class="line">            img.setScaledSize(QSize(self.image_label.width(), height))</span><br><span class="line">            img = img.read()</span><br><span class="line">            pixmap = QPixmap(img)</span><br><span class="line">            self.image_label.setPixmap(pixmap)</span><br><span class="line">            self.fname = fname</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试代码放在这里</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.fname <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># y = self.model(x)</span></span><br><span class="line">            <span class="comment"># y = str(y)</span></span><br><span class="line">            self.res.setText(<span class="string">"cls 1: 0.9, cls 2: 0.8, cls 3: 0.9"</span>)</span><br><span class="line">        <span class="comment"># res = self.model(img)</span></span><br><span class="line">        <span class="comment"># self.res.setText(res)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msgBox = QMessageBox()</span><br><span class="line">            msgBox.setIcon(QMessageBox.Warning)</span><br><span class="line">            msgBox.warning(self, <span class="string">"警告"</span>, <span class="string">"请选择图片后再预测"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_clicked</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        path = self.dirModel.fileInfo(index).absoluteFilePath()</span><br><span class="line">        self.listview.setRootIndex(self.fileModel.setRootPath(path))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载模型的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_model</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.status.setVisible(<span class="literal">True</span>)</span><br><span class="line">        file_filter = <span class="string">'PKL File (*.pt *.pth *.pkl)'</span></span><br><span class="line">        response = QFileDialog.getOpenFileName(</span><br><span class="line">            parent=self,</span><br><span class="line">            caption=<span class="string">'Select a data file'</span>,</span><br><span class="line">            directory=os.getcwd(),</span><br><span class="line">            filter=file_filter,</span><br><span class="line">        )</span><br><span class="line">        pth_file, _ = response</span><br><span class="line">        <span class="comment"># torch load model</span></span><br><span class="line">        <span class="comment"># self.model.load_state_dict(torch.load(pth_file))</span></span><br><span class="line">        self.status.setVisible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QApplication([])</span><br><span class="line">    dark_stylesheet = qdarkstyle.load_stylesheet_pyqt5()</span><br><span class="line">    <span class="comment"># 如果想美化就取消注释</span></span><br><span class="line">    <span class="comment"># app.setStyleSheet(dark_stylesheet)</span></span><br><span class="line">    m = mainwindow()</span><br><span class="line">    m.show()</span><br><span class="line">    sys.exit(app.exec())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;寒假某天下午的突发奇想，想实现一款图像预览软件。大概思路是：在软件的左侧点击图片，软件的右侧就能实时预览图片，因为感觉这个功能有一定的应用场景，所以实现了一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s4.ax1x.com/2022/02/12/H0ywWQ.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="GUI" scheme="https://muyuuuu.github.io/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>算是一个陈述句流水帐的年终总结吧</title>
    <link href="https://muyuuuu.github.io/2022/02/04/2021/"/>
    <id>https://muyuuuu.github.io/2022/02/04/2021/</id>
    <published>2022-02-04T09:44:53.000Z</published>
    <updated>2022-02-05T11:32:15.201Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时间有些晚了，选一个词来描述今年的话，现实魔幻主义，孤魂野鬼又一年。现实比魔幻还要魔幻，魔幻比现实还要现实。</p><a id="more"></a><p>还是那句话，悲观是我的状态，努力是我的态度，不冲突。</p><ul><li><p>1 月，那会儿在期末考试吧，并趁考试的时候忙里偷闲学完了操作系统和 C++。至于为什么研究生在考试的时候才是一年中最清闲的时光，懂得都懂。大概又说错了一些话，又错过了，以后只在适当的时候和懂得人去说。也是在这时候完成的心态的转变，放弃科研。这个月看完了火影，仿佛自己是宇智波，被生活的重压的反噬了。</p></li><li><p>2 月，忘记了，大概是返校，选课。有一门老师的课极度恶心，又是说论文多么多么重要，不注重实践的东西反手退课，我至今羡慕学完计算机原理能写 RISC 五级流水的人。这个月印象最深的是初次尝试去淘宝开代码店了，这也是今年值得记录的大事之一。实在穷的揭不开锅，接近没钱吃饭的程度，实在没办法。接的前两个业务是 LaTeX 排版的，第一笔业务挣了 20 块钱，我当时在想我能免费用 5 次学校的洗衣机。我成为了我曾经讨厌的人，也许并不是。</p></li><li><p>3 月，连夜参加了同学的婚礼。同学在大学所在地结婚，正好我大学毕业很匆忙，没和同学告别，趁此机会好多同学都回来了，大家一起吃个饭，一起聊聊天，弥补当面没有告别的遗憾。不像上次，这次分别没有哭的稀里哗啦。</p></li><li><p>4 月，同学来了西安，和他一起在西安、咸阳转了转，是我第一次正经在西安旅游吧。之后爬了华山，和她矛盾愈演愈烈，不喜欢阴阳的聊天，索性不聊了。这个月应该是接业务的顶峰，啥都接，凌晨一点写代码头很晕的那种，不上课不科研一直在陪客户，很累，像个孤魂野鬼。在某一天，听了很久的音乐，推了所有的业务，退款道歉，准备收手。</p></li><li><p>5 月，学了下 mmdetection，shell 和设计模式，之后就是研三毕业的节奏占据实验室的主流，真好，解脱了。业务并没有彻底放弃，一个月一两笔，多了就不接了，第一点没啥营养，第二点我没钱吃饭。</p></li><li><p>6 月，准备期末？和几个客户确定了长期关系。</p></li><li><p>7 月，暑假放 10 天，但接了个华为的项目，旅行计划泡汤。想临时冲一下项目，加上暑假回去也没想见的人，索性留校了。后续又自己学了一些无监督、高维索引和线程池的东西，自己把项目解决了。</p></li><li><p>8 月，被折腾去投论文，很累，累的原因倒不是多难，而是这个字体加粗，这里行间距，这里符号替换，和换成及，去掉空格，加粗，换成楷体，真的很没意思。开始打游戏缓解压力，一天一天又一天。</p></li><li><p>9 月，在华为项目基础上又做了上游的开发，算是体验了一下一整套系统吧，然后打游戏，打游戏，打游戏…… 置身现实魔幻主义，被折腾的很累。</p></li><li><p>10 月，又被抓去投论文，真的很没意思。不是落地的项目，只在玩具数据集上追求比 A 高 2 个点，比 B 高 3 个点，比 C 高 10 个点，仿佛前人的工作都是垃圾，自己论文无与伦比的新颖，晚诞生一年就是这个世界的损失，用各种词汇体现论文的创新，但本来就是很简单的东西。因此对这种东西深恶痛绝。一个同学考上了清华，给我介绍了一笔大业务，会持续到明年 4 月吧，能写到简历里。所以除了老客户的业务，新业务都不接了。</p></li><li><p>11 月，接到了第二个华为的项目，补了一下 C++ 的高级特性，然后就去开发了。体验了面向生产环境该如何编程，如何设计数据结构，代码如何检验，开发之余还是打游戏，接业务。仿佛脱离了现实进入了魔幻。</p></li><li><p>12 月，大四的师弟来了，帮着我搞项目，也请了几顿饭，我又又又被抓去投论文了，真的恶心，持续性头晕。其中一点是，做深度学习但没有显卡，实验得不到保障。时隔 8 个月，和他关系有所缓和，他也理解了我所处环境的苦衷，终于能好好说话了，不容易。我也尝试不再去抱怨，可总是没话题去说，也许随缘吧。开始不带手机回宿舍，好好睡一觉。买了把静电容键盘。</p></li></ul><p>生活总是这样，不给半点希望的星光，把人压的苟延残喘却无可奈何，难过的时候都要去 b 站算卦占卜来看一下接下来的日子走势，企图获得一星半点的慰籍。可能是自己想太多，进入了精神内耗，经历过很多难熬的日子，似乎也不差这几百天。可能有什么办法呢？今年就要秋招了，努力一下，等找完工作稳定下来，好好休息吧，不再去想乱七八糟的东西。</p><p>我觉得师兄有句话很好，毕业了绝对不能立刻买房，先玩几年。学校里跟个孙子似的，没必要一毕业立刻成为孙子，每天一挣钱欠银行几百块钱的日子也不好受。虽然早晚是孙子，但先玩几年，快乐几年再说。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间有些晚了，选一个词来描述今年的话，现实魔幻主义，孤魂野鬼又一年。现实比魔幻还要魔幻，魔幻比现实还要现实。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Life" scheme="https://muyuuuu.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>半监督浅显入门</title>
    <link href="https://muyuuuu.github.io/2022/01/30/semi-intro/"/>
    <id>https://muyuuuu.github.io/2022/01/30/semi-intro/</id>
    <published>2022-01-30T12:15:16.000Z</published>
    <updated>2022-01-30T12:21:34.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>寒假开始前还是把在学校里遗留的工作先搞完，所接项目的目标是实现半监督语义分割。既然是半监督，就先来看一下半监督的经典论文，我选了经典的、结构相似的三篇论文。</p><p>第一篇是：NIPS 2017 的 Mean teachers are better role models: Weight-averaged consistency targets improve semi-supervised deep learning results，因为我发现伪标签相关的论文或多或少有它的影子。</p><p>第二篇是：ICCV 2021 的 End-to-End Semi-Supervised Object Detection with Soft Teacher，微软出品的半监督目标检测，质量上还是比较让人相信的，且语义分割也可以借鉴目标检测的东西。</p><p>第三篇是：ECCV 2021 的 Semi-supervised Semantic Segmentation via Strong-weak Dual-branch Network，因为搜半监督语义分割，最新的进展论文就是它了。</p><p>文章最后有代码实现。<del>才发现好久没更新博客了。</del></p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因为现实世界标注数据比较昂贵，但无标注的数据很容易获得，那么基于少量标注数据和大量无标注数据的训练，也就是半监督训练也成为了研究的热门。简单来说，半监督分为两类：</p><ul><li>伪标签，用有标签数据训练一个分类器，然后用这个分类器对无标签数据进行分类，这样就会产生伪标签(<code>pseudo label</code>)，挑选其中认为分类正确的无标签样本，把选出来的无标签样本用来训练分类器，这样就使用了无标签数据。</li><li>协同训练，假设每个数据可以从不同的视角（对应到 <code>torch</code> 的话，就是不同的 <code>torchvision.transform</code>）进行分类。不同视角可以训练出不同的分类器，分类器对不同视角的图片分类结果应该相同。然后用这些从不同视角训练出来的分类器对无标签样本进行分类，再选出认为可信的无标签样本加入训练集中。由于这些分类器从不同视角训练出来的，可以形成一种互补，而提高分类精度，就如同从不同视角可以更好地理解事物一样。</li></ul><h1 id="半监督图像分类"><a href="#半监督图像分类" class="headerlink" title="半监督图像分类"></a>半监督图像分类</h1><p>这篇论文还是很简单的：</p><p><img data-src="https://s4.ax1x.com/2022/01/30/HC2TpQ.png" alt></p><p>但论文中的训练过程写的不是很清楚，看了<a href="https://github.com/CuriousAI/mean-teacher/tree/546348ff863c998c26be4339021425df973b4a36/pytorch" target="_blank" rel="noopener">代码</a>了解了完整的训练流程：</p><ul><li>有标签输入学生的预测输出和 <code>one-hot label</code> 进行对比，这个是分类损失；和教师的输出使用 <code>consistency cost</code> 进行对比，论文中用的是两个模型输出的二阶范数，代码提供了 <code>mse</code> 和 <code>kl</code> 散度两个损失。第二个 <code>loss</code> 根据 <code>epoch</code> 调整权重，<code>epoch</code> 越大，权重越大。</li><li>两个权重相加，反向传播更新学生的模型，<code>exponential moving average (EMA)</code> 更新教师模型，能在每个 <code>batch</code> 后聚合信息而不是每个 <code>epoch</code> 后才聚合信息，这样能获取更好的表示。</li><li>最后使用教师模型进行预测。</li></ul><p>至于<a href="https://github.com/CuriousAI/mean-teacher/blob/546348ff863c998c26be4339021425df973b4a36/pytorch/mean_teacher/data.py#L72-L79" target="_blank" rel="noopener">无标签数据部分</a>，就是一批数据作两次变换，第一组视为有标签，第二组数视为无标签。</p><p>这篇论文的思想可以总结为：作为教师，用来产生学生学习时的目标；作为学生，则利用教师模型产生的目标来进行学习。</p><h1 id="半监督目标检测"><a href="#半监督目标检测" class="headerlink" title="半监督目标检测"></a>半监督目标检测</h1><p>如果说分类图像的数据难以标注，那么目标检测的数据更加难以标注。</p><p>半监督目标检测的重点是：提升伪标签质量，伪标签质量好了也利于后续的训练。传统的半监督目标检测是多阶段方法：使用标签数据训练一个检测器，之后对无标签数据生成伪标签，再次训练检测器。但是也很容易受到限制：如何保证伪标签的质量？标签数据和无标签数据分布不一致怎么办？且不是端到端的，多年前写 <code>MTCNN</code> 的时候就感觉不是端到端就很不方便。</p><p>同样类似 <code>mean teacher</code> 的结构，创建两个模型，并使用 <code>EMA</code> 更新教师模型。教师模型指导学生模型的训练，而不是简单的提供伪标签就结束了。在获取学生模型生成的预测后，得分大于某个阈值的视为前景，以此保证伪标签的质量，但即使这样仍然有很多预测结果是背景，后文会给出解决方案。</p><p>对于无标签数据，控制标签数据和无标签数据在一个 <code>batch</code> 中的比率，从 <code>0.5</code> 开始，衰减到最后的 <code>epoch</code> 为 0。</p><p><img data-src="https://s4.ax1x.com/2022/01/30/HC2bXn.png" alt></p><p>在图里可以看到：教师模型对无标签数据进行弱数据增强，并生成盒子的伪标签和类别的伪标签。学生模型读入有标签数据，得到一个损失 $L_u$ ，对无标签数据使用强数据增强，预测结果和教师模型生成的伪标签对比，又得到一个损失 $L_s$ 。最后的损失为 $L_s + \alpha L_u$。</p><p>对于 $L_u$ 的分类部分，与半监督分类的一致性分布损失相反，目标检测的伪标签相对复杂，无标签数据上能检测出上千个盒子，即使 <code>NMS</code> 之后也会留下很多盒子，所以选择前景分数大于某个阈值的作为盒子，但是阈值高导致召回率低，也就是说，学习模型的前景被匹配为背景。为了避免这个问题，在得到学生模型计算出的前景和背景后，前景直接和伪标签进行对比，背景使用可靠性分数进行加权。</p><p>对于 $L_u$ 的盒子部分，前景得分并没有提供很好的定位信息，也就是说使用得分作为阈值筛选教师提供的盒子伪标签没啥用，那么如何使盒子的定位信息更加可靠呢？论文是这么做的，在教师生成的标签盒子周围附近进行随机采样，再次得到预测的盒子，重复这个过程$N$（实验部分取 10）次得到多个盒子，计算这些盒子的标准差，标准茶大于 0.5 的才视为前景的盒子。</p><p>代码是用 mmdetection 写的，几年前我用过这个东西，暂时不考虑精读代码，这个并不是大众用户的东西，暂时不考虑精读代码。</p><h1 id="半监督语义分割"><a href="#半监督语义分割" class="headerlink" title="半监督语义分割"></a>半监督语义分割</h1><p><img data-src="https://s4.ax1x.com/2022/01/30/HC2xtU.png" alt></p><p>这篇论文的结构和上面两篇论文的结构很像，在这一瞬间仿佛世界线收束了，虽然这个论文没提供代码，但个人感觉这个方法是靠谱的。</p><p>它在语义分割的时候分为有标签样本和弱标签样本，弱标签样本是用别的方法生成的，我没有细看生成的方法。因为我准备在这篇论文的结构上在加一个教师网络，用教师网络生成伪标签，剩下的东西和半监督图像分类差不多了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码用的 <code>segmentation model pytorch</code>，我看了下代码，魔改成半监督的话还是比较简单的，思路有了，代码都好说。会在不久的将来开源程序和结果，预计三月初。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/437754834" target="_blank" rel="noopener">半监督目标检测 MMdetection 实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;寒假开始前还是把在学校里遗留的工作先搞完，所接项目的目标是实现半监督语义分割。既然是半监督，就先来看一下半监督的经典论文，我选了经典的、结构相似的三篇论文。&lt;/p&gt;
&lt;p&gt;第一篇是：NIPS 2017 的 Mean teachers are better role models: Weight-averaged consistency targets improve semi-supervised deep learning results，因为我发现伪标签相关的论文或多或少有它的影子。&lt;/p&gt;
&lt;p&gt;第二篇是：ICCV 2021 的 End-to-End Semi-Supervised Object Detection with Soft Teacher，微软出品的半监督目标检测，质量上还是比较让人相信的，且语义分割也可以借鉴目标检测的东西。&lt;/p&gt;
&lt;p&gt;第三篇是：ECCV 2021 的 Semi-supervised Semantic Segmentation via Strong-weak Dual-branch Network，因为搜半监督语义分割，最新的进展论文就是它了。&lt;/p&gt;
&lt;p&gt;文章最后有代码实现。&lt;del&gt;才发现好久没更新博客了。&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="CV" scheme="https://muyuuuu.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>CV 领域的自监督</title>
    <link href="https://muyuuuu.github.io/2021/12/28/SSL-intro/"/>
    <id>https://muyuuuu.github.io/2021/12/28/SSL-intro/</id>
    <published>2021-12-28T07:09:23.000Z</published>
    <updated>2022-01-03T08:45:41.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>还是要认真的学习一会儿，降低多巴胺的分泌。在使用 triplet loss 学表示的时候，出现了模型坍塌的情况，也就是说，模型对任何输入的输出都是一样的，损失恒定的现象。在网上搜了一些解决方案后，需要用户去花精力构造正负样本，我不喜欢这样的东西，所以开始看了自监督的论文，毕竟都是学表示。也发现自监督会在一段时间内成为未来的视觉领域的主流，正好我做的东西和自监督也算相关，做一个论文整理。包括了 MoCo，SimCLR，SimSiam 和 Barlow Twins。</p><blockquote><p>模型崩塌，也就是模型为了偷懒，无论什么图片都会输出同样表示，这样结果 loss 很小，然后却没学到任何东西。</p></blockquote><a id="more"></a><p>图像领域的自监督主要由两部分组成，对比损失和数据增强，而那四篇论文也是基于这两个东西去做的，无非是如何对比。</p><h1 id="MoCo"><a href="#MoCo" class="headerlink" title="MoCo"></a>MoCo</h1><p>首先是 <code>MoCo</code>，简单的看一下模型的结构</p><p><img data-src="https://s4.ax1x.com/2021/12/28/TsYsxS.png" alt="TsYsxS.png"></p><p>对同一个样本做两次数据增强，会得到两个样本 $x_q$ 和 $x_k$，创建两个 <code>encoder</code>，左边那个 <code>encoder</code> 接入 $x_q$，右边的 <code>encoder</code> 接入 $x_k$，使得这两个的相似性越高越好，与此同时，期望 $x_q$ 与负样本的相似性越低越好。那么如何衡量相似性呢？使用的是 <code>InfoNCE</code> 这个损失函数。</p><p>\begin{aligned}<br>{L}_{InfoNCE} =-{E}_X\left[\log \frac{f_{k}\left(x_{t+k}, c_{t}\right)}{\sum_{x_{j} \in X} f_{k}\left(x_{j}, c_{t}\right)}\right] \\<br>\end{aligned}</p><p>分子是正样本的相似度，分母是负样本的相似度，这个比值越大，log 就越大，对应的损失函数就越小。<code>MoCo</code> 的改动如下，用点积来衡量 $x_q$ 和正负样本的距离。也就是说，使用对比损失来区分图像的高维特征。</p><p>\begin{equation}<br>{L}_q = -\log \frac{ \exp(q\cdot k_{+}/\tau) }{\sum_{i=0}^K \exp(q\cdot k_{i}/\tau)}<br>\end{equation}</p><p>那么与众不同的地方呢？换句话说，负样本从哪里来呢？模型会设计一个队列，队列负责维护将刚进入的样本视为负样本放入队列（最开始没负样本的话，用的是随机数），并弹出之前的负样本，这就需要很大的显存以及代码编写的难度，我不是很喜欢这两点。不信你来看他们官方的<a href="https://github.com/facebookresearch/moco" target="_blank" rel="noopener">程序</a>。</p><p>此外需要注意的是，作者提出了动量的更新方式，来更新右侧的网络：</p><p>\begin{equation}<br>\theta_k \leftarrow m\theta_k + (1-m)\theta_q , m\in[0,1)<br>\end{equation}</p><p>也许你会有疑问，都计算好梯度了，更新左侧的网络就没事，更新右侧的网络就有事，莫非在耍流氓？这个梯度给谁不是给，为什么不用梯度更新两个网络？论文上写的是：由于样本很多，右侧网络不容易更新。很多网上的论文解析也是人云亦云，看了代码就知道存储负样本的队列和右侧的网络没半毛钱关系，队列在计算梯度的时候已经 <code>detach</code> 了。所以，论文写的更新困难并不是梯度回传困难，那么为什么不能用梯度更新右侧的网络呢？</p><p>先来解释为什么不把左侧网络的参数拷贝给右侧网络的参数。这么做的目的是因为不同 <code>epoch</code> 之间数据分布差异可能很大，<code>encoder</code> 的参数有可能会发生突变，不能将多个 <code>epoch</code> 的数据特征近似成一个静止的大 <code>batch</code> 数据特征，因此就使用了这么一个类似于滑动平均的方法来更新右侧网络。</p><p>再来回答为什么不用梯度更新右侧的网络。$x_k$ 经过右侧网络后，然后我们就得到了它们相对应的表示。而对于这个表示，它们不光包含了这个 <code>mini-batch</code> 的表示，也包含了一些之前处理过的 <code>mini-batch</code> 中的表示。换句极端的话说，右侧的网络掌握了全部数据的表示，来调控左侧网络该学到什么样的表示。这些表示通过右侧网络后放入队列中，相对于只在本 <code>mini-batch</code> 内做比较的方法而言，<code>moco</code> 能用较小的管理开销来获得更多的负样本。如果只用一个 <code>mini-batch</code> 的梯度更新右侧网络，或者说右侧网络只掌握一个 <code>mini-batch</code> 的表示，那右侧网络直接输出和左侧网络一样的东西不就行了，这样损失很小，但什么也没学到。因此，不能用一个 <code>mini-batch</code> 的梯度去更新右侧网络。</p><h2 id="损失函数解析"><a href="#损失函数解析" class="headerlink" title="损失函数解析"></a>损失函数解析</h2><p>此外是本文较为迷惑的损失函数，文章写的没啥迷惑，迷惑的是代码。我第一眼过去，直接理解为不管是正样本还是负样本，都和 0 去接近，正样本明明越大越好，应该和 1 去接近，这么写肯定不对呀。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l_pos = torch.einsum(<span class="string">'nc,nc-&gt;n'</span>, [q, k]).unsqueeze(<span class="number">-1</span>)</span><br><span class="line">l_neg = torch.einsum(<span class="string">'nc,ck-&gt;nk'</span>, [q, self.queue.clone().detach()])</span><br><span class="line">logits = torch.cat([l_pos, l_neg], dim=<span class="number">1</span>)</span><br><span class="line">labels = torch.zeros(logits.shape[<span class="number">0</span>], dtype=torch.long)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">loss = criterion(logits, target)</span><br></pre></td></tr></table></figure><p>后来仔细抠的代码才理解，<code>torch</code> 的交叉熵损失函数由 <code>logsoftmax</code> 和 <code>nllloss</code> 组成，前者完成 <code>logsoftmax</code> 的计算，后者 <code>nllloss</code> 取出对应的标签，在 <code>nllloss</code> 的时候，标签为 0 的意思是取出 <code>batch</code> 中的第一列，而这一列正好是正样本，<code>nlloss</code> 期望这列的值越小越好，那么回退到 <code>logsoftmax</code>，就是期望这列的值越大越好，也就是，正样本的相似度很高。<strong>并不是像网上那种垃圾博客说的，无监督任务都分成 0 类即可。</strong> 这里还是建议理解一下，因为自监督的损失大多是这么设计的。</p><h1 id="SimCLR"><a href="#SimCLR" class="headerlink" title="SimCLR"></a>SimCLR</h1><p>推荐一个比较好的<a href="https://github.com/Spijkervet/SimCLR" target="_blank" rel="noopener">实现</a>。因为反感 <code>MoCo</code> 那种开显存的操作，毕竟不是所有人都有  <code>facebook</code> 的财力，所以继续去读了其他自监督的论文，较为相似的一篇论文是 <code>SimCLR</code>。还是先来看模型结构图：</p><p><img data-src="https://s4.ax1x.com/2021/12/28/TsYr28.png" alt="TsYr28.png"></p><p>注意，左右两边的网络都是相同的，也就不存在梯度该传给谁的问题。一个 <code>batch</code> 的样本，经过数据增强得到两个 <code>batch</code> 的样本，这两个 <code>batch</code> 的样本进入网络会得到两个 <code>batch</code> 的表示，期待这两组表示中，同一数据的表示很接近，放大不同数据的差异。损失同样是用的类似 <code>InfoNCE</code> 的损失函数。不过论文中有比较奇怪的点，放一段原文：</p><blockquote><p>We randomly sample a minibatch of N examples, augmented examples derived from the minibatch, resulting in 2N data points. We treat the other 2(N-1) augmented examples within a minibatch as negative examples.The final loss is computed across all positive pairs.</p></blockquote><p>问题来了，一共 $2N$ 个样本，$2(N-1)$ 都视为负样本，哪来的 positive pairs？还是直接看代码吧，其实 <code>MoCo</code> 的论文写的也够晕的。看了代码损失函数的设计后发现，就是自己和自己是正样本，自己和其他的样本的关系是负样本。严格来说，对于一个样本而言，有 <code>2(N-2)</code> 个负样本。损失函数和 <code>MoCo</code> 的保持一致，都是用交叉熵损失函数实现的。推荐去看这个损失函数的实现，代码写的还是比较有意思的。但是计算量会大一些。</p><h1 id="SimSiam"><a href="#SimSiam" class="headerlink" title="SimSiam"></a>SimSiam</h1><p>在 <code>MoCo</code> 之后，提出了更简单的网络结构：</p><p><img data-src="https://s4.ax1x.com/2021/12/28/TsYD8f.png" alt="TsYD8f.png"></p><p>提前声明，相似度用的是余弦函数，因为余弦函数相似性越高数值越大，因此损失函数取了负数，最后的损失值也是负的。思路很简单，对同一个图像做两次增强得到俩个正样本，$x_1$ 和 $x_2$，$x_1$ 经过 <code>encoder</code> 得到表示 $z1$，$z1$ 经过 <code>predictor</code> 得到 $p_1$，同理得到 $p_2$ 和 $z_2$，计算 $p_1$ 和 $z_2$ 以及 $p_2$ 和 $z_1$ 的相似度，然后就没了。</p><p>简单吗？简单。有坑吗？有。我当时在想，如果 <code>predictor</code> 的权重全部是 1，那么相似度不就会很小了，但仍然是模型坍塌的情况。然后带着疑问去看代码，结果人家直接冻结了 <code>predictor</code> 某一层的权重，是我大意了。后来我以抄袭的形式复现的时候，没有冻结权重，效果比 SimCLR 要好一些。</p><h1 id="Barlow-Twins"><a href="#Barlow-Twins" class="headerlink" title="Barlow Twins"></a>Barlow Twins</h1><p>到这篇论文，思路更加简单，东西和 SimCLR 比较类似，损失函数用的是大二学过的协方差矩阵，对角线越大越好，其余位置越小越好。它虽然很简洁，但我感觉他比 SimSiam 更令人喜欢。</p><p>\begin{equation}<br>L=\sum_{i}(1-C_{ii})^2 + \lambda \sum_i \sum_{j\neq i} C_{ij}^2<br>\end{equation}</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://kakack.github.io/2021/05/Moco-%E5%9F%BA%E4%BA%8E%E5%8A%BF%E8%83%BD%E6%9B%B4%E6%96%B0%E7%9A%84%E8%87%AA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">MoCo 参考</a></li><li><a href="https://blog.csdn.net/qq_22210253/article/details/85229988" target="_blank" rel="noopener">NLLLoss 解析</a></li><li><a href="https://zhuanlan.zhihu.com/p/357088620" target="_blank" rel="noopener">SimSiam 为什么 stop grad</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还是要认真的学习一会儿，降低多巴胺的分泌。在使用 triplet loss 学表示的时候，出现了模型坍塌的情况，也就是说，模型对任何输入的输出都是一样的，损失恒定的现象。在网上搜了一些解决方案后，需要用户去花精力构造正负样本，我不喜欢这样的东西，所以开始看了自监督的论文，毕竟都是学表示。也发现自监督会在一段时间内成为未来的视觉领域的主流，正好我做的东西和自监督也算相关，做一个论文整理。包括了 MoCo，SimCLR，SimSiam 和 Barlow Twins。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模型崩塌，也就是模型为了偷懒，无论什么图片都会输出同样表示，这样结果 loss 很小，然后却没学到任何东西。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="CV" scheme="https://muyuuuu.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>工程开发经验总结三，以 sspaddmm 为例，再来谈一谈并行加速</title>
    <link href="https://muyuuuu.github.io/2021/12/27/project-experience-3/"/>
    <id>https://muyuuuu.github.io/2021/12/27/project-experience-3/</id>
    <published>2021-12-27T15:07:29.000Z</published>
    <updated>2022-01-07T08:31:56.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天来写什么呢？准备整理一些多线程的东西，虽然多线程相对很熟悉了，可每次工程中都会有新的收获。这次不谈多线程的理论问题，毕竟计算机专业都懂多线程的理论并写过相关程序，也了解其使用的背景。之前使用多线程的时候，总是看一看加速比和结果是否准确就完了，那么这次以多线程使用者和多线程设计者的角度出发，来谈一谈如何更好的使用和设计多线程。</p><a id="more"></a><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>给定一个 2D 的稀疏矩阵，稀疏矩阵的采用 COO 格式的表示，如下图所示：</p><p><img data-src="https://s4.ax1x.com/2021/12/27/Treg5d.png" alt></p><p>稀疏矩阵由三部分组成，包括 <code>Indices, Values, Shapes</code>。具体而言，这是一个 100 X 100 的二维稀疏矩阵，索引的第一行表示行，第二行表示列，行列对应的索引处为具体的数值，初次之前全部是 0。比如，<code>sparse[1][0]=0.6</code>，注意：其中的索引是可以重复的，比如有两个 <code>[2,1]</code>。</p><p>现在的问题是，稀疏矩阵乘以稠密矩阵，既然是矩阵乘法，很容易想到并行。不过在此之前，还是简单说一下矩阵乘法的流程：</p><p>假设稀疏矩阵第 $r_1$ 行和第 $c_1$ 列的值为 $v_1$，假设稠密矩阵由 $C$ 列，那么乘法就是：将 $v_1$ 与稠密矩阵中第 $c_1$ 行对应的所有的列的值相乘，结果的索引是 $(r_1, 1), (r_1, 2), \cdots, (r_1, C)$。举个例子：</p><p><img data-src="https://s4.ax1x.com/2021/12/27/TreoqS.png" alt></p><p>如上的例子中，稀疏矩阵乘以稠密矩阵，将单个系数矩阵元素相乘的结果，直接以 <code>+=</code> 的形式放到对应的位置中，既然画图了，那么也就能看出来并行的点：</p><ol><li>方案 1：乘以稠密矩阵要遍历其所有的列，所以在取列的时候并行，这样不会有冲突</li><li>方案 2：稀疏矩阵并行，以上图为例，直接拿那两个的稀疏矩阵的元素去乘以稠密矩阵的列。不过这里会有冲突，比如稀疏矩阵中有多个行相同的索引，比如上图的稀疏矩阵 <code>[1,0], [1, 2]</code> 这样的，在 <code>+=</code> 的时候不加锁，多线程会出问题。</li></ol><p>以下，<code>mat1</code> 表示稀疏矩阵，<code>mat2</code> 表示稠密矩阵，且 <code>sspaddmm</code> 函数<strong>要求返回稀疏矩阵</strong>而不是稠密矩阵，上面的图只是为了便于理解。此外，能使用的并行工具有限，这取决于所在的工程，这个没办法，有点戴着镣铐跳舞的意思，高中老师经常用戴着镣铐跳舞来 PUA 我们，即：你必须听话，在听话的范围内做到很好，不能越界。</p><h2 id="并行-API"><a href="#并行-API" class="headerlink" title="并行 API"></a>并行 API</h2><p>API 是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对矩阵中每个元素自增 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 串行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  arr[i] += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> shared = [&amp;](uint start, uint end) &#123;</span><br><span class="line">  <span class="keyword">for</span> (uint i = start; i &lt; end; i++) &#123;</span><br><span class="line">    arr[i] += <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">parallelfor(<span class="number">10000</span>, <span class="number">10000</span> / n_threads, shared);</span><br></pre></td></tr></table></figure><p>其中 <code>parallelfor</code> 的第一个元素是任务总数，<code>n_threads</code> 是线程的数量，最后传入定义的匿名函数，在匿名函数中，默认从 0 开始，到任务总数结束，并划分对应的 <code>start</code> 和 <code>end</code> 区间，比如 1 到 5000 为一组，5000 到 10000 为另一组。</p><h1 id="串行版本"><a href="#串行版本" class="headerlink" title="串行版本"></a>串行版本</h1><p>矩阵的串行乘法比较容易理解，写出串行程序来，也就知道了如何写并行程序。先遍历第一个矩阵，在遍历第二个矩阵，相乘即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat1_nums; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> row1 = mat1_indices[i][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> col1 = mat1_indices[i][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat2_col; j++) &#123;</span><br><span class="line">    output_val[cnt] += mat1_val[i] * mat2_val[col1][j];</span><br><span class="line">    output_idx[cnt][<span class="number">0</span>] = row1;</span><br><span class="line">    output_idx[cnt][<span class="number">1</span>] = j;</span><br><span class="line">    cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用方案-1"><a href="#使用方案-1" class="headerlink" title="使用方案 1"></a>使用方案 1</h1><p>方案 1 的并行似乎很简单，可真的是这样吗？看上文的串行程序，我们发现做完一次乘法，就将结果直接写到 <code>output</code> 对应的地址中，写完一次，<code>cnt++</code>，为下一次写出数据做准备。那么问题来了，<code>parallelfor</code> 不提供锁，那么变量在没被保护的情况下的自增就会错误，如何解决呢？</p><p>既然读写会出现错误，而多线程的读是没有问题的，那么就想办法去掉写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; idx_map_cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat1_nums; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> row1 = mat1_indices[i][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat2_col; j++) &#123;</span><br><span class="line">    idx_map_cnt[row1][j] = cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat1_nums; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> row1 = mat1_indices[i][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> col1 = mat1_indices[i][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">auto</span> shared = [&amp;](uint start, uint end) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; end; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> idx = idx_map_cnt[row1][j];</span><br><span class="line">      output_val[idx] += mat1_val[i] * mat2_val[col1][j];</span><br><span class="line">      output_idx[idx][<span class="number">0</span>] = row1;</span><br><span class="line">      output_idx[idx][<span class="number">1</span>] = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  parallelfor(<span class="number">10000</span>, <span class="number">10000</span>/n_threads, shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，在时间复杂度不变的情况下，借助一个额外的映射表就实现了并行，因为是针对 mat2 进行了并行，mat1 部分仍然是串行，也就是说，不会同时出现两个 <code>row1</code> 相等的情况，因此多线程中的 <code>+=</code> 是安全的。</p><h1 id="使用方案-2"><a href="#使用方案-2" class="headerlink" title="使用方案 2"></a>使用方案 2</h1><p>如果明白了方案 1 的并行思路，那么问题又来了，假设 mat1 有 2000 个元素，mat2 的列也是 20，那么此时我们应该针对 mat1 进行并行，而不是 mat2。但是 mat1 并行会出乱子，因为使用多线程访问上述程序中的 <code>row1</code>，可能会用重复的结果，那么多线程中的 <code>+=</code> 就是不安全的。如何解决呢？反而言之，多线程访问 mat1，如何保证每个线程拿到的 <code>row1</code> 是不一样的。我和师弟提出了两种思路：</p><ol><li>先来看思路 1。设计一个数据结构，这个数据结构每次从 mat1_indices 中抽取出不重复的行，因为行是不同的，那么这样就可以并行了。举个例子，mat1 中的行是 <code>[1, 2, 1, 2, 3, 4, 5, 5, 6, 7]</code>，那么我第一次选择 <code>[1, 2, 3, 4, 5, 6, 7]</code> 去并行，第二次选择 <code>[1, 2, 5]</code> 去运算，每次选择的元素不会有重复，这样多线程的 <code>+=</code> 就安全了。可视化一下这样的结构：</li></ol><p><img data-src="https://s4.ax1x.com/2021/12/27/Trm9ZF.png" alt></p><p>来看如何实现这样的数据结构，也就是下文中的 <code>unrepeated</code>，因为映射的 <code>key</code> 是唯一的，所以使用 <code>key</code> 来记录不同的索引，选择的时候，也是选择其中的 <code>key</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; unrepeated;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int64_t</span> i = <span class="number">0</span>; i &lt; mat1_num; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> _row = mat1_indices[i][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> _col = mat1_indices[i][<span class="number">1</span>];</span><br><span class="line">  unrepeated[_row].push_back(_col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (unrepeated.size()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = unrepeated.begin(); it != unrepeated.end(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unrepeated[it-&gt;first].size() == <span class="number">1</span>) &#123;</span><br><span class="line">      res.push_back(&#123;it-&gt;first, it-&gt;second.back()&#125;);</span><br><span class="line">      tmp.push_back(it-&gt;first);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.push_back(&#123;it-&gt;first, it-&gt;second.back()&#125;);</span><br><span class="line">      it-&gt;second.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : tmp) &#123;</span><br><span class="line">    unrepeated.erase(i);</span><br><span class="line">  &#125;</span><br><span class="line">  tmp.clear();</span><br><span class="line">  <span class="keyword">int</span> n = res.size();</span><br><span class="line">  <span class="keyword">auto</span> shared = [&amp;](uint start, uint end) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> row1 = res[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> col1 = res[i][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &gt; mat2_col; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> idx = idx_map_cnt[row1][j];</span><br><span class="line">      output_val[idx] += mat1_val[i] * mat2_val[col1][j];</span><br><span class="line">      output_idx[idx][<span class="number">0</span>] = row1;</span><br><span class="line">      output_idx[idx][<span class="number">1</span>] = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  parallelfor(res.size(), res.size()/n_threads, shared);</span><br><span class="line">  res.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有发现问题？我猜一定没有，因为不会有人盯着一段非必须的程序仔细的看。还是直接说把，上述程序中的 <code>mat1_val[i]</code> 不是合法的，因为并行化以后，i 对应的是 <code>res.size()</code> 的某个元素，而不是 <code>mat1_values</code> 的第 i 个数值。怎么办呢？再加一个映射 <code>co_map_idx</code> 呗，把索引映射为数值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; co_map_idx;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int64_t</span> i = <span class="number">0</span>; i &lt; mat1_vals_num; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> _row = mat1_indices[i][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> _col = mat1_indices[i][<span class="number">1</span>];</span><br><span class="line">  unrepeated[_row].push_back(_col);</span><br><span class="line">  co_map_idx[_row][_col].push_back(mat1_val_addr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> shared = [&amp;](uint start, uint end) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> row1 = res[i][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> col1 = res[i][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">double</span> val = co_map_idx[row_mat1][row_mat2].back();</span><br><span class="line">  co_map_idx[row_mat1][row_mat2].pop_back();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &gt; mat2_col; j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> idx = idx_map_cnt[row1][j];</span><br><span class="line">    output_val[idx] += val * mat2_val[col1][j];</span><br><span class="line">    output_idx[idx][<span class="number">0</span>] = row1;</span><br><span class="line">    output_idx[idx][<span class="number">1</span>] = j;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是根据实际运行的结果来看中，这是一种很烂的方案，每次都要选择不重复元素、清空和删除，这会带来不必要的开销，时间会很慢。那么再来看二种并行思路：我们已经有了 <code>unrepeated</code> 这样的数据结构，那么直接对 <code>unrepeated</code> 直接分组不是更好吗？</p><p><img data-src="https://s4.ax1x.com/2021/12/27/TrmesK.png" alt></p><p>直接对 <code>unrepeated</code> 的 <code>key</code> 进行分组计算，这样就不会出现重复的 <code>key</code>，不过为了拿到不同的 <code>key</code>，仍然需要一些预处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = unrepeated.begin(); it != unrepeated.end(); it++)</span><br><span class="line">  res.push_back(it-&gt;first)</span><br><span class="line"><span class="keyword">auto</span> multi = [&amp;](<span class="keyword">uint32_t</span> start, <span class="keyword">uint32_t</span> end) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="comment">// get val</span></span><br><span class="line">    <span class="keyword">auto</span> row_mat1 = res[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> row_mat2 : unrepeated[row_mat1]) &#123;</span><br><span class="line">        <span class="keyword">double</span> val = co_map_idx[row_mat1][row_mat2].back();</span><br><span class="line">        co_map_idx[row_mat1][row_mat2].pop_back();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; mat2_col; j++) &#123;</span><br><span class="line">            <span class="comment">// get val</span></span><br><span class="line">          <span class="keyword">uint32_t</span> idx = idx_map_cnt[row_mat1][j];</span><br><span class="line">          *(out_val_addr + idx) +=</span><br><span class="line">              val * mat2_val_addr[row_mat2 * mat2_col + j];</span><br><span class="line">          out_idx_addr[idx] = row_mat1;</span><br><span class="line">          out_idx_addr[idx + out_num] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看，方法总比困难多，问题被完美解决。在这之后，我尝试了各种并行方案，以及双重并行，上述代码是性能最好的一个，但性能与其他库比仍然查了很多。为什么呢？来分析原因。当矩阵规模很小的时候会执行串行乘法，而串行乘法的效率会远远好于其他库，这就说明乘法的思路没问题，我觉得是并行 <code>API</code> 设计的不够好，它只支持一维的并行，且不支持额外的自定义，这就导致了这个接口的应用受限，甚至为了使用这个 API 还要执行很多其他的辅助。如果一定要在矩阵乘法中套两次并行，效率会极度低下。</p><h1 id="如何设计多线程-API？"><a href="#如何设计多线程-API？" class="headerlink" title="如何设计多线程 API？"></a>如何设计多线程 API？</h1><p>既然 <code>parallelfor</code> 这么难用，那如果我们是工程师，该如何设计这个接口呢？首先我们要知道，多线程的使用场景多种多样变化无穷，以计算为例，可以以行为单位进行并行，也可以以列为单位，甚至可以以数据块为单位。我想了很久，并没有想出一个很好的方案。也许，我要是能想出来，甲方也不至于提供 <code>parallelfor</code> 这样的 API 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来写什么呢？准备整理一些多线程的东西，虽然多线程相对很熟悉了，可每次工程中都会有新的收获。这次不谈多线程的理论问题，毕竟计算机专业都懂多线程的理论并写过相关程序，也了解其使用的背景。之前使用多线程的时候，总是看一看加速比和结果是否准确就完了，那么这次以多线程使用者和多线程设计者的角度出发，来谈一谈如何更好的使用和设计多线程。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Design" scheme="https://muyuuuu.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>工程开发经验总结二，如果我是甲方，该如何外包？</title>
    <link href="https://muyuuuu.github.io/2021/12/09/project-experience-2/"/>
    <id>https://muyuuuu.github.io/2021/12/09/project-experience-2/</id>
    <published>2021-12-09T11:49:01.000Z</published>
    <updated>2021-12-27T15:08:15.827Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本来是想直接写下的，半路除了点问题，写一篇中吧。具体出了什么意外呢？当然是自己不太熟悉的 <code>git</code> 操作，实在是缺乏和别人一起开发项目的经验。后来又陆续有一些其他的收获，一并整理。</p><a id="more"></a><p>承接上文，在代码开发与测试完成后，其实工作量才完成了一半，对的，你没听错。</p><h2 id="关于代码提交"><a href="#关于代码提交" class="headerlink" title="关于代码提交"></a>关于代码提交</h2><p>提交代码自然而然用的是 <code>git</code>，但是甲方的代码开放程度是不同的，甲方的主代码我们称为 <code>master</code> 分支，每个组有一个 <code>owner</code>，<code>owner</code> 能直接获取 <code>master</code> 的仓库，而开发人员只能获取 <code>owner</code> 的仓库。</p><p>这种操作就导致了一个问题，<strong>代码更新不及时，开发者和甲方沟通低效</strong>。开发者想要更新仓库，就必须先让 <code>owner</code> 更新；甲方提出代码的问题，就必须由 <code>master</code> 转发。</p><p>暂且假设更新成功，本地提交时，创建分支，提交代码，由于没获取 <code>master</code> 仓库的权限，只能由 <code>owner</code> 发起 <code>pull request</code>。而众所周知：一件事情经过的转手次数越多，经过的人员越多，处理速度就越慢。脑补你办一件事情，一张纸要盖很多章，那些人踢皮球的水平超乎你的想象。</p><p>其实这也不能怪 <code>owner</code>，如果这是在公司，上班时间我们开发的会很快；但是这是在学校，且还是研究生，你永远不知道你的老师会在什么时间给你安排什么奇奇怪怪的任务，事情一多就容易耽误，且心累。</p><p>再次假设，<code>pull request</code> 成功了，由于 <code>master</code> 频繁收录提交的代码进行更新，刚刚提交的 <code>pull request</code> 很可能代码冲突，此时就需要手动处理。我尝试了用 <code>gitee</code> 的界面进行处理，结果，呵呵，我们组全部的 <code>pr</code> 被我弄没了，全部重新提交，大型操作失误现场。</p><p>之后尝试用命令行操作，手动处理冲突并提交，<code>pr</code> 处显示没冲突，但是代码审核就是有冲突，冲突的位置我看了一下，本地明明已经处理好了。也许是我 <code>git</code> 操作不熟练，也许是线上环境的问题，很奇怪，最后也没有修复，重新拉取最新，草草提交了。</p><p>这前前后后大概浪费了三天宝贵的时间，这也在提醒我，抽时间学 <code>git</code>。</p><h2 id="关于修改程序"><a href="#关于修改程序" class="headerlink" title="关于修改程序"></a>关于修改程序</h2><p>因为需求性分析搞错了方向，导致我在这上面吃了大亏。当时大概有两种可行路线，一种是 A 路线，一种是 B 路线，两者只是表现形式不一样，但最终结果是一样的。我当时盲目自信，以为都行，就选择了 A 路线。后来个甲方沟通才知道，要实现 B 路线。<strong>这就导致了代码大改，白白的浪费时间和精力。</strong> 以至于为了赶进度，我还叫别人帮我一起改，可真是愧疚。</p><p>实现代码的改动会带动原型定义代码、测试代码的一起变动，难确实不难，恶心是真的恶心。我也第一次体会到，实际开发中，测试代码会比实现代码多的多。而且改代码的时候需要注意，改一点编译一点，不要一次性改一堆然后一次性编译，出错了都不知道是哪错了。</p><p>用一句话总结吧，中国有个成语叫管中窥豹，但也有见微知著，有一叶知秋，也有一叶障目不见泰山，无论如何都有个成语，叫自以为是。</p><h2 id="从甲方的视角看代开发"><a href="#从甲方的视角看代开发" class="headerlink" title="从甲方的视角看代开发"></a>从甲方的视角看代开发</h2><p>因为在开发的过程中遇到了一些困难，不是实现代码的困难，而是理解逻辑的困难。所以引出了这个思考，如果我是甲方，我把项目外放给别人，<strong>我应该怎么描述问题，才能让对面完成的更好？</strong>毕竟花同样一份钱，我希望拿到更好的程序。</p><p>第一点是提前告知项目的所有内容。这次开发有两个任务，第一个任务是开发和测试，第二个任务是适配。当时大家都以为适配很简单，外什么呢？因为一开始根本看不到第二个任务的说明书和文档，只有做完第一个任务才能看到后续任务的文档。相比之下，我们都认为适配会比开发简单的多，所以时间花费不合理，导致在开发浪费的过多的精力。等看到第二个任务的文档时，才发现代码量不会比开发低，但此时已经没有时间了，只能延期。如果是我，我会提前告知，以及在开发期间进行适当的催促。</p><p>第二点是整理常用的编译命令。因为大型项目的编译不是点按钮就能实现了，需要在命令行执行很长的了命令。我会写单独的一个文档，把这些命令从文档的各个角落收集起来，方便开发人员的粘贴。不然翻来翻去太麻烦了，真的。</p><p>最后一点，也是我认为最重要的一点。<strong>在文档之中，而不是文档之前进行一个逻辑说明</strong>，而不是单纯的告诉用户哪个文件的程序该怎么写。为什么呢？配置环境，如何开发等基础文档在这里就先忽略了，不是重点。</p><p>如果把概念性的东西写在最前面，开发者读起来会晕，而且不知所云。放在文档中间，当用户写完程序后，相对有了一定了解，知道代码写的是什么，在看到概念性的东西会比较直观。这就像看当代论文一样，先看摘要和引言，丝毫不知道在说什么，往往看到最后才明白。这其实和中国人的思维不符。举个例子，中国人盖房先打地基，自底向上，外国人盖房先设计房顶，自顶向下。两者都没有错，可中国人习惯了自底向上，被迫看自顶向下的东西不舒服。再举个例子，学计算机网络，是从物理层学到网络层，还是从网络层学到物理层？</p><p>其次，我要告诉用户他写的那些文件之间是什么逻辑。假设有 A B C 三个代码，开发者可能以为 A 会调用 B，为保证运行正确，B 中需要进行初始化操作；但其实呢，A 不会调用 B，B 也不用初始化，因为初始化工作已经在 C 中完成了。相信我，当项目规模十分庞大的时候，复杂的文件以及这些调用关系不是人眼能看出来的。即使能看出来，你也不会相信这种调用关系，不信？我举个例子。A 是测试代码，里面含有正确结果，B 是实现代码，B 需要把返回结果写到数组中，但数组大小未知。</p><ul><li>第一种情况，B 不需要经过运算获得数组大小，直接把结果写到测试代码的结果里面就好。</li><li>第二种情况，B 需要运算并获取数组大小，开辟新的数组，将结果写到新的数组，并返回与测试结果对比。</li></ul><p>正确答案是第一种情况。为什么不用具体实现？实际调用代码的时候没人会给你测试代码提供结果啊？代码不实现功能怎么能行？刚开始我也这么想的，但后来发现在实际使用的时候，会在一个默默无闻的 C 文件的代码中对 B 文件中的代码进行初始化，这就是没有搞清楚逻辑的后果，再次导致了代码的改动，而这种改动是可以在一开始避免的。</p><p>那么对于乙方，如何避免这种情况呢？开发的时候多和身边的人聊一聊，要多问多交流，而不是闷头凭自己的感觉和想象写程序，独行快，众行远。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来是想直接写下的，半路除了点问题，写一篇中吧。具体出了什么意外呢？当然是自己不太熟悉的 &lt;code&gt;git&lt;/code&gt; 操作，实在是缺乏和别人一起开发项目的经验。后来又陆续有一些其他的收获，一并整理。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Design" scheme="https://muyuuuu.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>工程开发经验总结一，如何参与开发？</title>
    <link href="https://muyuuuu.github.io/2021/12/03/project-experience-1/"/>
    <id>https://muyuuuu.github.io/2021/12/03/project-experience-1/</id>
    <published>2021-12-03T15:41:41.000Z</published>
    <updated>2021-12-27T15:08:31.863Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>拖更了两个月，不知道是最近无事发生还是之前太能写了，这期间发生了很多事，现实与虚幻并存，度过目前的难关以后再慢慢吐槽吧。决定更新一篇工程开发经验的文章，无技术细节。</p><p>亿点点项目总结。大概是第一次接这么正规的项目，从代码要求、提交规范、开发流程、开发需求、测试流程到文档撰写，虽然其中有不尽人意的地方，但也算正规。按时间流程说吧。</p><a id="more"></a><h1 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h1><p>首先是明确需求，也就是说知道自己从开始到结束要干什么。开始很简单，配置环境，登陆远程服务器，clone 源代码；中间的开发过程由甲方提供，对我而言就是实现 <code>sspaddmm</code> 算子，并且通过单元测试和性能测试；在开发完成后，需要提交程序、撰写文档和完成适配，这也就是知道自己要干什么。</p><p>不尽人意的地方是：甲方说哪里不明白直接去 github new issue，我也照做了，可惜直到半个月后才回复我。反而直接微信找他聊天反馈更快，这样问题、分析和解答都是私有的，得不到积累和分享，不利于后来者的查阅以及项目的进展。</p><h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>这个对于乙方是重点，那么重点来谈一下。</p><h2 id="关于读文档"><a href="#关于读文档" class="headerlink" title="关于读文档"></a>关于读文档</h2><p>配置环境、clone 源代码就不用说了，都是基础操作。重点是开发，按着文档一步一步来，先写哪个文件，在写哪个文件，不得不说，甲方文档写的好丑。</p><p>如果期间遇到不懂的疑问，可以翻阅文档，也可以查阅相关代码，但是建议查阅代码的 API，为什么呢？文档不是更好吗？我遇到的情况并不是的，众所周知，代码的更新速度是要比文档更新速度快的，代码写完就可以提交，文档要等代码写完后才能写，甚至懒得写，懒得写占大多数情况。程序员最讨厌的四件事：写文档、写注释、别人不写文档、别人不写注释。</p><p>这就导致了一个问题，文档滞后于程序，我甚至发现文档的描述和程序的功能不符，这会造成一定的时间浪费，具体表现在：用户按照文档写程序，结果写到一半发现错了，需要重写；用户不读文档，直接读代码 API 的难度系数又可想而知。</p><p>尽管难度系数大，但也要能读代码，为什么呢？还是回到懒这一话题，工程中很多 API 并没有记录在文档中，换句话说，文档中没有描述的操作，工程含有的 API 也许支持。因此遇到问题时，我们需要找到相关类的定义，可以粗糙的通过见名知意来了解函数的用途。</p><p>这一流程的确帮了我一个大忙。简而言之：我在程序实现的时候必须新开辟空间，修改传入的指针指向的地址，程序结束后，指针还在那里，但不能指向实现中开辟的空间，因为变量是被封装的，不是修改指针指向那么简单。困惑的时候，发现对应的累有 API 可以实现获取修改数据的地址，万事大吉。</p><h2 id="关于实现"><a href="#关于实现" class="headerlink" title="关于实现"></a>关于实现</h2><h3 id="关于参考"><a href="#关于参考" class="headerlink" title="关于参考"></a>关于参考</h3><p>而对于刚接手工程而言，以飞快的速度吃透原理、架构和各个类的各个功能是不现实的，毕竟代码过于庞大。那么这个时候就建议先看工程中有没有类似的实现，做一个参考。这会节省很多的时间，包括 API 阅读、实现逻辑和类设计这三个角度。</p><p>除此之外，还可以参考已有程序，避免造轮子。举个例子，<code>sspaddmm</code> 是要对标 <code>torch.sspaddmm</code> 的，那么就先可以参考 <code>torch.sspaddmm</code> 是如何实现的。借鉴前人千锤百炼的代码，我们能更好的出发。</p><h3 id="关于开发"><a href="#关于开发" class="headerlink" title="关于开发"></a>关于开发</h3><p>无论如何，都会回到具体的程序开发中。这个时候，我推荐的是<strong>迭代式开发</strong>，不要一次性做到尽善尽美，这样后面 debug 的压力会很大，没有任何一个程序员可以保证一次性写千行左右的程序而不报错，我自己说的。</p><p>这个时候写一个最小的程序版，感觉对即可。由于大型工程项目的编译和运行并不像平时点按钮就能运行那么简单。因此，在调试困难的情况下，写完最小程序版通过编译即可，不必关心程序运行结果的正确与否。与此同时，做好 <code>info</code> 的输出，也就是说，在执行各个子模块时，在前面加一句 <code>std::cout &lt;&lt; &quot;run module X&quot; &lt;&lt; std::endl</code>，这样更方便定位到程序哪里出了问题。</p><h2 id="关于测试"><a href="#关于测试" class="headerlink" title="关于测试"></a>关于测试</h2><h3 id="关于单元测试"><a href="#关于单元测试" class="headerlink" title="关于单元测试"></a>关于单元测试</h3><p>在开发中，由于我们没有保证程序的逻辑正确性，这一点可以在测试时完成。因为程序上线之前必须经过严格的测试，测试样例尽可能广泛、极端，保证程序的行覆盖率。生成测试样例和期望输出后，就可以对自己写的程序正确与否进行校对了。</p><p>如果不对，确切而言，99.99% 的情况都是不对的。我是通过缩小单元测试样例的数量和数据量，比如只有一个测试样例，这个测试样例的数据很小，毕竟应该通过常见用例后再去测其他广泛的用例。在凭借 <code>std::cout</code> 一步一步的 debug 后，程序基本没问题了，其中的技术细节不在这里详谈，技术内容会单独写到其他文章中。这里需要注意的是，每次编译运行都比较耗时间，因此多加几个 <code>std::cout</code>，之加一个每次 debug 一小段，太浪费时间。</p><p>单元测试通过后，就可以进行编译部署，将自己的程序部署到工程中。这个时候，我不建议提交代码，因为性能测试还会发现程序的问题，程序还会面临二次修改，这是其一；其二是：有些人自以为是贪功冒进，写一点代码就提交，也不管正确与否，这样别人在 pull 时会拉取到错误的代码，编译时不会通过，这种行为令人做呕。</p><h3 id="关于性能测试"><a href="#关于性能测试" class="headerlink" title="关于性能测试"></a>关于性能测试</h3><p>性能测试就不多说了，批量生成不同大小的数据，记录执行时间，与甲方要求的性能进行对比即可。我当时在这里遇到了很多问题，具体来说一下：</p><p>首先是甲方工程的报错信息不够人性化，说不支持 int 类型，不支持 int 类型你咋不上天呢？后来发现，是性能测试配置文件中有的内容由脚本生成、有的内容直接写到配置文件中导致的。由于数据量大，数据字段由脚本生成，类型字段我直接写到配置文件中了，也就是 int。所以报一个「不支持 int 类型的错误」，我不理解。别问我是怎么发现这个错误的，呵呵。</p><p>之后发现性能测试报错，其报错信息提示「不支持输入类型」，已经有了前车之鉴，我知道真正的错误不会是不支持数据类型，后来发现是：数据格式排列错误，比如 [2] 应该写成 [1, 2]，这些是小错误，可以通过阅读代码来解决。那么大错误呢？比如直接告诉我运行超时，但不可能是运行超时，如何解决？</p><p>一个万能的方案是，看日志。其实写到这里，虽然吐槽甲方程序的缺点，但是能把自定义类型、类的设计、架构设计、各种极端情况的应对 API、单元测试模块、性能测试模块、整合并调用第三方库、报错信息提示和日志收集做的如此系统，虽然有瑕疵，但也可圈可点，这其中使用了多少设计模式，细思极恐。也不知道什么时候我才能有这么强的工程能力，成为一个工程的总设计师得多厉害。</p><p>回到看日志这一话题，我发现导致超时的原因是：core dumped，一个喜闻乐见的错误。再次回到实现部分的代码加上 <code>std::cout</code> 进行 debug。结果发现是开辟内存空间出错了，怀疑单元测试和性能测试用的链接库不是同一个。换成更加安全的内存开辟方法，bug 解决了。</p><p>但是发现性能比 <code>pytorch</code> 弱了不少，这个时候继续迭代开发。给程序增加多线程功能，读到这里，也许你能更好的明白：「为什么不要急着提交程序」，你以为的程序正确，但也只是你以为的，后期还有很大概率要完善和修改。修改完毕后，记得回头去执行单元测试，因为修改代码后很可能导致单元测试无法通过。</p><p>增加多线程的时候，回顾操作系统，多线程访问变量的弊端，因此很轻松能确定什么时候加多线程，什么时候不加。因为只能使用被封装的多线程库，不能自己手写，所以有些地方不方便加锁。至此，程序开发的东西告以结束，性能比 <code>pytorch</code> 快了两倍。前前后后花费了大约 20 天的时间，也收获了不少东西，做此记录。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拖更了两个月，不知道是最近无事发生还是之前太能写了，这期间发生了很多事，现实与虚幻并存，度过目前的难关以后再慢慢吐槽吧。决定更新一篇工程开发经验的文章，无技术细节。&lt;/p&gt;
&lt;p&gt;亿点点项目总结。大概是第一次接这么正规的项目，从代码要求、提交规范、开发流程、开发需求、测试流程到文档撰写，虽然其中有不尽人意的地方，但也算正规。按时间流程说吧。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Design" scheme="https://muyuuuu.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的智能指针</title>
    <link href="https://muyuuuu.github.io/2021/11/22/cpp-intelligence-pointer/"/>
    <id>https://muyuuuu.github.io/2021/11/22/cpp-intelligence-pointer/</id>
    <published>2021-11-22T13:52:30.000Z</published>
    <updated>2022-05-16T15:32:51.522Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>承接移动语义，来更新智能指针，上文说到 <code>unique_ptr</code> 也会用到移动语义的东西。由于 C++ 语言没有自动内存回收机制，程序员每次 <code>new</code> 出来的内存都要手动 <code>delete</code>，一旦忘记 <code>delete</code> 或者程序过早退出而没有 <code>delete</code>，导致内存泄漏总是不好的。内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存，从而造成了内存的浪费。</p><p>所以，能不能有一种东西的存在，使用 <code>new</code> 创建对象后，对象作用域消失时，能不能自动析构并调用 <code>delete</code>？手动管理过程繁琐且容易出错，那么尝试通过智能指针来实现这一管理过程。</p><a id="more"></a><h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><p><code>std::unique_ptr</code> 是通过指针独占式拥有或严格拥有并管理另一对象，建立了所有权的概念，一个智能指针只能拥有一个对象，一个对象也只能被一个智能指针所拥有，这样智能指针消失时，就会 <code>delete</code> 对象，并在 <code>unique_ptr</code> 离开作用域或拥有的最后一个资源被销毁时释放。</p><p>赋值时，对象的所有权会转让，也就是<strong>移动赋值</strong>，因为所有权独享所以删除了拷贝构造，只能通过 <code>move</code> 实现移动所有权。应用场景：对象延迟销毁，可以将对象转移到另一个线程释放，不影响主线程。来看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; <span class="title">ps</span> <span class="params">(a)</span></span>;</span><br><span class="line">    ps-&gt;show();</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="comment">// 错误，因为管理的资源被释放</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (ps.get() == <span class="literal">nullptr</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 移动所有权</span></span><br><span class="line">    <span class="keyword">auto</span> ps1 = <span class="built_in">std</span>::move(ps);</span><br><span class="line">    ps1-&gt;show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    demo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>智能指针和指针一样，可以解引用，或者访问类成员。不过智能指针指向的对象必须位于堆区，否则 <code>delete</code> 时会发生错误。</p><p>智能指针的构造函数有 <a href="https://muyuuuu.github.io/2021/07/21/constructor-and-destructor-with-inheritance/"><code>explicit</code></a> 修饰，因此不能发生隐式转换，也就是说，下面的语句是错误的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>* pr = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span>&gt; ptr;</span><br><span class="line">ptr = pr; <span class="comment">// not allowed, implicit conversion</span></span><br></pre></td></tr></table></figure><p>然后顺手看了官网的 <code>API</code>，比较常用的是 <code>release</code>， <code>swap</code> 和 <code>reset</code> 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    A() = <span class="keyword">default</span>;</span><br><span class="line">    A(<span class="keyword">int</span> c) : a&#123;c&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> A(<span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; <span class="title">up2</span><span class="params">(<span class="keyword">new</span> A(<span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 交换对象 </span></span><br><span class="line">    up1.swap(up2);</span><br><span class="line">    up1-&gt;show(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// deletes managed object, acquires new pointer</span></span><br><span class="line">    up1.reset (<span class="keyword">new</span> A(<span class="number">3</span>));       </span><br><span class="line">    up1-&gt;show(); <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// deletes managed object</span></span><br><span class="line">    up1.reset();               </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> A(<span class="number">14</span>))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"About to release Foo...\n"</span>;</span><br><span class="line">    <span class="comment">// release 对象给别人</span></span><br><span class="line">    A* fp = up.release();</span><br><span class="line">    fp-&gt;show(); <span class="comment">// 14</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><p><code>shared_ptr</code> 使用引用计数，记录多个指针可以指向一个对象，即多个 <code>shared_ptr</code> 共同管理一个对象，仅当最后一个指针消失时，调用 <code>delete</code>。</p><p>因此，<code>shared_ptr</code> 对象除了包括一个所拥有对象的指针外，还必须包括一个引用计数代理对象的指针，通过计数实现对象的最后一个拥有着有责任销毁对象，并清理与该对象相关的所有资源；且时间上的开销主要在初始化和拷贝操作上，因为不能像移动语义那样移动所有权。但这也造就了 <code>shared_ptr</code> 独特的应用场景：</p><ol><li>共享权不明，多个对象管理同一个内存。举个例子，实验室的所有人共同拥有空调，空调的所有权不属于某一个人，但最后一个人走的时候要关空调。</li><li>如果一个对象的复制操作很费时，同时我们又需要在函数间传递这个对象，我们往往会选择传递指向这个对象的指针来代替传递对象本身，以此来避免对象的复制操作。既然选择使用指针，那么使用 <code>shared_ptr</code> 是一个更好的选择，即起到了向函数传递对象的作用，又不用为释放对象操心。</li><li><code>shared_ptr</code> 支持在构造的时候传入一个定制删除器，替代 <code>delete</code> 在生命周期结束时调用，以此实现 <code>RAII</code> 的思想，即资源的有效期与持有资源的对象的生命期严格绑定，将资源的获取放在类的构造函数里，资源的释放放在类的析构函数里。在类的生存期结束的时候，析构函数会被自动调用，对应的资源将会释放。</li><li>把指针存入标准库容器时，如果容器中保存的是普通指针，当我们在清空某个容器时，先要释放容器中指针所指向的资源，然后才能清空这些指针本身。如果普通指针替换成相应 <code>shared_ptr</code>，容器的 <code>clear()</code> 清空 <code>shared_ptr</code>，而随着 <code>shared_ptr</code> 的释放，它会自动释放它所管理的资源，而无需我们主动去释放。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tranditionally </span></span><br><span class="line">FILE *fp = fopen(<span class="string">"./1.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"><span class="comment">// 通过使用定制删除器, 将删除器作为回调函数传入</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span> <span class="title">fp1</span><span class="params">(fopen(<span class="string">"./1.txt"</span>,<span class="string">"r"</span>), fclose)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h1><p><code>weak_ptr</code> 允许共享但不拥有某对象，指向 <code>shared_ptr</code> 指针指向的对象的内存，却并不拥有该内存。在使用的时候检查一下指针的有效性。一旦最后一个共享该对象的智能指针失去了所有权，任何 <code>weak_ptr</code> 的 <code>lock()</code> 方法返回 <code>nullptr</code>。因此，在 <code>default</code> 和 <code>copy</code> 构造函数之外，<code>weak_ptr</code> 只提供接受一个 <code>shared_ptr</code> 的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Check</span><span class="params">(weak_ptr&lt;<span class="keyword">int</span>&gt; &amp;wp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp = wp.lock(); <span class="comment">// 重新获得shared_ptr对象</span></span><br><span class="line">    <span class="keyword">if</span> (sp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The value is "</span> &lt;&lt; *sp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Pointer is invalid."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1;</span><br><span class="line">    weak_ptr&lt;<span class="keyword">int</span>&gt; wp = sp1; <span class="comment">// 指向sp1所指向的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *sp1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Check(wp);</span><br><span class="line"></span><br><span class="line">    sp1.reset(); <span class="comment">// 释放所管理的对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Check(wp);</span><br><span class="line"></span><br><span class="line">    sp2.reset();</span><br><span class="line">    Check(wp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以应用于对象可能失效的场景，可打破<a href="https://muyuuuu.github.io/2022/05/03/python-gc/">循环引用</a> <code>cycles of references</code> 的问题。</p><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>题外话，我们可以通过观察来发现程序是否存在内存泄漏：程序长时间运行后内存占用率一直不断的缓慢的上升，而实际上在你的逻辑中并没有这么多的内存需求。至于手动解决内存泄漏，一般的方法是：</p><ol><li>查询 <code>new</code> 与 <code>delete</code>，看看内存的申请与释放是不是成对释放的</li><li>如果依旧发生内存泄露，可以通过记录申请与释放的对象数目是否一致来判断。在类中追加一个静态变量 <code>static int count</code>，在构造函数中执行 <code>count++</code>，在析构函数中执行 <code>count--</code>，通过在程序结束前将所有类析构，之后输出静态变量，看 <code>count</code> 的值是否为 0。</li><li>检查类中申请的空间是否完全释放，尤其是存在继承父类的情况，看看子类中是否调用了父类的析构函数，有可能会因为子类析构时没有释放父类中申请的内存空间，这里建议将父类的析构函数声明为<a href="https://muyuuuu.github.io/2021/07/21/constructor-and-destructor-with-inheritance/">虚函数</a>，否则可能不会调用子类的析构函数。</li><li>对于函数中申请的临时空间，认真检查，是否存在提前跳出函数的地方没有释放内存。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://juejin.cn/post/6844903993055920141" target="_blank" rel="noopener">如何解决内存泄漏</a></li><li><a href="https://zhuanlan.zhihu.com/p/56874877" target="_blank" rel="noopener"><code>shared_ptr</code> 指针释放</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;承接移动语义，来更新智能指针，上文说到 &lt;code&gt;unique_ptr&lt;/code&gt; 也会用到移动语义的东西。由于 C++ 语言没有自动内存回收机制，程序员每次 &lt;code&gt;new&lt;/code&gt; 出来的内存都要手动 &lt;code&gt;delete&lt;/code&gt;，一旦忘记 &lt;code&gt;delete&lt;/code&gt; 或者程序过早退出而没有 &lt;code&gt;delete&lt;/code&gt;，导致内存泄漏总是不好的。内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存，从而造成了内存的浪费。&lt;/p&gt;
&lt;p&gt;所以，能不能有一种东西的存在，使用 &lt;code&gt;new&lt;/code&gt; 创建对象后，对象作用域消失时，能不能自动析构并调用 &lt;code&gt;delete&lt;/code&gt;？手动管理过程繁琐且容易出错，那么尝试通过智能指针来实现这一管理过程。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
</feed>
