<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just for Life.</title>
  
  <subtitle>明月更几时</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muyuuuu.github.io/"/>
  <updated>2021-12-09T12:25:16.724Z</updated>
  <id>https://muyuuuu.github.io/</id>
  
  <author>
    <name>兰铃</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工程开发经验总结：中</title>
    <link href="https://muyuuuu.github.io/2021/12/09/project-experience-2/"/>
    <id>https://muyuuuu.github.io/2021/12/09/project-experience-2/</id>
    <published>2021-12-09T11:49:01.000Z</published>
    <updated>2021-12-09T12:25:16.724Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本来是想直接写下的，半路除了点问题，写一篇中吧。具体出了什么意外呢？当然是自己不太熟悉的 <code>git</code> 操作，实在是缺乏和别人一起开发项目的经验。</p><a id="more"></a><p>乘接上文，在代码开发与测试完成后，其实工作量才完成了一半，对的，你没听错。</p><h2 id="关于代码提交"><a href="#关于代码提交" class="headerlink" title="关于代码提交"></a>关于代码提交</h2><p>提交代码自然而然用的是 <code>git</code>，但是甲方的代码开放程度是不同的，甲方的主代码我们称为 <code>master</code> 分支，每个组有一个 <code>owner</code>，<code>owner</code> 能直接获取 <code>master</code> 的仓库，而开发人员只能获取 <code>owner</code> 的仓库。</p><p>这种操作就导致了一个问题，代码更新不及时。开发者想要更新仓库，就必须先让 <code>owner</code> 更新。</p><p>暂且假设更新成功，本地提交时，创建分支，提交代码，由于没获取 <code>master</code> 仓库的权限，只能由 <code>owner</code> 发起 <code>pull request</code>。众所周知：一件事情经过的转手次数越多，经过的人员越多，处理速度就越慢，脑补一张纸要盖很多章，那些人踢皮球的水平超乎你的想象。</p><p>其实这也不能怪 <code>owner</code>，如果这是在公司，上班时间我们开发的会很快；但是这是在学校，且还是研究生，你永远不知道你的老师会在什么时间给你安排什么奇奇怪怪的任务，事情一多就容易耽误，且心累。</p><p>再假设，<code>pull request</code> 成功了，由于 <code>master</code> 频繁收录提交的代码进行更新，刚刚提交的 <code>pull request</code> 很可能代码冲突，此时就需要手动处理。</p><p>我尝试了用 <code>gitee</code> 的界面进行处理，结果，呵呵，我们组全部的 <code>pr</code> 被我弄没了，全部重新提交，大型操作失误现场。</p><p>之后尝试用命令行操作，手动处理冲突并提交，<code>pr</code> 处显示没冲突，但是代码审核就是有冲突，冲突的位置我看了一下，本地明明已经处理好了。也许是我 <code>git</code> 操作不熟练，但是就很奇怪，最后也没有修复，重新拉取最新，草草提交了。</p><p>这前前后后大概浪费了三天宝贵的时间，这也在提醒我，抽时间学 <code>git</code>。</p><h2 id="关于程序实现"><a href="#关于程序实现" class="headerlink" title="关于程序实现"></a>关于程序实现</h2><p>发现写完「代码提交」文章很短，有水文章的嫌疑，所以决定用简洁明了的语言说一下我是怎么实现的 <code>sspaddm</code> 算子。</p><p>我们来具体看一下这个算子的运算：<code>beta * input + alpha mat1 * mat2</code>，并返回一个稀疏矩阵。其中 <code>beta, alpha</code> 是标量形式的系数，<code>input, mat1</code> 是二维的稀疏矩阵，形式和 <code>torch</code> 的是一样的，<code>mat2</code> 是二维的稠密矩阵。</p><h3 id="稀疏矩阵的表示"><a href="#稀疏矩阵的表示" class="headerlink" title="稀疏矩阵的表示"></a>稀疏矩阵的表示</h3><p>首先来看稀疏矩阵的表示，一个稀疏矩阵有三个元素组成，第一个元素是 <code>indices</code>，顾名思义表示哪些索引的位置有数值，其余位置的数值都是 0，形状是 <code>2XN</code>，<code>N</code> 是元素个数。另一个元素是 <code>values</code>，也就是数值是多少，形状是 <code>N</code>。第三个元素是 <code>shape</code>，表示稀疏矩阵的大小。</p><h3 id="参数检验"><a href="#参数检验" class="headerlink" title="参数检验"></a>参数检验</h3><p>其实重点检验的就两部分，稀疏矩阵的 <code>indices</code> 和 <code>values</code> 元素数量是否相等；对于 <code>indices</code> 中的元素，是否超过了 <code>shape</code>，俗称越界检查。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>来到激动人心的地方。实现需要注意的是，这个算子要返回稀疏矩阵，程序内部传入了要返回的地址空间。</p><p>第一步，实现标量与稀疏矩阵的乘法，这一步系数乘以稀疏矩阵的数值就可以了，将结果存写到稀疏矩阵的数值的地址空间内，很简单。</p><p>第二步，实现稀疏矩阵与稠密矩阵的乘法，把稀疏矩阵看成稠密矩阵，这就是矩阵乘法了。首先可以确定的是，我们能知道矩阵乘法后有多少个元素，假设有 <code>ce</code> 个，那么将「输出地址」的空间扩容到 <code>ce</code> 个，将结果直接写入到扩容后的输出地址空间。为什么不一开始就设置输出地址的空间大小？因为不进行运算，是不知道真正的空间大小是后多少的，如果提前通过计算得知开辟空间的大小，这也就相当于多实现了一运算，没意义。</p><p>其实在这里我又复习了一下 C 语言如何开辟地址空间，当时学 C 语言和数据结构的时候觉的这些知识没用，就没好好学，都在几年后的一晚还了回来。</p><p>第三步就是稀疏矩阵的加法，这一步更加简单，将输出地址的空间再次扩容，假设经过矩阵乘法后的地址空间大小为 <code>ce1</code>，<code>input</code> 稀疏矩阵的大小是 <code>ce2</code>，那么扩容的大小就是 <code>ce1 + ce2</code>，将两者的结果直接拷贝到新扩容的空间即可。</p><p>你也许会有疑问，如果 <code>input</code> 中的元素和 <code>mat1*mat2</code> 中的元素有冲突怎么办？比如说两者在索引 <code>[1,1]</code> 处两者都有数值，不进行去重和求和吗？我刚开始也是这么想的，使用了二维的 <code>map</code> 进行去重，结果发现对标的 <code>torch</code> 都没有去重，想想还是算了。</p><p>下一篇会更新一个 <code>C++</code> 的黑魔法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来是想直接写下的，半路除了点问题，写一篇中吧。具体出了什么意外呢？当然是自己不太熟悉的 &lt;code&gt;git&lt;/code&gt; 操作，实在是缺乏和别人一起开发项目的经验。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Design" scheme="https://muyuuuu.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>工程开发经验总结：上</title>
    <link href="https://muyuuuu.github.io/2021/12/03/project-experience-1/"/>
    <id>https://muyuuuu.github.io/2021/12/03/project-experience-1/</id>
    <published>2021-12-03T15:41:41.000Z</published>
    <updated>2021-12-09T11:47:30.523Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>拖更了两个月，不知道是最近无事发生还是之前太能写了，这期间发生了很多事，现实与虚幻并存，度过目前的难关以后再慢慢吐槽吧。决定更新一篇工程开发经验的文章，无技术细节。</p><p>亿点点项目总结。大概是第一次接这么正规的项目，从代码要求、提交规范、开发流程、开发需求、测试流程到文档撰写，虽然其中有不尽人意的地方，但也算正规。按时间流程说吧。</p><a id="more"></a><h1 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h1><p>首先是明确需求，也就是说知道自己从开始到结束要干什么。开始很简单，配置环境，登陆远程服务器，clone 源代码；中间的开发过程由甲方提供，对我而言就是实现 <code>sspaddmm</code> 算子，并且通过单元测试和性能测试；在开发完成后，需要提交程序、撰写文档和完成适配，这也就是知道自己要干什么。</p><p>不尽人意的地方是：甲方说哪里不明白直接去 github new issue，我也照做了，可惜直到半个月后才回复我。反而直接微信找他聊天反馈更快，这样问题、分析和解答都是私有的，得不到积累和分享，不利于后来者的查阅以及项目的进展。</p><h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>这个对于乙方是重点，那么重点来谈一下。</p><h2 id="关于读文档"><a href="#关于读文档" class="headerlink" title="关于读文档"></a>关于读文档</h2><p>配置环境、clone 源代码就不用说了，都是基础操作。重点是开发，按着文档一步一步来，先写哪个文件，在写哪个文件，不得不说，甲方文档写的好丑。</p><p>如果期间遇到不懂的疑问，可以翻阅文档，也可以查阅相关代码，但是建议查阅代码的 API，为什么呢？文档不是更好吗？我遇到的情况并不是的，众所周知，代码的更新速度是要比文档更新速度快的，代码写完就可以提交，文档要等代码写完后才能写，甚至懒得写，懒得写占大多数情况。程序员最讨厌的四件事：写文档、写注释、别人不写文档、别人不写注释。</p><p>这就导致了一个问题，文档滞后于程序，我甚至发现文档的描述和程序的功能不符，这会造成一定的时间浪费，具体表现在：用户按照文档写程序，结果写到一半发现错了，需要重写；用户不读文档，直接读代码 API 的难度系数又可想而知。</p><p>尽管难度系数大，但也要能读代码，为什么呢？还是回到懒这一话题，工程中很多 API 并没有记录在文档中，换句话说，文档中没有描述的操作，工程含有的 API 也许支持。因此遇到问题时，我们需要找到相关类的定义，可以粗糙的通过见名知意来了解函数的用途。</p><p>这一流程的确帮了我一个大忙。简而言之：我在程序实现的时候必须新开辟空间，修改传入的指针指向的地址，程序结束后，指针还在那里，但不能指向实现中开辟的空间，因为变量是被封装的，不是修改指针指向那么简单。困惑的时候，发现对应的累有 API 可以实现获取修改数据的地址，万事大吉。</p><h2 id="关于实现"><a href="#关于实现" class="headerlink" title="关于实现"></a>关于实现</h2><h3 id="关于参考"><a href="#关于参考" class="headerlink" title="关于参考"></a>关于参考</h3><p>而对于刚接手工程而言，以飞快的速度吃透原理、架构和各个类的各个功能是不现实的，毕竟代码过于庞大。那么这个时候就建议先看工程中有没有类似的实现，做一个参考。这会节省很多的时间，包括 API 阅读、实现逻辑和类设计这三个角度。</p><p>除此之外，还可以参考已有程序，避免造轮子。举个例子，<code>sspaddmm</code> 是要对标 <code>torch.sspaddmm</code> 的，那么就先可以参考 <code>torch.sspaddmm</code> 是如何实现的。借鉴前人千锤百炼的代码，我们能更好的出发。</p><h3 id="关于开发"><a href="#关于开发" class="headerlink" title="关于开发"></a>关于开发</h3><p>无论如何，都会回到具体的程序开发中。这个时候，我推荐的是<strong>迭代式开发</strong>，不要一次性做到尽善尽美，这样后面 debug 的压力会很大，没有任何一个程序员可以保证一次性写千行左右的程序而不报错，我自己说的。</p><p>这个时候写一个最小的程序版，感觉对即可。由于大型工程项目的编译和运行并不像平时点按钮就能运行那么简单。因此，在调试困难的情况下，写完最小程序版通过编译即可，不必关心程序运行结果的正确与否。与此同时，做好 <code>info</code> 的输出，也就是说，在执行各个子模块时，在前面加一句 <code>std::cout &lt;&lt; &quot;run module X&quot; &lt;&lt; std::endl</code>，这样更方便定位到程序哪里出了问题。</p><h2 id="关于测试"><a href="#关于测试" class="headerlink" title="关于测试"></a>关于测试</h2><h3 id="关于单元测试"><a href="#关于单元测试" class="headerlink" title="关于单元测试"></a>关于单元测试</h3><p>在开发中，由于我们没有保证程序的逻辑正确性，这一点可以在测试时完成。因为程序上线之前必须经过严格的测试，测试样例尽可能广泛、极端，保证程序的行覆盖率。生成测试样例和期望输出后，就可以对自己写的程序正确与否进行校对了。</p><p>如果不对，确切而言，99.99% 的情况都是不对的。我是通过缩小单元测试样例的数量和数据量，比如只有一个测试样例，这个测试样例的数据很小，毕竟应该通过常见用例后再去测其他广泛的用例。在凭借 <code>std::cout</code> 一步一步的 debug 后，程序基本没问题了，其中的技术细节不在这里详谈，技术内容会单独写到其他文章中。这里需要注意的是，每次编译运行都比较耗时间，因此多加几个 <code>std::cout</code>，之加一个每次 debug 一小段，太浪费时间。</p><p>单元测试通过后，就可以进行编译部署，将自己的程序部署到工程中。这个时候，我不建议提交代码，因为性能测试还会发现程序的问题，程序还会面临二次修改，这是其一；其二是：有些人自以为是贪功冒进，写一点代码就提交，也不管正确与否，这样别人在 pull 时会拉取到错误的代码，编译时不会通过，这种行为令人做呕。</p><h3 id="关于性能测试"><a href="#关于性能测试" class="headerlink" title="关于性能测试"></a>关于性能测试</h3><p>性能测试就不多说了，批量生成不同大小的数据，记录执行时间，与甲方要求的性能进行对比即可。我当时在这里遇到了很多问题，具体来说一下：</p><p>首先是甲方工程的报错信息不够人性化，说不支持 int 类型，不支持 int 类型你咋不上天呢？后来发现，是性能测试配置文件中有的内容由脚本生成、有的内容直接写到配置文件中导致的。由于数据量大，数据字段由脚本生成，类型字段我直接写到配置文件中了，也就是 int。所以报一个「不支持 int 类型的错误」，我不理解。别问我是怎么发现这个错误的，呵呵。</p><p>之后发现性能测试报错，其报错信息提示「不支持输入类型」，已经有了前车之鉴，我知道真正的错误不会是不支持数据类型，后来发现是：数据格式排列错误，比如 [2] 应该写成 [1, 2]，这些是小错误，可以通过阅读代码来解决。那么大错误呢？比如直接告诉我运行超时，但不可能是运行超时，如何解决？</p><p>一个万能的方案是，看日志。其实写到这里，虽然吐槽甲方程序的缺点，但是能把自定义类型、类的设计、架构设计、各种极端情况的应对 API、单元测试模块、性能测试模块、整合并调用第三方库、报错信息提示和日志收集做的如此系统，虽然有瑕疵，但也可圈可点，这其中使用了多少设计模式，细思极恐。也不知道什么时候我才能有这么强的工程能力，成为一个工程的总设计师得多厉害。</p><p>回到看日志这一话题，我发现导致超时的原因是：core dumped，一个喜闻乐见的错误。再次回到实现部分的代码加上 <code>std::cout</code> 进行 debug。结果发现是开辟内存空间出错了，怀疑单元测试和性能测试用的链接库不是同一个。换成更加安全的内存开辟方法，bug 解决了。</p><p>但是发现性能比 <code>pytorch</code> 弱了不少，这个时候继续迭代开发。给程序增加多线程功能，读到这里，也许你能更好的明白：「为什么不要急着提交程序」，你以为的程序正确，但也只是你以为的，后期还有很大概率要完善和修改。修改完毕后，记得回头去执行单元测试，因为修改代码后很可能导致单元测试无法通过。</p><p>增加多线程的时候，回顾操作系统，多线程访问变量的弊端，因此很轻松能确定什么时候加多线程，什么时候不加。因为只能使用被封装的多线程库，不能自己手写，所以有些地方不方便加锁。至此，程序开发的东西告以结束，性能比 <code>pytorch</code> 快了两倍。前前后后花费了大约 20 天的时间，也收获了不少东西，做此记录。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拖更了两个月，不知道是最近无事发生还是之前太能写了，这期间发生了很多事，现实与虚幻并存，度过目前的难关以后再慢慢吐槽吧。决定更新一篇工程开发经验的文章，无技术细节。&lt;/p&gt;
&lt;p&gt;亿点点项目总结。大概是第一次接这么正规的项目，从代码要求、提交规范、开发流程、开发需求、测试流程到文档撰写，虽然其中有不尽人意的地方，但也算正规。按时间流程说吧。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Design" scheme="https://muyuuuu.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>一些攻击算法</title>
    <link href="https://muyuuuu.github.io/2021/09/22/some-attack-methods/"/>
    <id>https://muyuuuu.github.io/2021/09/22/some-attack-methods/</id>
    <published>2021-09-22T07:15:31.000Z</published>
    <updated>2021-11-09T12:00:18.710Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>又又又摸了几天，写了个爬虫，还是回来看论文了。整理一些常见的基于生成的攻击算法，之后再看一些较新的论文，就开始写自己的论文了，<del>早日毕业吧</del>。</p><a id="more"></a><h1 id="Natural-ADV"><a href="#Natural-ADV" class="headerlink" title="Natural ADV"></a>Natural ADV</h1><p>GENERATING NATURAL ADVERSARIAL EXAMPLES，发表在 ICLR 2018。众所周知，神经网络的输入层含有的信息和和隐层含有的信息是不同的，且常见攻击算法生成的对抗样本并不具有语义特征。所以这篇论文尝试生成 natural 的对抗样本。</p><p>与传统算法不同的是：传统算法在输入空间搜索对抗样本，而本文的算法尝试在隐空间进行搜索。即输入的为干净样本的分布 $P(x)$，搜索一个 $z^\star$，并通过生成器将其映射回 $x^\star$，并期望对抗样本是合法且和原始输入较为接近。</p><p>为了达到这个目标，作者选用 WGAN 作为生成器。首先训练一个 $G$，可以由 $z$ 生成 $x$；同时训练一个与 $G$ 相反的 $I$，由 $x$ 生成 $z$。通过最小化重构 $x$ 和 $z$ 与 $I(G(z))$ 的误差作为损失函数训练模型。</p><p><img data-src="https://z3.ax1x.com/2021/09/22/4US1kF.png" alt></p><p>之后便是对抗样本的生成方法，使用生成器来判断当前的噪音是否能欺骗分类器，即在 $f(G(z’)) \neq f(x)$ 的情况下，选择一个 $z’$，这个 $z’$ 和 $I(x)$ 最为接近，那么对抗样本就是 $x^\star=G(z’)$。那么问题来了，如何搜索 $z’$ 呢？论文提出了两种搜索算法，都是直接在干净样本对应的隐向量 $z$ 上增加扰动，如果扰动可以成功的攻击分类器，那么就认为搜索到了 $z’$。</p><p><img data-src="https://z3.ax1x.com/2021/09/22/4U9gdf.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又又又摸了几天，写了个爬虫，还是回来看论文了。整理一些常见的基于生成的攻击算法，之后再看一些较新的论文，就开始写自己的论文了，&lt;del&gt;早日毕业吧&lt;/del&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>基于数据分布的对抗防御和攻击</title>
    <link href="https://muyuuuu.github.io/2021/09/07/data-dis-attack-defense/"/>
    <id>https://muyuuuu.github.io/2021/09/07/data-dis-attack-defense/</id>
    <published>2021-09-07T12:20:30.000Z</published>
    <updated>2021-09-18T10:58:30.515Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在做对抗训练的时候，我时常在想一个问题：PGD、CW 这些攻击算法都会设置迭代步长和阈值，如果模型固定、参数固定，那么每次生成的对抗样本也会是一样的。如果使用 min-max 的方式进行对抗训练，那么模型可能会只认识在某一设置下的数据，如果面对新的分布攻击样本，如 ZOO, UAP, Deepfool 等，岂不是不能很好的防御？</p><p>这就又会回到小样本问题，总不能对所有的攻击算法在不同阈值下都生成对抗样本，而应该生成分布尽可能广泛的对抗样。既然提到生成，就不得不考虑 GAN，所以搜了些相关论文，并作整理。注意，所有论文我没看代码，所以不评价好与坏，在不久的将来如果我要发论文，肯定还会做对比算法，到时候回来评价各个算法。未完待续。</p><a id="more"></a><h1 id="advFlow"><a href="#advFlow" class="headerlink" title="advFlow"></a>advFlow</h1><p>AdvFlow: Inconspicuous Black-box Adversarial Attacks using Normalizing Flows, NIPS 2020。</p><p>这篇论文提出使用 normal flow 模型来生成对抗样本实现内部的 max。使得生成的对抗样本能围绕在干净样本附近，生成的对抗扰动能捕获图片信息，换句话说，可以根据图片信息来生成对抗扰动。</p><p><img data-src="https://z3.ax1x.com/2021/09/07/hozhMq.png" alt></p><p>首先预训练一个神经网络 $f$，这个网络是可逆的：</p><ul><li>输入为一随机分布 $z$，而后产生 $x$;</li><li>输入为干净样本 $x$，输入是随机分布 $z$</li></ul><p>整个流程如下：（这篇论文的 github 提供了 gif 来描述这个流程）</p><p>输入干净样本，经过 $f^{-1}$ 得到均值和方差下的噪音，将噪音再次经过 $f$ 得到对抗样本，将对抗样本输入目标模型，使用损失来更新均值和方差。以此来实现对抗训练。其中的损失、网络细节我没有看。</p><h1 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h1><p>Adversarial Distributional Training for Robust Deep Learning, NIPS 2020。</p><p>这篇论文和我的关注点一样，果然发顶会手要快。作者认为：对抗训练可不可以理解为数据增强？单个攻击算法并不能代表全部的对抗样本，所以作者提出了 ADT，通过增加熵正则化项，来获取潜在的分布在干净样本周围的对抗样本。以此来作为内部最大化，好的攻击算法才能产生更好的鲁棒性。</p><p>由于单个攻击算法不能覆盖全部的扰动，为了避免这个问题，应该找到干净样本附近的对抗样本的分布，而不是单纯的找到一个对抗样本。</p><p><img data-src="https://z3.ax1x.com/2021/09/07/hTCI1J.png" alt></p><p>如上图所示，蓝色点是 PGD 产生的对抗样本，黄色点是 ADT 产生的对抗样本。为了使对抗样本的分布具有多样性，增加了熵作为模型损失的一部分，众所周知，熵能衡量系统的稳定性，熵越大越不稳定。也就是，对抗样本的产生方式为：</p><p>\begin{equation}<br>E[L(f(x+\delta), y)] + \lambda H(p(\delta))<br>\end{equation}</p><p>$\delta$ 是对抗扰动，由高斯噪音分布并经过 $\text{tanh}$ 函数映射而来。相对于单个攻击算法，上述公式能更好的探索对抗扰动的分布。</p><h1 id="AGAT"><a href="#AGAT" class="headerlink" title="AGAT"></a>AGAT</h1><p>Attribute-Guided Adversarial Training for Robustness to Natural Perturbations，发表在 AAAI 2021。</p><p>在许多情况下，并不能获得全部的对抗样本，如果预测的对抗样本和训练的对抗样本没有来自同一分布，就会导致鲁棒性的下降。所以本文提出的对抗训练算法中，在内部最大化时，操纵图像属性空间的变化，这样训练出来的模型更具鲁棒性。</p><p>这里的属性空间是：翻转算一个属性空间，缩放算一个属性空间，颜色变化又算另一个属性空间。</p><p>本文使用的扰动是自然扰动，如图片尺寸和颜色的改变；缩放、旋转、腐蚀等。传统攻击算法的扰动有时会不满足 $\Vert x-x’ \Vert \leq \epsilon$ 的限制，且 $\epsilon$ 太大太小都不好，太小了没扰动效果，太大了图像会失真。但是本文的算法能有效的处理自然的扰动，使用 DNN 来生成扰动（看后文的意思是，输入图像，输出对抗样本）。</p><p><strong>这篇论文好多话写的我也不明所以</strong>，只能说大概流程是：前 N 个 epoch 训练干净样本，后面几个 epoch 训练对数据以迭代的形式进行扰动增强，而扰动增强这里我感觉很玄学。损失为最小化图像的分类损失、以及最大化干净样本与对抗样本在隐层的差异，以及通过 $L_2$ 范数限制扰动 $\alpha$ 的范围。</p><h1 id="advGAN"><a href="#advGAN" class="headerlink" title="advGAN"></a>advGAN</h1><p>Generating Adversarial Examples with Adversarial Networks，发表在 IJCAI 2018，使用 GAN 来生成对抗样本。</p><p>通过 GAN 来生成围绕着原始实例的高质量扰动来产生对抗样本，判别器来把关生成图像的质量。</p><p><img data-src="https://z3.ax1x.com/2021/09/08/hbA4bQ.png" alt></p><p>这个图已经把论文的含义表达的差不多了，思路也是简洁明了。输入原始图像，生成扰动并叠加至干净样本。和我最开始的构思一样，可惜被别人发表了。损失函数由三部分组成，一部分是对抗样本的分类损失，一部分是 GAN 的生成和判别损失，一部分是对抗扰动的范围损失，希望扰动范围越大越好。</p><h1 id="advGAN-1"><a href="#advGAN-1" class="headerlink" title="advGAN++"></a>advGAN++</h1><p>AdvGAN++ : Harnessing latent layers for adversary generation 发表在 ICCV 2019，是基于 advGAN 的改进，之前的 advGAN 是读取全部图像生成对抗扰动，这篇论文发现读取图像的隐层表示生成的对抗扰动会更好，就这样改进了一下。</p><p><img data-src="https://z3.ax1x.com/2021/09/08/hbEcdJ.png" alt></p><h1 id="RobGAN"><a href="#RobGAN" class="headerlink" title="RobGAN"></a>RobGAN</h1><p>Rob-GAN: Generator, Discriminator, and Adversarial Attacker，发表在 CVPR 2018。</p><p>这篇论文从另一个角度结合了 GAN 和对抗训练，将生成器融入对抗训练，提升判别器的鲁棒性；对抗训练使得 GAN 更快的收敛，并得到更好的生成器，两者互益。这篇论文的出发点同上：生成器生成分布更广阔的数据，使分类器在不可见数据集上获取更好的鲁棒性。</p><p><img data-src="https://z3.ax1x.com/2021/09/18/41SOfK.png" alt></p><p>对于 WGAN 的判别器而言，需要判别对抗样本和生成器的虚假样本，所以损失就是使这两者的分类误差达到最小，这里需要注意的是，虚假样本也要加上对抗扰动。</p><p>对于鲁棒性差的 GAN 而言，它虽然 smarter 但是 weaker，如下图所示：</p><p><img data-src="https://z3.ax1x.com/2021/09/18/41phNt.png" alt></p><p>在鲁棒的区域，能有效的抵御攻击而不会错分类。论文给出了一些证明，由于生成网络的任务是欺骗判别器，如果判别器不够鲁棒，那么只需要一点点的更新就可以欺骗判别器。如果判别器鲁棒，那么得到的生成器也会更好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做对抗训练的时候，我时常在想一个问题：PGD、CW 这些攻击算法都会设置迭代步长和阈值，如果模型固定、参数固定，那么每次生成的对抗样本也会是一样的。如果使用 min-max 的方式进行对抗训练，那么模型可能会只认识在某一设置下的数据，如果面对新的分布攻击样本，如 ZOO, UAP, Deepfool 等，岂不是不能很好的防御？&lt;/p&gt;
&lt;p&gt;这就又会回到小样本问题，总不能对所有的攻击算法在不同阈值下都生成对抗样本，而应该生成分布尽可能广泛的对抗样。既然提到生成，就不得不考虑 GAN，所以搜了些相关论文，并作整理。注意，所有论文我没看代码，所以不评价好与坏，在不久的将来如果我要发论文，肯定还会做对比算法，到时候回来评价各个算法。未完待续。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>神经网络常见问题</title>
    <link href="https://muyuuuu.github.io/2021/09/04/DNN-issue/"/>
    <id>https://muyuuuu.github.io/2021/09/04/DNN-issue/</id>
    <published>2021-09-04T12:36:07.000Z</published>
    <updated>2021-09-05T13:02:20.894Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写深度学习的代码多了，经常会发现网络准确率低、难以收敛等错误，大多时候不是算法问题，而是人为的 bug，特此记录。</p><p>比如：为何网络的误差一直是一个定值？为何同样的网络、同样的优化器和学习率，训练得到的准确率比别人低 20% ？</p><a id="more"></a><ol><li>神经网络处理数据时不进行<a href="https://muyuuuu.github.io/2021/05/07/DNN-data-normal/">标准化</a>，准确率会下降很多；</li><li>神经网络的学习率至关重要，batch 大而学习率小，batch 小而学习率大，都会导致不收敛问题。此外，学习率衰减很重要，能有效提升<a href="https://github.com/bearpaw/pytorch-classification" target="_blank" rel="noopener">卡在瓶颈</a>中的神经网络的准确率。</li><li>复现去噪器时，噪音数据在损失函数<a href="https://github.com/muyuuuu/Paper-ReImplement/tree/main/ADP-ICML-2021" target="_blank" rel="noopener">内部生成</a>。如果在损失外部生成噪音并输入网络，会导致网络的误差恒定为噪音的方差。</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文持续整理中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写深度学习的代码多了，经常会发现网络准确率低、难以收敛等错误，大多时候不是算法问题，而是人为的 bug，特此记录。&lt;/p&gt;
&lt;p&gt;比如：为何网络的误差一直是一个定值？为何同样的网络、同样的优化器和学习率，训练得到的准确率比别人低 20% ？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>YOLO V2，细读代码</title>
    <link href="https://muyuuuu.github.io/2021/08/28/yolo-v2/"/>
    <id>https://muyuuuu.github.io/2021/08/28/yolo-v2/</id>
    <published>2021-08-28T14:16:45.000Z</published>
    <updated>2021-08-28T14:33:55.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>还是老样子，不看代码永远不能称为学会了。况且 YOLO V2 有一些优化还是很常见的，如 Anchor Box 和多尺度训练。我之前也只是听说过这些名词，并不知道如何在程序中使用，索性直接读了程序了解一下，程序写的还是比较精彩的。另外：这是第一篇用 vim 写的博客。</p><a id="more"></a><h1 id="YOLO-v2"><a href="#YOLO-v2" class="headerlink" title="YOLO v2"></a>YOLO v2</h1><p>论文地址：<a href="https://arxiv.org/abs/1612.08242" target="_blank" rel="noopener">https://arxiv.org/abs/1612.08242</a><br>提供两个代码地址：第一个适合看模型、损失和多尺度训练，第二个适合看 anchor box 如何用到模型中，但是需要注意的是有 bug，但写的比第一个容易理解。</p><ol><li><a href="https://github.com/longcw/yolo2-pytorch" target="_blank" rel="noopener">https://github.com/longcw/yolo2-pytorch</a></li><li><a href="https://github.com/uvipen/Yolo-v2-pytorch/tree/master" target="_blank" rel="noopener">https://github.com/uvipen/Yolo-v2-pytorch/tree/master</a></li></ol><p>作者基于之前的 YOLO v1，提出了一些改进的策略，快速的同时准确率也大幅度提升。训练检测网络的同时，在 ImageNet 数据集上进行训练，提升了网络的分类能力。文章的一开始，作者指出了检测存在的几个问题：</p><ol><li>小目标检测能力受限</li><li>目标检测数据集的类别远远小于分类数据集的类别，且，不可能对检测数据集进行标注。所以能不能使用多个分类的数据集提升网络能识别的类别数呢？</li></ol><h2 id="Better"><a href="#Better" class="headerlink" title="Better"></a>Better</h2><p>作者进行了一些尝试来提升网络的性能：</p><ul><li>Batch Normalization，在卷积层后、激活层前加入 BN 层，大约提升了 2%。BN 层帮助网络实现正则化，能移除之前的 droupout层。</li><li>提高分辨率，将 v1 的 224 尺寸变为 448 尺寸，并先在 ImageNet 上训练 10 次，使得网络适应高分辨率，而后在检测任务中进行微调。</li><li>使用 Anchor Box 提升定位精准度，预测相对 anchor box 的坐标偏移，预测偏移相对直接预测坐标会简单些。这样提升了网络的召回率。此外，图片的 Ground Truth 一般都是正方形，1:2 的长方形或者 2:1 的长方形，预先准备几个几率比较大的 bounding box，再以它们为基准进行预测。</li><li>为了设置合适的 Anchor Box 的大小，对数据集的盒子进行 K-means 聚类，筛选出合适的 bounding box 大小。K-means 没有使用 欧拉距离，而是 $1-\text{IOU(box, center)}$，即盒子的 IOU 越大，距离越小。</li></ul><p>以上都是微小的改进，下面的三点改进是比较大的。</p><h3 id="Direct-location-prediction"><a href="#Direct-location-prediction" class="headerlink" title="Direct location prediction"></a>Direct location prediction</h3><p>作者使用 Anchor Box 的时候发现早期的网络不稳定，原因来自 $(x,y)$ 的预测。在 RPN 网络中，预测出 $t_x$ 和 $t_y$，$(x,y)$ 的计算为：</p><p>\begin{aligned}<br>x &amp;= (t_x * w_a) + x_a \\<br>y &amp;= (t_y * h_a) + y_a \\<br>\end{aligned}</p><p>由于 $t_x,t_y$ 的输出值不受限制，$(x,y)$ 能忽略 Anchor Box 的存在而而满天飞。所以网络增加了 sigmoid 函数限制 $t_x,t_y$ 的取值在 0 到 1 之间。具体一点，就是更改网络的输出为 $(t_x, t_y, t_w, t_h, t_o)$。由于 YOLO 的预测的尺寸、中心点的坐标都是相对图片的占比，比如一个目标位于图片的正中心，那么 $(x,y)=(0.5,0.5)$ 。如果当前格子相对图片的偏移是 $(c_x,c_y)$，Anchor Box 之前的宽和高是 $(p_w,p_h)$，那么预测的 bounding box 输出为：</p><p><img data-src="https://z3.ax1x.com/2021/08/26/hncDq1.png" alt></p><p>此外，置信度的输出替换为 $\sigma (t_o)$。</p><h3 id="Fine-Grained-Features"><a href="#Fine-Grained-Features" class="headerlink" title="Fine-Grained Features"></a>Fine-Grained Features</h3><p>为了提升小目标的检测精度，增加了 passthrough layer，用类似残差连接的方式传递前几层的特征到网络后面，堆叠高层特征和低层特征到不同通道上。</p><p><img data-src="https://z3.ax1x.com/2021/08/26/huFwqg.jpg" alt></p><h3 id="Multi-Scale-Training"><a href="#Multi-Scale-Training" class="headerlink" title="Multi-Scale Training"></a>Multi-Scale Training</h3><p>为了使模型适应不同的尺寸，不再单一的固定单张图片的大小。而是在网络迭代 10 个 batch 后，网络通过下采样来产生新的输入尺寸来读取图像。这样简单的操作，使得模型适应不同尺寸的图像。</p><h2 id="Faster"><a href="#Faster" class="headerlink" title="Faster"></a>Faster</h2><p>这里的快是为了保证准确率而尽可能快，所以未必会比 YOLO v1 快。作者提出了 DarkNet-19 （黑暗网络，好中二的名称）作为模型的 backbone，相比 VGG16 还是比较快的。之后：</p><ol><li>ImageNet 预训练 160 个 epoch，训练期间使用了随机裁剪、旋转、颜色变换等增强方式；</li><li>ImageNet 的尺寸是 224，为了适应高分辨率的图像，将输入层的尺寸调为 448，再次在 ImageNet 上训练 10 个 epoch；</li><li>更改网络结构，移除分类层添加检测头。对于 VOC 数据集而言，每个格子输出 5 组参数，也就是预先有 5 个 Anchor Box，每组参数是 20 个类别的得分 5 个盒子参数，所以每个盒子一共 125 个参数。而后 passthrough layer 预测小目标的输出。</li></ol><p>用检测数据进行训练时，训练了 160 个 epoch ，也使用了随机裁剪、旋转、颜色变换等增强方式。</p><h2 id="Stronger"><a href="#Stronger" class="headerlink" title="Stronger"></a>Stronger</h2><p>数据比模型更重要。那么有没有办法把 classification 数据集也利用起来？毕竟它们虽然没有提供坐标信息，但是也提供了类别信息，这部分类别信息能够显著拓展检测的类别数。当输入是 detection 数据时，按照正常的训练过程进行反向传播；当输入的是 classification 数据时，只计算和更新类别对应的 loss 和网络参数。</p><p>与 Faster 训练方式不同的是，将分类数据集和检测数据集进行联合训练。此时存在的问题是，分类数据集和检测数据集不是同一个数据集，如果检测数据集的标签是「狗」，那么分类数据集的标签很可能是「泰迪、田园犬」等，所以要合并这些标签。论文采用树的结构融合这些标签，得到具有 1396 个节点的树。针对每一个 anchor，预测出长度为 1396 的矢量，对该矢量按照层级关系进行同层级的 softmax 得到条件概率，根据全概率公式连乘即可得到所属类别的条件概率。</p><p><img data-src="https://z3.ax1x.com/2021/08/26/hnHwtJ.png" alt></p><p>经过这种弱监督式的融合数据集训练后，YOLO v2得以检测超过9000种类别，因此得名为YOLO 9000。</p><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><h2 id="模型部分"><a href="#模型部分" class="headerlink" title="模型部分"></a>模型部分</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 anchor 个 [类别，x, y, w, h] 这样的数据</span></span><br><span class="line">out_channels = cfg.num_anchors * (cfg.num_classes + <span class="number">5</span>)</span><br><span class="line">self.conv5 = net_utils.Conv2d(c4, out_channels, <span class="number">1</span>, <span class="number">1</span>, relu=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 x 和 y 激活处理，学习偏移量</span></span><br><span class="line">xy_pred = F.sigmoid(global_average_pool_reshaped[:, :, :, <span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 对 w 和 h 进行映射，用来乘以之前 anchor 的宽和高，得到预测的宽和高</span></span><br><span class="line">wh_pred = torch.exp(global_average_pool_reshaped[:, :, :, <span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">bbox_pred = torch.cat([xy_pred, wh_pred], <span class="number">3</span>)</span><br><span class="line"><span class="comment"># IOU 预测，YOLO V1 中是置信度</span></span><br><span class="line">iou_pred = F.sigmoid(global_average_pool_reshaped[:, :, :, <span class="number">4</span>:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类别预测，共 anchor 个类别</span></span><br><span class="line">score_pred = global_average_pool_reshaped[:, :, :, <span class="number">5</span>:].contiguous()</span><br><span class="line">prob_pred = F.softmax(score_pred.view(<span class="number">-1</span>, score_pred.size()[<span class="number">-1</span>])).view_as(score_pred)</span><br></pre></td></tr></table></figure><h2 id="数据与损失"><a href="#数据与损失" class="headerlink" title="数据与损失"></a>数据与损失</h2><p>对于加载数据部分，由于是多尺度训练，所以先要把图像 <code>resize</code> 到指定的输入尺寸，而后对标签中的宽度、中心点进行放缩，而后返回盒子、类别标签即可。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">batch[<span class="string">'images'</span>].append(images)</span><br><span class="line">batch[<span class="string">'gt_boxes'</span>].append(gt_boxes)</span><br><span class="line">batch[<span class="string">'gt_classes'</span>].append(classes)</span><br><span class="line">batch[<span class="string">'dontcare'</span>].append(dontcare)</span><br><span class="line">batch[<span class="string">'origin_im'</span>].append(origin_im)</span><br></pre></td></tr></table></figure><p>众所周知，对于卷积神经网络而言，输入图像的尺寸大小不同，输出的图像尺寸也不会一样。而网络超参数始终是固定的，适应多尺度训练是在损失函数中进行的，将标签数据的尺寸适配到网络输出的尺寸，这样就实现了多尺度训练。而后开始计算损失和反向传播，也就是<a href="https://github.com/longcw/yolo2-pytorch/blob/17056ca69f097a07884135d9031c53d4ef217a6a/darknet.py#L40" target="_blank" rel="noopener">这个函数</a>所做的。</p><p>之后就是损失函数部分了，重点是来看看是如何基于 <code>anchor box</code> 进行预测的，不过仍然可以确定的是，不管是分类损失，还是 IOU 损失或 bounding box 损失，使用的都是 MSE 损失函数。</p><p>对于标签数据而言，重要的是看懂<a href="https://github.com/uvipen/Yolo-v2-pytorch/blob/9589413b5dce0476eb9cccc41945cf30cf131b34/src/loss.py#L89-L145" target="_blank" rel="noopener">这里</a>的流程：</p><ol><li>遍历当前的 batch size，处理每一个 batch；</li><li>对预测输出和真实标签进行 IOU 计算，筛选出大于阈值的 bounding box 作为正样本，其余样本忽略；</li><li>筛选出与真实标签大小最为接近的 anchor box，基于 anchor box 计算和真实框的偏移量。anchor box 是预先设置的，anchor box 没有位置的概念，不是基于某个框生成的，anchor box 在整个训练期间是不变的。假设是第 2 个 anchor box 最接近。由于标签数据的维度和网络输出的维度相同，将标签数据的第 2 维填充为对应标签。这样，其余数据回被忽略。这一部分<a href="https://github.com/uvipen/Yolo-v2-pytorch/blob/9589413b5dce0476eb9cccc41945cf30cf131b34/src/loss.py#L89-L145" target="_blank" rel="noopener">代码</a>。</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这一部分代码还是耐心读吧……我也读了一晚上。也确实没发现网上有哪篇博客写的比代码还要详细清晰。读完了代码，我也知道了代码中如何实现多尺度训练和使用 anchor box。据说 YOLO v3/v4/v5 都是一些工程上的 trick 了。应该只会读那些具有创新点的代码，其他代码会选择性了略过了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还是老样子，不看代码永远不能称为学会了。况且 YOLO V2 有一些优化还是很常见的，如 Anchor Box 和多尺度训练。我之前也只是听说过这些名词，并不知道如何在程序中使用，索性直接读了程序了解一下，程序写的还是比较精彩的。另外：这是第一篇用 vim 写的博客。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>关于六天掌握 Vim 这件事</title>
    <link href="https://muyuuuu.github.io/2021/08/28/vim-learn/"/>
    <id>https://muyuuuu.github.io/2021/08/28/vim-learn/</id>
    <published>2021-08-28T14:15:36.000Z</published>
    <updated>2021-09-01T13:46:39.520Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学习 vim 的时候曾经4进4出一直没学会，这次下定决心要学一下了，也不求一口吃个胖子，每天学习一点点。首先从基础操作开始练习，先不要配置插件，也不管高亮和编程。<del>IDE是人类退步的阶梯</del>，沃茨基说的。</p><p>当然，这份文档不一定包含所有命令，只是教学的目的，遇到没有涵盖的命令自行查阅即可。有些命令是我自己的总结，不一定对。此外，本文涉及的命令之间可以任意组合实现各类高级功能，这个没办法统一列出。</p><p>此外，纸上得来终觉浅，学习 vim 一定多动手练习，在平时任务中多用 vim，自然而然就掌握了。我前后花了 6 天能使用 vim 应付日常开发工作，所以本文也叫六天掌握 vim。</p><a id="more"></a><p>这个是我参考的 vim 的学习笔记，感觉写的还是不错的：<a href="https://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">https://coolshell.cn/articles/5426.html</a></p><h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><p>我一点点的写vim，尝试着写点。</p><p>换行了。</p><pre><code>也能缩进。</code></pre><p>第一步直接安装 vim，而后新建一个文件，就叫 <code>vim-prac.md</code>，每次练习都打开这个文件，直接写入。我直接新建了一个博客，每次的练习都写入到这个博客。</p><p>首先要知道的，在 <code>normal</code> 模式下，万物都是功能键，比如 <code>hjkl</code> 是方向键，<code>h</code> 表示左，<code>j</code> 表示下，<code>k</code> 表示上，<code>l</code> 表示右。其实也容易记忆，位于两侧的 <code>hl</code> 表示左右，而后左下、右上这样记忆，即和 <code>h</code> 紧挨着的是下，和 <code>l</code> 紧挨着的是上。</p><ul><li>如果想要打字，按一下键盘上的 <code>i</code> 进入 <code>insert</code> 模式，而后开始随心所欲的打字，和编辑 txt 文件一样没啥区别，上面那些文字都是我刚入门就打出来的。</li><li>在写完之后，按键盘左上角的 <code>esc</code> 退出插入模式，而后输入 <code>:wq</code> 表示写入并退出，这样写好的文件就被保存了。冒号的意思是进入命令模式，<code>w</code> 是写入单词的首字符，<code>q</code> 是退出单词的首字符。</li></ul><p>那么再来看一下其他操作：</p><ul><li><code>x</code>，<code>normal</code> 模式下，表示删除光标后面的字符。既然删除了，是不是要撤销？那么撤销操作是 <code>u</code>，如果回退到 3 次修改之前，可以输入 <code>3u</code>。这个可以直接在界面下操作，也可以<code>:u</code>。如果发现撤销过头了，就需要恢复，此时的快捷键是 <code>ctrl+R</code>，或者 <code>:red</code>。</li><li><code>dd</code>，同样是在 <code>normal</code> 模式下，表示删除当前行，并复制到剪切板中，<code>p</code>，粘贴剪切板中的内容。如果复制的是一行，<code>p</code> 会另起一行粘贴，如果复制的是个单词， <code>p</code> 会空格后粘贴，<code>P</code> 会避免这些。</li></ul><p>现在差不多可以编辑基本的文本了，今天的内容学习到此结束。如果今后在面对不忙的、简单的、凭借目前 vim 技术可以解决的工作，可以尝试开始用 vim。</p><h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><p>在编辑文本的时候发现，光标的移动不是很便捷，每次都要狂按方向键才能到想要的位置。那么今天就来学习下便捷的光标移动与插入。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ul><li><code>a</code>，在光标后插入，假设一段序列是 <code>abcd</code>，光标位于 <code>a</code> 后面，在 <code>normal</code> 模式下，那么输入 <code>a</code> 后会移动到 <code>b</code> 的后面，而后开始插入；</li><li><code>o</code>，当前行后插入一个新行；</li><li><code>O</code>，当前行前插入一个新行；</li></ul><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ul><li><code>0</code>，移动到行头；</li><li><code>^</code>，当本行第一个不是空格、tab、回车、换行字符的位置，也就是一行开头的这些东西会被忽略；</li><li><code>$</code>，移动到本行的行尾；</li><li><code>g_</code>，到本行最后一个不是空格、tab、回车、换行字符的位置；</li><li><code>/pattern</code>，搜索 <code>pattern</code> 的字符串，如果有多个，按 <code>n</code> 到下一个。</li></ul><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>之前已经知道了 <code>p</code> 是粘贴，<code>dd</code> 是剪切当前行。如果不删除当前行直接复制呢？用的是 <code>yy</code>。</p><p>此外，有的时候还想不复制整行，只想复制一行中的某些文字。此时的命令是在 <code>normal</code> 模式下按 <code>v</code> 进入 <code>visual</code> 模式，而后移动光标（可以借助 <code>$</code> 等功能键）选中文本，按下 <code>y</code> 表示复制选中的文本。而后 <code>p</code> 表示在当前位置之后粘贴，即如果将一些内容复制到 <code>ABCDE</code> 的 <code>B</code> 后面，需要将光标放到 <code>A</code> 后面然后粘贴。</p><p>还有这里看着突兀的原因是，之前终端用的光标是 <code>Beam</code> 这样的细线，如果换成 <code>Block</code> 这样的光标块，能从视觉角度更好的理解复制和粘贴的位置。</p><p>还有诸如 <code>yG</code> 复制到当前文件结束，<code>y20G</code> 复制到第 20 行等操作，用到的时候再来整理。</p><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><ul><li><code>:e path</code>，表示打开指定 path 的文件</li><li><code>:wq, :x, XX</code>，保存并退出，<code>:x</code> 仅在有改动时保存</li><li><code>:q!</code>，强制退出不保存，<code>:qa!</code> 强制退出正在编辑的文件，即使有更改</li></ul><p>今天的练习结束，淘到了一个键盘，回宿舍洗一洗。</p><h1 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h1><p>一时技痒，偷着做了两件事情，一个是 <code>vim</code> 的配置文件，一个是 <code>vim</code> 的插件。</p><p>大概昨天尝试了一下使用 <code>vim</code> 安装插件，不得不说真香。我选择的插件管理器是 <code>vim-plug</code>，记得配置 <code>git</code> 的 <code>ssh</code> 和 <code>https</code> 代理，否则下载不下来。先装了一个 <a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener"><code>vim-airline</code></a> 还不错。之后等时间长了，配置一些编程用的插件。</p><p>而后是 <code>vim</code> 的配置文件，用户自己的配置文件位于 <code>~/.vimrc</code>，系统的配置文件位于 <code>/etc/.vimrc</code>。而后可以网上查一查如何配置，比如显示行号、设置缩进、显示文件名等。我的 <code>vim</code> 配置放到了我的 github 上：<a href="https://github.com/muyuuuu/my-vim-config" target="_blank" rel="noopener">https://github.com/muyuuuu/my-vim-config</a> 。</p><p>回到正题，今天额外学一些光标移动的操作，我也是使用了一段事件后才发现快速定位到某个位置真的是太有用了。</p><p>在配置文件中开启行号设置后，可以知道文件位于哪一行。在 <code>normal</code> 模式下，可以使用 <code>NG</code> 移动到第 <code>N</code> 行，<code>N</code> 是数字；<code>G</code> 是移动到最后一行。或者在 <code>command</code> 模式下，<code>:112</code> 会移动到 112 行。<code>ctrl+f</code> 向下翻页，<code>ctrl+b</code> 向上翻页；<code>ctrl+e</code> 逐行向下翻页；<code>ctrl+y</code> 逐行向上翻页。 </p><p>之后再来看一下行内的移动：</p><ul><li><code>w</code> 到下一个单词的开头，<code>b</code> 移动到上一个单词的开头，<code>e</code> 到当前单词的结尾。</li><li><code>%</code> 匹配括号移动，包括 <code>([{</code>，把光标移动到括号上面，按 <code>%</code> 就可以吧光标移动到匹配的位置。</li><li>单词移动，<code>*</code>（下一个） 和 <code>#</code>（上一个），匹配光标当前所在的单词，移动到上一个单词和下一个单词。</li><li><code>6l</code> 向右移动 6 个字符</li></ul><p>今天的学习到此结束。今天用 <code>vim</code> 写了一段代码，发现还是熟能生巧，得多用用。</p><h1 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h1><p>因为我的电脑屏幕比较大，所以启动终端只开一个 <code>vim</code> 窗口有些资源浪费，今天来学习一下如何分屏。</p><p>就像这张图一样，上面是文档，下面是代码。</p><p><img data-src="https://z3.ax1x.com/2021/08/30/hNeo7D.png" alt></p><ul><li><code>:split</code> 为垂直分屏，<code>:vsplit</code> 为水平分屏。</li><li><code>ctrl+w+hjkl</code> 用于切换分屏，还记得之前说过的方向键盘吗？</li><li><code>ctrl+w+</code> 增加尺寸，<code>ctrl+w-</code> 缩小尺寸。</li></ul><p>当然只是分屏还是不爽的，能不能直接在 <code>vim</code> 中编译或解释直接查看代码的执行结果而不是每次都要退出去？答案肯定还是有的，不过准备放到后面的打造 <code>vim</code> 了，这里还是以学习 <code>vim</code> 命令为主。</p><ul><li><code>.</code>，小数点是重复上次的命令</li><li><code>N&lt;cmd&gt;</code> 重复命令 N 次，这个命令不用进入 <code>normal</code> 模式</li><li>如写一百遍名字，命令就是 <code>100iname</code> </li></ul><p>此外，我发现复制粘贴用的还是比较多的，所以再来整理一些复制的命令。</p><ul><li><code>ye</code>，复制光标后面的单词，不含空格</li><li><code>yw</code>，复制光标后面的单词，含空格</li><li><code>yl</code>，复制光标后面的字符，<code>l</code> 是方向键的右</li><li><code>yh</code>，复制光标前面的字符，<code>h</code> 是方向键的左</li><li><code>4yy</code>，复制当前行及后面的3行共4行</li><li><code>4yl</code>，当前字符及后面的3个字符，共4个</li><li><code>4yh</code>，当前字符前面的4个字符，不包括当前字符</li></ul><p>同理，<code>d</code> 是剪切的命令，且大体和 <code>y</code> 相似：</p><ul><li><code>dd</code>，剪切当前行</li><li><code>4dd</code>，剪切当前行及后面的3行，共4行</li><li><code>dw</code>，剪切光标后面的单词，含空格</li></ul><p>今天学习内容结束，大概还差区域选择、块操作、宏录制和可视化选择；在之后就会尝试把 vim 打造成 IDE 了，一去不复返。</p><h1 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h1><p>我又额外补充了一些插件换了主题来提升效率。<code>wakatime</code> 记录编程时间，<code>nerdtree</code> 显示工作目录，<code>startify</code> 显示近期打开的文件，<code>onehalfdark</code> 作为主题。</p><p>在服务器上体验了一把裸敲 <code>vim</code> 的快感，首先补充一些光标移动的东西，快速定位到想要的位置，这玩意太重要了。</p><ul><li><code>fa</code> 移动到下一个为 <code>a</code> 的字符处；<code>3fa</code> 移动到第三个 <code>a</code> 的位置；<code>F</code> 与 <code>f</code> 的查找顺序刚好相反。</li><li><code>t,</code> 到逗号前的一个字符，这里暂不支持中文字符 <del>难道以后我写文档要用英文符号了？</del></li></ul><p>此外，在编程时候会常用块操作，比如注释某个函数，或者 <code>python</code> 中的某段内容全部缩进，就需要块操作来实现。</p><ul><li>光标定位到要操作的地方；</li><li><code>ctrl+v</code> 进入「块可视化」模式，选取要操作的行；</li><li><code>shift+i</code> 输入要插入的内容；</li><li><code>esc</code> 按两次，会在每行的选定的区域出现插入的内容。</li></ul><p>另外的内容是区域选择，命令为 <code>&lt;action&gt;a&lt;object&gt;</code> 或者 <code>&lt;action&gt;i&lt;object&gt;</code>，两者的区别是，前者会选中 <code>object</code>，后者则不会。给定字符串 <code>((a) + (&quot;b+c&quot;)</code>。</p><ul><li>光标位于 <code>b</code>，<code>vi&quot;</code> 会选中 <code>b+c</code>，<code>va&quot;</code> 会选中 <code>&quot;b+c&quot;</code>；</li><li>光标位于 <code>b</code>，<code>v2i)</code> 会选中 <code>(a) + (&quot;b+c&quot;)</code>，<code>v2a)</code> 会选中全部</li></ul><p>今天的学习内容到此结束，其实很多时候都在查漏不缺，每次都要花很多时间联系，所以虽然内容很少，但是内容很多（误。</p><h1 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h1><p>今天大概是最后一天了，是一些批处理的内容，宏录制和块选择。可惜最近学业繁忙，事情太多，不能学的尽兴。如果之后时间充裕或者不想学习，一定花时间继续打造我的 <code>vim</code>，主要包括：编程语言的支持、自动提示、以及如何不退出 <code>vim</code> 直接执行程序。</p><p>首先是宏录制，这个功能十分强大。这里只举一个例子，如何给文件每一行末尾添加逗号：<del>如果功能过于复杂，我第一反应肯定是写脚本处理。</del></p><ol><li>按 <code>q</code> 加 <code>a~z</code> 中的任意字符，如 <code>qc</code> 表示开始录制宏，这个宏的名字叫 <code>c</code>，而后可以使用 <code>c</code> 来调用宏；</li><li>比如对文件的每一行末尾条件逗号，那么就是如下操作 <code>$a,ESC,j</code>，注意结束时移动到下一行；</li><li>再次输入 <code>q</code>，表示退出宏录制；</li><li><code>n@c</code> 表示执行宏命令 <code>n</code> 次；</li></ol><p>注意，录制上面的宏时，会修改第一行的内容，不用担心。除了宏之外，可视化选择也提供了丰富的选择，例如第五天提到的批量注释。<del>其实录制宏也能实现。</del> 今天就来细看可视化模式。</p><p>首先，<code>v</code> 是进入字符可视化模式，<code>V</code> 进入行可视化模式，<code>ctrl+v</code> 进入块可视化模式。<code>gv</code> 可以选中上次可视化模式选中的文本；<code>o</code> 会移动到选中区域的另一侧。 </p><ul><li>对于 <code>v</code>，进入可视化模式后移动光标，使用 <code>4l</code> 选中右边的 4 个字符，按 <code>d</code> 删除</li><li>对于 <code>V</code>，进入行可视化模式，同样的是选中，而后操作</li><li>对于 <code>ctrl-v</code>，进入块可视化模式，可以使用 <code>2l</code> 和 <code>3j</code> 选择两行三列</li></ul><p>而按照上面三种方法选中文本后，都可以进行编辑，如 <code>C</code> 删除选中文本并插入新文本，<code>~</code> 进行大小写替换，<code>ctrl+v</code> 进入块可视化模式，选中行后<code>J</code> 将这些行连成一行，<code>&gt;</code> 向右缩进<code>&lt;</code> 向左缩进，<code>=</code> 自动缩进。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><code>vim</code> 学习的内容到此结束，我宣布第 5 次 <code>vim</code> 学习顺利结束，完结撒花。不保证本文覆盖全部内容，但至少能看懂常见的命令，以及遇到问题知道往哪个方向搜索。之后的插件配置会放到 <code>github</code> 仓库里面了，那些东西放到这里也没啥用。还是那句话，不会走就别着急学跑，<code>vim</code> 还没学会就打造 IDE 和装插件的意义也不大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习 vim 的时候曾经4进4出一直没学会，这次下定决心要学一下了，也不求一口吃个胖子，每天学习一点点。首先从基础操作开始练习，先不要配置插件，也不管高亮和编程。&lt;del&gt;IDE是人类退步的阶梯&lt;/del&gt;，沃茨基说的。&lt;/p&gt;
&lt;p&gt;当然，这份文档不一定包含所有命令，只是教学的目的，遇到没有涵盖的命令自行查阅即可。有些命令是我自己的总结，不一定对。此外，本文涉及的命令之间可以任意组合实现各类高级功能，这个没办法统一列出。&lt;/p&gt;
&lt;p&gt;此外，纸上得来终觉浅，学习 vim 一定多动手练习，在平时任务中多用 vim，自然而然就掌握了。我前后花了 6 天能使用 vim 应付日常开发工作，所以本文也叫六天掌握 vim。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Vim" scheme="https://muyuuuu.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>YOLO目标检测从 V1 开始，细读代码</title>
    <link href="https://muyuuuu.github.io/2021/08/26/yolo-v1/"/>
    <id>https://muyuuuu.github.io/2021/08/26/yolo-v1/</id>
    <published>2021-08-26T11:06:48.000Z</published>
    <updated>2021-08-27T13:01:52.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>忙里偷闲，写几篇长文，从 YOLO 的 v1 到 v5。没想到时隔多年会回来重新看 YOLO 系列的东西，相比两阶段检测，YOLO 真的太快了，加上一些训练的 trick，mAP 也不会很低。网上看了好多教程不明所以，索性还是直接去读原论文了，读了原论文有些东西还是不理解，索性又去读了源程序。不过为了便于理解，有的地方不会按照论文顺序进行整理。少问问题，读论文产生的疑问在代码里都有解答，不看代码永远不能被称为学会了。</p><a id="more"></a><p>如果对本文有疑问或者想找男朋友，可以联系我，<a href="https://muyuuuu.github.io/about/">点击此处有我联系方式</a>。</p><h1 id="YOLO-v1"><a href="#YOLO-v1" class="headerlink" title="YOLO v1"></a>YOLO v1</h1><ul><li>论文地址：<a href="https://arxiv.org/abs/1506.02640" target="_blank" rel="noopener">https://arxiv.org/abs/1506.02640</a></li><li>pytorch 程序地址：<a href="https://github.com/motokimura/yolo_v1_pytorch" target="_blank" rel="noopener">https://github.com/motokimura/yolo_v1_pytorch</a></li></ul><p>YOLO v1 将目标检测定义为回归问题，直接读入全部图像，回归出边界框和分类概率。与同时期的 Faster RCNN 对比，算法快了不少，也没有 RPN 以及后处理，也避免里滑动窗口这样的暴力检测。所以能用到一些实时系统中，也是我花精力看这一些列论文的原因。</p><p>但是对于 v1 的 YOLO 存在一些缺陷，作者在论文中也进行了阐述：准确率低、定位不准尤其是小目标的定位。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>首先将图片分为 $S\times S$ 个网格，论文中 $S=7$，如果一个物体的中心落入这个格子中，那么这个格子负责预测这个目标。设每个格子负责预测 $B$ 个物体的盒子参数和置信度得分，盒子参数指明物体的位置，置信度表示盒子含有目标且预测准确的可信程度。即对于图片的每个格子，会输出 $B$ 个 $(x,y,w,h,c)$，论文中 $B=2$。</p><p>既然有了输出，那么就需要 label 进行损失计算。$(x,y,w,h,c)$ 是人工标注的数据，$c$ 初始化为 1。论文定义网络输出的置信度标签是一个分段函数，如果格子没有目标，置信度是 0；如果有目标，置信度是预测框和真实框的 IOU 值，公式描述为 $\text{Pr(Object)} * \text{IOU}_{\text{pred}}^\text{truth}$。</p><p>目标检测和分类是分不开的，为了达到分类的目的，每个格子也会输出 $C$ 个类别的概率，公式表述为 $\text{Pr(Class}_i|\text{Object})$，即格子里面得是个目标，才能计算分类的概率和损失。而每个格子输出一组<a href="https://github.com/motokimura/yolo_v1_pytorch/blob/master/detect.py#L203-L206" target="_blank" rel="noopener">预测</a>，即使输出了 $B$ 组数据，这就限制了网络的表达。</p><p>在测试阶段，类别置信度的分数就是分类概率和置信度相乘，即盒子中「有这个类别的概率」和「网络预测这个类别的概率」的乘积：</p><p>\begin{equation}<br>\text{Pr(Class}_i|\text{Object})*\text{Pr(Object)}*\text{IOU}_{\text{pred}}^\text{truth}=\text{Pr(Class}_i) * \text{IOU}_{\text{pred}}^\text{truth}<br>\end{equation}</p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p>这种东西还是代码清楚，只放了最关键的检测输出：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nn.Linear(<span class="number">4096</span>, S * S * (<span class="number">5</span> * B + C))</span><br><span class="line">nn.Sigmoid()</span><br><span class="line">x.view(<span class="number">-1</span>, S, S, <span class="number">5</span> * B + C)</span><br></pre></td></tr></table></figure><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>\begin{aligned}<br>{ } &amp; \lambda_{coord} \sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{I}_{ij}^{\text{obj}} [(x_i-\hat{x}_i)^2 + (y_i-\hat{y}_i)^2] \\<br>{ } &amp;+ \lambda_{coord} \sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{I}_{ij}^{\text{obj}} [(\sqrt{w_i}-\sqrt{\hat{w}_i})^2+(\sqrt{h_i}-\sqrt{\hat{h}_i})^2] \\<br>{ } &amp;+ \sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{I}_{ij}^{\text{obj}} (C_i - \hat{C}_i)^2 \\<br>{ } &amp;+ \lambda_{noobj} \sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{I}_{ij}^{\text{noobj}} (C_i - \hat{C}_i)^2 \\<br>{ } &amp;+ \sum_{i=0}^{S^2} \mathbb{I}_{ij}^{\text{obj}} \sum_{c\in classes} (p_i(c)-\hat{p}_i(c))^2<br>\end{aligned}</p><ul><li>$\lambda_{coord}$ 是前景的权重，$\mathbb{I}_{ij}^{\text{obj}}$ 是指示函数，取值只有 0 和 1</li><li>前两行表示 bound box 的损失</li><li>第三行是前景置信度的损失</li><li>第四行是背景置信度的损失</li><li>第五行是分类的损失</li></ul><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ol><li>每个网格只能检测一个类别和两个目标，类间竞争严重，网络表达受限，对于密集群体的检测性能会下降；</li><li>定位不准确，因为网络直接预测 bounding box 的坐标，一开始的偏移可能会很大，导致定位不准确，读完代码能深刻理解这里的缺陷；</li><li>对于检测问题而言，大多情况背景居多，前景居少，也就是样本不均衡。YOLO v1 的损失中，并没有计算背景的 bound box 损失，只计算了前景的，YOLO v1 回避了样本不均衡的问题，这会影响网络的稳定性与背景的识别。</li></ol><h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><p>「如果对算法有疑问，就去读代码吧」这一经验帮助我理解了很多算法的困惑之处，不仅仅是 YOLO。如果要看懂一个深度学习的算法，核心有三要素，首先是网络模型，理解输入、输出和结构；其次是数据与损失，理解加载什么格式的数据，理解网络预测数据和加载的数据如何计算损失，所以这俩常常放在一起；最后是细枝末节，即数据增强、学习率策略、整体训练流程等。所以接下来整理网络模型和损失。<del>训练策略那些不是 YOLO 的重点。</del></p><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>我们知道网络的输出是 <code>x.view(-1, S, S, 5 * B + C)</code> 这种类型的格式，这是预测数据，即 $S \times S $ 组 $5 \times B + C$ 这样的数据，$C$ 是类别数量。那么可想而知，在训练阶段，同样需要提供同等尺寸大小的标签数据。</p><h2 id="数据与损失"><a href="#数据与损失" class="headerlink" title="数据与损失"></a>数据与损失</h2><p>YOLO 处理目标时，使用的是目标中心点的坐标相对图像大小的占比。如果一张图像的大小是 224 X 224，目标中心点位于 112 X 112，那么中心点的坐标是 $(0.5,0.5)$。这有两点好处：</p><ol><li>如果一个图像的尺寸是 1920 X 1080，目标中心点的坐标是 1000 X 1000，直接输出 1000 对于网络来说难以把控，会造成梯度爆炸的现象。而占比只需要输出 [0,1] 之间的小数，不会导致梯度爆炸。</li><li>方便图像的标准化处理。网络常常使用多个 batch 进行训练，每个 batch 的数据要求大小统一，对于不同尺寸的图像应选择 <code>resize</code>。如果直接用坐标，<code>resize</code> 后会导致坐标错位，而如果用占比，位于之前图像 (0.5, 0.5) 处的点在 <code>resize</code> 后的坐标仍然是 (0.5, 0.5)。</li></ol><p>由于 YOLO 最初设计的方案是：物体中心落到哪个格子，就由这个格子预测这个目标，这一观点需要仔细阅读代码才能理解。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和网络输出同等大小的标签</span></span><br><span class="line">target = torch.zeros(S, S, N)</span><br><span class="line"><span class="comment"># S=7，表示每个格子的占比</span></span><br><span class="line">cell_size = <span class="number">1.0</span> / float(S)</span><br><span class="line"><span class="comment"># 计算宽度和高度</span></span><br><span class="line">boxes_wh = boxes[:, <span class="number">2</span>:] - boxes[:, :<span class="number">2</span>]</span><br><span class="line"><span class="comment"># x,y 的中心点坐标，此时已经除以图像大小</span></span><br><span class="line">boxes_xy = (boxes[:, <span class="number">2</span>:] + boxes[:, :<span class="number">2</span>]) / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于 b 和 batch 的盒子进行处理</span></span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> range(boxes.size(<span class="number">0</span>)):</span><br><span class="line">    xy, wh, label = boxes_xy[b], boxes_wh[b], int(labels[b])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算中心点位于哪个格子</span></span><br><span class="line">    ij = (xy / cell_size).ceil() - <span class="number">1.0</span></span><br><span class="line">    <span class="comment"># 取出 i j，用于 SXS 的填充</span></span><br><span class="line">    i, j = int(ij[<span class="number">0</span>]), int(ij[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 格子左上角的坐标</span></span><br><span class="line">    x0y0 = ij * cell_size</span><br><span class="line">    <span class="comment"># 相对格子左上角的坐标</span></span><br><span class="line">    <span class="comment"># 除以 cell_size 没啥用，这人代码写的有问题，后面损失计算的时候又乘了回来</span></span><br><span class="line">    xy_normalized = (xy - x0y0) / cell_size</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始填充</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(B):</span><br><span class="line">        s = <span class="number">5</span> * k</span><br><span class="line">        target[j, i, s  :s+<span class="number">2</span>] = xy_normalized <span class="comment"># 坐标</span></span><br><span class="line">        target[j, i, s+<span class="number">2</span>:s+<span class="number">4</span>] = wh            <span class="comment"># 大小</span></span><br><span class="line">        target[j, i, s+<span class="number">4</span>    ] = <span class="number">1.0</span>           <span class="comment"># 置信度</span></span><br><span class="line">    target[j, i, <span class="number">5</span>*B + label] = <span class="number">1.0</span>           <span class="comment"># 类别标签</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> target</span><br></pre></td></tr></table></figure><p>在损失计算阶段，代码真的太长了不便展示，这里只记录核心要素：</p><ol><li>对于有目标计算损失，无目标忽略这一点，是通过对真实标签进行掩码处理实现的，只取出真实标签中置信度为 1 的标签记录维度，并在 predict 中取出同维度的数据就算损失，其余数据忽略。假设这一步保留了 $X$ 个盒子。</li><li>对于 $X$ 个盒子中的 $B$ 组数据继续处理，对于每组数据而言，选择和真实标签 IOU 最大的盒子计算损失，其余盒子忽略，也就是没有正负样本的概念。这里需要注意，如果网络初期计算到 IOU 为 0，那么默认第一个盒子和真实标签进行损失计算。</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我已经正负样本划分、格子、bounding box、anchor box 的概念已经搞混了，论文里不会写这太细节的东西，不然我也不会来读代码。毕竟整理理论知识太简单了，也容易自欺欺人，并不清楚网络的流程。所以 YOLO v2, v3, v4, v5 和 x 的内容等下几篇博客了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/183261974" target="_blank" rel="noopener">你一定从未看过如此通俗易懂的YOLO系列(从v1到v5)模型解读</a></li><li><a href="https://fengweiustc.github.io/paper-reading/2020/06/17/yolo/" target="_blank" rel="noopener">YOLO v1/v2/v3/v4</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;忙里偷闲，写几篇长文，从 YOLO 的 v1 到 v5。没想到时隔多年会回来重新看 YOLO 系列的东西，相比两阶段检测，YOLO 真的太快了，加上一些训练的 trick，mAP 也不会很低。网上看了好多教程不明所以，索性还是直接去读原论文了，读了原论文有些东西还是不理解，索性又去读了源程序。不过为了便于理解，有的地方不会按照论文顺序进行整理。少问问题，读论文产生的疑问在代码里都有解答，不看代码永远不能被称为学会了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>C++ 多线程</title>
    <link href="https://muyuuuu.github.io/2021/08/12/cpp-thread-safe/"/>
    <id>https://muyuuuu.github.io/2021/08/12/cpp-thread-safe/</id>
    <published>2021-08-12T10:05:47.000Z</published>
    <updated>2021-08-13T16:29:10.787Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>rush 项目的时候，有些地方可以并行化，可以借助 C++ 的多线程来加速程序的执行。多线程的基本概念在一年前整过了，这里只是来看一下 C++ 的多线程该怎么写，顺便查漏补缺。</p><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>在多线程进入 C++ 标准之前，人们使用 C++ 编写多线程的程序，只能依赖操作系统提供的 API。比如在 Linux 环境下就只能使用 pthread 库实现多线程，因此也一直被诟病。但有了 C++11 的 <code>std::thread</code> 以后，可以通过标准库在语言层面编写多线程程序了，直接的好处就是多线程程序的跨平台移植提供了便利。但是在编译的时候需要注意链接平台相关的线程库，如 <code>g++ demo.cpp -lpthread -o test.o</code>。</p><h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::thread t&#123;show_info, s&#125;;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上述程序为例，来详细的剖析一下多线程期间到底发生了什么：</p><ol><li>首先引入头文件 <code>thread</code>，在这个头文件中，C++ 11 提供了创建、管理线程的类和方法；</li><li>使用 <code>std::thread</code> 创建线程，并通过列表初始化传入函数名作为构造函数的参数。传入的函数会作为子线程的入口函数，也就是说，当子线程准备就绪之后，就会开始执行这个入口函数。由于函数名表示函数的地址，子线程可以快捷的找到函数地址进而执行。<blockquote><p>我们知道，每个程序都有一个入口。当程序被装载到内存，处于系统态完成一些初始化的工作之后，控制权就转交给程序入口，并以此为标志进入用户态，这是一个程序的开始。同样地，线程也需要有「开始」的地方。作为线程入口的函数，就是线程函数，也就是例子中的 show_info。线程函数必须在启动线程之前，就准备好，否则线程去执行什么呢？并在线程初始化后立即执行。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p></blockquote></li><li>当线程函数返回时，线程也就随之终止了，上述程序中使用 <code>join</code> 衔接方法确保主线程在子线程退出之后才退出，因为主线程会阻塞住，直到该子线程退出为止。如果程序员没有显式的说明线程结束该如何处理，那么线程对象在被销毁时调用的析构函数中，会调用 <code>std::terminate()</code> 函数，销毁当前对象。如果程序写多了，应该不至于犯主线程退出子线程还没结束的低级错误。</li></ol><h2 id="detach"><a href="#detach" class="headerlink" title="detach"></a>detach</h2><p>前面说过线程的 <code>join</code> 会阻塞调用线程，可以使用 <code>detach</code> 来避免，但一定要做好控制：避免主线程退出子线程还没结束的低级错误。一个 cppreference 官网的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">independentThread</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Starting concurrent thread.\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exiting concurrent thread.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCaller</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Starting thread caller.\n"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(independentThread)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exiting thread caller.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    threadCaller();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Starting thread caller.</span></span><br><span class="line"><span class="comment">// Starting concurrent thread.</span></span><br><span class="line"><span class="comment">// Exiting thread caller.</span></span><br><span class="line"><span class="comment">// Exiting concurrent thread.</span></span><br></pre></td></tr></table></figure><h1 id="可调用类型"><a href="#可调用类型" class="headerlink" title="可调用类型"></a>可调用类型</h1><p>在创建线程对象时，传入的参数不仅是可被调用执行的函数，类的对象如果能被调用，也是可以作为线程对象的参数，用于构造函数初始化线程对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">()</span></span>=<span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> a)</span> : cnt</span>&#123;a&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;cnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread t&#123;Task&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为要调用对象，所以重载了 <code>()</code> 运算符，不然线程不知道去哪个地址执行。此外，构造函数传入的是一个类类型的对象，所以对象会被拷贝到线程的存储空间，而后再开始执行。因此，<strong>类必须做好足够的拷贝控制</strong>，不然将出现难以调试的 bug，<del>我大概只知道深浅拷贝，等有时间了去看下移动语义</del>。</p><p>当然，不重载 <code>()</code> 运算符，选择类中的函数执行也是可以的，不过需要注意以下两点：</p><ul><li>必须显式地使用函数指针，作为 <code>std::thread</code> 构造函数的第一个参数；知道执行哪个函数。</li><li>非静态成员函数的第一个参数，实际上是类实例的指针。所以在创建线程时，需要显式地填入这个参数；知道执行的函数在哪个对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">()</span></span>=<span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> t)</span> : a</span>&#123;t&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::thread t&#123;&amp;A::show_info, &amp;a&#125;;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他要注意的数据类型"><a href="#其他要注意的数据类型" class="headerlink" title="其他要注意的数据类型"></a>其他要注意的数据类型</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>如果子线程函数的参数是引用类型，也需要格外注意。由于子线程的数据是主线程的拷贝，因此子线程函数得到的拷贝实际是「线程存储空间中的拷贝的引用」，并不是主线程中的变量，应该使用 <code>std::ref()</code> 来生成正确的引用绑定，否则会报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::thread t&#123;show_info, <span class="built_in">std</span>::ref(s)&#125;;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>右值引用和移动语义等我后期开坑了。</del></p><h1 id="锁与线程安全"><a href="#锁与线程安全" class="headerlink" title="锁与线程安全"></a>锁与线程安全</h1><p>众所周知，<del>写代码的人都学过操作系统，学过操作系统都知道线程同步</del>。线程同步一般有三种机制：互斥量、信号量和条件变量，这三者到底什么已经在<a href="https://muyuuuu.github.io/2021/02/19/process-synchronization/">这篇博客</a>中详细的描写过了，所以不再多说。不过当时是用 C 语言写的，现在来了解下 C++ 的写法。</p><h2 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123;</span><br><span class="line">        mtx.lock();</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1</span>));</span><br><span class="line">        counter++;</span><br><span class="line">        mtx.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(increase, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(increase, <span class="number">100</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"counter:"</span> &lt;&lt; counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>引入 <code>mutex</code> 头文件，创建 <code>std::mutex</code> 对象 <code>mtx</code></li><li>对于 <code>mtx</code> 对象，任意时刻最多允许一个线程对其进行上锁，上锁后操作变量，就不会出错</li><li><code>mtx.try_lock()</code> 是尝试上锁，如果上锁不成功，当前线程不阻塞</li><li>在用完锁之后一定记得释放锁，否则会发生死锁现象</li></ol><h2 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h2><p>为了避免 <code>mutex</code> 忘记解锁等情况，可以使用 <code>std::lock_guard</code>，<a href="https://en.cppreference.com/w/cpp/thread/lock_guard" target="_blank" rel="noopener">这个类</a>只有构造函数和析构函数，搭配 <code>mutex</code> 使用，在创建这个对象时传入锁，调用锁的 <code>lock</code> 函数；变量销毁会调用析构函数，此时调用锁的 <code>unlock</code> 函数，这也就是传说中的 RAII 机制 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p><p>如下述程序 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> ，避免一个线程意外退出没来得及释放锁，导致另一个线程无法获取资源而死锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase_proxy</span><span class="params">(<span class="keyword">int</span> time, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"throw excption...."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前线程休眠1毫秒</span></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1</span>));</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> time, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        increase_proxy(time, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt; <span class="string">", "</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(increase, <span class="number">100</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(increase, <span class="number">100</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"counter:"</span> &lt;&lt; counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lock-guard-与-adopt-lock"><a href="#lock-guard-与-adopt-lock" class="headerlink" title="lock_guard 与 adopt_lock"></a>lock_guard 与 adopt_lock</h2><p>还有一种为了防止死锁的方式是一次性申请所有临界资源的互斥量，只有申请到才能进行之后的操作，而 <code>std::lock</code> 提供了这种实现 <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>。此外，为了防止没有锁定或提前释放互斥量导致危险，可以使用 <code>lock_guard</code> 并传入 <code>std::adopt_lock</code>，前者保证当变量销毁时释放互斥量，后者保证线程已经上锁成功时不再调用 <code>lock()</code> 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bank_account</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bank_account</span><span class="params">(<span class="keyword">int</span> balance)</span> : <span class="title">balance</span><span class="params">(balance)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> balance;</span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(bank_account &amp;from, bank_account &amp;to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// avoid deadlock in case of self transfer</span></span><br><span class="line">    <span class="keyword">if</span>(&amp;from == &amp;to) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    <span class="comment">// lock both mutexes without deadlock</span></span><br><span class="line">    <span class="built_in">std</span>::lock(from.m, to.m);</span><br><span class="line">    <span class="comment">// make sure both already-locked mutexes are unlocked at the end of scope</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock1</span><span class="params">(from.m, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock2</span><span class="params">(to.m, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    from.balance -= amount;</span><br><span class="line">    to.balance += amount;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">bank_account <span class="title">my_account</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">bank_account <span class="title">your_account</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(transfer, <span class="built_in">std</span>::ref(my_account), <span class="built_in">std</span>::ref(your_account), <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(transfer, <span class="built_in">std</span>::ref(your_account), <span class="built_in">std</span>::ref(my_account), <span class="number">5</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>adopt_lock</code> 之外，还有 <code>try_to_lock</code>，<code>defer_lock</code>，他们都有不同的应用场景，还可以配合使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_block</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//unique_lock有多组构造函数, 这里std::defer_lock不设置锁状态</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">my_lock</span> <span class="params">(mtx, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">//尝试加锁, 如果加锁成功则执行</span></span><br><span class="line">    <span class="comment">//(适合定时执行一个job的场景, 一个线程执行就可以, 可以用更新时间戳辅助)</span></span><br><span class="line">    <span class="keyword">if</span>(my_lock.try_lock()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他锁的内容实在是太多了，还有时间锁、递归锁、<code>lock_unique</code>，读写锁的 <code>shared_lock</code> 等等，等哪天用到在整理这些，这里只整理最简单的，详情可以参考 cppreference <sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>。</p><h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p>如果按照之前 <code>C</code> 语言的写法，条件变量需要注意的是 <code>wait</code> 那边的判断一定是 <code>while</code> 循环。<a href="https://blog.7rule.com/2018/11/24/thread.html" target="_blank" rel="noopener"><code>C</code> 语言风格的代码</a>。</p><p>当然，如果按照 <code>C++</code> 的写法，我们发现条件变量的 <code>wait</code> 方法有<a href="https://en.cppreference.com/w/cpp/thread/condition_variable/wait" target="_blank" rel="noopener">两个参数</a>，第二个参数用于接受一个变量，如果继续等待，那么那个变量的取值是 <code>false</code>，如果不需等待，那么那个变量返回 <code>true</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex g_mutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable g_cond;</span><br><span class="line"><span class="keyword">int</span>  g_i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> g_running = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>; </span><br><span class="line">      ++g_i;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"plus g_i by func thread "</span> </span><br><span class="line">                &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待被唤醒</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"wait for exit"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  g_cond.wait(lock, [=] &#123;<span class="keyword">return</span> g_running;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func thread exit"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(ThreadFunc, n)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">      ++g_i;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"plus g_i by main thread "</span> </span><br><span class="line">                &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 唤醒</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">    g_running = <span class="literal">true</span>;</span><br><span class="line">    g_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  t1.join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g_i = "</span> &lt;&lt; g_i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">plus g_i by func thread 140476623930944</span><br><span class="line">plus g_i by func thread 140476623930944</span><br><span class="line">wait for exit // 表示子线程等待唤醒</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">plus g_i by main thread 140476623935296</span><br><span class="line">func thread exit // 子线程被唤醒</span><br><span class="line">g_i = 200</span><br></pre></td></tr></table></figure><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>因为一开始我也不知道该怎么去写信号量，所以打开了万能的搜索引擎，看到了关于 C++ 不支持信号量这样的东西 <sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>。如果想实现信号量，可以通过互斥量和条件变量来实现。而关于信号量和互斥量的区别，在<a href="https://muyuuuu.github.io/2021/02/19/process-synchronization/">这篇文章</a>中已经写明了。那么来实现一个信号量的类 <sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::mutex mutex_;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable cv_;</span><br><span class="line">  <span class="keyword">int</span> count_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> count = <span class="number">0</span>)</span> : <span class="title">count_</span><span class="params">(count)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    ++count_;</span><br><span class="line">    cv_.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="comment">// 第二个参数，如果返回 false 继续等待, 如果为 true，可以继续申请资源</span></span><br><span class="line">    cv_.wait(lock, [=] &#123; <span class="keyword">return</span> count_ &gt; <span class="number">0</span>; &#125;);</span><br><span class="line">    --count_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">FormatTimeNow</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">time_t</span> now_c = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(now);</span><br><span class="line">  <span class="built_in">std</span>::tm* now_tm = <span class="built_in">std</span>::localtime(&amp;now_c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">std</span>::strftime(buf, <span class="keyword">sizeof</span>(buf), format, now_tm);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Semaphore <span class="title">g_semaphore</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// 防止同时抢占输出资源</span></span><br><span class="line"><span class="built_in">std</span>::mutex g_io_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  g_semaphore.Wait();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::thread::id thread_id = <span class="built_in">std</span>::this_thread::get_id();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> now = FormatTimeNow(<span class="string">"%H:%M:%S"</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_io_mutex)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; thread_id &lt;&lt; <span class="string">": wait succeeded"</span> </span><br><span class="line">              &lt;&lt; <span class="string">" ("</span> &lt;&lt; now &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Sleep 1 second to simulate data processing.</span></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  g_semaphore.Signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    v.emplace_back(&amp;Worker);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::thread&amp; t : v) &#123;</span><br><span class="line">    t.join();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>信号量的值为 3，表示能同时申请 3 个资源</li><li>当一个线程申请资源后，即执行了 <code>wait</code> 操作，<code>count_</code> 取值递减，表示有一个资源被占用</li><li>当 <code>count_</code> 取值小于 0 时，调用条件变量的 <code>wait</code> 方法，当先线程等待有了资源被唤醒</li><li>当一个线程释放资源后，执行了 <code>signal</code> 操作，<code>count_</code> 取值递增，表示有一个资源被释放，并执行 <code>notify_one</code> 方法，即唤醒一个等待的线程</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://liam.page/2017/05/16/first-step-on-multithread-programming-of-cxx/" target="_blank" rel="noopener">线程函数</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zhuanlan.zhihu.com/p/34660259" target="_blank" rel="noopener">RAII机制</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zhuanlan.zhihu.com/p/91062516" target="_blank" rel="noopener">线程异常退出导致死锁</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://en.cppreference.com/w/cpp/thread/lock" target="_blank" rel="noopener">std::lock申请多个互斥量</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;"><a href="https://en.cppreference.com/w/cpp/thread/lock_tag_t" target="_blank" rel="noopener">cppreference_lock</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.boost.org/doc/libs/1_31_0/libs/thread/doc/faq.html" target="_blank" rel="noopener">C++不支持信号量</a></span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;"><a href="https://segmentfault.com/a/1190000006818772" target="_blank" rel="noopener">信号量实现</a></span><a href="#fnref:7" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;rush 项目的时候，有些地方可以并行化，可以借助 C++ 的多线程来加速程序的执行。多线程的基本概念在一年前整过了，这里只是来看一下 C++ 的多线程该怎么写，顺便查漏补缺。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
      <category term="OS" scheme="https://muyuuuu.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>花样繁多的GAN</title>
    <link href="https://muyuuuu.github.io/2021/08/11/GAN-basic/"/>
    <id>https://muyuuuu.github.io/2021/08/11/GAN-basic/</id>
    <published>2021-08-11T01:39:51.000Z</published>
    <updated>2021-08-13T16:35:18.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在做对抗样本的时候，我发现对抗防御和 GAN 在某种程度上很像：</p><ul><li>对抗防御：内部生成对抗样本攻击分类器，分类器更新参数防御攻击；</li><li>GAN：生成器 $G$ 生成样本欺骗判别器，判别器更新防御 $G$ 的欺骗。</li></ul><p>所以说，这俩在某种程度上真的很像，所以决定整理一下 GAN 的知识，开拓一下思路，视频内容来自<a href="https://www.bilibili.com/video/BV1JE411g7XF?from=search&amp;seid=17206901754423397958" target="_blank" rel="noopener">这里</a>。警告：里面有大量数学公式的推导，而我就不一样了，<del>不仅有公式推导</del>还有代码。</p><a id="more"></a><h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>我发现我在看论文或者别人的博客的时候，经常发现数据分布、概率分布等，然而时间长了竟然不知道所谓的分布是什么，这里来提前说一下：</p><ul><li>数据分布：可以理解为字面意思，数据的分布。比如一个数据集：<code>1,2,3</code>，只有三条数据，可能是 1，可能是 2，可能是 3，这就是数据的分布；</li><li>概率分布：可以理解为字面意思，概率的分布。比如一枚硬币，正面朝上的概率是 50%，反面朝上的概率也是 50%，这就是概率分布，类似的，正态分布、泊松分布等都是概率分布。</li></ul><h1 id="朴素-GAN"><a href="#朴素-GAN" class="headerlink" title="朴素 GAN"></a>朴素 GAN</h1><p><img data-src="https://z3.ax1x.com/2021/08/11/fNaeNF.png" alt></p><p>以图像为例，GAN 的生成器 $G$ 输入为某种随机分布的数据，输出为一张图像；而判别器 $D$ 的输入是一张图像，输出是一个数字，数字越大表示当前图像的质量越高，我们设置 $G$ 生成的图片是假的。两者相互博弈，$G$ 企图去欺骗 $D$，$D$ 防止来自 $G$ 的欺骗。</p><ul><li>$G$ 只适合生成，不适合做判别，因为 $G$ 的主要任务是生成图像。如果 $G$ 要判别图像的好坏，如何定义生成图像的好坏？生成图像的每个像素点的位置、偏移、颜色、旋转，以及像素点之间的联系将会很复杂，模型将会很复杂，所以由 $D$ 来做判别；</li><li>$D$ 只适合判别，不适合生成。$D$ 的判别是宏观角度的判断当前图像好不好，并不会纠结于某个像素的颜色、旋转、偏移的好坏。如果 $D$ 要做生成，那么需要遍历所有数据 $x$，来看看哪个数据使得网络的输出得分最高。这样虽然可以生成，但枚举所有数据是不可能的操作。</li></ul><p>或者说，这是一种<strong>另类的小样本</strong>，网络不可能见过所有生成的数据，但是要求 $D$ 能判断没见过的数据是好是坏。此外，<strong>足够强的 $D$ 才能迫使 $G$ 生成的图片足够逼真，足够好的 $G$ 才会使 $D$ 的判别越来越准。</strong> 在接下来的实验中将见识到这一点。</p><p><img data-src="https://z3.ax1x.com/2021/08/11/fN64Kg.png" alt></p><p>如上图所示：横坐标为 $G$ 和 $D$ 的演化过程，纵坐标表示概率分布，红色曲线表示 $G$，红色的点表示 $G$ 生成的数据，绿色的线表示 $D$,绿色的点表示真实数据。</p><ol><li>首先，图的最左侧，$G$ 生成的数据和真是数据不符，那么判别器抑制 $G$ 把数据生成到其他分布，并希望 $G$ 生成的数据分布和真实数据的分布较为接近；</li><li>其次，图的中间，因为 $G$ 的目的是无限度找 $D$ 的漏洞，虽然相比左图，生成数据的分布和真实数据的分布接近了，但是把更多的数据生成到了另外的分布，这也是不行的；</li><li>经过多次的博弈，最终达到右侧图的效果。</li></ol><h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><h3 id="G-的目标"><a href="#G-的目标" class="headerlink" title="$G$ 的目标"></a>$G$ 的目标</h3><p>我们的目标可以用公式表述为：通过 $G$，寻找数据 $x$ 的分布 $P_G(x)$，但是目前只有数据 $x$，也就是知道近似的 $P(x)$。可以通过极大似然估计来求解问题，使 $P_G(x)$ 逐渐逼近 $P(x)$，即在 $P(x)$ 中采 $m$ 个样本，使得 $\prod_{i=1}^mP_G(x_i;\theta)$ 的概率最大，逐步采样与迭代求出模型的参数 $\theta$。</p><p>\begin{aligned}<br>\theta &amp;= \arg \max_\theta \prod_{i=1}^mP_G(x_i;\theta) \\<br>       &amp;\Leftrightarrow \arg \max_\theta \log \prod_{i=1}^mP_G(x_i;\theta) \\<br>       &amp;= \arg \max_\theta \sum_{i=1}^m \log P_G(x_i;\theta) \\<br>       &amp;\Leftrightarrow \arg \max_\theta \mathbb{E}_{x\sim p(x)} \bigl[ \log P_G(x;\theta) \bigr] \\<br>       &amp;\Leftrightarrow \arg \max_\theta \int_x p(x) \log P_G(x;\theta) dx - \int_x p(x) \log P(x) dx \\<br>       &amp;= \arg \min_\theta KL(P(x) || P_G(x;\theta))<br>\end{aligned}</p><p>也就是说，生成模型的求出的 $P_G(x;\theta)$ 最好情况就是与真是数据的分布 $P(x)$ 的 $KL$ 散度距离最小。当然你也可以用其他距离，详情可以参考 f-GAN <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 这篇论文，不过究其到底，都可以描述为寻找一个 $P_G(x;\theta)$，使其生成的数据分布和 $P(x)$ 最为接近， $G^\star=\arg\min_G D(P_G(x;\theta), P(x))$。</p><p>当然在模型参数过多的情况下，极大似然估计求解困难，可以使用神经网络的反向传播，来求解出模型的参数。</p><h3 id="D-的目标"><a href="#D-的目标" class="headerlink" title="$D$ 的目标"></a>$D$ 的目标</h3><p>对于 $D$ 而言，其目标是期望真实数据的评分很高，$G$ 生成数据的评分很低，以此来鼓励 $G$ 生成更加逼真的数据达到内卷的目的。那么 $D$ 的目标可以描述为：</p><p>\begin{equation}\label{D}<br>\max \mathbb{E}_{x\sim P(x)} \bigl[ \log D(x) \bigr] + \mathbb{E}_{x\sim P_G(x;\theta)} \bigl[ \log(1-D(x)) \bigr]<br>\end{equation}</p><p>此时固定 $G$，训练 $D$，式 $\eqref{D}$ 继续推导：</p><p>\begin{aligned}<br>\eqref{D} &amp;= \int_x P(x) \log (D(x)) dx+ \int_x P_G(x) \log (1 - D(x)) dx \\<br>&amp;= \int_x P(x) \log (D(x)) + P_G(x) \log (1 - D(x)) dx\\<br>\end{aligned}</p><p>为了使积分最大，可以等价转换为使积分内部的元素取值最大，即对于以下公式求对 $D(x)$ 微分，微分等于0的时候，取得极值，且下述公式是极大值：</p><p>\begin{equation}<br>f(D(x)) = P(x) \log (D(x)) + P_G(x) \log (1 - D(x))<br>\end{equation}</p><p>此时求出的 $D(x)$：</p><p>\begin{equation}<br>D(x) = \frac{P(x)}{P(x)+P_G(x)}<br>\end{equation}</p><p>把 $D(x)$ 带回式 $\eqref{D}$ ：</p><p>\begin{aligned}<br>\eqref{D} &amp;= \mathbb{E}_{x\sim P(x)} \bigl[ \log \frac{P(x)}{P(x)+P_G(x)} \bigr] + \mathbb{E}_{x\sim P_G(x)} \bigl[ \log \frac{P_G(x)}{P(x)+P_G(x)} \bigr] \\<br>&amp;= \int_x P(x)\log \frac{P(x)}{P(x)+P_G(x)} dx + \int_x P_G(x)\log \frac{P_G(x)}{P(x)+P_G(x)} dx \\<br>&amp;= -2\log 2 + KL(P(x) || \frac{P(x) + P_G(x)}{2}) + KL(P_G(x) || \frac{P(x) + P_G(x)}{2}) \\<br>&amp;= -2\log 2 + 2 JS(P(x) || P_G(x))<br>\end{aligned}</p><p>而 JS 散度的取值范围是 $[0, \log2]$，因此 式 $\eqref{D}$ 的最大值为 0。而这里的代码实现可以使用 <code>torch.BCE</code>，但要按照负梯度进行反向传播，所以损失那里直接加了负数，因此代码的损失是正数不要感到意外。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>既然有了模型结构和公式推导，那么来看一下代码改怎么写，以 <code>MNIST</code> 数据集为例，全部代码在 <a href="https://github.com/muyuuuu/colab/blob/main/GAN/minmaxGAN.ipynb" target="_blank" rel="noopener"><code>github</code></a>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment"># g_input_dim = 100, g_output_dim=784</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, g_input_dim, g_output_dim)</span>:</span></span><br><span class="line">        super(Generator, self).__init__()       </span><br><span class="line">        self.fc1 = nn.Linear(g_input_dim, <span class="number">256</span>)</span><br><span class="line">        self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features*<span class="number">2</span>)</span><br><span class="line">        self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features*<span class="number">2</span>)</span><br><span class="line">        self.fc4 = nn.Linear(self.fc3.out_features, g_output_dim)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span> </span><br><span class="line">        x = F.leaky_relu(self.fc1(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.leaky_relu(self.fc2(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.leaky_relu(self.fc3(x), <span class="number">0.2</span>)</span><br><span class="line">        <span class="keyword">return</span> torch.tanh(self.fc4(x))</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment"># d_input_dim = 784</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d_input_dim)</span>:</span></span><br><span class="line">        super(Discriminator, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(d_input_dim, <span class="number">1024</span>)</span><br><span class="line">        self.fc2 = nn.Linear(self.fc1.out_features, self.fc1.out_features//<span class="number">2</span>)</span><br><span class="line">        self.fc3 = nn.Linear(self.fc2.out_features, self.fc2.out_features//<span class="number">2</span>)</span><br><span class="line">        self.fc4 = nn.Linear(self.fc3.out_features, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = F.leaky_relu(self.fc1(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.dropout(x, <span class="number">0.3</span>)</span><br><span class="line">        x = F.leaky_relu(self.fc2(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.dropout(x, <span class="number">0.3</span>)</span><br><span class="line">        x = F.leaky_relu(self.fc3(x), <span class="number">0.2</span>)</span><br><span class="line">        x = F.dropout(x, <span class="number">0.3</span>)</span><br><span class="line">        <span class="keyword">return</span> torch.sigmoid(self.fc4(x))</span><br><span class="line"></span><br><span class="line">n_epoch = <span class="number">200</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, n_epoch+<span class="number">1</span>):           </span><br><span class="line">    D_losses, G_losses = [], []</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (x, _) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            D_train(x)</span><br><span class="line">        D_losses.append(D_train(x))</span><br><span class="line">        G_losses.append(G_train(x))</span><br></pre></td></tr></table></figure><p>$D$ 为什么要比 $G$ 多训练两次？因为只有去够好的 $D$，此案能使得 $G$ 也好，$G$ 好了 $D$ 也会好；否则 $D$ 很差，$G$ 也懒得更新，生成的结果会很差。此外，如果两者都只训练一次，我发现 $D$ 的损失是逐步上升的。如下图所示，右侧是 $D$ 训练三次的，左侧是 $D$ 训练一次的效果，明显发现右侧的效果要好一些。</p><p><img data-src="https://z3.ax1x.com/2021/08/11/fNru9O.png" alt></p><h1 id="WGAN-GP"><a href="#WGAN-GP" class="headerlink" title="WGAN-GP"></a>WGAN-GP</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过前文我们可以了解到，如果 $D$ 训练得太弱，指示作用不显著，则 $G$ 不能进行有效的学习；但是，如果 $D$ 训练得太好， $G$ 就无法得到足够的梯度继续优化，这样一来， $D$ 的训练火候就非常难把控，这就是 GAN 训练难的根源。如下图所示：</p><p><img data-src="https://z3.ax1x.com/2021/08/11/fUlFNn.png" alt></p><ul><li>左侧的 $D$ 很弱，$G$ 也不知道哪边好哪边弱；</li><li>右侧的 $D$ 很强，存在梯度消失和梯度爆炸问题，即在区域 $G$ 获取到的梯度近似为0而无法获得有效的更新。</li></ul><blockquote><p>说点通俗的话，你在学习，你的老师太弱，你学不出来；你的老师太强，无论你怎么学老师都说你是错的，即使进步是有效的，但还是被你的老师说没用，那么之前的进步也可能会回退，你还是学不出来。</p></blockquote><h2 id="朴素-GAN-的缺陷"><a href="#朴素-GAN-的缺陷" class="headerlink" title="朴素 GAN 的缺陷"></a>朴素 GAN 的缺陷</h2><p>虽然有着完备的理论推导，但是朴素 GAN 仍有以下的缺陷：</p><ul><li>对于 $D$ 的目标，经过推导会发现竟然要最大化 $P(x)$ 和 $P_G(x;\theta)$ 的距离，显然违背了 $D$ 的初衷，或者说，不是这样判别的；关于 $D$ 计算距离的缺陷，这里 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> 有详细公式推导。</li><li>对于 $G$ 的目标，如果一味的最小化 $P_G(x;\theta)$ 和 $P(x)$ 的距离，会使生成的数据只有安全性，没有多样性，这显然也是不好的。</li></ul><h2 id="Wasserstein-距离"><a href="#Wasserstein-距离" class="headerlink" title="Wasserstein 距离"></a>Wasserstein 距离</h2><p>于是，如何巧妙的<strong>衡量生成分布与真实分布之间的距离</strong>，WGAN 定义了 Wasserstein 距离。即：</p><p>\begin{equation}<br>W(P(x), P_G(x;\theta))=\inf_{\gamma\sim\prod(P(x), P_G(x;\theta))} \mathbb{E}_{(x,y)\sim \gamma} \bigl[ \Vert| x-y \Vert \bigr]<br>\end{equation}</p><p>$\prod(P(x), P_G(x;\theta))$ 是 $P(x)$ 和 $P_G(x;\theta)$ 联合分布的集合，对于每一个联合分布 $\gamma$ 从中取样，得到一个真实样本 $x$ 和一个虚假样本 $y$，并计算联合分布 $\gamma$ 中两两样本的距离 $\Vert x-y \Vert$，这也就是 Wasserstein 距离。意思是，从 $y$ 移动到 $x$ 需要多远，即便两个分布没有重叠，Wasserstein 距离仍然能够反映它们的远近。</p><p>既然如此，那么就把 Wasserstein 距离用到 GAN 中，由于 $\inf$ 是最大下确界，所以：</p><p>\begin{aligned}<br>W(P(x), P_G(x;\theta)) &amp; \leq \int_{P(x), P_G(x;\theta)} \Vert x-y \Vert d\gamma \\<br>{ }&amp; = \mathbb{E}_{(x,y)\sim \gamma} \bigl[ \Vert x-y \Vert \bigr] \\<br>&amp;= \mathbb{E}_{x\sim P(x)} D(x) - \mathbb{E}_{x\sim P_G(x;\theta)} D(G(x))<br>\end{aligned} </p><p>至此，真实分布与生成分布之间的 Wasserstein 距离融入到了 GAN 中。朴素 GAN 的 $D$ 做的是真假二分类任务，所以最后一层是 sigmoid，但是现在 WGAN 中的 $D$ 做的是近似拟合 Wasserstein 距离，属于回归任务，所以要把 $D$ 最后一层的 sigmoid 拿掉。</p><p>接下来 $G$ 要最小化 Wasserstein 距离，$D$ 要最大化 Wasserstein 距离的优良性质，也不需要担心 $D$ 导致的梯度消失的问题，这样就得到了WGAN的两个loss，$G$ 的 loss 是 $- \mathbb{E}_{x\sim P_G(x;\theta)} D(G(x))$，$D$ 的 loss 是 $-\mathbb{E}_{x\sim P(x)} D(x) + \mathbb{E}_{x\sim P_G(x;\theta)} D(G(x))$ （距离最小，取负号）。</p><p>为了使距离不在梯度消失问题和梯度爆炸，后续有论文进行了改进 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，并不是直接对 $D$ 的权重进行裁剪限制在某个范围内，而是加入了惩罚项，因此 $D$ 的损失函数变为：</p><p>\begin{equation}<br>-\mathbb{E}_{x\sim P(x)} D(x) + \mathbb{E}_{x\sim P_G(x;\theta)} D(G(x)) + \lambda \mathbb{E}_{\hat{x}\sim P(\hat{x})} \bigl( \Vert \nabla_\hat{x} D(\hat{x}) \Vert_2 - 1 \bigr)^2<br>\end{equation}</p><p>$\hat{x}$ 是真实数据和虚假数据的随机采样，也就是说，希望 $D$ 对 $\hat{x}$ 数据的梯度保持在都是 1 左右，这样就不用再考虑梯度消失问题和梯度爆炸问题，虚假数据也好往真实数据去移动。最终的算法如下所示：</p><p><img data-src="https://z3.ax1x.com/2021/08/11/fU5bh4.png" alt></p><p>WGAN 有以下优势：</p><ul><li>不再需要纠结如何平衡 $G$ 和 $D$ 的训练程度，大大提高了GAN 训练的稳定性,$D$ 训练得越好，对提升 $G$ 就越有利。</li><li>即使网络结构设计得比较简陋，WGAN 也能展现出良好的性能，包括避免了样本不够多样性的现象，体现了出色的鲁棒性。</li><li>$D$ 的 loss 很准确地反映了 $G$ 生成样本的质量，因此可以作为展现 GAN 训练进度的定性指标。</li></ul><h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><p>完整代码在 <a href="https://github.com/muyuuuu/colab/blob/main/GAN/WGAN-GP.ipynb" target="_blank" rel="noopener"><code>github</code></a>，这里只展示计算惩罚项的部分：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_gradient_penalty</span><span class="params">(D, real_samples, fake_samples)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># [0, 1] 之间的随机数</span></span><br><span class="line">    alpha = torch.rand(<span class="number">1</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成 \hat&#123;x&#125;</span></span><br><span class="line">    x = (alpha * real_samples + ((<span class="number">1</span> - alpha) * fake_samples)).requires_grad_(<span class="literal">True</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># D 对生成数据的梯度控制为 1 左右，所以计算梯度</span></span><br><span class="line">    interpolates = D(x)</span><br><span class="line"></span><br><span class="line">    fake = torch.ones(bs, <span class="number">1</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算 D(x) 对 interpolates 的梯度</span></span><br><span class="line">    gradients = torch.autograd.grad(</span><br><span class="line">        outputs=interpolates, <span class="comment"># 用来求导的</span></span><br><span class="line">        inputs=x,             <span class="comment"># 被求导的梯度值</span></span><br><span class="line">        grad_outputs=fake,    <span class="comment"># 求梯度时对输出的权重</span></span><br><span class="line">        create_graph=<span class="literal">True</span>,    <span class="comment"># 创建计算图</span></span><br><span class="line">    )[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    gradient_penalty = ((gradients.norm(<span class="number">2</span>, dim=<span class="number">1</span>) - <span class="number">1</span>) ** <span class="number">2</span>).mean()</span><br><span class="line">    <span class="keyword">return</span> gradient_penalty</span><br></pre></td></tr></table></figure><p>可能是我网络设置的比较简单，效果并不是很好：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><center> After 100 epochs </center></th><th style="text-align:center"><center>After 200 epochs</center></th><th style="text-align:center"><center>After 300 epochs</center></th><th style="text-align:center"><center>After 400 epochs</center></th><th style="text-align:center"><center>After 500 epochs</center></th></tr></thead><tbody><tr><td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwc9JA.png" alt></td><td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwcnij.png" alt></td><td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwclQ0.png" alt></td><td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwcBy6.png" alt></td><td style="text-align:center"><img data-src="https://z3.ax1x.com/2021/08/12/fwcseO.png" alt></td></tr></tbody></table></div><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文涉及了大量的公式推导，从朴素的 GAN 推到了 WGAN-GP。此外，还有啥 conditional GAN，infoGAN，BigGAN，cycleGAN，XGAN 等等等等，不过那些东西脱离了我要做的内容，所以，等哪天空闲了，会简单的整理这些模型的框架和 idea，如果不忙会尝试复现一个 photo shop。</p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/pdf/1606.00709.pdf" target="_blank" rel="noopener">f-GAN论文</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://arxiv.org/pdf/1704.00028.pdf" target="_blank" rel="noopener">Improved WGAN</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zhuanlan.zhihu.com/p/25071913" target="_blank" rel="noopener">判别器JS散度距离缺陷</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做对抗样本的时候，我发现对抗防御和 GAN 在某种程度上很像：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对抗防御：内部生成对抗样本攻击分类器，分类器更新参数防御攻击；&lt;/li&gt;
&lt;li&gt;GAN：生成器 $G$ 生成样本欺骗判别器，判别器更新防御 $G$ 的欺骗。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以说，这俩在某种程度上真的很像，所以决定整理一下 GAN 的知识，开拓一下思路，视频内容来自&lt;a href=&quot;https://www.bilibili.com/video/BV1JE411g7XF?from=search&amp;amp;seid=17206901754423397958&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。警告：里面有大量数学公式的推导，而我就不一样了，&lt;del&gt;不仅有公式推导&lt;/del&gt;还有代码。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>一些对抗样本去噪算法</title>
    <link href="https://muyuuuu.github.io/2021/08/05/some-adversarial-sample-denoise/"/>
    <id>https://muyuuuu.github.io/2021/08/05/some-adversarial-sample-denoise/</id>
    <published>2021-08-05T05:45:59.000Z</published>
    <updated>2021-08-22T13:24:05.593Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>忙完了其它的，还是要回归科研做好整理，相当于论文笔记吧。对抗样本去噪算法算是告以段落，或者说叫对抗样本提纯。本文总结了一些近几年的、思路还行结果也还好的对抗样本去噪算法，就相当于写个类似的综述了，注意，并非详解。优缺点仅是个人分析，<del>其实论文读多了或者看了代码，总会有一些想法</del>。包含以下论文：</p><ol><li>Comdefend: An efficient image compression model to defend adversarial examples, CVPR 2019</li><li>Feature denoising for improving adversarial robustness, CVPR 2019</li><li>Defense against adversarial attacks using high-level representation guided denoiser, CVPR 2018</li><li>A Self-supervised Approach for Adversarial Robustness, CVPR 2020</li><li>Denoised Smoothing: A Provable Defense for Pretrained Classifiers, NIPS 2020</li><li>Stochastic Security: Adversarial Defense Using Long-Run Dynamics of Energy-Based Models, ICLR 2021</li><li>Online Adversarial Purification based on Self-Supervision, ICLR 2021</li><li>Adversarial Purification with Score-based Generative Models, ICML 2021</li></ol><a id="more"></a><h1 id="ComDefend"><a href="#ComDefend" class="headerlink" title="ComDefend"></a>ComDefend</h1><p>来自论文：Comdefend: An efficient image compression model to defend adversarial examples, CVPR 2019。</p><p><img data-src="https://z3.ax1x.com/2021/08/22/hpM6XR.png" alt></p><ul><li>核心思想，在目标模型之前训练一个编码器和解码器，编码器的目标是提取图像的结构信息，移除冗余信息；解码器的目标是重构输入的图像，移除扰动信息。</li><li>损失函数，对于编码器，使用更多的 0 来编码图像，因此损失为 $\lambda \Vert Com(\theta_1, x) \Vert^2$，使其尽可能的小；对于解码器要尽可能的重构原始图像，因此损失为 $\Vert Rec(\theta_2, Com(\theta_1, x)+\phi) -x \Vert^2$，$\phi$ 是高斯噪音。最终的损失是两者相加，两个模型的参数是同时训练和更新的。但是我在复现的时候，发现 $\lambda = 0.0001$，也能猜出这篇论文的大概效果。</li></ul><p><strong>对抗样本在输入层的扰动其实只是很小的一部分，微小的扰动会在模型隐层无限放大。这篇论文只是在输入层去除对抗样本的扰动信息，没有考虑在模型隐层去除扰动信息。</strong></p><h1 id="Feature-Denoising"><a href="#Feature-Denoising" class="headerlink" title="Feature Denoising"></a>Feature Denoising</h1><p>来自论文 Feature denoising for improving adversarial robustness, CVPR 2019。如下图所示，论文注意到了对抗样本在模型高层的巨大差异信息，所以，选择了在模型的高层对数据进行去噪，而不是输入层。</p><p><img data-src="https://z3.ax1x.com/2021/08/05/fZKpjA.png" alt></p><p>论文选择的去噪方式也很简单，对于特征图 $y$，对于一个区域 $L$，重新计算其表示：</p><p>\begin{equation}<br>y_i=\frac{1}{C(x)}\sum_{j \in L} f(x_i, x_j) \cdot x_j<br>\end{equation}</p><p>其中，$f(x)$ 有多种选择，论文中给出了：高斯函数、内积、和一些滤波器。</p><h1 id="HGD"><a href="#HGD" class="headerlink" title="HGD"></a>HGD</h1><p>来自论文：Defense against adversarial attacks using high-level representation guided denoiser, CVPR 2018。</p><p><img data-src="https://z3.ax1x.com/2021/08/22/hpQS3Q.png" alt></p><p>核心思想：基于干净样本和对抗样本在模型高维的差异来指导去噪器的训练。设 $x$ 为干净样本，$x^\star$ 为对抗样本，$\hat{x}$ 为对抗样本去噪后的样本。论文选择 U-Net 结构对样本进行去噪，输入为 $x^\star$，输出为同等大小的 $-d\hat{x}$，那么 $\hat{x}=x^\star - d\hat{x}$，使用 $L_1$ 范数作为 $\hat{x}$ 和 $x$ 的损失。第二个损为 $f_l(x)$ 与 $f_l(\hat{x})$ 的 $L_1$ 范数，即去噪样本和干净样本在模型第 $l$ 层的差异应尽可能接近。</p><p>我觉得这篇论文的思想是不错的，所以在我的工作中也借鉴了这篇论文的思想。分别在模型的输入层和隐层对对抗样本进行去噪，不过其他内容则不一样了。</p><h1 id="NRP"><a href="#NRP" class="headerlink" title="NRP"></a>NRP</h1><p>来自论文：A Self-supervised Approach for Adversarial Robustness, CVPR 2020。这篇论文我也<a href="https://github.com/muyuuuu/Paper-ReImplement" target="_blank" rel="noopener">复现</a>了，讲真复现结果很差。一方面是论文中给出的参数不合理，一方面是论文并没有对一些东西解释清楚，最重要的是不仅没给代码，还没说怎么实现他的代码，也没有说某些实验参数，所以我只能按照论文描述来实现代码了。那为什么还要写呢？因为这篇论文借鉴 GAN 的思想来去除扰动，还是感觉有一点点新意的。</p><p><img data-src="https://z3.ax1x.com/2021/08/22/hpQ3E6.png" alt></p><p>作者定义一个提纯网络 $P$ 用于去除噪音，定义判别网络 $C$ 来判断当前样本是对抗样本还是干净样本，定义 backbone $F$ 来提取对抗样本和干净样本的特征差异生成自监督扰动，将扰动叠加至干净样本生成对抗样本，作为 $P$ 的训练数据。$P$ 去噪后传送给 $C$，以此来定义 $P$ 去除扰动的好坏。损失函数由三个部分组成，最终带权相加组成最终的损失函数：</p><ul><li>对抗损失是 $P(\hat{x})$ 和 $x$ 在判别网络 $C$ 上的相似度</li><li>特征损失为 $F(x)$ 和 $F(\hat{x})$ 的欧式距离</li><li>像素损失为 $P(\hat{x})$ 和 $x$ 的欧氏距离</li></ul><h1 id="Denoised-smoothing"><a href="#Denoised-smoothing" class="headerlink" title="Denoised smoothing"></a>Denoised smoothing</h1><p>这篇论文来自 Denoised Smoothing: A Provable Defense for Pretrained Classifiers, NIPS 2020。</p><p>写这篇论文并不是因为这个论文发表的等级高、时间新。而是因为，我发现一些对抗去噪采纳了集成的思想，这篇论文就是其一。<strong>借助多个分类器的投票结果指导去噪器的训练</strong>，三个臭皮匠，赛过诸葛亮，何况分类器呢？如果你对集成感兴趣，可以考虑沿着这个方向做下去。这个论文还算是集成思想中比较保守的了。</p><p><img data-src="https://z3.ax1x.com/2021/08/22/hpQ6PS.png" alt></p><p>但是呢，我是比较反感堆叠模型这样的方案的，这就相当于应该花 3 年去准备高考，而你花了 21 年去准备，效果虽然好，但是成本太大了。应该设计算法去提高一个模型的准确度，而不是多个模型投机取巧，另外我也没这样大规模的算力。</p><p>这篇论文写了一个单独的<a href="https://www.microsoft.com/en-us/research/blog/denoised-smoothing-provably-defending-pretrained-classifiers-against-adversarial-examples/" target="_blank" rel="noopener">博客</a>，也给出了<a href="https://github.com/microsoft/denoised-smoothing" target="_blank" rel="noopener">程序</a>，思路还是比较清晰的，在损失函数上，先用去噪后的图像和原始图像的 MSE 作为损失，再用去噪后的图像和原始图像在高维的差异作为损失微调。</p><h1 id="EBM-defense"><a href="#EBM-defense" class="headerlink" title="EBM-defense"></a>EBM-defense</h1><p>论文来自 Stochastic Security: Adversarial Defense Using Long-Run Dynamics of Energy-Based Models, ICLR 2021。模型啥的也比较简单，但是我比较反感堆叠模型的操作，丑拒这样的 idea。</p><p><img data-src="https://z3.ax1x.com/2021/08/21/fze1BD.png" alt></p><h1 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h1><p>来自论文 Online Adversarial Purification based on Self-Supervision, ICLR 2021。这篇论文在模型、算法还是有一定创新度的，也是我重点复现的论文之一。不过这篇论文虽然有对抗样本提纯的概念，但严格意义来说，属于对抗训练的论文，应为这个算法会修改目标模型的参数。</p><p><img data-src="https://z3.ax1x.com/2021/08/22/hplmIf.png" alt></p><ul><li>在训练阶段，设计两个损失，第一个损失是目标模型的分类损失，第二个损失是子监督扰动的损失，企图网络能够去除自监督扰动，以此抵御对抗样本的攻击。</li><li>在推理阶段，通过子监督扰动损失的指导，去除对抗样本的扰动信息，之后再进行推理。（具体可以看代码）</li></ul><p>论文的目标损失是：</p><p>\begin{equation}<br>\min_\theta L_{\text{cls}}((g\circ f)(x;\theta_{\text{enc}}, \theta_{\text{cls}}), y) + \alpha L_{\text{aux}}((h\circ f)(x;\theta_{\text{enc}}, \theta_{\text{aux}}))<br>\end{equation}</p><p>$g$ 是分类器的前部分，$h$是辅助分支的模型，不过实际代码中这俩被合二为一了，也就是，一个神经网络有两个损失。</p><p>对于 $L_{\text{aux}}$ 损失，论文给出了三种选择，在实现时选择其中的一种即可。</p><ol><li>叠加噪音，即图像叠加噪音后，还是之前的图像。这里的损失使用了叠加噪音前后的 MSE 差异。</li><li>图像旋转，即图像旋转后，还是之前的图像。这里的损失使用了旋转后图像与真实标签的交叉熵作为损失。</li><li>标签持续性，即图像经过两种数据增强后，这两组图像的标签一致。这里的损失是两种数据增强后的 MSE 差异。</li></ol><p>在去噪阶段，论文提出了多部去噪，一定程度弥补了之前单步去噪的缺陷：</p><p><img data-src="https://z3.ax1x.com/2021/08/22/hptNng.png" alt></p><h1 id="ADP"><a href="#ADP" class="headerlink" title="ADP"></a>ADP</h1><p>来自论文 Adversarial Purification with Score-based Generative Models, ICML 2021。我复现了这篇论文，训练缓慢、预测缓慢，且不提供训练代码只提供预测代码，预测代码和论文算法描述不一致。前面的模型是别人的，如果没看到这一点，我都不知道怎么复现论文。如果一定有评价的话，那就是：呵，tui。</p><p>模型来自「Improved techniques for training score-based generative models」这篇发表在 NIPS 2020 的论文，所以网络结构直接看这篇论文的代码即可。损失函数的设计如下（前面那堆推导没啥用）：</p><p>\begin{equation}<br>L(\theta, \sigma) = \mathbb{E}_{q(\tilde{x}|x)p_{\text{data}}(x)}[\frac{1}{2\sigma^2} \Vert \tilde{x} + \sigma^2 s_\theta(\tilde{x}) -x \Vert^2]<br>\end{equation}</p><p>$q(\tilde{x}|x)$ 是以 $x$ 为中心，以 $\sigma$ 为均方差生成的噪音样本。这个损失的意思是，期望 $s_{\theta}$ 能够有效去除 $\tilde{x}$ 上含有的噪音信息，并且和原始图像差不多，以此来抵御对抗样本的攻击。</p><p>预测阶段极度风骚，来看伪码：</p><p><img data-src="https://z3.ax1x.com/2021/08/22/hpYaJx.png" alt></p><p>一步去噪不到位，居然用多步去噪……这样与其他算法对比并不公平，这就像之前举的参加高考的例子。当然这不是最离谱的，最离谱的是，代码和这个算法毫不相关。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(max_iter):</span><br><span class="line">    labels = torch.ones(x_pur.shape[<span class="number">0</span>], device=x_pur.device)</span><br><span class="line">    labels = labels.long().to(config.device.ebm_device)</span><br><span class="line">    grad = network_ebm(x_pur, labels) <span class="comment"># Get gradients</span></span><br><span class="line">    <span class="comment"># Get adaptive step size</span></span><br><span class="line">    x_eps = x_pur + lr_min*grad</span><br><span class="line">    <span class="comment">#print(torch.mean(torch.norm(grad.view(grad.shape[0],-1), p=2,dim=1)).item(), flush=True)</span></span><br><span class="line">    grad_eps = network_ebm(x_eps, labels)</span><br><span class="line">    z1 = torch.bmm(grad.view(grad.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">-1</span>), grad_eps.view(grad_eps.shape[<span class="number">0</span>], <span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">    z2 = torch.bmm(grad.view(grad.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">-1</span>), grad.view(grad.shape[<span class="number">0</span>], <span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">    z = torch.div(z1, z2)</span><br><span class="line">    <span class="keyword">if</span> mode==<span class="string">"attack"</span>:</span><br><span class="line">        step_lambda = config.attack.attack_lambda</span><br><span class="line">    <span class="keyword">elif</span> mode==<span class="string">"purification"</span>:</span><br><span class="line">        step_lambda = config.purification.purification_lambda</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    step_size = torch.clamp(step_lambda*lr_min/(<span class="number">1.</span>-z), min=min_step_lr, max=min_step_lr*<span class="number">10000.</span>).view(<span class="number">-1</span>)</span><br><span class="line">    cont_purification = torch.logical_and(cont_purification, (step_size&gt;config.purification.stopping_alpha))</span><br><span class="line">    <span class="keyword">if</span> torch.sum(cont_purification)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    step_size *= cont_purification</span><br><span class="line">    x_pur_t = x_pur.clone().detach()</span><br><span class="line">    x_pur = torch.clamp(transform_ebm_to_raw(x_pur_t+grad*step_size[:, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]), <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line">    step_sizes.append(step_size)</span><br><span class="line">    images.append(x_pur)</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>当然，还有一系列的其他算法，如 Feature squeezing, JPEG Compressionm，TVM 等算法，我感觉不如之前的论文有意思，所以没有详细的写，读者有兴趣的话可以自己去看一看。</p><p>接下来，会看一些攻击方向的经典论文而后复现，大概一周吧，之后会转入全新的领域：对抗训练，偏数据分布的处理，如果有兴趣欢迎联系（是妹子就更好了（误。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;忙完了其它的，还是要回归科研做好整理，相当于论文笔记吧。对抗样本去噪算法算是告以段落，或者说叫对抗样本提纯。本文总结了一些近几年的、思路还行结果也还好的对抗样本去噪算法，就相当于写个类似的综述了，注意，并非详解。优缺点仅是个人分析，&lt;del&gt;其实论文读多了或者看了代码，总会有一些想法&lt;/del&gt;。包含以下论文：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Comdefend: An efficient image compression model to defend adversarial examples, CVPR 2019&lt;/li&gt;
&lt;li&gt;Feature denoising for improving adversarial robustness, CVPR 2019&lt;/li&gt;
&lt;li&gt;Defense against adversarial attacks using high-level representation guided denoiser, CVPR 2018&lt;/li&gt;
&lt;li&gt;A Self-supervised Approach for Adversarial Robustness, CVPR 2020&lt;/li&gt;
&lt;li&gt;Denoised Smoothing: A Provable Defense for Pretrained Classifiers, NIPS 2020&lt;/li&gt;
&lt;li&gt;Stochastic Security: Adversarial Defense Using Long-Run Dynamics of Energy-Based Models, ICLR 2021&lt;/li&gt;
&lt;li&gt;Online Adversarial Purification based on Self-Supervision, ICLR 2021&lt;/li&gt;
&lt;li&gt;Adversarial Purification with Score-based Generative Models, ICML 2021&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>从代码角度理解局部敏感哈希算法</title>
    <link href="https://muyuuuu.github.io/2021/08/04/LSH-consine/"/>
    <id>https://muyuuuu.github.io/2021/08/04/LSH-consine/</id>
    <published>2021-08-04T08:13:44.000Z</published>
    <updated>2021-08-05T13:44:44.143Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为开发图像检索系统的需要，需要学习局部敏感哈希算法。我在网上看了很多局部敏感哈希算法的讲解，也没有一个能讲清楚的。什么打乱表格、计数 1 最开始出现的索引、minHash 等没啥用的东西把人说的云里雾里。</p><p>而如何设计哈希函数、如何把相似内容放到同一个桶中、计算相似度则闭口不谈。所以，关于数学理论推导，本文就不描述了，网上其他博客多的是，本文从代码的角度来理解局部敏感哈希算法，相对更清晰，附 <code>C++</code> 程序实现。</p><a id="more"></a><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p><img data-src="https://z3.ax1x.com/2021/08/04/fAhTfK.png" alt></p><p>如上图所示有两张不同的哈希表。在查询阶段，对于输入的每条数据，都会在这两个哈希表中进行查询，因此更多的查询结果可以保证查询的召回率。但是，也会带来查询时间、构建哈希表时间线性增加的弊端。会在文末给出如何设置合理的哈希表数目，这里只需要理解哈希表多了、少了的优缺点即可。</p><p>在程序中，我们设置哈希表为三维容器，维度为 $T \times 2^{F} \times 0$，$T$ 表示哈希表的数量，$F$ 表示哈希函数的数量，用 $2^F$ 表示桶的数量，$0$ 是每个桶的容量，初始化为 0, 后期桶内添加数据时容量会增加，维度也会随即发生变化。</p><h1 id="哈希函数与哈希过程"><a href="#哈希函数与哈希过程" class="headerlink" title="哈希函数与哈希过程"></a>哈希函数与哈希过程</h1><p>对于任何局部敏感哈希函数 $f(x)$ 而言，它都应该实现：在处理数据库数据时，相似的特征放入同一个桶，不相似特征放入不同的桶中，每个桶可以有多个结果。在处理查询数据时，同样通过哈希函数 $f(x)$，将当前查询的向量映射到桶中，而后在那个桶中返回最接近的 $K$ 个向量。此时，会触发 $f(x)$ 的隐藏条件，在处理数据库数据和查询数据的时候，$f(x)$ 保持不变。</p><p>在程序中，我使用了二级哈希，也就是有两个哈希函数：</p><ul><li>一级哈希函数 $f_1$ 是一个二维矩阵，维度是 $T \times F$，每个元素都是 $[0, F)$ 区间内的随机整数。之后会讲述这么做的原因是为了防止越界。</li><li>二级哈希函数 $f_2$ 是一个二维矩阵，维度是 $F \times D$，$D$ 是数据的维度数，其元素取值为以 0 为均值，以 0.2 为方差的服从正太分布的随机数。</li></ul><h2 id="哈希运算"><a href="#哈希运算" class="headerlink" title="哈希运算"></a>哈希运算</h2><p>重点来了，在对数据进行哈希时，按照表、哈希函数、数据维度的顺寻进行三层遍历，程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历哈希表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="keyword">this</span>-&gt;n_tables; t++) &#123;</span><br><span class="line">    <span class="comment">// 遍历这些哈希函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> f = <span class="number">0</span>; f &lt; <span class="keyword">this</span>-&gt;n_functions; f++) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;n_dim; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;bFile &gt;&gt; x;</span><br><span class="line">            <span class="comment">// 一级哈希，this-&gt;f_1[t][f]，哈希到某个哈希函数</span></span><br><span class="line">            <span class="comment">// 二级哈希，this-&gt;f_2 访问当前哈希函数的第 i 个值</span></span><br><span class="line">            sum += x * <span class="keyword">this</span>-&gt;f_2[ <span class="keyword">this</span>-&gt;f_1[t][f] ][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">            pos += <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>, f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>, <span class="keyword">this</span>-&gt;n_functions))</span><br><span class="line">        pos = <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>, <span class="keyword">this</span>-&gt;n_functions) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 容器追加，避免处理哈希冲突</span></span><br><span class="line">    <span class="comment">// 追加到第 t 个表的第 pos 个桶中</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;hashTables[t][pos].push_back(line);</span><br></pre></td></tr></table></figure><ul><li>一级哈希 <code>this-&gt;f_1[t][f]</code> ，确定使用哪个哈希函数 $i$，因此取值范围是 $[0, F)$</li><li>二级哈希，使用第 $i$ 个哈希函数，对当前数据进行哈希，哈希的运算为乘积并求和。这里需要注意的是，「查询数据处理的阶段」和「数据库数据处理阶段」的哈希形式必须一致，否则无法保证查到近似结果。因此，查询阶段的哈希运算也是乘积并求和。</li><li>针对哈希结果，确定将当前数据放入哪个桶中，也就是 <code>pos</code></li></ul><p>至于上述程序中为何 <code>sum &gt; 0</code> 和 <code>pos += std::pow(2, f);</code>，都是哈希函数的机制，也可以自己定义新的运算，这个没有统一的标准。</p><h1 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段"></a>查询阶段</h1><p>对于查询数据，首先要查找当前数据位于哪个桶，而 <code>pos</code> 的计算和上述的哈希运算完全一致：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LSH::hash_query</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> sum&#123;<span class="number">0</span>&#125;, x&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> pos&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;n_functions; i++) &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>-&gt;n_dim; j++) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;qFile &gt;&gt; x;</span><br><span class="line">      sum += x * <span class="keyword">this</span>-&gt;hashFunction[<span class="keyword">this</span>-&gt;amplifyFunction[t][i]][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">      pos += <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取这个桶后，遍历这个桶内的所有元素，按照相似性距离压入优先级队列，这样就可以逐个访问最相似的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t 是当前哈希表，pos 是查询到的桶</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i: <span class="keyword">this</span>-&gt;hashTables[t][pos]) &#123;</span><br><span class="line">    <span class="keyword">double</span> dis = <span class="keyword">this</span>-&gt;calcute_cosine_distance(i, line);</span><br><span class="line">    <span class="comment">// 距离与项，按照第一项进行排序</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;res.emplace(dis, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算相似度"><a href="#计算相似度" class="headerlink" title="计算相似度"></a>计算相似度</h2><p>也就是上述程序中的 <code>calcute_cosine_distance</code> 函数，这个还是比较容易实现的。$\text{cos}$ 相似性计算为：</p><p>\begin{equation}<br>\text{sim}= \frac{x \cdot y}{ \Vert x \Vert \Vert y \Vert}<br>\end{equation}</p><p>分子是内积，分母是模长。</p><h1 id="关于参数设置"><a href="#关于参数设置" class="headerlink" title="关于参数设置"></a>关于参数设置</h1><p>如何确定哈希函数、哈希表的数量呢？</p><ul><li>一个极端的假设，我有很多的哈希函数和哈希表，这无疑会增加建立哈希表的复杂度</li><li>一个极端的假设，我只有一个哈希函数和一个哈希表，在查询阶段会查询到大量无关的结果</li></ul><p>那么，假设数据库里面有 10000 条数据，那么我可以设置 10 个哈希函数，因为 $2^{10}=1024$，这样就有了 1024 个桶。而如果 10000 数据分布均匀，每个桶就可以有 10 条左右的数据，查询也快。至于哈希表，2个，3个都是可以的，但是不能太多。</p><p>此外还要注意的是，每个哈希桶内的元素数最好是均匀的，这样查询时间也更稳定。所以要设置合理的哈希函数的机制，也就是 <code>pos</code> 的分布一定要均匀。</p><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>我自己实现了一份<a href="https://github.com/muyuuuu/SeetaFace-Retri/tree/main/CosineLSH" target="_blank" rel="noopener">局部敏感哈希程序</a>，我是 C++ 初学者，代码写的不是很难，相信你看完代码是可以理解局部敏感哈希算法的。计算相似度是使用的余弦距离，因为欧拉距离会面临维灾。<code>modules</code> 里面的 <code>config.cpp</code> 可以忽略，那个是为了衔接其他业务设计的。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>处理 <code>13466 X 2048</code> 大小的数据，即 13466 条数据，每条数据的维度是 2048 维。构建 1024 个哈希函数，两张哈希表。log 日志显示每秒哈希 50 条数据。 对 100 条数据进行查询，每条数据返回最接近的 5 条数据。每条数据的平均查询时间为 0.86 秒，最低时间为 0.34 秒，召回率接近 100% 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为开发图像检索系统的需要，需要学习局部敏感哈希算法。我在网上看了很多局部敏感哈希算法的讲解，也没有一个能讲清楚的。什么打乱表格、计数 1 最开始出现的索引、minHash 等没啥用的东西把人说的云里雾里。&lt;/p&gt;
&lt;p&gt;而如何设计哈希函数、如何把相似内容放到同一个桶中、计算相似度则闭口不谈。所以，关于数学理论推导，本文就不描述了，网上其他博客多的是，本文从代码的角度来理解局部敏感哈希算法，相对更清晰，附 &lt;code&gt;C++&lt;/code&gt; 程序实现。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Algorithm" scheme="https://muyuuuu.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Arch 折腾全记录，彻底告别 Windows</title>
    <link href="https://muyuuuu.github.io/2021/07/31/Arch-config/"/>
    <id>https://muyuuuu.github.io/2021/07/31/Arch-config/</id>
    <published>2021-07-31T11:51:26.000Z</published>
    <updated>2021-08-29T13:38:37.524Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>想来想去，以壮士断腕的决心决定抛弃垃圾 <code>windows</code> 了，实在是 <code>TMD</code> 卡的要死，但是以我电脑的配置，不可能卡的。加上 <code>C</code> 盘的无理由暴增，<code>TMD</code> 空间锐减，加上每次系统动不动更新，每次更新都 <code>TMD</code> 出 <code>bug</code> 直接卡死。我宁肯花一周的时间打造一款我的主力 <code>Arch Linux</code> ，再 <code>TMD</code> 也不向 <code>windows</code> 低头了。以本文记录 <code>Arch Linux</code> 的折腾全记录。</p><p>包括：代理、终端、字体、换源更新、软件、甚至是博客迁移等。最重要的是，关于向这个世界的妥协，如何使安装 QQ、微信和 word 等非必要但深入人心的软件。毕竟老板让你微信给他发文件还是很常见的，毕竟老板没手没脚，发一次不接收必须发第 $N$ 次，毕竟他用 LaTeX 也要手动编号。</p><a id="more"></a><h1 id="关于代理"><a href="#关于代理" class="headerlink" title="关于代理"></a>关于代理</h1><p>我用的是 <code>clash</code>，直接 <code>sudo pacman -s clash</code> 即可，而后将其设置为开机启动，后台自己执行。<a href="https://github.com/Sitoi/SystemdClash" target="_blank" rel="noopener">相关参考</a>。</p><p>不过刚到新系统，一般会面临先有鸡还是先有蛋的问题，即：代理服务在国外，没有代理买不了服务，没有服务就出不去。所以，提前找同学接好代理，注意：有些代理只能在 <code>windows</code> 使用，一定要看好 <code>linux</code> 是否可以用。</p><h1 id="关于输入法"><a href="#关于输入法" class="headerlink" title="关于输入法"></a>关于输入法</h1><p><a href="https://www.cnblogs.com/qscgy/p/13385905.html" target="_blank" rel="noopener">文章推荐</a>，关于安装和配置就这个写的比较好，网上其他教程太垃圾且过时。在配置输入法的时候记得选择里面的 <code>pinyin</code>，其他的中文输入不行，然后重启即可。</p><h1 id="关于更新与换源"><a href="#关于更新与换源" class="headerlink" title="关于更新与换源"></a>关于更新与换源</h1><p><code>sudo pacman -Syu</code>，同步仓库即同步本地软件和仓库中软件的最新状态，更新所有系统上被 <code>pacman</code> 管理的的软件。<code>Su</code> 升级系统；<code>Syy</code> 会只刷新数据库。</p><p><strong>Arch Linux 中文社区仓库</strong> 是由 Arch Linux 中文社区驱动的非官方软件仓库，包含许多官方仓库未提供的额外的软件包，以及已有软件的 git 版本等变种。一部分软件包的打包脚本来源于 AUR，但也有许多包与 AUR 不一样。以清华大学的源为例，在 <code>/etc/pacman.conf</code> 文件末尾添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><p>因为所有软件包都是经过开发者私钥签名，验证签名需要导入对应的公钥，即：安装 <code>archlinuxcn-keyring</code> 包以导入 GPG key。</p><p>当然，有些软件不一定在 archlinuxcn 源中，所以其它软件的换源方式为：编辑 /etc/pacman.d/mirrorlist，文件顶端添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><p>更新软件包缓存：<code>sudo pacman -Syy</code>。</p><h1 id="关于浏览器"><a href="#关于浏览器" class="headerlink" title="关于浏览器"></a>关于浏览器</h1><p>我使用的浏览器是 <code>google-chrome-stable</code>，因为 <code>chromium</code> 不支持登录谷歌帐号，插件、书签无法同步，且 <code>chromium wiki</code> 上提供的解决方案也是曲线救国，我不喜欢。</p><p><img data-src="https://z3.ax1x.com/2021/07/31/Wv01K0.png" alt></p><p>在 <code>pacman -S google-chrome-stable</code> 后，因为浏览器不能使用代理而无法为了科学上网。我查了一下可以使用 <code>proxychains</code>，但是配合 <code>google-chrome-stable</code> 使用时会直接 <code>core dumped</code>，查了一下据说是这俩软件水火不容。而后我又查到了其它用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google-chrome-stable --proxy-server=&quot;socks5://127.0.0.1:7891&quot;</span><br></pre></td></tr></table></figure><p>这样开启的浏览器是有代理的，然后登录 <code>chrome</code>，登录谷歌，直接同步，一切都很舒服。</p><h1 id="关于字体"><a href="#关于字体" class="headerlink" title="关于字体"></a>关于字体</h1><p>掏出万能的 wiki 文档，发现安装字体的三种方式：</p><ul><li>如果有人打包，那么 <code>sudo pacman -S ttf-lxgw-wenkai</code>，这是一款我比较喜欢的字体，这样通过包管理器的方式安装；</li><li>如果没人打包，可以手动下载字体，将字体移动到 <code>/usr/share/fonts/</code> 目录，所有用户可用；如果是个人用户可用，那么就放到 <code>~/.local/share/fonts</code>，而后使用 <code>fc-cache -vf</code> 刷新字体缓存。字体权限是 <code>644</code>，-rw-r—r— 1。</li></ul><p>安装完毕后，可以在设置-&gt;字体中，配置自己喜欢的字体，如果没有立即生效，记得重启。关于 <code>latex</code> 如何调用系统的字体，时而文件名、时而字体名，时而镜像中克隆的名字，等改天单独写吧。</p><p>一般而言，<code>sans serif</code> 表示无衬线字体，<code>Serif</code> 表示衬线字体，<code>Noto</code> 表示谷歌命名的字体，<code>Mono</code> 是等宽字体。我一般使用的字体是：思源宋体黑体、<code>source code pro</code> 和 <code>IBM Plex Mono</code>，落霞孤鹜等。</p><p>此外，还会遇到终端、软件里面时而衬线字体时而非衬线字体等极度丑陋的情况，这个时候需要进行一些配置，可以参考<a href="https://szclsya.me/zh-cn/posts/fonts/linux-config-guide/" target="_blank" rel="noopener">这篇博客</a>。</p><h1 id="关于终端"><a href="#关于终端" class="headerlink" title="关于终端"></a>关于终端</h1><ul><li>更改系统默认终端：<code>sudo chsh -s /usr/bin/bash</code>，如果切换失败，可以尝试进入 <code>root</code> 切换或 <code>usermod -s /usr/bin/fish lanling</code> 命令，查看系统默认终端：<code>cat /etc/shells</code>；</li><li><code>shell</code> 用的是 <code>fish</code> 毕竟是真的舒服，<code>oh my zsh</code> 太乱了。系统自带的 <code>konsole</code> 配和 <code>oh my zsh</code> 时常乱码，但是，不可否认，<code>konsole</code> 分屏、配色、标签页等各个方面都极度强大。</li></ul><p><img data-src="https://z3.ax1x.com/2021/07/31/Wv07dS.jpg" alt></p><p>所以我决定抛弃 <code>zsh</code>。注意切换终端时需要注意：进入 <code>root</code> 切换，不能在当前用户切换，否则下次重启电脑无法进入系统（并不是密码错误，我确实遇到了这个问题）。然后我登录了 <code>root</code> 用户，发现切换到子用户时：<code>failed to execute /bin/zsh</code>，说明 <code>shell</code> 没切换成功，而后两种方案，一种是装回 <code>zsh</code> ，一种是在 <code>root</code> 端切换为 <code>bash</code>，这样用户端就能进入系统了。</p><ul><li>而后选择的新 <code>shell</code> 是 <code>fish</code>，<code>sudo pacman -S fish</code> 即可，在终端执行 <code>ish_config</code>，进入 <code>web</code> 端的颜色配置。</li><li><code>set -U fish_prompt_pwd_dir_length 0</code> 会在终端现实全部的路径，如 <code>code/github/Face/Detect</code>，否则是 <code>c/g/F/D</code> 很难看。</li></ul><h1 id="关于软件"><a href="#关于软件" class="headerlink" title="关于软件"></a>关于软件</h1><p>列出我使用的软件，对于如何安装 QQ，微信和 word，将在文末给出。</p><ul><li><code>telegram</code>，吹水与交流技术</li><li><code>peek</code>，录制 <code>gif</code></li><li><code>visual-studio-code-bin</code>，写代码</li><li><code>clash</code>，懂得都懂</li><li><code>google-chrome-stable</code>，浏览器</li><li><code>typora</code>，写 <code>markdown</code> 的东西</li><li><code>flameshot</code>，截图工具，比深度截图好用一百倍</li></ul><p>此外，还设置了一些软件开启自启动：<code>flameshot</code>，<code>clash</code> 等。</p><p>软件的快捷键自己设置吧，我只设置了终端、浏览器，截图的快捷键。位于设置、自定义快捷键、编辑、新建、全局快捷键、命令。</p><h1 id="关于美化"><a href="#关于美化" class="headerlink" title="关于美化"></a>关于美化</h1><p>众所周知，不美化还怎么写代码，但是我友情提示一下：以我多年美化的经验而言，美化的尽头绝对是系统默认。</p><ul><li>底部的 <code>dock</code> 栏可以使用 <code>plank</code> 这个软件，但是无法和状态栏配合双屏使用，于是卸载。</li><li>设置、外观里面设置主题。</li><li>如果设置无法打开，那么查看是否有 <code>systemsettings5</code> 进程没彻底杀死，如果有，杀死即可。</li><li>而后自己折腾吧，<code>i3wm</code> 有点无从下手的样子。我尝试折腾了一下，直接黑屏，除了鼠标啥都没有，然后不知道动了哪个配置文件，<code>KDE</code> 都回不去了，系统会自动退出到登陆界面，登陆后还是退出，一个死循环。无奈，删除账户，新建账户，第六次重装系统。</li></ul><h1 id="关于博客搬家"><a href="#关于博客搬家" class="headerlink" title="关于博客搬家"></a>关于博客搬家</h1><p>我的博客是基于 <code>hexo</code> 的，而之前的博客在 windows 上，所以要进行博客搬家。博客搬家倒是很容易，先安装必要依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nodejs</span><br><span class="line">sudo pacman -S npm</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>而后在安装 <code>hexo</code> 的时候有坑，有坑的是传统方案：<code>npm install -g hexo-cli</code>，这样会发现没权限，而后 <code>sudo npm install -g hexo-cli</code>，但这是很烂的行为，因为 <code>Arch</code> 的包最好用 <code>pacman</code> 管理起来，而 <code>npm</code> 安装的并不会被管理。所以，掏出万能的 <code>AUR</code>，发现里面有 <code>hexo</code>，安装即可。</p><p>之后的东西就简单了，新建博客路径，拷贝原始博客的文件到新的路径下：</p><ol><li>博客配置文件./_config.yml</li><li>主题配置文件夹./theme/</li><li>文章及相关内容的文件夹./source/</li><li>模板文件夹./scaffolds/</li><li>记录博客所有的插件的文件./package.json</li></ol><p>最后进入博客目录，执行 <code>npm install</code>，而后就可以使用博客了，这也是我换系统后的第一篇博客。</p><h1 id="关于善后"><a href="#关于善后" class="headerlink" title="关于善后"></a>关于善后</h1><p><code>word, excel, ppt, qq, wechat</code> 等软件如何使用或者寻找替代品也是必须要妥协的，毕竟很多人都在用，毕竟大部分人都不知道 latex 和 telegram 的存在。</p><h2 id="wps"><a href="#wps" class="headerlink" title="wps"></a>wps</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/Software/AUR</span><br><span class="line">cd ~/Software/AUR</span><br><span class="line">git clone https://aur.archlinux.org/wps-office-cn.git</span><br><span class="line">cd wps-office-cn</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure><p>而后按下 <code>meta</code> 键，就可以搜到了。再把字体从自己的 <code>windows</code> 系统拷贝过来，这样 <code>wps</code> 就有字体了，我是把字体拷贝到了 <code>/usr/share/fonts</code>。注意，安装完毕之后，<code>Software/AUR</code> 是可以删除的。</p><h2 id="qq"><a href="#qq" class="headerlink" title="qq"></a>qq</h2><p>无论是安装 QQ 还是 Tim，我试了网上和 wiki 说的那些什么用 <code>yay</code> 安装 <code>qq, deepin, office, wine, light</code> 乱七八糟的无法装成功，不如直接用官方构建好的包。去 <a href="https://im.qq.com/pcqq" target="_blank" rel="noopener">官方</a> 下载对应的发行版的包，<code>arch</code> 就下载 <code>pacman</code> 的，而后 <code>sudo pacman -U linuxqq_2.0.0-b2-1089_x86_64.pkg.tar</code>。</p><h2 id="wechat"><a href="#wechat" class="headerlink" title="wechat"></a>wechat</h2><p>既然 QQ 都安装成功了，那么也就通过这种方式安装 wechat 吧。去 github 下载别人<a href="https://github.com/countstarlight/deepin-wine-wechat-arch" target="_blank" rel="noopener">打包好的</a>，安装方式同 QQ。因为 3.0+ 的不能发文件且我在 issue 里面也没看到啥特别好修复方法。建议下载 <code>2.9.5</code> 版本的，然后将 wine 替换为 deepin-wine5 修理一下，可以参考<a href="https://www.jianshu.com/p/11231b51ece0" target="_blank" rel="noopener">这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想来想去，以壮士断腕的决心决定抛弃垃圾 &lt;code&gt;windows&lt;/code&gt; 了，实在是 &lt;code&gt;TMD&lt;/code&gt; 卡的要死，但是以我电脑的配置，不可能卡的。加上 &lt;code&gt;C&lt;/code&gt; 盘的无理由暴增，&lt;code&gt;TMD&lt;/code&gt; 空间锐减，加上每次系统动不动更新，每次更新都 &lt;code&gt;TMD&lt;/code&gt; 出 &lt;code&gt;bug&lt;/code&gt; 直接卡死。我宁肯花一周的时间打造一款我的主力 &lt;code&gt;Arch Linux&lt;/code&gt; ，再 &lt;code&gt;TMD&lt;/code&gt; 也不向 &lt;code&gt;windows&lt;/code&gt; 低头了。以本文记录 &lt;code&gt;Arch Linux&lt;/code&gt; 的折腾全记录。&lt;/p&gt;
&lt;p&gt;包括：代理、终端、字体、换源更新、软件、甚至是博客迁移等。最重要的是，关于向这个世界的妥协，如何使安装 QQ、微信和 word 等非必要但深入人心的软件。毕竟老板让你微信给他发文件还是很常见的，毕竟老板没手没脚，发一次不接收必须发第 $N$ 次，毕竟他用 LaTeX 也要手动编号。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Computer" scheme="https://muyuuuu.github.io/tags/Computer/"/>
    
  </entry>
  
  <entry>
    <title>C++踩坑记录：构造与析构函数</title>
    <link href="https://muyuuuu.github.io/2021/07/21/constructor-and-destructor-with-inheritance/"/>
    <id>https://muyuuuu.github.io/2021/07/21/constructor-and-destructor-with-inheritance/</id>
    <published>2021-07-21T02:22:11.000Z</published>
    <updated>2021-07-21T20:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我是练习时长一年的 <code>C++</code> 个人练习生，喜欢野指针、模板报错和未定义行为（undefined behavior）。之前在写设计模式的『工厂模式』时，一脚踩到了构造、继承和 <code>new</code> 组合起来的坑，现在也有时间来整理一下了。</p><a id="more"></a><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>众所周知：在创建对象时，防止有些成员没有被初始化导致不必要的错误，在创建对象的时候自动调用构造函数（无声明类型），完成成员的初始化。即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c <span class="comment">// 隐式，默认构造函数</span></span><br><span class="line">Class c = Class() <span class="comment">// 显示，默认构造函数</span></span><br><span class="line">Class c = Class(<span class="string">"name"</span>) <span class="comment">// 显示，非默认构造函数 </span></span><br><span class="line">Class* c = <span class="keyword">new</span> Class <span class="comment">// 隐式，默认构造函数</span></span><br></pre></td></tr></table></figure><ul><li>构造函数执行前，对象不存在</li><li>构造函数创建对象后，对象不能调用构造函数</li><li>类中如果不定义构造函数，编译器提供有默认的构造函数，无参数，也不执行任何额外的语句</li><li>如果提供非默认构造函数，没有默认构造函数将会出错。所以要定义一个不接受任何参数的构造函数，并为成员定义合理的值</li><li>一般而言，默认的构造函数是用来对所有类成员做隐式初始化的</li><li>自己定义的构造函数一般用使用列表初始化来初始化参数</li><li>通过构造函数对成员赋值，要优于通过函数为成员赋值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by default creator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    Stone(<span class="keyword">int</span> w, <span class="keyword">double</span> r) : weight&#123;w&#125;, radius&#123;r&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by custom creator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;radius &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 隐式，成员有默认值</span></span><br><span class="line">    Stone s1;</span><br><span class="line">    s1.showInfo();</span><br><span class="line">    <span class="comment">// 显式，通过列表初始化，为成员赋值</span></span><br><span class="line">    Stone s2 = Stone(<span class="number">12</span>, <span class="number">3.3</span>);</span><br><span class="line">    s2.showInfo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过构造函数实现的类型转换"><a href="#通过构造函数实现的类型转换" class="headerlink" title="通过构造函数实现的类型转换"></a>通过构造函数实现的类型转换</h2><p>观察以下的代码，我们发现 <code>Stone s2;s2 = 3.3;</code> 这样将一个 <code>double</code> 类型的数据赋值给类类型并没有出错，这是隐式类型转换，从参数类型到类类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by default creator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 都关闭</span></span><br><span class="line">    Stone(<span class="keyword">double</span> r) : radius&#123;r&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by parameter radius"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stone(<span class="keyword">int</span> w) : weight&#123;w&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by parameter weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;radius &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Stone s2;</span><br><span class="line">    s2 = <span class="number">3.3</span>;</span><br><span class="line">    s2.showInfo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为：接受一个参数的构造函数允许使用赋值语法来为对象赋值。<code>s2=3.3</code> 会创建 <code>Stock(double)</code> 临时对象，临时对象初始化后，逐成员赋值的方式复制到对象中，在几个构造函数中加入了 <code>cout &lt;&lt; this</code> 的语句，由对象的地址不同，可以判断该赋值语句额外生成了临时对象。</p><p>为了防止隐式转换带来的危险，可以使用关键字 <code>explicit</code> 关闭这一特性，这样就得显式完成参数类型到类类型的转换：<code>s = Stock(1.3)</code>；不过，得保证没有二义性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by default creator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 都关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Stone</span><span class="params">(<span class="keyword">double</span> r)</span> : radius</span>&#123;r&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by parameter radius"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Stone</span><span class="params">(<span class="keyword">int</span> w)</span> : weight</span>&#123;w&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Class Stone was created by parameter weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;radius &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Stone s2;</span><br><span class="line">    s2 = Stone(<span class="number">3</span>);</span><br><span class="line">    s2.showInfo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，如果 <code>Stone(int w)</code> 没有被关闭，那么 <code>s2=3.3</code> 将调用这一构造函数。所以构造函数建议都加上 <code>explicit</code> 声明。</p><h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h2><p>派生类要注意的是：派生类被构造之前，通过调用一个基类的构造函数，创建基类完成基类数据成员的初始化；也就是说，基类对象在程序进入派生类构造函数之前被创建。那么，可以通过初始化列表传递给基类参数，不传递的话，调用基类的默认的构造函数，如下述程序中的：<code>Gem(){}:Stone()</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This object was in address: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    Stone(<span class="keyword">int</span> w, <span class="keyword">double</span> r) : weight&#123;<span class="number">2</span>&#125;, radius&#123;r&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">    auto getRadius() -&gt; double &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gem</span> :</span> <span class="keyword">public</span> Stone &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Gem()&#123;&#125;;</span><br><span class="line">    Gem(<span class="keyword">double</span> p, <span class="keyword">int</span> w, <span class="keyword">double</span> r) : Stone(w, r), price&#123;p&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;getWeight() &lt;&lt; <span class="string">", Radius"</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;getRadius();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Gem g1; <span class="comment">// call default</span></span><br><span class="line">    Gem g2 = Gem(<span class="number">1300</span>, <span class="number">1</span>, <span class="number">2.3</span>); <span class="comment">// call custom </span></span><br><span class="line">    <span class="comment">// g.setWeight(130);</span></span><br><span class="line">    g2.show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先创建基类对象</li><li>派生类通过初始化列表（只能用在构造函数）将基类信息传递给基类的构造函数</li><li>派生类构造函数可以为派生类初始化新的成员</li></ul><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>对象过期时，程序会调用对象的析构函数完成一些清理工作，如释放变量开辟的空间等。如构造函数使用了 <code>new</code> 来申请空间，析构就需要 <code>delete</code> 来释放空间。如果没有特别声明析构函数，编译器会为类提供默认的析构函数，在对象作用域到期、被删除时自动被调用。</p><p>如 <code>stock1 = Stock()</code>，这种就申请了一个临时变量，变量消失时会调用析构函数。此外，这种局部变量放在栈区，先入后出，也就是，最后被申请的变量最先被释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This object was in address: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" Object was deleted."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Stone s1;</span><br><span class="line">        Stone s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承中的析构函数"><a href="#继承中的析构函数" class="headerlink" title="继承中的析构函数"></a>继承中的析构函数</h2><p>继承类比较容易理解，毕竟都学过面向对象。公有继承的时候，基类的公有成员也是派生类的共有成员；私有成员也是派生类的一部分，不过需要共有或保护方法来访问。但是但是但是，派生类和基类的析构函数之间，也是一个坑。在继承中：</p><ul><li>如果一个方法不是虚方法，那么将根据引用类型或指针类型选择执行的方法</li><li>如果一个方法是虚方法，将根据指针或引用指向对象的类型选择执行的方法</li></ul><p>在继承中，对象的销毁顺序和创建相反。创建时先创建基类，而后创建子类；销毁时，先调用子类的析构函数，而后自动调用基类的析构函数。因此，对于基类而言，建议将析构函数写成虚方法。如果析构不是虚方法，对于以下情况，只有基类的析构被调用；如果析构是虚方法，子类、基类的析构方法都被调用。可以尝试删除下述代码的 <code>virtual</code> 来观察结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> weight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> radius&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This object was in address: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    Stone(<span class="keyword">int</span> w, <span class="keyword">double</span> r) : weight&#123;<span class="number">2</span>&#125;, radius&#123;r&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">", Radius: "</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">    auto getRadius() -&gt; double &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Stone() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stone class was deleted."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gem</span> :</span> <span class="keyword">public</span> Stone &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Gem() &#123;&#125;;</span><br><span class="line">    Gem(<span class="keyword">double</span> p, <span class="keyword">int</span> w, <span class="keyword">double</span> r) : Stone(w, r), price&#123;p&#125; &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;getWeight() &lt;&lt; <span class="string">", Radius"</span> </span><br><span class="line">             &lt;&lt; <span class="keyword">this</span>-&gt;getRadius();</span><br><span class="line">    &#125;</span><br><span class="line">    ~Gem() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Gem class was deleted."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Stone* s1 = <span class="keyword">new</span> Gem(<span class="number">2.3</span>, <span class="number">2</span>, <span class="number">3.2</span>);</span><br><span class="line">    <span class="keyword">delete</span> s1;</span><br><span class="line">    <span class="comment">// Gem* g1 = new Gem(2.3, 2, 1.2);</span></span><br><span class="line">    <span class="comment">// delete g1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>大概常见的坑在上面都记录好了，来看一段我写的危险的程序（我大概抽象了一下），覆盖了：野指针和为定义行为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()&#123;</span><br><span class="line">        <span class="keyword">delete</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">int</span>* b = a.create();</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>每次调用 create 都会 new 一次，但只 delete 了一次。</li><li>如果没有调用 create 直接析构，未定义行为</li><li>如果 b 持有了 a.create() 的指针，然后 a 提前析构，那么 b 是野指针</li><li>delete b 是没必要的。这样会 double free，也是未定义行为</li><li>上述代码没有区分类里面 new 且 返回的东西要在哪删除合适</li><li>可以让类来管理这一个 new，修改一下 create 的实现或者干脆在构造 new，在析构 delete</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是练习时长一年的 &lt;code&gt;C++&lt;/code&gt; 个人练习生，喜欢野指针、模板报错和未定义行为（undefined behavior）。之前在写设计模式的『工厂模式』时，一脚踩到了构造、继承和 &lt;code&gt;new&lt;/code&gt; 组合起来的坑，现在也有时间来整理一下了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++函数进阶：内联、重载和模板</title>
    <link href="https://muyuuuu.github.io/2021/07/18/cpp-advanced-function/"/>
    <id>https://muyuuuu.github.io/2021/07/18/cpp-advanced-function/</id>
    <published>2021-07-18T07:11:53.000Z</published>
    <updated>2021-07-18T22:07:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++ 细节逐步填坑中，还有几个大坑预计 8 月前结束。普通的函数没啥意思了，本文涉及函数的进阶使用，包括：函数的默认参数、内联函数、函数重载和函数模板。</p><a id="more"></a><h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><p>也就是某些教材上常说的函数声明，如果没有函数原型，那么函数首次使用前出现的整个函数定义充当了函数原型。函数由三部分组成：</p><ul><li>函数原型，约定好返回值的类型与接受参数的类型。这就描述了函数到编译器的接口，将参数类型和数量提前告知编译器。这样当函数的返回值放到某个寄存器时，编译器也知道检索多少个字节来解释返回值。如果不告知函数原型，<code>main</code> 函数的编译只能终止然后去寻找函数原型，这样会导致效率不高，甚至有些文件没有搜索的权限，这样会报错。而 <code>C++</code> 的编程风格，习惯将 <code>main</code> 函数放在前面，这样更需要函数原型。</li><li>函数定义，函数头 + 函数体，实现完整的函数功能。</li><li>函数调用，主函数调用子函数完成功能。</li></ul><p>因此，函数原型有以下的作用：</p><ul><li>正确处理函数的返回值</li><li>检查参数的数目、类型是否正确；如果不正确，尽可能转换为正确类型</li></ul><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>常规函数和内联函数的<strong>主要区别</strong>不在于编写方式不同，更多的是程序组合到程序中的方式不同。</p><ul><li><p>对于普通函数而言，程序在执行到函数调用指令时，存储当前指令的地址（保护现场），将函数参数复制到堆栈帧，跳转到子函数起始的内存地址，执行子函数，执行的临时变量放入堆栈帧。执行完毕后，跳回指令被保存的地址处（恢复现场），继续往下执行。使用子函数会造成来回的记录和跳转，造成一定的开销。</p></li><li><p>内联函数会代替函数调用，内联函数直接被插入到主函数中，这样就无需跳转而是顺序执行。执行速度快，但是需要更大的内存。</p></li></ul><blockquote><p>如果函数执行的时间远大于跳转时间，则内联函数的意义不大；如果代码执行时间很短，且需要多次调用，那么内联调用会节省很多时间；如果节省的时间所占执行的时间并不大，或者很少调用，则不需要内联函数。注意，内联函数不能递归。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a&#123;<span class="number">12.3</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="built_in">sqrt</span>(a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p>这个倒是不难，就是为一些参数提供默认值。如果一个参数有默认值，那么，它右边的参数必须也要有默认值，且赋值的时候不允许跳过。按照 <code>main</code> 函数放前面这样的编程风格来试一下，默认值在函数原型中提供，函数定义不需要，否则报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span> a=<span class="number">1</span>, <span class="keyword">int</span> b=<span class="number">2</span>, <span class="keyword">int</span> c=<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d&#123;<span class="number">12</span>&#125;, e&#123;<span class="number">13</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">11</span>&#125;;</span><br><span class="line">    show_info(d, e, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="string">" "</span> &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>对于一个打印函数 <code>print</code> ，可能传入 <code>int</code> 类型的数据，也可能传入 <code>double</code> 类型的数据，这个时候就需要函数重载。函数重载的重点是函数的特征标，也就是函数的参数列表，也就是参数的数目、类型和排列顺序。比如可以这样重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> str, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> str, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a&#123;<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> b&#123;<span class="number">1.23</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"void"</span>;</span><br><span class="line">    print(str, <span class="number">1</span>);</span><br><span class="line">    print(a, <span class="number">1</span>);</span><br><span class="line">    print(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果调用函数出现了未匹配的类型，很可能错误，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a&#123;<span class="number">12</span>&#125;;</span><br><span class="line">print(a, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><code>double</code> 和 <code>int</code> 都可以接受 <code>unsigned int</code> 的参数，二义性的程序会导致错误。</p><h2 id="const-重载"><a href="#const-重载" class="headerlink" title="const 重载"></a>const 重载</h2><p><code>const</code> 可以构成重载，不过只能是指针，非指针不构成重载。这也很容易理解，对于非指针而言，<code>const</code> 或非 <code>const</code> 都不重要，因为原数据无法修改，因此不构成重载；指针则不一样，<code>const</code> 表示原数据或指针不修改，非 <code>const</code> 表示原数据或指针任意修改。这是两个含义的特征标，因此可以构成重载。而编译器根据实参是否为 <code>const</code> 来决定匹配的原型函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>* a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="string">"---"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="string">"==="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* a = &amp;p;</span><br><span class="line">    *a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* b = &amp;p;</span><br><span class="line">    print(a);</span><br><span class="line">    print(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>void print(const int* a)</code> 这样的函数，如果没有重载，那么这个函数是可以接收非 <code>const</code> 数据的。</p><blockquote><p>此外，对于没有任何参数的函数，且不希望函数修改任何变量，可以将 <code>const</code> 关键字放到函数括号的后面。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用重载"><a href="#引用重载" class="headerlink" title="引用重载"></a>引用重载</h2><p>引用无法构成重载，因为无论是否引用，都可以接收参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>&amp; x)</span></span></span><br></pre></td></tr></table></figure><p>但是引用加上 <code>const</code>，含义改变，就可以重载。而对于引用的重载，调用最为匹配的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>&amp; x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 右值引用，没有的话就调用 print(const double&amp; x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>&amp;&amp; x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> x</span>&#123;<span class="number">33.3</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> y&#123;<span class="number">12.3</span>&#125;;</span><br><span class="line">print(x);      <span class="comment">// print(double&amp; x)</span></span><br><span class="line">print(y);      <span class="comment">// print(const double&amp; x)</span></span><br><span class="line">print(x + y);  <span class="comment">// print(double&amp;&amp; x)</span></span><br></pre></td></tr></table></figure><h2 id="如何实现重载"><a href="#如何实现重载" class="headerlink" title="如何实现重载"></a>如何实现重载</h2><p><code>C++</code> 通过名称修饰来跟踪重载函数，根据函数原型的函数特征标对函数进行加密。也就是根据特征标对函数进行编码，在函数上添加一组符号后，函数换了个名字作为自己的内部表示，不同特征标的函数名也不一样，不过使用者看不到这一层。具体如何修饰，这取决于编译器。</p><p>重载诱人，但使用时一定要注意类型，只有用相同的形式处理不同类型的数据，才会考虑重载。</p><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>模板比重载还要更省事一点。使用泛型来定义函数，也就是，类型作为参数传递给模板代码，编译器生成指定类型的函数。也就是说，模板通过泛型（参数化类型）来解决任务。使用背景一般是：同一算法需要处理多种类型的参数。</p><p>重载也可以完成这些任务，比如说要交换两个同类型的数，<code>int, double, float, const, char, str, vector</code> 等等等等，重载可以，但是写很多遍会很累。</p><p>模板例子：使用 <code>template &lt;typename T&gt;</code> 来建立模板，编译器检查传入的类型参数，生成相应的函数以供执行。程序员看不到生成的代码，但代码确实被生成以及被使用。且最终生成的代码不包含模板，只包含为程序生成的实际代码。如下所示的模板，交换任意简单类型的数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a&#123;<span class="number">1.2</span>&#125;, b&#123;<span class="number">2.1</span>&#125;;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> c&#123;<span class="number">1</span>&#125;, d&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    swap(c, d);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">" "</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般而言，对不同类型使用相同算法会考虑模板。但是，不是所有类型用相同的算法都能实现，比如，对象、数组等会涉及深浅拷贝、地址等，并不像简单数据类型那样容易处理。</p><p>举个例子，以交换函数而言，如果是数值类型，就交换；如果是数组类型，交换前 2 个元素；如果是类，有的成员交换有的成员不交换。总之，模板具有局限性，判断相等时，数组不能直接用等号。所以编写的模板很可能无法处理某些类型，大概有两种解决方案：</p><ul><li>在类中重载运算符，如大小、相等的比较；</li><li>为特定类型提供具体化的模板定义</li></ul><p>但是这部分坑准备留在类的重载运算符、移动语义和深浅拷贝之后了，方便对比。</p><h2 id="模板重载"><a href="#模板重载" class="headerlink" title="模板重载"></a>模板重载</h2><p>如果重载模板，函数的特征标同样不能相同。注意，泛型并不是所有参数都得是模板参数类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T a[], T b[], <span class="keyword">int</span> i = <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a&#123;<span class="number">1.2</span>&#125;, b&#123;<span class="number">2.1</span>&#125;;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">4</span>] = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    swap(c, d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c[i] &lt;&lt; <span class="string">" &lt;=&gt; "</span> &lt;&lt; d[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T a[], T b[], <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    T t[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        t[j] = a[j];</span><br><span class="line">        a[j] = b[j];</span><br><span class="line">        b[j] = t[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板的发展"><a href="#模板的发展" class="headerlink" title="模板的发展"></a>模板的发展</h2><p>在 <code>C++98</code> 中，编写模板函数时会一个问题，不知道该声明为哪一种类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T1 x, T2 y)</span> </span>&#123;</span><br><span class="line">    z = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的 <code>z</code> 是什么类型呢？而 <code>C++11</code> 新增的关键字 <code>decltype</code> 提供了解决方案，按照给定的 <code>expression</code> 类型创建指定类型的变量，即 <code>decltype (x) y</code>，<code>y</code> 和 <code>x</code> 同类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x&#123;<span class="number">12.3</span>&#125;;</span><br><span class="line">    <span class="keyword">decltype</span> (x) y;</span><br><span class="line">    <span class="comment">// d</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(y).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么上述模板代码就有了解决方案。而 <code>decltype (expr) var</code> 为确定 <code>var</code> 的类型，遍历一个核对表，只要有一项匹配，那么类型确定完毕，不用在判断后面的。</p><ol><li><code>expr</code> 是一个没有括号标识符，那么 <code>var</code> 与 <code>expr</code> 相同；</li><li><code>expr</code> 是一个函数，<code>var</code> 与函数返回值类型相同；</li><li>如果 <code>expr</code> 是一个左值，<code>var</code> 为 <code>expr</code> 类型的引用，以 <code>double</code> 为例， <code>decltype ((x)) y</code>，<code>y</code> 就是 <code>double</code> 类型的引用；</li><li>如果不满足以上，那么 <code>expr</code> 与 <code>var</code> 同类型，如 <code>int&amp; x, int&amp; y, decltype (x+y) z</code>，<code>z</code> 是 <code>int</code> 类型，不是引用类型；</li></ol><p>但是尽管解决了函数中对变量类型的赋值，但是没有解决模板返回值的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">? gt (T1 x, T2 y)</span><br></pre></td></tr></table></figure><p>函数的返回值类型和 <code>T1</code> 和 <code>T2</code> 相关，但是要运算后才知道。但是返回值区域， <code>x,y</code> 还不在作用域内就无法使用，这就成了先有鸡还是先有蛋的问题，那么如何提前知道运算结果的类型呢？即使在函数内部知道了返回值类型，也没办法反馈到函数的声明中。</p><p>这个可以通过后置返回值类型 (tailing return type) 可以实现，写法：<code>auto f1(int x, float y) -&gt; double</code>，对应到函数声明，写法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto f1(T1 x, T2 y) -&gt; decltype(x + y)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ 细节逐步填坑中，还有几个大坑预计 8 月前结束。普通的函数没啥意思了，本文涉及函数的进阶使用，包括：函数的默认参数、内联函数、函数重载和函数模板。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的引用</title>
    <link href="https://muyuuuu.github.io/2021/07/15/Cpp-refer/"/>
    <id>https://muyuuuu.github.io/2021/07/15/Cpp-refer/</id>
    <published>2021-07-15T14:49:24.000Z</published>
    <updated>2021-07-17T09:08:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>引用是 C++ 中一个比较神奇的东西。在这之前或者说 C 语言中，一般是使用指针来减少传参所带来的不必要的开销。如函数传递的参数是数组或结构体时，使用指针会省很多事，毕竟传递的是地址。而 C++ 中引用变量的主要用途也是函数传参，子函数直接操作原始数据，而不是其副本，这样处理大型数据结构也会佷便捷。</p><a id="more"></a><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>以一维数组为例。众所周知数组名是是数组首元素的地址。因此调用子函数时，主函数传递的是数组首元素的地址，所以子函数接收的是地址，无法预知数组的长度，需要增加额外的参数指明数组元素的数量。</p><p>对于函数，一般用 <code>int arr[]</code> 这样的形式指明 <code>arr</code> 接收的是数组，这样的可读性强；换一种方法，因为传递的是数组首元素的地址，而数组首元素为 <code>int</code> 类型，地址是 <code>int*</code> 类型，因此可以用 <code>int* arr</code> 来接收一个数组，但是这样表意不明确。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        t += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    sum(arr, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>升级到二维数组，二维数组的类型本质就是指向『多个 <code>int</code> 组成的数组』的指针，因此参数的形式为 <code>int (*arr)[4]</code>，而不是 <code>int* arr[4]</code>。</p><ul><li>前者是一个『由 4 个指向 int 的指针』组成的数组；即一个数组，数组元素是四个 int 指针；</li><li>后者是一个指向『由 4 个 int 组成数组』的指针；即一个指针，指向 4 个 int 的数组。为了更好的可读性，一般声明如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">4</span>], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            t += arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 数组有三个元素，每个元素是数组</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line">    sum(arr, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>二维数组的指针是不是感觉有点晕？先来看一下简单的引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a&#123;<span class="number">11</span>&#125;;</span><br><span class="line"><span class="comment">// 类型是 int&amp;，指向 int 的引用</span></span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br></pre></td></tr></table></figure><p>这样 <code>b</code> 和 <code>a</code> 就指向了相同的值和内存单元，只是名字不一样。此外，引用必须在声明的时候进行初始化，否则这个变量不知道指向哪个内存单元和值，但是指针可以先声明在赋值。</p><p>此外，声明一旦绑定，就无法在修改。可以通过初始化声明来设置引用，不能通过赋值来设置。如下所示的程序，只是对引用 <code>b</code> 进行了赋值，而不是修改引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a&#123;<span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line"><span class="keyword">int</span> c&#123;<span class="number">32</span>&#125;;</span><br><span class="line">b = c;</span><br></pre></td></tr></table></figure><h2 id="引用传参"><a href="#引用传参" class="headerlink" title="引用传参"></a>引用传参</h2><p>回到主题，一般将引用用做函数传参时。主函数中的变量名是被调用函数中对应变量的别名，在调用时用实参初始化形参，因此引用参数被初始化为：函数调用时传递过来的实参。如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n1&#123;<span class="number">12</span>&#125;, n2&#123;<span class="number">21</span>&#125;;</span><br><span class="line">swap(n1, n2);</span><br></pre></td></tr></table></figure><p>此外，传递引用时对类型的限制更加严格，以求和函数为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">12</span>&#125;;</span><br><span class="line"><span class="comment">// 临时变量</span></span><br><span class="line">sum(a);</span><br><span class="line">sum(<span class="number">6.2</span>);</span><br><span class="line"><span class="comment">// 临时变量</span></span><br><span class="line">sum(a + <span class="number">6.3</span>);</span><br></pre></td></tr></table></figure><p>换句话说，当实参和形参的类型不匹配时，将会生成临时变量传给形参。但是引用则不行，限制相对严格，<code>sum(a + 6.3)</code> 会报错，传递的实参是表达式不是变量，而引用不能绑定到表达式上，且此时不会生成临时变量。</p><p>但是当参数为 const 引用时，会创建一个临时的无名变量，临时变量的值初始化为 <code>a + 6.3</code>，而后再将无名变量赋给引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a&#123;<span class="number">10</span>&#125;;</span><br><span class="line">    sum(a + <span class="number">6.3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许你会有疑问，这个时候为什么会生成临时变量？<code>const</code> 为什么合理呢？如果引用参数是 <code>const</code>，两种情况会生成临时变量：</p><ul><li>实参类型正确，但不是左值，如 <code>a + 6.3</code> 这样的表达式</li><li>实参类型不正确，但可以转为正确类型，如 <code>int</code> 隐式转换为 <code>double</code>；<code>double</code> 到 <code>int</code> 则错误</li></ul><blockquote><p>左值：左值是可以被引用的数据对象，变量、数组、元素等，非左值有字面常量，多项的表达式等。或者说，可以放在赋值语句左侧 and 能访问地址的就是左值，也就是说，赋值语句左侧是可修改的内存块，const 变量也是左值，只是不可修改。</p></blockquote><p>回到原问题，如果形参加上 <code>const</code> 修饰，意思是函数只使用这个值，不修改这个值。即使因类型不匹配生成了临时变量，引用参数引用这个临时变量，都不会造成任何不好的副作用。但此时就是值传递而不是地址传递，因为要用临时变量来存储数值。所以也推荐尽可能使用 <code>const</code>：</p><ul><li>避免无意修改数据造成结果错误</li><li>能更好的接收实参，生成并使用临时变量</li></ul><h2 id="返回值为引用"><a href="#返回值为引用" class="headerlink" title="返回值为引用"></a>返回值为引用</h2><p>对于传统的调用函数而言，返回结果的这个值被复制到临时位置，也就是产生值的副本，调用程序将使用这个值。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    len += <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// len 复制到临时位置</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">// 从临时位置获取值</span></span><br><span class="line">a = sum(a);</span><br></pre></td></tr></table></figure><p>而返回引用的函数实际上是返回被引用变量的别名。返回引用值时，并不产生值的副本。而是将返回值直接复制给接收函数的变量或对象，言简意赅，当函数返回引用类型时，没有复制返回值创建临时变量，相反，返回的是对象本身，并复制到接收变量那里。</p><p>对于一个大型的数据结构如结构体，将结构体复制到额外的地址的开销会很大；如果返回引用，将返回的引用的结构体直接赋值给接收值，避免额外的开销。</p><p>但是，避免返回指向临时变量的引用，临时变量在执行完毕后会消失，引用会指向乱七八糟的地址，就跟避免指向临时变量的指针一样。有两种解决方法：</p><ul><li>使用 new，将数据放到堆区，不过内存模型的坑准备后续开</li><li>传递一个额外的参数，传递给函数的引用，将该参数返回。因此返回引用时，要求在函数的参数中，包含有以引用方式需要被返回的参数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">double</span> value&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 返回变量 t 的引用</span></span><br><span class="line"><span class="function">node&amp; <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len, node&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        n.value += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    node t;</span><br><span class="line">    <span class="comment">// a 被 t 的引用给赋值</span></span><br><span class="line">    node a = sum(<span class="number">5</span>, t);</span><br><span class="line">    <span class="comment">// 修改 a 不会修改 t</span></span><br><span class="line">    a.value = <span class="number">13.2</span>;</span><br><span class="line">    <span class="comment">// a 是 t 的引用，修改 a 也会修改 b</span></span><br><span class="line">    <span class="comment">// node&amp; a = sum(5, t);</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.value &lt;&lt; <span class="string">" "</span> &lt;&lt; t.value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，非引用函数的返回值类型是右值，这种语句位于表达式的右侧，也无法通过地址访问这个值，也无法放到复制语句的左侧。因为返回值的地址在执行完毕后就消失了，也就是说无法引用。如果一定要引用返回值，将返回值类型声明为引用，这样返回的就是左值，就可以引用。</p><p>总结一下：当返回结果需要做为左值时，就要用引用返回。即重载函数的返回结果需要出现在赋值语句左边时，必须用引用返回。如果不用引用返回，那么重载函数的返回结果会是一个临时变量，临时变量是不能放在赋值语句左边的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误，右值不能在赋值语句左侧</span></span><br><span class="line"><span class="function">node <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len, node&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        n.value += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">5</span>, t).value = <span class="number">12.3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t.value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，返回的引用是左值</span></span><br><span class="line"><span class="function">node&amp; <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len, node&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        n.value += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">5</span>, t).value = <span class="number">12.3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t.value;</span><br></pre></td></tr></table></figure><p>如果不想返回的引用被修改，就加 <code>const</code> 修饰：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">double</span> value&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 返回变量 t 的引用</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> node&amp; <span class="title">sum</span><span class="params">(<span class="keyword">int</span> len, node&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        n.value += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    node t;</span><br><span class="line">    <span class="comment">// 将 t 引用的值赋值给 a，所以可以修改 a</span></span><br><span class="line">    node a = sum(<span class="number">5</span>, t);</span><br><span class="line">    a.value = <span class="number">13</span>;</span><br><span class="line">    <span class="comment">// b 引用 t，不可修改</span></span><br><span class="line">    node&amp; b = sum(<span class="number">5</span>, t);</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    b.value = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引用是 C++ 中一个比较神奇的东西。在这之前或者说 C 语言中，一般是使用指针来减少传参所带来的不必要的开销。如函数传递的参数是数组或结构体时，使用指针会省很多事，毕竟传递的是地址。而 C++ 中引用变量的主要用途也是函数传参，子函数直接操作原始数据，而不是其副本，这样处理大型数据结构也会佷便捷。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>python __init__.py 文件的用法</title>
    <link href="https://muyuuuu.github.io/2021/07/11/python-init-file/"/>
    <id>https://muyuuuu.github.io/2021/07/11/python-init-file/</id>
    <published>2021-07-11T11:09:07.000Z</published>
    <updated>2021-07-11T20:14:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近 <code>rush</code> 代码遇到一些问题，如一种典型的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-main/</span><br><span class="line">|----test1/</span><br><span class="line">|--------module1.py</span><br><span class="line">|----test2/</span><br><span class="line">|--------module2.py</span><br></pre></td></tr></table></figure><p>如上，想在 <code>module2.py</code> 中调用 <code>module1.py</code> 中的某个类，如果在 <code>module2.py</code> 中写：<code>from ..test1 import module1</code>，在 <code>test2</code> 文件夹下执行 <code>python module2.py</code> 会提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: attempted relative import with no known parent package</span><br></pre></td></tr></table></figure><p>会遇到这样的错误。那么，如何解决呢？如果你只想看如何解决问题，直接翻到文末即可；网上大概搜了一下，需要 <code>__init__.py</code> 来解决下这个问题，但是网上搜了一圈，没啥写的特别好的教程，实在是烂的可以，特此来填坑。</p><a id="more"></a><h1 id="init-py-是什么-1"><a href="#init-py-是什么-1" class="headerlink" title="__init__.py 是什么 1"></a>__init__.py 是什么 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h1><p>假设此时的路径结构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-main/</span><br><span class="line">|----__init__.py</span><br><span class="line">|----test1/</span><br><span class="line">|--------__init__.py</span><br><span class="line">|--------module1.py</span><br><span class="line">|----test2/</span><br><span class="line">|--------__init__.py</span><br><span class="line">|--------module2.py</span><br></pre></td></tr></table></figure><p>在 <code>test1</code> 目录下的 <code>__init__.py</code> 中写入：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'module1 was called'</span>)</span><br></pre></td></tr></table></figure><p>在 <code>test2</code> 目录下的 <code>__init__.py</code> 中写入：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'module2 was called'</span>)</span><br></pre></td></tr></table></figure><p>在 <code>main</code> 目录下的 <code>__init__.py</code> 中写入：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'parent package was called'</span>)</span><br><span class="line"><span class="comment"># 导入 [] 里面定义的模块</span></span><br><span class="line">__all__ = [<span class="string">'test1'</span>, <span class="string">'test2'</span>]</span><br></pre></td></tr></table></figure><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>通俗来说，<code>__init__.py</code> 可以将文件封装成包，将多个文件合并到一个逻辑命名空间。但是这么说太突兀了，由浅入深，一点一点来。先来看看文件夹中添加 <code>__init__.py</code> 会发生什么。假设此时的路径为 <code>main</code> 文件夹下，尝试导入模块，会发现上述信息被打印：</p><p><img data-src="https://z3.ax1x.com/2021/07/11/WCmmuT.png" alt></p><p>同理，在 <code>main</code> 文件夹的 <strong>上一级路径</strong> 下执行导入，也会有同样的效果，但是不会导入子模块。</p><p><img data-src="https://z3.ax1x.com/2021/07/11/WCm05d.png" alt></p><p>如果想导入单个子模块，可以 <code>import main.test1</code>，此时会打印 <code>module1 was called</code>；如果再次调用 <code>import main.test1</code>，也就是在模块已经导入的情况下再次导入，则不会打印任何信息。</p><p>如果导入全部子模块，也是可以的。因为声明了 <code>__all__</code>，所以子模块被导入。</p><p><img data-src="https://z3.ax1x.com/2021/07/11/WCmyxP.png" alt></p><p>但是你也许会有疑问，我经常写 <code>import math</code>，而 <code>math.sin</code> 等函数是导入的，且可以使用，为什么这里就不行了呢？如果想行，也是可以的，只需要在 <code>main</code> 目录下的 <code>__init__.py</code> 中写入以下信息就可以了，也就是 <code>import main; main.test1</code> 可用。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'parent package was called'</span>)</span><br><span class="line"><span class="comment"># 删除 __all__</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> test1</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> test2</span><br></pre></td></tr></table></figure><p>通过以上例子，我们可以看出，<code>__init__.py</code> 会起到以下作用：</p><ul><li>导入模块时初始化一些信息，如 <code>web</code> 项目中，启动 <code>session</code> 等</li><li>在父目录中，导入多个子模块</li></ul><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>也许你会觉得以上功能比较弱，或者说没啥用。那么来看一些实用的简化工作量的写法 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 。此时的目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├─ main.py</span><br><span class="line">└─ network</span><br><span class="line">       ├─ __init__.py</span><br><span class="line">       ├─ msg</span><br><span class="line">       │    └─ info</span><br><span class="line">       │           └─ send.py</span><br><span class="line">       └─ parse.py</span><br></pre></td></tr></table></figure><p>在 <code>send.py</code> 中，定义如下函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'send:'</span>, msg)</span><br></pre></td></tr></table></figure><p>如果想在 <code>main.py</code> 中调用这个函数，需要以下写法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> network.msg.info <span class="keyword">import</span> send</span><br><span class="line">send.send_msg(<span class="string">'hello'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># from network.msg.info.send import send_msg</span></span><br><span class="line"><span class="comment"># send_msg('hello')</span></span><br></pre></td></tr></table></figure><p>但无论那种方法，都要写长长的路径，甚为不便。这个时候，我们可以在 <code>network</code> 文件夹下面创建一个 <code>__init__.py</code> 文件，并在里面填写如下内容：<code>from .msg.info.send import send_msg</code>。而 <code>main.py</code> 文件中的内容可以修改为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> network <span class="keyword">import</span> send_msg</span><br><span class="line">send_msg(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure><p>是不是简短了很多。这是因为，当一个文件夹里面有 <code>__init__.py</code> 以后，这个文件夹就会被 <code>python</code> 作为一个包 <code>package</code> 来处理。此时，对于这个包里面层级比较深的函数、常量、类，我们可以先把它们导入到 <code>__init__.py</code> 中。这样以来，包外面再想导入这些内容时，就可以用 <code>from 包名 import 函数名</code> 来导入了。</p><p>这样做有很多好处，由于调用包的其他模块所在的绝对路径是千变万化的，当有一些代码会在很多地方被使用时，我们可以把这些代码打包起来，作为一个公共的接口提供给其他模块调用，这会方便很多。</p><p>所以在<strong>包的内部</strong>调用自身其他文件中的函数、常量、类，就不应该使用相对路径，而是绝对路径。这里以添加新功能为例，如下所示，在 <code>parse.py</code> 文件中添加以下内容：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两种都可以</span></span><br><span class="line"><span class="comment"># from .msg.info.send import send_msg</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> send_msg</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_msg</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'parse:'</span>, msg)</span><br><span class="line">    send_msg(msg)</span><br></pre></td></tr></table></figure><p>可以看到，在包里面的一个文件调用这个包里面的另一个文件，只需要知道另一个文件的相对位置就可以了，不用关心这个包被放在哪里。上 面<code>parse.py</code> 中导入 <code>send_msg</code> 函数的代码还可以进一步简化，由于 <code>send_msg</code> 函数已经被导入到了 <code>__init__.py</code> 中，所以我们可以直接从 <code>.</code> 里面导入 <code>send_msg</code> 函数。</p><p>之后在 <code>__init__.py</code> 中追加：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .parse <span class="keyword">import</span> parse_msg</span><br></pre></td></tr></table></figure><p>此时，<code>main.py</code> 的写法可以如下，可以看到，即使追加了新的模块，<code>main.py</code> 调用起来也会很方便，并不需要知道 <code>parse_msg</code> 这个方法的任何位置信息。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> network <span class="keyword">import</span> parse_msg</span><br><span class="line">parse_msg(<span class="string">'hhh'</span>)</span><br></pre></td></tr></table></figure><p>此外，当一个文件夹里面包含 <code>__init__.py</code> 时，这个文件夹会被 <code>python</code> 认为是一个包 <code>package</code>，此时，包内部的文件之间互相导入可以使用相对导入，并且通过提前把函数、常量、类导入到 <code>__init__.py</code> 中再在其他文件中导入，可以精简代码。</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>既然了解了 <code>__init__.py</code> 的用法，那么去解决文章最开始提到的问题。目录结构如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">├─ main.py</span><br><span class="line">├─ test1</span><br><span class="line">│    ├─ __init__.py</span><br><span class="line">│    └─ m1.py</span><br><span class="line">└─ test2</span><br><span class="line">       └─ m2.py</span><br></pre></td></tr></table></figure><p>实现的想法也很简单，<code>m2.py</code> 调用 <code>m1.py</code> 中的函数。</p><p><code>m1.py</code> 定义如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure><p><code>m2.py</code> 定义如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> m1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    m1.send(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure><p>距离成功只差一步，那就是修改 <code>test1</code> 中的 <code>__init__.py</code> 的内容，把 <code>test1</code> 看成一个 <code>package</code>，暴露其中的 <code>m1</code> 即可。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> m1</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># from . import m1</span></span><br></pre></td></tr></table></figure><p>这样，在外部的 <code>main</code> 函数中：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test2.m2 <span class="keyword">as</span> m2</span><br><span class="line">m2.run()</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># from test2 import m2</span></span><br><span class="line"><span class="comment"># m2.run()</span></span><br></pre></td></tr></table></figure><p>就可以了。</p><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">https://zhuanlan.zhihu.com/p/130927618</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">https://www.kingname.info/2020/03/23/init-in-python/</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近 &lt;code&gt;rush&lt;/code&gt; 代码遇到一些问题，如一种典型的结构&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;|-main/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|----test1/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|--------module1.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|----test2/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|--------module2.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如上，想在 &lt;code&gt;module2.py&lt;/code&gt; 中调用 &lt;code&gt;module1.py&lt;/code&gt; 中的某个类，如果在 &lt;code&gt;module2.py&lt;/code&gt; 中写：&lt;code&gt;from ..test1 import module1&lt;/code&gt;，在 &lt;code&gt;test2&lt;/code&gt; 文件夹下执行 &lt;code&gt;python module2.py&lt;/code&gt; 会提示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ImportError: attempted relative import with no known parent package&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;会遇到这样的错误。那么，如何解决呢？如果你只想看如何解决问题，直接翻到文末即可；网上大概搜了一下，需要 &lt;code&gt;__init__.py&lt;/code&gt; 来解决下这个问题，但是网上搜了一圈，没啥写的特别好的教程，实在是烂的可以，特此来填坑。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="https://muyuuuu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>对抗训练篇：MART 防御算法论文笔记</title>
    <link href="https://muyuuuu.github.io/2021/06/22/MART/"/>
    <id>https://muyuuuu.github.io/2021/06/22/MART/</id>
    <published>2021-06-22T13:26:54.000Z</published>
    <updated>2021-07-22T09:20:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MART(Misclassification Aware adveRsarial Training) 是 2020 年提出的最好的对抗防御算法。传统对抗训练算法中 min-max 时不会考虑当前样本是否被正确分类，统一制作对抗样本。而作者抓住了这一点，发现对于 max 制作对抗样本期间没有被网络正确分类的样本，对结果的影响很大。换句话说，<strong>网络连干净样本都不认识，何谈认识它的对抗样本？</strong> MART 算法的创新点在于区别对待错分类和正确分类的样本。</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>MART 防御的仍然是微小扰动的图像，也就是人眼察觉不出来的那种。论文用$p$ 范数满足这一限制：$\Vert x’-x \Vert_p \leq \epsilon$。对抗训练可以视为使用对抗样本进行数据增强，解决的是以下优化问题：</p><p>\begin{equation}<br>\min_\theta \frac{1}{n} \sum_{i=1}^{n} \max_{\Vert x’-x \Vert_p \leq \epsilon} L(h_\theta(x_i’), y_i)<br>\end{equation}</p><p>$n$ 是一个 batch 的大小，$L$ 是分类的损失函数。内部通过最大化损生成对抗样本，外部最小化对抗样本的分类损失来训练更好的 DNN，如 <a href="https://muyuuuu.github.io/2021/04/26/DNN-safe-basic/">PGD</a> 就是使用的这种方案。</p><p>而本文的关注点在对抗训练的对抗样本上，其实许多对抗训练算法忽略了一点，有些样本被正确分类，有些样本被错误分类，但无论哪种样本，都在 min-max 中直接制作对抗样本。因此本文也就抛出例如下疑问：</p><blockquote><p>由错分类样本和正确分类的样本产生的对抗样本，对模型的鲁棒性贡献程度是一样的吗？如果不是，如何利用这个差异，来提升模型的鲁棒性？</p></blockquote><p>本文针对这个被忽略的一点做了一些探索，发现被错分类和正确分类的样本对最终模型的鲁棒性的确有不同的影响。</p><p>本文做了这样的实验，在 CIFAR-10 数据集上做白盒攻击，扰动值 $\epsilon=8/255$。使用 PGD-10 算法制作对抗样本，以对抗训练的形式训练得到的网络的准确率是 87%。然后选择被错分类的样本记为 $S^-$，在选择被正确分类的样本记为 $S^+$。之后使用这两类样本，用不同的方式训练上述网络，最后用 PGD-20 算法制作的对抗样本评估最终模型的鲁棒性。结果如下图所示：</p><p><img data-src="https://z3.ax1x.com/2021/06/22/RmVckj.png" alt></p><p>在图 a 中：错分类样本对鲁棒性有明显影响。</p><ol><li>蓝色的线是标准对抗训练的对抗鲁棒性</li><li>绿色的线表示没有对 $S^-$ 制作对抗样本，其它样本仍然是对抗样本，鲁棒性降低很大；</li><li>橙色的线表示没有对 $S^+$ 制作对抗样本，其它样本仍然是对抗样本，鲁棒性变换其实不大。</li></ol><p>图 b 中：为了更深理解『错分类样本和其它样本』的影响是不同的，外部 min 采用交叉熵，内部 max 采用攻击强度很弱的 <a href="https://muyuuuu.github.io/2021/04/26/DNN-safe-basic/">FGSM</a> 算法：</p><ol><li>蓝色的线是标准对抗训练的对抗鲁棒性</li><li>绿色的线表示在 $S^-$ 上产生的对抗样本对鲁棒性几乎没有提升。这可以说明不同的 max 方法在 $S^-$ 上会对模型鲁棒性有不同程度的影响。然而，</li><li>橙色的线表示，低强度的攻击算法在 $S^+$ 上制作的对抗样本会使鲁棒性退化。</li></ol><p>图 c 中，内部 max 选择 PGD-10 算法，外部 min 尝试不同的函数。发现对错分类的样本使用不同的 min 方法，对最终鲁棒性的结果影响也很大。</p><ol><li>蓝色的线是，对传统对抗训练，外部 min 使用交叉熵函数</li><li>绿色的线是，对错分类样本添加额外的 KL 散度作为正则化项，鲁棒性有明显的提升</li><li>绿色的线是，将同样的 KL 散度作为正则化项添加到正确分类的样本上，鲁棒性也有提升，但不如绿色的线明显。</li></ol><p>基于以上实验发现，论文考虑了错分类样本对鲁棒性的影响，提出了一个新的防御算法，以一种动态的方式实现对抗训练。主要贡献是：</p><ul><li>研究了错分类和正确分类的样本对『对抗训练』最终鲁棒性的影响，结果表明，在 min-max 框架下，对错分类样本的处理对模型最终鲁棒性的影响佷大，且 min 方法比 max 方法更为关键。</li><li>提出一种正则化的对抗风险，将错误分类的样本做显式区分，作为正则化项添加到损失函数中。</li></ul><h1 id="MART-算法"><a href="#MART-算法" class="headerlink" title="MART 算法"></a>MART 算法</h1><p>临时通知一周后期末考试，去准备期末考试了，考完了回来填坑。其实这个算法的缺陷显而易见，可以尝试往 GAN 那边走一走。考完了，回来填坑。</p><h2 id="前期定义"><a href="#前期定义" class="headerlink" title="前期定义"></a>前期定义</h2><p>对于一个 $K$ 分类问题，给定数据集 $(x_i,y_i)$，深度模型 $h_\theta$，对于每个样本而言，网络的输出如下：</p><p>\begin{equation}<br>\begin{aligned}<br>h_\theta(x_i) &amp;= \arg \max p_k(x_i, \theta) \\<br>p_k(x_i, \theta) &amp;= \exp(z_k(x_i,\theta)) / \sum_{j=1}^K \exp(z_j(x_i,\theta))<br>\end{aligned}<br>\end{equation}</p><p>其中，$z_k(x_i,\theta)$ 是网络的逻辑输出，<code>softmax</code> 后获得类别标签。对抗风险定义为：一个 batch 中被分类错误的样本数除以 batch 数。对抗样本的制作为：</p><p>\begin{equation}<br>\hat{x} = \arg\max \mathbb{I}(h_\theta(x_i) \neq y_i)<br>\end{equation}</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote><p>注，原文第二章写了一些0-1损失，后面又说不用这个，所以我没有写0-1损失</p></blockquote><p>首先将训练样本分为正样本 $S^+_{h\theta}$ 和错样本 $S^-_{h\theta}$，即能被网络正确识别的样本和不能被正确识别的样本。</p><ul><li>对于 $S^-_{h\theta}$ 而言，添加正则化项，使得网络能稳定的防御错分类对抗样本。因为对抗样本的分类需要更强的分类器和更光滑的决策边界，损失函数定义为 $\mathbb{I}(h_\theta(\hat{x_i}) \neq y_i) + \mathbb{I}(h_\theta(x_i) \neq h_\theta(\hat{x_i}))$，意思是，第一项优化的目标是，使对抗样本被分类正确；第二项优化的目标是，使网络认识原始样本和对抗样本。</li><li>对于 $S^+_{h\theta}$ 而言，正则化不会明显提升网络鲁棒性。在这种情况下，已经有 $h_\theta(x_i)=y_i$，因此此时的优化目标是 $\mathbb{I}(h_\theta(x_i) \neq h_\theta(\hat{x}))=\mathbb{I}(h_\theta(\hat{x_i})\neq y_i)$，也就是说，网络将干净样本和对抗样本视为两个类别且对抗样本分类错误的概率。</li><li>其中 $\mathbb{I}$ 是指示函数，意思是，错了损失值为1，正确损失值为0。</li></ul><p>但是这个指示函数难以优化，本文提出 BCE(boosted cross entropy) 损失函数，用于代替 $\mathbb{I}(h(\hat{x} \neq y))$，定义如下：</p><p>\begin{equation}<br>\begin{aligned}<br>\text{BCE}(p(\hat{x}, \theta), y_i) &amp;= -\log(p_{y_i}(\hat{x},\theta)) - \log (1-\max_{k\neq y_i}p_k(\hat{x}, \theta))<br>\end{aligned}<br>\end{equation}</p><p>第一项是普通的交叉熵损失函数，第二项用于提升模型决策边界的间隙。</p><p>使用 $KL$ 散度代替 $\mathbb{I}(h_\theta(x) \neq h_\theta(\hat{x}))$，定义如下：</p><p>\begin{equation}<br>\text{KL}(p(x_i,\theta)||p(\hat{x}, \theta))=\sum_{k=1}^K p_k{(x_i,\theta)} \log \frac{p_k(x_i,\theta)}{p_k(\hat{x_i},\theta)}<br>\end{equation}</p><p>对于制作对抗样本使用的指示函数 $\mathbb{I}(h_\theta(x_i) \neq y_i)$，通过 $1-p_{y_i}(x_i, \theta)$ 的形式选择对抗样本。因此，内部最大化的损失定义如下，攻击方式选择 PGD。</p><p>\begin{equation}<br>\hat{x} = \arg \max \text{CE} (p(x_i, \theta), y_i)<br>\end{equation}</p><p>将两中损失结合起来到对抗训练的框架中，最终的损失函数为：</p><p>\begin{equation}<br>L = \text{BCE}(p(\hat{x}, \theta), y_i) + \lambda \text{KL} (p(x_i,\theta)||p(\hat{x}, \theta))(1-p_{y_i}(x_i, \theta))<br>\end{equation}</p><p>$\lambda$ 参数用于平衡两个损失。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MART(Misclassification Aware adveRsarial Training) 是 2020 年提出的最好的对抗防御算法。传统对抗训练算法中 min-max 时不会考虑当前样本是否被正确分类，统一制作对抗样本。而作者抓住了这一点，发现对于 max 制作对抗样本期间没有被网络正确分类的样本，对结果的影响很大。换句话说，&lt;strong&gt;网络连干净样本都不认识，何谈认识它的对抗样本？&lt;/strong&gt; MART 算法的创新点在于区别对待错分类和正确分类的样本。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DeepLearning" scheme="https://muyuuuu.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的常量与指针</title>
    <link href="https://muyuuuu.github.io/2021/06/22/const-pointer/"/>
    <id>https://muyuuuu.github.io/2021/06/22/const-pointer/</id>
    <published>2021-06-22T12:26:47.000Z</published>
    <updated>2021-06-22T20:33:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>和指针联用有佷微妙的地方，之前一直佷晕，现在来继续研究下。诸如以下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>const</code> 是一种处理符号常量的方法，以 <code>const</code> 声明的变量，一般首字母大写，声明之后无法被修改。相比于 <code>define</code>，<code>const</code> 会显式的指定类型。除定义符号外，一般可用于函数声明，表示函数不会修改任何值；用于参数，表示函数不会修改参数；甚至可以用于声明数组的长度。</p><h1 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h1><p>const默认作用于其左边的东西。左边没东西的情况下，作用于其右边的东西。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p><ol><li><code>const int* p</code>，只有右边有东西，修饰的为 <code>int</code>，所以数值不能被修改。在与 <code>*</code> 结合，意思是<code>*p</code>不能被修改，其它的都可以。即不可通过该指针改变其指向的内容，但可改变指针本身所指向的地址。</li><li><code>int const* p</code>，先作用于左侧的 <code>int</code> 为 <code>int const</code>，在叠加上右侧的 <code>*</code>，所以修饰的为 <code>int* p</code>，所以，<code>*p</code>不能被修改，其它的都可以。即不可通过该指针改变其指向的内容，但可改变指针本身所指向的地址。也就是，和上面的是一样的。</li><li><code>int* const p</code>，左边是 <code>*</code>，所以 <code>const</code> 作用于指针，指向一个 <code>int</code> 变量。即不可以修改 <code>p</code>，但可以修改 <code>*p</code>，即不可改变指向的地址。</li><li><code>const int* const p</code>，对于第一个 <code>const</code>，左边没东西，修饰右边的 <code>int</code>，指向的值不能修改；对于第二个 <code>const</code> 修饰 <code>*</code>，指针不能修改。即不可改变指针本身所指向的地址，也不可通过指针改变其指向的内容。同 <code>int const* const p</code>。</li><li><code>int const* const* p</code>，第一个 <code>const</code> 修饰 <code>int</code>，第二个 <code>const</code> 修饰第一个 <code>*</code>，也就是，指向 <code>const int* const p</code> 的指针，最后一个 <code>*</code> 没有被修饰，因此可以指向其它变量。<code>int const* const* const</code> 就不可以了。</li><li>之后再出现此类情况，也可以慢慢分析满天飞的 <code>const</code> 和指针。</li></ol><h1 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h1><p>为了更好的理解上述内容，这里来举一些例子。常见的一般有两种选择：</p><ul><li>常指针指向一个变量，防止修改指针修改变量值</li><li>常指针指向一个常量</li><li>非常指针指向常量（错误）</li></ul><p>先看第一种情况：解引用只是取出指向内存区域的值，因此指向内存区域的值是可以直接修改的，但不能通过指针修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a&#123;<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="comment">// *p 为 const，不能被修改</span></span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    <span class="comment">// *p ++;</span></span><br><span class="line">    <span class="comment">// p 指向的不是常量，因此，可以修改 a</span></span><br><span class="line">    a ++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> b&#123;<span class="number">12</span>&#125;;</span><br><span class="line">    p = &amp;b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第二种情况：不能修改变量，也不能修改常量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a&#123;<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="comment">// *p 为 const，不能被修改，a 也不能被修改</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b&#123;<span class="number">12</span>&#125;;</span><br><span class="line">    p = &amp;b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第三种情况：修改指针来修改常量会显得佷荒谬，因此编译会直接报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a&#123;<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="comment">// error: invalid conversion from 'const int*' to 'int*'</span></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    *p ++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><p>之前说到，常指针可以指向变量，但是涉及二级指针后，情况又会发生逆转。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a&#123;<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>** p1;</span><br><span class="line">    <span class="keyword">int</span>* p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error: invalid conversion from 'int**' to 'const int**'</span></span><br><span class="line">    p1 = &amp;p2;</span><br><span class="line">    *p1 = &amp;a;</span><br><span class="line"></span><br><span class="line">    *p2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述代码通过，那么完全可以通过 <code>p2</code> 指针修改常量。因此我们可以得到以下结论：</p><ul><li>若数据类型本身不是指针，可以将 <code>const</code> 数据或非 <code>const</code> 数据的地址赋给指向 <code>const</code> 的指针，但指针可以修改，指向别的值。因此，<code>const</code> 修饰的数组不能传参给非常量指针。</li><li>如果数据类型是指针，非 <code>const</code> 数据的地址只能赋值给非 <code>const</code> 指针，如二级指针中，<code>p1 = &amp;p2</code> 是错误的。</li></ul><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">https://www.zhihu.com/question/443195492</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;和指针联用有佷微妙的地方，之前一直佷晕，现在来继续研究下。诸如以下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;* p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; p;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 的名称空间</title>
    <link href="https://muyuuuu.github.io/2021/06/20/cpp-namespace/"/>
    <id>https://muyuuuu.github.io/2021/06/20/cpp-namespace/</id>
    <published>2021-06-20T09:43:46.000Z</published>
    <updated>2021-06-21T20:37:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前在学 C++ 的时候，第一个例子大概是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时也没多想，<code>std</code> 这个东西是什么。后来在接触了其它库后，发现也需要 <code>std</code> 的配合使用，如 <code>std::sort()</code>。今日来仔细研究下名称空间这个东西。</p><a id="more"></a><p>先掏出 cplusplus.com 来看看 <code>&lt;iostream&gt;</code> 是什么东西，官方的定义如下：</p><blockquote><p>Header that defines the standard input/output stream objects. After C++11, including <code>&lt;iostream&gt;</code> automatically includes also <code>&lt;ios&gt;</code>, <code>&lt;streambuf&gt;</code>, <code>&lt;istream&gt;</code>, <code>&lt;ostream&gt;</code> and <code>&lt;iosfwd&gt;</code>.</p></blockquote><p>而对于 <code>std</code> 而言，<code>std</code> 是一个名称空间，<code>::</code> 是作用域解析运算符，<code>std::cout</code> 的意思就是使用 <code>std</code> 名称空间中的 <code>cout</code> 标识符，也就是这个对象。而这个对象的定义在 <code>&lt;iostream&gt;</code> 这个标准库文件中，所以要包含这个头文件，才能使用 <code>cout</code> 这个对象。</p><p>除此之外，C++ 标准库中的<strong>函数或对象</strong>都是在名称空间 <code>std</code> 中定义的，所以我们要使用标准函数库中的<strong>函数或对象</strong>都要使用 <code>std</code> 来限定。所以使用 <code>cout</code> 的时候要加上 <code>std::</code> 时，编译器就会明白我们调用的 <code>cout</code> 是名字空间 <code>std</code>中的 <code>cout</code>，而不是其它名称空间中的 <code>cout</code>。</p><ul><li><code>#include</code> 是预处理器编译指令，表示使用预处理器在主编译之前对源文件进行整理。这里并不需要任何指令调用预处理器，编译时自动调用执行。这里的意思就是将 <code>iostream</code> 文件中的内容添加到程序中，即合成为一个新文件。这里的用途就是，在源文件被编译之前，替换或添加文本，这也是典型的一种预处理器操作。</li><li><code>using namespcec std</code> 是编译指令，如果是 <code>#include &lt;xxx.h&gt;</code> 则不需要 <code>using</code> 编译指令，因为老式的头文件没有使用名称空间。新头文件使用了 <code>std</code> 名称空间，标准库的类、函数、变量是 C++ 编译器的标准组件，被放到了 <code>std</code> 空间中。</li></ul><p>但是，尽量不要使用 <code>using namespace std</code>，这句话的意思是告诉编辑器我们将要使用空间 <code>std</code> 中的函数或者对象。或者说，能不用就不用，能在大括号里面用就不要在外面用，尤其是在 <code>.h</code> 等头文件中。幻想一下，你写的 <code>.h</code> 文件被其它人使用，你的名字空间和他人的名字空间不一样，但名字空间下面的函数名一样，就会导致冲突。跟 <code>python</code> 中写 <code>from numpy import *</code> 一个道理。</p><h1 id="自定义名称空间"><a href="#自定义名称空间" class="headerlink" title="自定义名称空间"></a>自定义名称空间</h1><p>名称空间提供了一个声明名称的区域，而可以通过作用域解析运算符 <code>::</code> 访问其中的名称。如下是一种简单的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mylib/show_info.h 文件下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 名称空间</span></span><br><span class="line"><span class="keyword">namespace</span> std1 &#123;</span><br><span class="line">    <span class="comment">// 名称</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cout</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cout</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"second"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp 文件下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mylib/show_info.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="using-声明与编译指令"><a href="#using-声明与编译指令" class="headerlink" title="using 声明与编译指令"></a>using 声明与编译指令</h2><p>有的时候并不希望每次使用名称时都进行限定，所以 <code>C++</code> 提供了两种机制，<code>using</code> 声明使得特定的名称可用，<code>using</code> 编译指令使名称空间中的所有名称可用，两者都可以简化名称空间中名称的使用，也都会增加名称冲突的可能性。</p><p>对于 <code>using</code> 声明而言，将指定的的名称添加到声明区域，使其可用。如下所示的代码：</p><ul><li>在声明的作用域内，不能在声明其它同名变量；</li><li>屏蔽全局同名变量。除用户定义的名称空间外，还存在一个全局名称空间，全局变量在这里面。同 <code>C++</code> 的局部变量会屏蔽全局变量一样，名称空间也是如此，但两个名称空间中的同名变量并不会冲突。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 冲突</span></span><br><span class="line">    <span class="comment">// int a;</span></span><br><span class="line">    <span class="keyword">using</span> test::a;</span><br><span class="line">    <span class="comment">// 冲突</span></span><br><span class="line">    <span class="comment">// int a;</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 12</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>using</code> 编译指令而言，会使所有名称可用，包括可能不会使用的名称。如下所示的代码：</p><ul><li><code>test::a</code> 位于局部名称空间，不会影响全局变量；</li><li>局部同名变量会屏蔽名称空间里的变量和全局变量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局名称空间</span></span><br><span class="line"><span class="comment">// using namespace test;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 编译指令</span></span><br><span class="line">    <span class="comment">// 局部名称空间</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> test;</span><br><span class="line">    <span class="comment">// 不冲突</span></span><br><span class="line">    <span class="keyword">int</span> a&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 全局变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 名称空间的变量</span></span><br><span class="line">    test::a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; test::a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是，当名称空间和声明区域定义了相同的名称：</p><ol><li><code>using</code> 声明导入时，会冲突；</li><li><code>using</code> 编译指令导入时，局部名称会屏蔽名称空间里面的名称，且没有警告。</li></ol><p>因此，使用 <code>using</code> 声明会更加安全，编译指令可能会掩盖一些同名变量。此外，还有一些其它要注意的点：</p><ul><li>名称空间可以嵌套，但最好加上限定，表明这个名称的来源；</li><li>以函数为例，名称空间里面的函数的声明和定义要在同一名称空间内；</li><li>如果函数被重载，那么一个 <code>using</code> 声明将导入所有版本；</li><li><p>对于未命名的名称空间，不能显式使用 <code>using</code>，不能在名称空间之外的文件使用名称空间中的名称。这可以作为<strong>链接性为内部静态变量的替代品</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 名称空间中的 a</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当名称空间很长时，可以简化名称空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MEF = math::element::fire;</span><br><span class="line"><span class="keyword">using</span> MEF::flame;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在学 C++ 的时候，第一个例子大概是：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;hello world&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 或者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;hello world&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当时也没多想，&lt;code&gt;std&lt;/code&gt; 这个东西是什么。后来在接触了其它库后，发现也需要 &lt;code&gt;std&lt;/code&gt; 的配合使用，如 &lt;code&gt;std::sort()&lt;/code&gt;。今日来仔细研究下名称空间这个东西。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="https://muyuuuu.github.io/tags/C/"/>
    
  </entry>
  
</feed>
