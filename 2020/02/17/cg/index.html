<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/apple-touch-icon-next.png">
  <link rel="mask-icon" href="/images/apple-touch-icon-next.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"muyuuuu.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":10,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="当时为了增长业余知识，在MOOC上听完了中国农业大学的计算机图形学这门课，后面几章的方程没有听，仅仅听到了三维变换。这是当时的电子版笔记，后来发现电子版笔记是真的累人，累倒有的笔记都不想放上来了。这是第一次，也是最后一次。 当然感觉这些东西还是挺有意思的，就准备放上来。如果你是华北理工大学的学生选了这门课，把这个网页里的内容看完85+也没问题了（缺少二维变换的例题，主要是太长了，真懒的写了。还有一">
<meta name="keywords" content="Computer">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机图形学笔记">
<meta property="og:url" content="https://muyuuuu.github.io/2020/02/17/cg/index.html">
<meta property="og:site_name" content="Just for Life.">
<meta property="og:description" content="当时为了增长业余知识，在MOOC上听完了中国农业大学的计算机图形学这门课，后面几章的方程没有听，仅仅听到了三维变换。这是当时的电子版笔记，后来发现电子版笔记是真的累人，累倒有的笔记都不想放上来了。这是第一次，也是最后一次。 当然感觉这些东西还是挺有意思的，就准备放上来。如果你是华北理工大学的学生选了这门课，把这个网页里的内容看完85+也没问题了（缺少二维变换的例题，主要是太长了，真懒的写了。还有一">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-02-17T15:15:54.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机图形学笔记">
<meta name="twitter:description" content="当时为了增长业余知识，在MOOC上听完了中国农业大学的计算机图形学这门课，后面几章的方程没有听，仅仅听到了三维变换。这是当时的电子版笔记，后来发现电子版笔记是真的累人，累倒有的笔记都不想放上来了。这是第一次，也是最后一次。 当然感觉这些东西还是挺有意思的，就准备放上来。如果你是华北理工大学的学生选了这门课，把这个网页里的内容看完85+也没问题了（缺少二维变换的例题，主要是太长了，真懒的写了。还有一">

<link rel="canonical" href="https://muyuuuu.github.io/2020/02/17/cg/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机图形学笔记 | Just for Life.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Just for Life." type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Just for Life.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">明月更几时</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>本站主页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>时光轴</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于兰铃</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签云</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-image fa-fw"></i>远夏拾忆</a>

  </li>
        <li class="menu-item menu-item-share">

    <a href="/share/" rel="section"><i class="fa fa-share fa-fw"></i>好物分享</a>

  </li>
        <li class="menu-item menu-item-message">

    <a href="/message/" rel="section"><i class="fa fa-list fa-fw"></i>留言板</a>

  </li>
        <li class="menu-item menu-item-friends">

    <a href="/friends/" rel="section"><i class="fa fa-link fa-fw"></i>友情链接</a>

  </li>
        <li class="menu-item menu-item-reward">

    <a href="/reward/" rel="section"><i class="fa fa-history fa-fw"></i>博客收益</a>

  </li>
        <li class="menu-item menu-item-hot">

    <a href="/hot/" rel="section"><i class="fa fa-fire fa-fw"></i>热门文章</a>

  </li>
        <li class="menu-item menu-item-record">

    <a href="/record/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>记录</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>本地搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://muyuuuu.github.io/2020/02/17/cg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="兰铃">
      <meta itemprop="description" content="爱生活-------爱读书-------爱摄影   爱运动-------爱睡觉-------爱旅行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just for Life.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机图形学笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-17 14:50:17 / 修改时间：15:15:54" itemprop="dateCreated datePublished" datetime="2020-02-17T14:50:17+00:00">2020-02-17</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>当时为了增长业余知识，在<code>MOOC</code>上听完了中国农业大学的计算机图形学这门课，后面几章的方程没有听，仅仅听到了三维变换。这是当时的电子版笔记，后来发现电子版笔记是真的累人，累倒有的笔记都不想放上来了。这是第一次，也是最后一次。</p>
<p>当然感觉这些东西还是挺有意思的，就准备放上来。如果你是华北理工大学的学生选了这门课，把这个网页里的内容看完85+也没问题了（缺少二维变换的例题，主要是太长了，真懒的写了。还有一些基础概念靠自己的悟性了）。</p>
<a id="more"></a>
<h1 id="Chapter-01-计算机图形学概述"><a href="#Chapter-01-计算机图形学概述" class="headerlink" title="Chapter-01 计算机图形学概述"></a>Chapter-01 计算机图形学概述</h1><h2 id="什么是计算机图形学"><a href="#什么是计算机图形学" class="headerlink" title="什么是计算机图形学"></a>什么是计算机图形学</h2><ul>
<li>计算机图形：由计算机产生的图像。</li>
<li>计算机图形学是研究如何利用计算机显示、生成和处理图形的原理、方法和技术的一门学科。</li>
<li>是真实世界或者虚拟世界的数字模拟。</li>
</ul>
<h2 id="计算机图形学的研究内容"><a href="#计算机图形学的研究内容" class="headerlink" title="计算机图形学的研究内容"></a>计算机图形学的研究内容</h2><ul>
<li>包括计算机图形学中定义的内容；</li>
<li>图形硬件，显示器，图形加速卡，图形输出设备(不重要)</li>
<li>基本图形元素的生成算法</li>
<li>图形的变换和裁剪</li>
<li>自由曲线、曲面的生成算法</li>
<li>几何造型技术</li>
<li>真实感图形的生成算法</li>
<li>计算机动画、虚拟现实、交互式三维图形处理</li>
</ul>
<p><strong>计算机生成物体的三个步骤</strong>：</p>
<ul>
<li>几何造型：规则物体应该建立生成图像的物理模型，即对应的几何数据和拓扑关系；非规则的工具表示不规则物体；几何造型技术：用简单的体素(圆柱、圆锥等)构建复杂的模型。</li>
<li>光照模型：表示颜色，表示光源；使用简单的数学模型表示、近似为实际中的物理学中的光学模型。</li>
<li>绘制(渲染)技术：选择恰当的算法渲染将场景渲染出来，将模型真实的显示在屏幕上。</li>
</ul>
<p>计算机屏幕由像素构成，像素是构成图形的基本单位。为了显示图形，需要研究哪些像素显示图形，显示哪些颜色，也就有了光栅显示器(70年代)中的一套算法。</p>
<h2 id="计算机图形学的应用领域"><a href="#计算机图形学的应用领域" class="headerlink" title="计算机图形学的应用领域"></a>计算机图形学的应用领域</h2><ul>
<li>人机交互GUI(Windows, Icon, Mouse, Pointer)</li>
<li>计算机辅助制造(CAD, 电路设计)</li>
<li>真实感图形绘制(计算机重现自然界真实场景)与自然景物仿真</li>
<li>计算机游戏、动画、电影</li>
<li>计算机艺术：钢笔画、油画</li>
<li>计算机仿真：二维、三维结果的表示</li>
<li>科学计算与可视化</li>
<li>虚拟现实</li>
<li>地理信息系统(geographic information system)，如三维地图重建</li>
<li>农业种植模拟</li>
</ul>
<h2 id="计算机图形系统的组成"><a href="#计算机图形系统的组成" class="headerlink" title="计算机图形系统的组成"></a>计算机图形系统的组成</h2><p>输入、输出、计算、交互、存储是五个最基本的功能。</p>
<p>图形系统由图形软件和图形硬件组成。</p>
<ul>
<li>图形软件：<ul>
<li>图形应用数据结构： 对应图形的数据文件，存放欲生成的图形的全部描述信息。</li>
<li>图形应用软件：核心部分，解决某个问题的软件，包含图形生成处理等个重技术，如Photoshop。</li>
<li>图形支撑软件：是图形应用软件的底层，有规范的接口。</li>
</ul>
</li>
<li>图形硬件：包括图形计算机平台和图形设备(如显示器)。</li>
</ul>
<p>实现图形软件的放歌方法：用子程序写包(如OpenGL)，扩充计算机语言，设计专用的图形系统。</p>
<h2 id="交互式计算机图形处理系统"><a href="#交互式计算机图形处理系统" class="headerlink" title="交互式计算机图形处理系统"></a>交互式计算机图形处理系统</h2><p>图形系统中重要的为：图形处理器、图形输入、输出设备。</p>
<ul>
<li>图形输入设备：穿孔纸$\rightarrow$键盘,光笔$\rightarrow$鼠标,触摸屏$\rightarrow$三维输入设备$\rightarrow$智能人机接口:用户语音、手势等。</li>
<li>图形输出设备：图形的输出包括图形的显示和绘制，显示是指在屏幕上输出图形，图形的绘制是指将图形画在纸上，如打印机。<ul>
<li>CRT显示器：阴极射线管，加热电子轰击荧光屏，荧光屏有三种颜色。</li>
<li>LCD液晶显示器：液晶粒子每一面的颜色为红绿蓝，按照收到的数据控制每个粒子转向对应的面，以此来显示颜色。(用于电脑显示)</li>
<li>LED显示器：发光二极管。(光源器件用于照明，如广告牌)</li>
<li>等离子显示器：厚度薄，分辨率好。显示屏排列小低压气体室，电流激发紫外光，紫外光撞击三原色的屏幕，发出可见光。</li>
<li>3D显示器：不用戴眼镜即可看到，用的时差栅栏技术。</li>
</ul>
</li>
</ul>
<p><strong>帧缓冲器与屏幕像素</strong></p>
<p>帧缓冲器每一点可以存储颜色、强度信息，在计算机上画图形，需要计算每个像素的RGB值，因此帧缓存写RGB等价于屏幕画图像。帧缓冲器的单元个数和像素总数相同，存储单元一一对应可寻址的屏幕像素位置。</p>
<ul>
<li>分辨率：一行有几个点，一共多少行。<ul>
<li>屏幕分辨率：屏幕上显示的像素的个数。</li>
<li>显示分辨率：对于文本的显示方式，水平和垂直方向上能显示的字符总数的乘积表示；对于图形显示方式，水平和垂直能显示的像素点数的乘积表示。</li>
<li>显卡分辨率：显卡输出给显示器，并能在显示器上扫描的像素点的数量。电脑的最高分辨率取决于显卡和显示器的最低分辨率。</li>
</ul>
</li>
<li>帧缓冲器的存储单元的位长决定了一副画面能显示的颜色的种类。(256色需要8bit， $2^8=256$)</li>
<li>显存的大小：2MB显存，分辨率$1204\times 768$，每个帧缓冲器的存储单元的位长：$x = 2\times 1204\times 1024 \div 1024 \div 768$，则$2\leq x \leq 3$，最多需要两个字节表示，故支持64K色彩数。</li>
</ul>
<p><strong>显示器的点距</strong></p>
<p>相邻像素点的距离，距离越小越好。028mm足够，小于则更好。</p>
<p><strong>显卡的作用与性能指标</strong></p>
<p>基本作用是显示图文，显示卡与显示器构成了计算机的显示系统。除了CPU与内存外，显卡对计算机的显示性能起了决定性作用。(也可以处理数据)</p>
<h2 id="图形与图像的区别"><a href="#图形与图像的区别" class="headerlink" title="图形与图像的区别"></a>图形与图像的区别</h2><ul>
<li>图形：计算机绘制，矢量图。</li>
<li>图像：认为用外部设备拍摄捕捉，点阵图。</li>
</ul>
<p>图形图像的构成属性</p>
<ul>
<li>几何属性：几何要素，轮廓，形状，点线面。(如圆心、半径)</li>
<li>非几何属性：视觉属性，颜色，材质，明暗，透明度，纹理。</li>
</ul>
<p>图形分类</p>
<ul>
<li>几何属性很重要：基于线条信息表示，如等高图、工程图。</li>
<li>非几何属性很重要：明暗图，通常的真实感图形。</li>
</ul>
<p><strong>矢量图与位图的区分</strong></p>
<p>两者可以相互转换，矢量扫描转换到点阵，点阵图像处理到矢量。</p>
<ul>
<li>概念区分：<ul>
<li>位图：点阵图，图由屏幕上的像素构成，每个点用二进制表述颜色与明暗。</li>
<li>矢量图：数学描述曲线及曲线围成的色块制作的图形。矢量图中的图形元素也成为对象。每个对象自成一个实体，具有颜色、形状、大小和位置等属性。</li>
</ul>
</li>
<li>存储方式的区别：<ul>
<li>点阵文件存储每个像素点的位置、颜色和灰度信息(存储空间大)</li>
<li>矢量文件用数学方程对图形进行描述，用图形的形状参数和属性参数表示图形</li>
</ul>
</li>
<li>缩放的区别：<ul>
<li>位图与分辨率有关，在一定面积上含有固定数量的元素，所以放大后失真</li>
<li>不会影响清晰度，无失真的放大缩小。</li>
</ul>
</li>
<li>存储格式的区别：<ul>
<li>位图：png, bmp, gif, jpeg</li>
<li>矢量图：eps, svg(scalable vector graphics), DXF(data exchange file), WMF, EMF.</li>
</ul>
</li>
</ul>
<p>位图更容易模仿真实感图形效果，矢量图不失真，用于文字设计、标志设计、插图等。</p>
<h1 id="Chapter-02-光栅图形学算法"><a href="#Chapter-02-光栅图形学算法" class="headerlink" title="Chapter-02 光栅图形学算法"></a>Chapter-02 光栅图形学算法</h1><p>出现了光栅显示器，为了在计算机上处理和显示图形，需要一套算法。属于计算机图形的底层算法，设计了计算机图形学的基本概念和思想。</p>
<h2 id="直线段的扫描转换算法-1"><a href="#直线段的扫描转换算法-1" class="headerlink" title="直线段的扫描转换算法(1)"></a>直线段的扫描转换算法(1)</h2><p>直线无限，而像素有限，所以要用有限的像素逼近无限的直线，所以可能存在锯齿情况，不够理想。</p>
<p>问题：求每个像素点的$x, y$坐标。</p>
<p>求解：</p>
<p>过$P_0(x_0, y_0), P_1(x_1, y_1)$的直线$y=kx+b$ 得到 $k=\frac{y_1-y_0}{x_1-x_0}(x_1\neq x_0)$</p>
<p>假设$x$已知，从$x$的起点$x_0$开始，沿$x$前进一个像素，则步长为1。</p>
<p>计算相应的$y$值，因为像素坐标是整数，$y$需要+0.5，向下取整。</p>
<p>真实感图形往往调用成千上万次的画线程序，因此这个算法影响了图形的质量和显示速度。在函数$y=kx+b$中，存在$kx$的乘法运算，而计算机最快的运算是加法，所以接下来要取消乘法的运算。</p>
<h2 id="直线段的扫描转换算法-2"><a href="#直线段的扫描转换算法-2" class="headerlink" title="直线段的扫描转换算法(2)"></a>直线段的扫描转换算法(2)</h2><p>一共有三个比较出名的算法</p>
<ul>
<li>数值微分法(DDA)</li>
<li>中点画线法</li>
<li>Bresenham算法</li>
</ul>
<p><strong>DDA算法</strong></p>
<p>重要的思想为增量思想。设单位步长为一个像素。</p>
<script type="math/tex; mode=display">y_i=kx_i+b \Longrightarrow y_{i+1}=kx_{i+1}+b</script><script type="math/tex; mode=display">y_{i+1}=k(x_i+1)+b = kx_i+b+k = y_i+k</script><p>即：$y_{i+1}=y_i+k$，$k$是增量。$y_i$加$k$得到$y_{i+1}$，取消了乘法。当$|k|\leq 1$时，一切正常。参考下列例题。</p>
<p><strong>例题</strong></p>
<p>DDA算法扫描转换连接两点$P_0(0, 0)$，$P_1(5, 3)$的直线段。</p>
<p>$k=\frac{3-0}{5-0}=0.6$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$x$</th>
<th>$y$</th>
<th>int($y$+0.5)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>0 | 0 | 0<br>1 | 0.6 | 1<br>2 | 0.6+0.6 | 1<br>3 | 1.2 + 0.6 | 2<br>4 | 1.8 + 0.6 | 2<br>5 | 2.4 + 0.6 | 3</p>
<p><strong>思考</strong> </p>
<p>在DDA算法的$|k|&gt;1$时，如$(0, 0)$到$(2, 100)$画点，光栅点会很系数，点很少，没有办法表达直线(只是每个点亮)。此时不能$x+1$作为基本单位。</p>
<p>$y_{i+1}=y_i+k$，一般情况下，$y$和$k$都是小数，而且每一步都需要取整，唯一的改进方法是，将浮点数计算改为整数计算。</p>
<p>如果换一种直线方程的表达形式，是否可以改进效率。</p>
<p><strong>中点画线法</strong></p>
<p>直线的一般式：$F(x, y)=0$ 即 $Ax + By + C = 0$。</p>
<ul>
<li>直线上的点：$F(x, y) = 0$</li>
<li>直线上方的点：$F(x, y) &gt; 0$</li>
<li>直线下方的点：$F(x, y) &lt; 0$</li>
</ul>
<p>每次在最大位移方向走一步，另一个方向是否移动取决于中点误差项的判断。</p>
<p>对于$0\leq|k|\leq 1$，$x$在方向上加1， $y$方向是否加1需要判断。如下图所示：</p>
<p><img data-src="/2020/02/17/cg/midpoint1.png" alt></p>
<ul>
<li>交点$Q$在Midpoint上方时，$Q$距离$P_u$近；</li>
<li>交点$Q$在Midpoint下方时，$Q$距离$P_t$近；</li>
</ul>
<p>将$M$带入理想的只想方程，$F(x_m, y_m) = Ax_m + By_m + C$，记为距离$d$。</p>
<ul>
<li>当$d &lt; 0$时，$M$在$Q$下方，选择$P_u$</li>
<li>当$d &gt; 0$时，$M$在$Q$上方，选择$P_t$</li>
<li>当$d = 0$时， 选择$P_t$或者$P_u$都可以</li>
</ul>
<p>得到：</p>
<script type="math/tex; mode=display">d < 0 \Longrightarrow y_{i+1} = y_i+1</script><script type="math/tex; mode=display">d \geq 0 \Longrightarrow y_{i+1} = y</script><script type="math/tex; mode=display">d_i = A(x_i+1)+B(y_i+0.5)+C</script><p>上面的公式两个乘法，四个加法，所以要提升效率。</p>
<ol>
<li>在$d&lt;0$时</li>
</ol>
<p><img data-src="/2020/02/17/cg/midpoint2.png" alt></p>
<ul>
<li>在点$M_0$处，$d_0=F(x_{m0}, y_{m0})=A(x_i+1)+B(y_i+0.5)+C$</li>
<li>在点$M_1$处，$d_1=A(x_i+2) + B(y_i+1.5) + C=d_0+A+B$</li>
</ul>
<ol>
<li>在$d\geq 0$时</li>
</ol>
<p><img data-src="/2020/02/17/cg/midpoint3.png" alt></p>
<ul>
<li>在点$M_0$处，$d_0=F(x_{m0}, y_{m0})=A(x_i+1)+B(y_i+0.5)+C$</li>
<li>在点$M_1$处，$d_1=A(x_i+2) + B(y_i+0.5) + C=d_0+A$</li>
</ul>
<p>于是得到$d$的递推公式：</p>
<script type="math/tex; mode=display">d_0 = A(x_0+1)+ B(y_0+0.5) + C = A + 0.5B</script><script type="math/tex; mode=display">d\geq0  \Longrightarrow d_{i+1}=d_i+A</script><script type="math/tex; mode=display">d < 0 \Longrightarrow d_{i+1}=d_i+A+B</script><p>但是在$d_0$中有小数，且只判断$d$的符号，所以可以使用$2d$代替$d$，即$d_0=2A+B$，摆脱浮点运算，提高到整数加法，优于DDA算法。</p>
<p><strong>Bresenham算法</strong></p>
<p>效率没办法提升，所以算法要解决其它问题，如是否可以画圆，不限于直线的方程形式。</p>
<p><img data-src="/2020/02/17/cg/bresenham.png" alt></p>
<p>此时不再依赖直线的方程形式，更加一般化。</p>
<p>计算直线的起点到终点与垂直网格线的交点，根据误差项判断与交点最近的像素点。</p>
<p>每次$x+1$，$y$的增量为0或者1， 取决于最近光栅网格点的距离。最开始是，$d_0=0$，递增公式为$d=d+k$。一旦$d&gt;1$，则$d=d-1$，使得$d$在$[0, 1]$区间内。所以：</p>
<script type="math/tex; mode=display">d > 0.5 \Longrightarrow y_{i+1}=y_i+1</script><script type="math/tex; mode=display">d \leq 0.5  \Longrightarrow  y_{i+1}=y_i</script><p>但是需要将浮点计算提升到整数运算。</p>
<p>Step1: $e=d-0.5$</p>
<script type="math/tex; mode=display">e > 0 \Longrightarrow y_{i+1}=y_i+1</script><script type="math/tex; mode=display">e \leq 0 \Longrightarrow y_{i+1}=y_i</script><p>Step2: $e_0=-0.5$，$e=e+k$，$e&gt;0.5$时，$e=e-1$。</p>
<p>Step3：$e_0=-0.5$，$k=\frac{dy}{dx}$。用$2e\Delta x$代替$e$(计算过程为两边同时乘以$2\Delta x$，并将$2e\Delta x$写为$e$)，于是</p>
<script type="math/tex; mode=display">e_0=-\Delta x</script><script type="math/tex; mode=display">e=e+2\Delta y</script><script type="math/tex; mode=display">e>0, e = e - 2\Delta x</script><p>最终的算法步骤:</p>
<ul>
<li>输入起点$P(x_0, y_0)$和终点$P_n(x_n, m_n)$</li>
<li>计算初始值$e_0$</li>
<li>绘制点$(x_0,y_0)$</li>
<li>$e$更新为$e+2\Delta y$。若$e&gt;0.5$，更新$e$为$e - 2\Delta x$，$(x_i,y_i)$更新为$(x_i+1,y_i+1)$；否则$e$不更新，坐标更新为$(x_i+1,y_i)$。</li>
<li>如果没有画完，持续三四步骤，如果画完了就结束。</li>
</ul>
<h2 id="多边形的扫描转换与区域填充"><a href="#多边形的扫描转换与区域填充" class="headerlink" title="多边形的扫描转换与区域填充"></a>多边形的扫描转换与区域填充</h2><p>实际上为离散的像素点到连续的二维图形之间的转换。</p>
<p>多边形的两种表现形式：</p>
<ul>
<li>顶点表示：描述为顶点的序列，侧重几何意义，没有指明哪些点在多边形的内部。</li>
<li>点阵表示：多边形内部的像素点集合，丢失了边界信息和顶点信息，常用于光栅显示器的显示。</li>
</ul>
<p>进一步，导出两个问题：</p>
<ul>
<li>知道边界，就知道了哪些像素在多边形内，就可以转换为点阵表示，也叫多边形的扫描转换。即将顶点表示转换为点阵表示，寻找内部的像素点并填充颜色。</li>
<li>知道多边形内部的像素，但不可以确定多边形的边界。(属于图像处理课程的东西)</li>
</ul>
<p><img data-src="/2020/02/17/cg/muliangle.png" alt></p>
<p><strong>X扫描线算法</strong></p>
<p>以数值扫描为例，按照扫描的顺序，求与多边形相交的区间，对区间内部的像素点进行颜色填充。同样，坐标点需要四舍五入为整数。</p>
<p><img data-src="/2020/02/17/cg/scan-fill.png" alt></p>
<p>需要以$x$递增的排列顺序得到$x$的坐标，也就是要在$[2,4],[7,9]$两个区间内填充。</p>
<p>如果图形中，$y_{\mathrm{min}}$值为$1$，$y_{\mathrm{max}}$值为$12$，一共需要$12$条扫描线从下向上扫描，其他线不考虑。在$y\in [y_{\mathrm{min}},y_{\mathrm{max}}]$中，对每一条扫面线的扫描结果进行填充，步骤为：</p>
<ul>
<li>求交点</li>
<li>升序对$x$的坐标进行排序</li>
<li>保证交点为偶数个，配对</li>
<li>填充</li>
</ul>
<p>为了保证交点为偶数个，需要对交点的取舍问题进行解决。</p>
<ul>
<li>共享顶点的两条边在扫描线的两侧，算一个交点</li>
<li>共享顶点的两条边在扫面线的一侧，需要检查共享顶点的另外两个端点的$y$值，按照大于$y$值的个数决定交点的个数。</li>
</ul>
<p><img data-src="/2020/02/17/cg/pair.png" alt></p>
<p>如上图所示</p>
<ul>
<li>左图：共享顶点的两条边在扫描线的两侧，算一个交点</li>
<li>中间图：$O_2 &lt; O_1, O_3 &lt; O_1$，零个交点</li>
<li>右图：$y_1&gt;y_4,y_3&gt;y_5$，共四个交点，每个交点有两个</li>
</ul>
<p>例题：</p>
<p><img data-src="/2020/02/17/cg/pair-exam.png" alt></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编号</th>
<th>个数</th>
<th>编号</th>
<th>个数</th>
<th>编号</th>
<th>个数</th>
<th>编号</th>
<th>个数</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>1 | 0 | 2 | 1 | 3 | 1 | 4 | 1<br>5 | 1 | 6 | 0 | 7 | 2 | 8 | 2</p>
<p>同理可知，最右下脚的交点个数为2。但是，每次都需要求交点，暴力循环会导致计算量过大，应该采取某种方法避免求交。</p>
<p><strong>改进的多边形扫面转换算法</strong></p>
<p>解决每次的扫面线和边求交点的问题。</p>
<ul>
<li>有效边饥溺羞赧感相交运算，而暂时用不到的边则不计算</li>
<li>当前扫描线与下条扫描线与当前边或下一条边的交点顺序可能相似，即扫描线的连贯性</li>
<li>多边形的连贯线，某边与扫描线相交，还可能与下条扫描线继续相交</li>
</ul>
<p>如$P_1,P_2,P_3$三条扫描线连贯性，多边形的边也有连贯性。</p>
<p><img data-src="/2020/02/17/cg/continue.png" alt></p>
<p>此时需要引入特殊的数据结构，活性边表AET(Active Edge Table)，活性边是指与扫描线相交的边，同样以$x$递增的顺序放入一个表内。这个表的节点内容为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$x$</th>
<th>$\Delta x$</th>
<th>$y_{\mathrm{max}}$</th>
<th>$\mathrm{next}$</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>$x$是当前交点的值</li>
<li>$\Delta x$是$x$的增量，用于计算下一个$x$。扫面线移动，和多边形的交点与上一个交点是有关的。</li>
<li>$y_{\mathrm{max}}$表示当前活性边的最高点，即扫描线何时此笔边相交，及时删除。</li>
<li>next指向下一条边</li>
</ul>
<p>$\Delta x$的计算过程：</p>
<script type="math/tex; mode=display">k=\frac{\Delta y}{\Delta x}=\frac{y_{i+1}-y_i}{x_{i+1}-x_i}=\frac{1}{x_{i+1}-x_i}</script><p>得到：</p>
<script type="math/tex; mode=display">x_{i+1}=x_i+\frac{1}{k}\Longrightarrow \Delta x=\frac{1}{k}</script><p><strong>例题</strong></p>
<p><img data-src="/2020/02/17/cg/AET.png" alt></p>
<p>为了方便存放多边形的边，AET的建立与更新，需要建立新边表NET(New Edge Table)。是一种纵向链表，长度为最大扫描线的数量，每个节点是一个吊桶，对应一条扫描线，节点的结构为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$y_{\mathrm{max}}$</th>
<th>$x_{\mathrm{min}}$</th>
<th>$\frac{1}{k}$</th>
<th>$\mathrm{next}$</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><strong>例题</strong></p>
<p><img data-src="/2020/02/17/cg/NET.png" alt></p>
<p>$1,3,5,7$处需要更新，读入新的边，所以存入NET表，从最低点的$y=1$开始做，引入两条边放入AET处理。</p>
<p><strong>总结</strong></p>
<p>每次扫描线要经过三个处理</p>
<ul>
<li>判断是否需要取出(读$y_{\mathrm{max}}$即可)</li>
<li>不取出的话以$x=x+\frac{1}{k}$对$x$更新</li>
<li>判断有无新边的进入，新边在NET中，插入排序插入即可。(读$y_{\mathrm{max}}$和next判断)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python code for algorithm flow</span></span><br><span class="line">Begin Algorithm</span><br><span class="line">--------------------------------------------------</span><br><span class="line">sort(every_scanline)</span><br><span class="line">num = len(every_scanline) + scanline[<span class="number">0</span>].height</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(scanline[<span class="number">0</span>].height, num):</span><br><span class="line">    init NET[e]</span><br><span class="line">    insert the edge <span class="keyword">in</span> NET[e] which edge.y_min = e</span><br><span class="line"></span><br><span class="line">y = min(scanline)</span><br><span class="line">init AET</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(scanline[<span class="number">0</span>].height, num):</span><br><span class="line">    <span class="comment"># x's value is in ascending</span></span><br><span class="line">    Insert to AET <span class="keyword">from</span> NET[e] by Insert Sort Method</span><br><span class="line">    loop through AET, pair x <span class="keyword">and</span> brush(x, y, color)</span><br><span class="line">    loop through AET, delete edge.y_max = e <span class="keyword">from</span> AET</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line">End  Algorithm</span><br></pre></td></tr></table></figure>
<p>这样就可以完成对任意多边形的填充，利用了扫描线增量的思想，多边形的连贯性和一种新的数据结构。但是要求待填充区域必须已知，无法对位置边界的区域进行填充。</p>
<p>此外还有其他多种算法可以完成对多边形的填充，如边缘填充算法，随机则一条边和边的遍历顺序，对每条边的右侧像素取补运算，即可完成对多边形区域额填充。</p>
<p><img data-src="/2020/02/17/cg/edge-fill.png" alt></p>
<p><strong>区域填充算法</strong></p>
<p>将区域内的某个点赋予颜色(种子点)，并将此颜色扩展到整个区域，其中的区域是指：已经点阵表示的填充图形的像素的集合。</p>
<p>区域表示的两种方法：</p>
<ul>
<li>内点表示：枚举所有像素，着同一颜色</li>
<li>边界表示：枚举边界的所有像素，内部点着同一颜色</li>
</ul>
<p>这个算法要求区域是连通的，进行四向连通和八向连通。</p>
<p><img data-src="/2020/02/17/cg/connected.png" alt></p>
<p>以四连通填充为例，边界的像素与内部的像素颜色不同，找到内部的种子像素，并填充到内部的其他像素。使用栈结构实现(和栈结构的米够求解问题类似)</p>
<p>算法伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push seed</span><br><span class="line"><span class="keyword">while</span>(!empty(stack)):</span><br><span class="line">    e = pop(shack)</span><br><span class="line">    brush(e)</span><br><span class="line">    a = go through adjacent pixels by four directions</span><br><span class="line">    <span class="keyword">if</span> a <span class="keyword">not</span> brushed:</span><br><span class="line">        push(a)</span><br></pre></td></tr></table></figure>
<p>可以脑补栈结构的迷宫求解问题理解上述代码。有些像素需要入栈多次，浪费时间，多次循环浪费时间，效率低下。</p>
<p><strong>总结</strong></p>
<p>扫描线算法与区域填充算法的对比：</p>
<ul>
<li>扫描算法只将顶点转换为点阵表示，从顶点出发，利用连贯性填充和全新的数据结构。</li>
<li>区域填充没有改变区域的表示方法，依赖连通性，需要知道多边形边界与内部的像素差异，要求的条件更多。</li>
</ul>
<h2 id="反走样算法"><a href="#反走样算法" class="headerlink" title="反走样算法"></a>反走样算法</h2><p>走样是理想世界数字化的必然产物，发生走样的原因是像素本身是离散的，可能会导致锯齿状、微小物体丢失的现象。</p>
<p>走样可以总结为:原始信号变化快，采样频率低而导致，最终的结果会取决于低频的采样信号(低频的采样信号可以理解为很少的像素点，分辨率低，分辨率高则采样频率也会高)</p>
<p><img data-src="/2020/02/17/cg/frequency.png" alt></p>
<p>反走样：减少或消除走样的效果。所有的图像处理系统都会对基本图形进行反走样处理。</p>
<ul>
<li>提高分辨率：像素更密集，但是付出的存储代价和扫描转换时间都要提升，还要提高电子枪的射击速度，并不可取。</li>
<li>以一种模糊的形式去平滑，如白纸黑字下，黑子旁边增加灰色像素柔滑尖锐的效果。</li>
</ul>
<p><strong>两种反走样算法</strong></p>
<p><strong>非加权采样方法</strong></p>
<p>以物体的覆盖率计算像素的颜色，即某个像素区域被物体覆盖的比例，覆盖率越大，颜色越亮。</p>
<p><img data-src="/2020/02/17/cg/coverage.png" alt></p>
<p>如上图所示的第$3$号区域，覆盖了一个像素的一般的区域，所以颜色取原来的二分之一。如果为小数则进行四舍五入的取整。</p>
<p>缺点</p>
<ul>
<li>与相交的区域成正比，与区域块的位置无关，仍然可能会存在锯齿的现象，因为没有良好的区分边界位置与中心位置。</li>
<li>相邻的像素点会有较大的灰度差，因为每个像素的权重一样，亮度完全取决于覆盖面积。</li>
</ul>
<p><strong>加权采样方法</strong></p>
<p>亮度取决于距离像素中心的远近，区域与像素中心的距离决定了对像素亮度的贡献。将一个像素分为$3\times 3$的矩阵，矩阵的每个值被赋予权重，乘以颜色求平均，得到最后的亮度值。(和图像处理中的高斯模糊过程一致)</p>
<h2 id="裁剪算法"><a href="#裁剪算法" class="headerlink" title="裁剪算法"></a>裁剪算法</h2><p>内部存储的比实际显示的要大，所以要对不分区域进行裁剪，确定哪些像素落在显示区域内。(基于点阵的判断)</p>
<p><img data-src="/2020/02/17/cg/cat.png" alt></p>
<p>判断一个点$P(x,y)$是否在区域内部的方法：</p>
<script type="math/tex; mode=display">x_{\text{left}}\leq x\leq x_{\text{right}}, y_{\text{bottom}}\leq y\leq y_{\text{top}}</script><p>而直线段的裁剪，是复杂图形裁剪的基础，分为以下三种情况。</p>
<ul>
<li>完全在window内</li>
<li>完全在window外</li>
<li>与window的边界相交</li>
</ul>
<p>有常用的三种算法</p>
<ul>
<li>Cohen-Sutherland算法</li>
<li>中点分割算法</li>
<li>Liang-Barsky算法</li>
</ul>
<p><strong>Cohen-Sutherland</strong></p>
<p><img data-src="/2020/02/17/cg/cat-cate.png" alt></p>
<p>设直线的两个端点$p_1,p_2$</p>
<ul>
<li>$p_1,p_2$全部在窗口内，保留直线</li>
<li>完全在窗口外，抛弃<ul>
<li>$x_1\leq x_{\text{left}} \&amp; x_2\leq x_{\text{left}}$</li>
<li>$x_1\geq x_{\text{right}} \&amp; x_2\geq x_{\text{right}}$</li>
<li>$y_1\geq y_{\text{top}} \&amp; y_2\geq y_{\text{top}}$</li>
<li>$y_1\geq y_{\text{bottom}} \&amp; y_2\geq y_{\text{bottom}}$</li>
</ul>
</li>
<li>与窗口相交，则按照交点分段，抛弃一部分，保留窗口内的线段。</li>
</ul>
<p>以窗口的延长线将区域分为9部分，编码四位数$D_0D_1D_2D_3$，编码规则为</p>
<ul>
<li>$x\leq x_{\text{left}}, D_0=1 \text{ else } D_0=0$</li>
<li>$x\geq x_{\text{right}}, D_1=1 \text{ else } D_1=0$</li>
<li>$y\leq y_{\text{bottom}}, D_2=1 \text{ else } D_2=0$</li>
<li>$y\geq y_{\text{top}}, D_3=1 \text{ else } D_3=0$</li>
</ul>
<p>通过二进制的运算来判断是否保留线段</p>
<ul>
<li>两个交点的与运算后，$\neq0$，在窗口外，抛弃</li>
<li>两个交点的或运算后，$=0$，在窗口内，保留</li>
<li>如果以上均不成立，则需要求交点，划分线段，然后继续</li>
</ul>
<p><strong>例题</strong></p>
<p><img data-src="/2020/02/17/cg/cohen.png" alt></p>
<p>编码的思想值得学习，二进制计算速度快，适用于直线的大部分在区域内可见或者大部分在区域外不可见的情况。</p>
<p><strong>Liang-Barsky算法</strong></p>
<p><img data-src="/2020/02/17/cg/liang.png" alt></p>
<p>核心思想：</p>
<ul>
<li>将直线以参数方程进行表示</li>
<li>将线段视为有方向的线段</li>
<li>入边：直线由窗口外向窗口内移动时会与边界有交点(左侧与下侧)，出边：直线由窗口内向窗口外移动时会与边界有交点(上侧与下侧)。</li>
<li>最后只需要求解裁剪后的起点与终点，即参数方程中的参数是，求解得到裁剪后的方程。</li>
<li>$u_1$窗口内可见的起点，$u_1=max(0, u_l, u_b)$(入边)</li>
<li>$u_2$窗口内可见的终点，$u_2=min(1, u_t, u_r)$(出边)</li>
</ul>
<p><img data-src="/2020/02/17/cg/barsky.png" alt></p>
<p>所以现在的问题是：</p>
<ul>
<li>如何判断入边与出边</li>
<li>$u_l, u_b, u_t, u_r$如何去求</li>
</ul>
<p>判断线段的某各部分是否在窗口内，可以判断线段上的一个点$P$是否在窗口内，于是转换为裁剪不等式：</p>
<script type="math/tex; mode=display">x_{left}\leq x_1+u\Delta x \leq x_{right}</script><script type="math/tex; mode=display">y_{bottom}\leq y_1+u\Delta y \leq y_{top}</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">u(-\Delta x) \leq x_1-x_{left}</script><script type="math/tex; mode=display">u(\Delta x) \leq x_{right}-x_1</script><script type="math/tex; mode=display">u(-\Delta y) \leq y_{1}-y_{bottom}</script><script type="math/tex; mode=display">u(\Delta y) \leq y_{top}-ys_1</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">up_k\leq q_k \Longrightarrow u = \frac{q_k}{p_k}(k=1,2,3,4)</script><p>$u$为直线与四条边交点的参数，求出四个交点。通过$p_k$的符号来判断入边与出边。</p>
<ul>
<li>$\Delta x &gt; 0 \Longrightarrow u(-\Delta x) &lt; 0$, 外到内，左侧，入边。</li>
<li>$\Delta x &gt; 0 \Longrightarrow u(\Delta x) &gt; 0$, 内到外，右侧，出边。</li>
<li>$\Delta y &gt; 0 \Longrightarrow u(-\Delta y) &lt; 0$, 外到内，下侧，入边。</li>
<li>$\Delta y &gt; 0 \Longrightarrow u(\Delta y) &gt; 0$, 内到外，上侧，出边。  </li>
</ul>
<p>如此，求得了出边与入边，以及相关的$u$值，求解即可。</p>
<p><strong>例题</strong></p>
<p><img data-src="/2020/02/17/cg/liang-exam.png" alt></p>
<p>可以看到，Liang-barsky算法一般情况下会更好，但只适用于矩形的裁剪窗口。更改的底层算法效率更高，可以固化到计算机底层硬件中，加速显示与执行效率，且图形软件则不用研究此类算法（如photoshop）</p>
<p><strong>多边形裁剪</strong></p>
<p>裁剪后的多边形边界的顶点序列。保留封闭区域，可能一个，也可能多个。Sutherland-hodgemen算法针对裁剪过程中出现的四种情况，作出了分类求解：</p>
<p><img data-src="/2020/02/17/cg/hodgemen.png" alt></p>
<p><strong>例题</strong></p>
<p><img data-src="/2020/02/17/cg/hodgemen-exam.png" alt></p>
<p><strong>文字裁剪算法</strong></p>
<ul>
<li>串精度的裁剪：字符串全部在窗口内部，保留；一个字符不在，全部舍弃。</li>
<li>字符精度裁剪：一个字符位于边界没完全在窗口内，舍弃这个字符，字符串的其他字符保留。</li>
<li>笔划、像素精度的裁剪：哪些像素在窗口内，保留，即但个字符会切为两部分。</li>
</ul>
<h2 id="消隐算法"><a href="#消隐算法" class="headerlink" title="消隐算法"></a>消隐算法</h2><p>消隐：当物体不透明时，物体的背面时看不到的，于是不可见一侧的面不用绘制。消除不可见的线与面。消隐的过程与对象有关，与观察者的位置有关。</p>
<p>按消隐对象分类：</p>
<ul>
<li>线消隐：消除的是线</li>
<li>面消隐：消除的是面</li>
</ul>
<p>按消隐空间分类：</p>
<ul>
<li>物体空间：$k$个物体与$k-1$个物体的对比遮挡。</li>
<li>图像空间：像素位置距离观察者的远近（主流研究）</li>
</ul>
<p>消隐的基础算法：画家算法。先画远的，再画近的，近的遮盖远处的物体，实现最简单的消隐。三维中，随观察者视野的变化，不同物体的近远可能会发生变化，此时可能会随视野变化相互遮挡。</p>
<p>消隐算法：</p>
<ul>
<li>Z-buffer算法</li>
<li>扫描线算法</li>
<li>Warnock算法</li>
</ul>
<p><strong>Z-buffer算法</strong></p>
<p>可用于生成复杂图形，首先设立帧缓冲器：</p>
<ul>
<li>帧缓冲器（像素点）存储每个可见像素的光强与颜色</li>
<li>深度数组（与像素点等量）存储可见像素的$z$坐标，近的$z$大，远的$z$小</li>
</ul>
<p>$z$的求法：空间中的平面方程为：$Ax+By+Cz+d=0\Longrightarrow z=\frac{Ax+By+d}{-C}$</p>
<p>在同一条视野线上：$P_1$在$P_2$前面，则只显示$P_1$的颜色。同一组$(x,y)$，通过判断$z$的大小来决定显示哪个像素，与在屏幕中的出现顺序无关。</p>
<p><img data-src="/2020/02/17/cg/z-buffer.png" alt></p>
<p>特点：</p>
<ul>
<li>占用空间大</li>
<li>没有利用到图形的相关性与连续性</li>
<li>像素级的消隐，复杂度高</li>
</ul>
<p><strong>只用一个帧缓冲器</strong></p>
<p>以$i,j$表示像素的在多边形内的某个点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">depth = minValue</span><br><span class="line"><span class="keyword">if</span> depth(i, j) &gt; depth:</span><br><span class="line">    depth = depth(i, j)</span><br><span class="line"><span class="keyword">if</span> depth(i, j) != minValue:</span><br><span class="line">    show_beam()</span><br><span class="line"><span class="keyword">if</span> new_polygen: <span class="comment"># 到了新的多边形</span></span><br><span class="line">    depth = minValue</span><br></pre></td></tr></table></figure>
<p>如何判断像素$(i,j)$是多边形内部的点：</p>
<ul>
<li>射线法</li>
<li>弧长法</li>
<li>弧长判断法</li>
</ul>
<p><strong>射线法</strong></p>
<p><img data-src="/2020/02/17/cg/ray.png" alt></p>
<p><strong>弧长法</strong></p>
<p><img data-src="/2020/02/17/cg/arc.png" alt></p>
<p>但是弧长的计算比较不容易，还需要考虑精度问题。需要加以改进。</p>
<p><strong>弧长判断法</strong></p>
<p><img data-src="/2020/02/17/cg/arc-judge.png" alt></p>
<p>虽然加以改进，仍是基于像素级别的消隐，时间效率不高。</p>
<p><strong>区间扫描线算法</strong></p>
<p>不再基于像素级别的消隐，加快了执行速度。</p>
<p>按照扫描线的思想，同款区间设置同款颜色，而相交的区间取决于谁在前。而在染色时，一个像素决定了一个区间的颜色，以逐段染色的方式对区间进行染色。</p>
<p>同样，借助图形的连贯性和连续性，以增量的形式避免求交，排序$x$点，染色。</p>
<p><img data-src="/2020/02/17/cg/scan-color.png" alt></p>
<ul>
<li>无多边形，$[a_4,a_5]$染背景颜色</li>
<li>一个多边形内，$[a_1,a_2]$染对应的颜色</li>
<li>多个多边形相交，$[a_6,a_7]$取决于$z$值</li>
</ul>
<p><strong>Warnock算法</strong></p>
<p>效率不是很高，而是一种全新的思想。</p>
<p>将区域递归分割，直到窗口内的目标足够简单到可以显示为止。</p>
<p>足够简单的定义（足够简单则直接显示）：</p>
<ul>
<li>只有一个多边形</li>
<li>窗口内无其他多边形</li>
<li>窗口被一个多边形包围</li>
<li>窗口与一个多边形分离</li>
</ul>
<p>判断一个多边形在窗口内：</p>
<script type="math/tex; mode=display">x_{min} \geq x_{left} \quad and \quad  x_{max} \leq x_{right}</script><script type="math/tex; mode=display">y_{min} \geq y_{bottom}\quad  and\quad  y_{max} \leq y_{top}</script><script type="math/tex; mode=display">OR</script><script type="math/tex; mode=display">x_{min}>x_{right} \text{ or } x_{max}<x_{left}</script><script type="math/tex; mode=display">y_{min}>y_{top} \text{ or } y_{max}<y_{bottom}</script><p>判断多边形与窗口相交：用直线方程（规定定义域内）求交点判断即可。</p>
<p>当窗口内有多个多边形无法直接显示时：</p>
<ul>
<li>没有物体染背景色</li>
<li>一个面则直接显示</li>
<li>窗口有两个面及其以上，等分为四个窗口，递归执行。</li>
</ul>
<p><img data-src="/2020/02/17/cg/warmock-exam.png" alt></p>
<h1 id="二维图形变换"><a href="#二维图形变换" class="headerlink" title="二维图形变换"></a>二维图形变换</h1><h2 id="向量的基础"><a href="#向量的基础" class="headerlink" title="向量的基础"></a>向量的基础</h2><p>对对象的变换：形状、位置、方向，最后计算每个点的像素值。变换的基础是向量，有长度方向，无位置；对于单纯的点，有位置，无长度与方向。且可以上升到$n$维向量，便于处理问题。</p>
<p>向量的线性组合：$\vec{w}=a_1\vec{v}_1+a_2\vec{v}_2+a_3\vec{v}_3+\dots+a_n\vec{v}_n$</p>
<p>仿射组合：$a_1+a_2+a_3+\dots+a_n=1$</p>
<p>基本运算：</p>
<ul>
<li>$|w|=\sqrt{a_1^2+a_2^2+a_3^2+\dots+a_n^2}$, $\hat{w}=\frac{\vec{w}}{|w|}$</li>
<li>$a\cdot b=a_1b_1+a_2b_2$</li>
<li>$\mathrm{cos}\theta = \frac{a\cdot b}{|a||b|}$</li>
<li>$a\times b=|a||b|\mathrm{sin}\theta$(求法向量)</li>
</ul>
<h2 id="图形坐标系"><a href="#图形坐标系" class="headerlink" title="图形坐标系"></a>图形坐标系</h2><p>坐标分为一维、二维、三维等，联系了图形与数。（当然也有直角座标，极座标，球坐标等）。用于描述对象的几何信息，应用于建模；表述对象的大小与位置，用于观察。（像素点坐标下没有小数）</p>
<ul>
<li>世界座标系：一个参考的标准，公共座标系，统一参考系。</li>
<li>建模座标系：物体内部的座标系。</li>
<li>观察座标系：不同观察角度对象的重新定位与描述，用于指定输出范围，在世界座标系中指定坐标，选定方向和位置进行裁剪。</li>
<li>设备座标系：（整数），针对一个具体设备的坐标系。</li>
<li>规范化座标系：不依赖于设备，但容易转化为不同设备的座标系（打印机、手机），范围在$[0,1]$。</li>
</ul>
<h2 id="二维图形转换"><a href="#二维图形转换" class="headerlink" title="二维图形转换"></a>二维图形转换</h2><p>基本的变换包括比例、旋转和镜像等。</p>
<p>变换的原理：</p>
<ul>
<li>图形在变化，但是连边规则不变</li>
<li>图形变化因为顶点位置在变</li>
<li>坐标变换，拓扑关系没变</li>
</ul>
<p>上述的变换符合二维到二维的线性变换（也符合仿射变换），具有以下性质</p>
<ul>
<li>平直性：直线经过变换仍然是直线</li>
<li>平行性：平行的直线变换后依然平行，直线上点的顺序不变</li>
</ul>
<script type="math/tex; mode=display">x'=ax+by+m</script><script type="math/tex; mode=display">y'=cx+dy+n</script><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><p>$(x,y)$ ，表示一个点 $(x*, y*)=(x,y) \cdot M$，$M$表示变换矩阵。 </p>
<script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">x^*=a_1x+b_1y+c_1</script><script type="math/tex; mode=display">y^*=a_2x+b_2y+c_2</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">[x^\*\;y^\*]=[x\;y\;1]\cdot M</script><script type="math/tex; mode=display">[x\;y\;1]\text{增加了一维}</script><p>$n+1$维表示$n$维：称为齐次坐标表示法，$(p_1,p_2,p_3,\dots,p_n)$推到$(hp_1,hp_2,hp_3,\dots,hp_n)$，$h$称为哑坐标，$h=1$是规格化坐标，前$n$个坐标是普通坐标下的$n$维坐标。</p>
<p>也可以这样考虑，$(x,y)$是$z=0$上的点，$(x,y,1)$是$z=1$上的点。会加速计算的方便性。</p>
<p><strong>平移变换</strong></p>
<p>$P$点沿直线到另一个点重定位的过程，平移变换是不产生形变的物体的刚体变换。</p>
<script type="math/tex; mode=display">x+T_x=x^*</script><script type="math/tex; mode=display">y+T_y=y^*</script><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><ol>
<li>bresenham算法的 $e$ 到底大于几</li>
<li>加权采样法如何计算</li>
<li>X扫描线算法(3)</li>
<li>NET的放入AET的标准</li>
<li>Z-buffer算法的帧缓冲器存储光强还是像素存储光强</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上内容和图片都参考了<code>MOOC</code>上中国农业大学计算机图形学的课程，如有雷同，雷同就雷同吧，反正是我抄的他的PPT。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">本文相关</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2021/07/31/Arch-config/" rel="bookmark">Arch 折腾全记录，彻底告别 Windows</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/11/15/Arch/" rel="bookmark">我和我的操作系统们</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/06/12/Computer-network/" rel="bookmark">计算机网络原理</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2021/02/23/MPI-basics/" rel="bookmark">MPI基础，以 mpi4py 为例（操作系统番外篇）</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/01/07/about-qa/" rel="bookmark">关于提问与回答</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div>明人不说暗话，如果感觉这篇文章还不错，您的打赏是对我读书路上莫大的支持，当然一切全凭自愿。 实在不行，我，秦始皇，打钱。</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="兰铃 o(*≧▽≦)ツ">
        <p>o(*≧▽≦)ツ</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="兰铃 ♪(^∇^*)">
        <p>♪(^∇^*)</p>
      </div>

  </div>
</div>

        

  <div class="followme">
    <p>欢迎订阅我的文章</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Computer/" rel="tag"># Computer</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/14/autocell/" rel="prev" title="元胞自动机——万物皆可模拟">
      <i class="fa fa-chevron-left"></i> 元胞自动机——万物皆可模拟
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/02/23/substring-match/" rel="next" title="通用的子串匹配问题求解算法">
      通用的子串匹配问题求解算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-01-计算机图形学概述"><span class="nav-number">1.</span> <span class="nav-text">Chapter-01 计算机图形学概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是计算机图形学"><span class="nav-number">1.1.</span> <span class="nav-text">什么是计算机图形学</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机图形学的研究内容"><span class="nav-number">1.2.</span> <span class="nav-text">计算机图形学的研究内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机图形学的应用领域"><span class="nav-number">1.3.</span> <span class="nav-text">计算机图形学的应用领域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机图形系统的组成"><span class="nav-number">1.4.</span> <span class="nav-text">计算机图形系统的组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交互式计算机图形处理系统"><span class="nav-number">1.5.</span> <span class="nav-text">交互式计算机图形处理系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图形与图像的区别"><span class="nav-number">1.6.</span> <span class="nav-text">图形与图像的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-02-光栅图形学算法"><span class="nav-number">2.</span> <span class="nav-text">Chapter-02 光栅图形学算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#直线段的扫描转换算法-1"><span class="nav-number">2.1.</span> <span class="nav-text">直线段的扫描转换算法(1)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直线段的扫描转换算法-2"><span class="nav-number">2.2.</span> <span class="nav-text">直线段的扫描转换算法(2)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多边形的扫描转换与区域填充"><span class="nav-number">2.3.</span> <span class="nav-text">多边形的扫描转换与区域填充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反走样算法"><span class="nav-number">2.4.</span> <span class="nav-text">反走样算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#裁剪算法"><span class="nav-number">2.5.</span> <span class="nav-text">裁剪算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消隐算法"><span class="nav-number">2.6.</span> <span class="nav-text">消隐算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二维图形变换"><span class="nav-number">3.</span> <span class="nav-text">二维图形变换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#向量的基础"><span class="nav-number">3.1.</span> <span class="nav-text">向量的基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图形坐标系"><span class="nav-number">3.2.</span> <span class="nav-text">图形坐标系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二维图形转换"><span class="nav-number">3.3.</span> <span class="nav-text">二维图形转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#齐次坐标"><span class="nav-number">3.4.</span> <span class="nav-text">齐次坐标</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#疑问"><span class="nav-number">4.</span> <span class="nav-text">疑问</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结语"><span class="nav-number">5.</span> <span class="nav-text">结语</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="兰铃"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">兰铃</p>
  <div class="site-description" itemprop="description">爱生活-------爱读书-------爱摄影   爱运动-------爱睡觉-------爱旅行</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">183</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">相册</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/muyuuuu" title="GitHub → https://github.com/muyuuuu" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">兰铃</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">732k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">11:05</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><div id="days"></div>
<script>
function show_date_time(){
    window.setTimeout("show_date_time()", 1000);
    BirthDay=new Date("09/28/2018 23:13:14");//修改为自己的blog建站时间
    today=new Date();
    timeold=(today.getTime()-BirthDay.getTime());
    sectimeold=timeold/1000
    secondsold=Math.floor(sectimeold);
    msPerDay=24*60*60*1000
    e_daysold=timeold/msPerDay
    daysold=Math.floor(e_daysold);
    e_hrsold=(e_daysold-daysold)*24;
    hrsold=setzero(Math.floor(e_hrsold));
    e_minsold=(e_hrsold-hrsold)*60;
    minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
    seconds=setzero(Math.floor((e_minsold-minsold)*60));
    document.getElementById('days').innerHTML="已在此等候你"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
}
function setzero(i){
    if (i<10)
    {i="0" + i};
    return i;
}
show_date_time();
</script>



        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span class="site-uv" title="总访客量">
        我的第 <span id="busuanzi_value_site_uv"></span> 位朋友
      </span>
    <span class="post-meta-divider">|</span>
      <span class="site-pv" title="总访问量">
        经过 <span id="busuanzi_value_site_pv"></span> 次回眸与你相遇
      </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>



  <script data-pjax>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 24077,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  <script src="/js/local-search.js"></script>








<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '639ddab88527bca5fe75',
      clientSecret: '0c08625a06e8796096a190cad5c07b4909d1e960',
      repo        : 'blabla',
      owner       : 'muyuuuu',
      admin       : ['muyuuuu'],
      id          : 'a24825d7f7380ed35f0027012c7cad2f',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
